# February 20, 2016

# February 29, 2016: 1. change axioms for if1 and if2 to make all axioms of the form x = ... 2. add last label as an output of translate0

# March 10 - April 27: a new translation for while-loop that parameterizes loop input variables and replaces smallest macros by inductive definition. Also a small correction to simplify()

# April 29: combining the two translations (c2l.py.old3 and c2l.py.old4): keep the old translation for program variables but use a new way to inductively define smallest macro: 
# N(x,y) = if C(x,y) then 0 else C(f(x),g(x)), where f and g is the new value of x and y, respectively, after one iteration
# in c2l.py.old4, f and g are the output functions for the body, here we parameterize f and g first, and use f(1,x) and g(1,y) to replace f(x) and g(y), respectively

# May 18: (not done yet) making functions first-order objects by using "+": f+[t1,...,tk,v] stands for the
# function f1 such that forall x1,...,xk: 
# f1(x1,...,xk) = ite(x1=t1 & ... & xk=tk, v, f(x1,...,xk))
# A translator from C to FOL in python 

# June 18: add solve_rec() by Pritom to solve recurrences in translating while-loop
# assume that the only dynamic functions are the program variables given by v and the system generated temporary functions including big N (is_program_var())
# this makes _base redundant

# August 30: add function definitions and function calls and define program as a sequence of functions. See program definitions just before translate1()

#example run: translate1(fact,vfact,1) or translate1(fact,vfact,2)


"""
Assumptions:
1. Program variables:
  - can be any word \w+
  - cannot be _x\d*, _n\d*, _N\d*,_y\d* 
    (these are reserved for general variables,
    natural number variables, and smallest macro constants
    in our axioms)
  - for a variable, its temporary variants are constructed 
    by adding to it TEMP+number
    and its output values after a labeled statement are 
    constructed by adding to it LABEL+number.
    (Currently, TEMP is empty and LABEL is '_'.) 
    This menas that if V is a variable, then
    V+TEMP+\d+ and V+LABEL+\d+ are not allowed to be variables 
    (right now it means that
    V1,V2,... and V_1,V_2,... cannot be variables).
  - smallest is a reserved word so cannot be a variable
"""


import sys
import os

currentdirectory = os.path.dirname(os.path.realpath(__file__))

sys.path.append(currentdirectory+"/packages/ply/")
sys.path.append(currentdirectory+"/packages/plyj/")
sys.path.append(currentdirectory+"/packages/pyparsing/")
sys.path.append(currentdirectory+"/packages/pycparser1/")
sys.path.append(currentdirectory+"/packages/pycparserext/")
sys.path.append(currentdirectory+"/packages/regex/")
sys.path.append(currentdirectory+"/packages/mpmath/")
sys.path.append(currentdirectory+"/packages/sympy/")
sys.path.append(currentdirectory+"/packages/z3/python/")


import xml.dom.minidom
import re
import random
#add by Pritom Rajkhowa
#import numpy as np
import resource
import hashlib
#import wolframalpha
#import sys
import itertools
import plyj.parser
import plyj.model as m
import subprocess
from sympy import *
import regex
#import os
import copy
import time
import datetime
import ConfigParser
import SyntaxFilter
import commandclass
import graphclass
#import solution_closed_form
#import FOL_translation
#import fun_utiles
from pyparsing import *
from sympy.core.relational import Relational
from pycparser1 import parse_file,c_parser, c_ast, c_generator
from pycparserext.ext_c_parser import GnuCParser
from pycparserext.ext_c_generator import GnuCGenerator
from itertools import permutations
ParserElement.enablePackrat()


#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])
#sys.setrecursionlimit(0x100000)

#resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
#sys.setrecursionlimit(10**6)
#os.system('ulimit -s ulimited')

sys.setrecursionlimit(100000)

def is_empty(any_structure):
    if any_structure:
        return False
    else:
        return True




def is_number(s):
    if s=='j':
    	return False
    try:
        float(s) # for int, long and float
    except ValueError:
        try:
            complex(s) # for complex
        except ValueError:
            return False
    return True

def is_hex(input_string):
        flag=True
        if input_string is None:
            return None
        try:
            flag=int(input_string, 16)
        except ValueError:
            return None
	if flag:
		if '0x' in input_string:
    			return str(int(input_string, 16))
    		else:
    			return None
	else:
    		return None


#Find Intersection of Two lists


def intersect3(c1,c2,c3):
	return list(set(list(set(c1) & set(c2)))-set(c3))

def intersect2(c1,c2):
	return list(set(c1) & set(c2))
        
def merge_two_dicts(x,y):
    z=x.copy()
    z.update(y)
    return z


config = ConfigParser.RawConfigParser()
config.read(currentdirectory+'/config.properties')
timeout=config.get('ConfigurationSection', 'timeout');
app_id=config.get('ConfigurationSection', 'app_id');



#Time Out 
if timeout.strip()!='' and timeout.strip()!='None' and is_number(timeout.strip())!=False:
	TIMEOUT=timeout.strip()
else:
	TIMEOUT=40000

if app_id.strip()!='' and app_id.strip()!='None':
	Mathematica_id=app_id.strip()
else:
	Mathematica_id=None


# base language (non dynamic, not changed by the program)
# do not use name with number in the end
# these names are not supposed to be used as prorgam variables

_base = ['=','==','!=','<','<=','>','>=','*','**','!','+','-','/', '%', 'ite', 'and', 'or', 'not', 'implies', 'all', 'some', 'null','>>','<<','&','|','^']
_infix_op = ['=','==','!=','<','<=','>','>=','*','**','+','-','/', '%', 'implies','<<','>>','&','|','^']
_relation_op = ['==','!=','<','<=','>','>=']

# variables introduced in the translation

def isvariable(x):
    if x.startswith('_x') or  x.startswith('_y') or  x.startswith('_n') or  x.startswith('_s'):
        return True
    else:
        return False



# program variables and temporary program variables and big N

def is_program_var(x,v):
    if x.startswith('_N'):
        return True
    for y in v:
        if x==y or x.startswith(y+OUT) or (x.startswith(y+TEMP) and 
                                           x[len(y+TEMP):].isdigit()) or x.startswith(y+LABEL):
            return True
    return False


current_milli_time = lambda: int(round(time.time() * 1000))

"""
#Get timestap
"""

def getTimeStamp():
	ts = time.time()
	st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')
	return "\n***********************\n"+str(st)+"\n***********************\n"


"""
RET for return value of a function
Temporary function names are constructed as: 
variable-name + TEMP + TC
Output function names are: 
variable-name + LABEL
for those with label, or
variable-name + OUT
for those without label.
 TC: TempCount, a global counter for naming temporary variables
 LC: LoopCount, a global counter for naming loop constants and variables
"""

RET='RET'
#OUT='Z' #so don't name variables xZ, yZ...
OUT='1' #so don't name variables x1, y1...
#TEMP = 'T' #so if x is a variable, then don't name variables xT, 
TEMP = '' #so if x is a variable, then don't name variables x2,x3,... (temp starts at 2)
LABEL = '_' #so if x is a variable, then don't name variables x_1,x_2, 
TC = 1  # for generating temporary functions to yield xt1,xt2,...
LC = 0  # for generating smallest macro constants in a loop _N1, _N2,... as well as
               # natural number variables _n1,_n2,...
"""
 Expressions: (f e1 ... ek) is represented as [f,e1,...,ek].
 Example: a+1 is ['+', ['a'],['1']]; constant a is ['a']; 
 sum(i+1,j) is ['sum', ['+', ['i'], ['1']], ['j']]
"""


#constructor: functor - a string like '+', '*', 'and', 
# or constants like '1', 'x'; args - a list of exprs
def expres(functor,args=[]):
    return [functor]+args

#accessor
def expr_op(e):
    return e[0]
def expr_args(e):
    return e[1:]

#prefix printing
def expr2string(e):
    if len(e)==1:
        return e[0]
    else:
        return '(' + e[0] +' '+ ' '.join(list(expr2string(x) for x in e[1:]))+ ')'

#normal infix printing
def expr2string1(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2string1(args[0])
            else:
                return '('+(' '+op+' ').join(list(expr2string1(x) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2string1(args[0])
        elif op=='implies' and len(args)==2:
            return expr2string1(args[0])+ ' -> '+expr2string1(args[1])
        elif op in _infix_op and len(args)==2:
            return '(' + expr2string1(args[0])+ op+expr2string1(args[1])+')'
        else:
            return op +'('+ ','.join(list(expr2string1(x) for x in args))+ ')'



def expr2stringvfact(e,var_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2stringvfact(args[0],var_map)
            else:
                return '('+(' '+op+' ').join(list(expr2stringvfact(x,var_map) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2stringvfact(args[0],var_map)
        elif op=='implies' and len(args)==2:
            return expr2stringvfact(args[0],var_map)+ ' -> '+expr2stringvfact(args[1],var_map)
        elif op in _infix_op and len(args)==2:
            t1=args[0][0]
            if t1 not in _base and is_number(t1)==False:
            	parameter=[]
            	
            	for x in range(0, len(args[0])):
            		parameter.append('int')
            	var_map[t1]=parameter
            t2=args[1][0]
            if t2 not in _base and is_number(t2)==False:
            	parameter=[]
            	
            	for x in range(0, len(args[1])):
            		parameter.append('int')
            		
            	var_map[t2]=parameter
            return '(' + expr2stringvfact(args[0],var_map)+ op+expr2stringvfact(args[1],var_map)+')'
        else:
            if isArrayFunction(op)==True:
            	count=0
            	for parameter in args:
            	
            		if len(parameter)==1:
            			name=expr2stringvfact(parameter,var_map)
            			if is_number(name)==False:
            				type_list=[]
            				if count==0:
            					type_list.append('array')
            				else:
            					type_list.append('int')
            				count=count+1
            			
            				var_map[name]=type_list
            			
            return op +'('+ ','.join(list(expr2stringvfact(x,var_map) for x in args))+ ')'





def expr2stringvfact2(e,var_map,allvariablelist,constraints):
    args=expr_args(e)
    op=expr_op(e)
    constraint=None
    if len(args)==0:
    	if op not in var_map.keys() and is_number(op)==False and is_hex(op)==None and op not in _base:
    		element=[]
    		element.append(op)
        	element.append(0)
        	element_para=[]
        	element.append(element_para)
        	typename=getVariableType(op,allvariablelist)
		if typename is None:
                        if '__VERIFIER_nondet_double' in op:
                            element_para.append('double')
                        elif '__VERIFIER_nondet_float' in op:
                            element_para.append('float')
                        else:
                            element_para.append('int')
		else:
			if isVariableArray(op,allvariablelist) is not None:
        			element_para.append('array')
        		else:
        			if typename=='unsigned':
                                        constraint=e
        				element_para.append('int')
        			elif typename=='long':
        				element_para.append('int')
        			else:
        				element_para.append(typename)
        	#print '----------'
                #print op
                #print element
                #print '----------'
        	var_map[op]=element
                if constraint is not None or '__VERIFIER_nondet_uint' in op:
                    con_equ=[]
                    con_equ.append('c1')
                    con_equ1=[]
                    con_equ1.append('>=')
                    con_equ1.append(e)
                    con_equ1.append(eval("['0']"))
                    con_equ.append(con_equ1)
                    constraints.append(wff2z3_update_postCond(con_equ))
                constraint=None  
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2stringvfact2(args[0],var_map,allvariablelist,constraints)
            else:
                return '('+(' '+op+' ').join(list(expr2stringvfact2(x,var_map,allvariablelist,constraints) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2stringvfact2(args[0],var_map,allvariablelist,constraints)
        elif op=='implies' and len(args)==2:
            return expr2stringvfact2(args[0],var_map,allvariablelist,constraints)+ ' -> '+expr2stringvfact2(args[1],var_map,allvariablelist,constraints)
        elif op in _infix_op and len(args)==2:
            return '(' + expr2stringvfact2(args[0],var_map,allvariablelist,constraints)+ op+expr2stringvfact2(args[1],var_map,allvariablelist,constraints)+')'
        else:
            if isArrayFunction(op)==True:
            	count=0
            	element=[]
            	element.append(op)
            	element.append(len(args))
            	element_para=[]
            	array_type=None
            	for parameter in args:
            		if count==0:
            			element_para.append('array')
            			element_in=[]
            			para_value=expr2stringvfact2(parameter,var_map,allvariablelist,constraints)
            			element_in.append(para_value)
            			element_in.append(0)
            			element_para_in=[]
            			element_para_in.append('array')
            			element_in.append(element_para_in)
            			var_map[para_value]=element_in
            			array_type=getVariableType(parameter,allvariablelist)
            		else:
            			expr2stringvfact2(parameter,var_map,allvariablelist,constraints)
            			typename=getVariableType(parameter,allvariablelist)
            			if typename is None:
            				element_para.append('int')
            			else:
            				if typename=='unsigned':
            					element_para.append('int')
            				elif typename=='long':
            					element_para.append('int')
            				else:
            					element_para.append(typename)
 			count=count+1
 		if array_type is None:
			element_para.append('int')
		else:
            		if typename=='unsigned':
                                constraint=e
            			element_para.append('int')
            		elif typename=='long':
                                constraint=e
            			element_para.append('int')
            		else:
            			element_para.append(array_type)
            	element.append(element_para)
            	var_map[op]=element
                if constraint is not None or '__VERIFIER_nondet_uint' in op:
                    con_equ=[]
                    con_equ.append('c1')
                    con_equ1=[]
                    con_equ1.append('>=')
                    con_equ1.append(e)
                    con_equ1.append(eval("['0']"))
                    con_equ.append(con_equ1)
                    constraints.append(wff2z3_update_postCond(con_equ))
                constraint=None  
            else:
            	if op not in var_map.keys() and op is not 'ite' and op not in _base:
            		element=[]
            		element.append(op)
            		element.append(len(args))
            		element_para=[]
            		if len(args)>0:
            			for x in args:
            				typename=getVariableType(expr2stringvfact2(x,var_map,allvariablelist,constraints),allvariablelist)
            				if typename is None:
            					element_para.append('int')
            				else:
            					element_para.append(typename)
            		       	typename=getVariableType(op,allvariablelist)
			        if typename is None:
                                    if '__VERIFIER_nondet_double' in op:
                                        element_para.append('double')
                                    elif '__VERIFIER_nondet_float' in op:
                                        element_para.append('float')
                                    else:
			        	element_para.append('int')
			        else:
            				if typename=='unsigned':
                                                constraint=e
            					element_para.append('int')
            				elif typename=='long':
            					element_para.append('int')
            				else:
            					element_para.append(typename)
            		else:
            			typename=getVariableType(op,allvariablelist)
            			if typename is None:
                                    if '__VERIFIER_nondet_double' in op:
                                        element_para.append('double')
                                    elif '__VERIFIER_nondet_float' in op:
                                        element_para.append('float')
                                    else:
            				element_para.append('int')
            			else:
            				if typename=='unsigned':
                                                constraint=e
            					element_para.append('int')
            				elif typename=='long':
            					element_para.append('int')
            				else:
            					element_para.append(typename)
            		element.append(element_para)
            		var_map[op]=element
                        if constraint is not None or '__VERIFIER_nondet_uint' in op:
                            con_equ=[]
                            con_equ.append('c1')
                            con_equ1=[]
                            con_equ1.append('>=')
                            con_equ1.append(e)
                            con_equ1.append(eval("['0']"))
                            con_equ.append(con_equ1)
                            constraints.append(wff2z3_update_postCond(con_equ))
                        constraint=None           	            			
            return op +'('+ ','.join(list(expr2stringvfact2(x,var_map,allvariablelist,constraints) for x in args))+ ')'



# Rearrage expression
def getRidOfDiv(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return e
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return e[:1]+list(getRidOfDiv(args[0]))
            else:
                return e[:1]+list(getRidOfDiv(x) for x in expr_args(e))
        elif op=='not' and len(args)==1:
            return e[:1]+list(getRidOfDiv(args[0]))
        elif op=='implies' and len(args)==2:
            return e[:1]+[getRidOfDiv(args[0])]+[getRidOfDiv(args[1])]
        elif op in _relation_op and len(args)==2:
            if len(args[0])>1 and len(args[1])>1 and '/'==args[0][0] and '/'==args[1][0]:
                list_vales=[]
                list_vales_temp1=[]
                list_vales_temp1.append('*')
                list_vales_temp1.append(list(args[0][1]))
                list_vales_temp1.append(list(args[1][2]))
                
                list_vales_temp2=[]
                list_vales_temp2.append('*')
                list_vales_temp2.append(list(args[1][1]))
                list_vales_temp2.append(list(args[0][2]))

        
                list_vales.append(list_vales_temp1)
                list_vales.append(list_vales_temp2)
                
                return e[:1]+list_vales
            elif len(args[0])>1 and '/'==args[0][0]:
                list_vales=[]
                list_vales_temp=[]
                list_vales_temp.append('*')
                list_vales_temp.append(list(args[1]))
                list_vales_temp.append(list(args[0][2]))
                args[1]=list_vales_temp
                list_vales.append(args[0][1])
                list_vales.append(args[1])
                return e[:1]+list_vales
            elif len(args[1])>1 and '/'==args[1][0]:
                list_vales=[]
                list_vales_temp=[]
                list_vales_temp.append('*')
                list_vales_temp.append(list(args[0]))
                list_vales_temp.append(list(args[1][2]))
                args[0]=list_vales_temp
                list_vales.append(args[0])
                list_vales.append(args[1][1])
                return e[:1]+list_vales
            else:
                return e[:1]+list(getRidOfDiv(x) for x in expr_args(e))
        elif op in _infix_op and len(args)==2:
            return e[:1]+list(getRidOfDiv(x) for x in expr_args(e))
        else:
            return e[:1]+list(getRidOfDiv(x) for x in expr_args(e))




#normal infix printing
def expr2stringSimplify(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2stringSimplify(args[0])
            else:
                return '('+(' '+op+' ').join(list(expr2stringSimplify(x) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2stringSimplify(args[0])
        elif op=='implies' and len(args)==2:
            return expr2stringSimplify(args[0])+ ' -> '+expr2stringSimplify(args[1])
        elif op in _infix_op and len(args)==2:
            return '(' + expr2stringSimplify(args[0])+ op+expr2stringSimplify(args[1])+')'
        else:
            if op is 'ite':
            	expresion1 = expr2stringSimplify(args[1])
            	expresion2 =  expr2stringSimplify(args[2])
            	if ('and' not in expresion1 and 'or' not in expresion1 and 'ite' not in expresion1) and ('and' not in expresion2 and 'or' not in expresion2 and 'ite' not in expresion2) and simplify(expresion1+'=='+expresion2)==True:
            		
            		return expresion1
		else:
			return op +'('+ ','.join(list(expr2stringSimplify(x) for x in args))+ ')'
            else:
            	return op +'('+ ','.join(list(expr2stringSimplify(x) for x in args))+ ')'


#Function to Simplify equation using Array Map

#e=['i1', 3, '_n1', ['d2array3', ['_x1'], ['_x2'], ['_x3'], ['+', ['_n1'], ['1']],['_n2'], ['_n3']], ['ite', ['and', ['=', ['_x1'], ['C']], ['=', ['_x2'], ['+', ['_n3'], ['0']]], ['=', ['_x3'], ['+', ['_n1'], ['0']]]], ['+', ['ite', ['and', ['=', ['C'], ['C']], ['=', ['+', ['_n3'], ['0']], ['+', ['_n3'], ['0']]], ['=', ['+', ['_n1'], ['0']], ['+', ['_n1'], ['0']]]], ['0'], ['d2array3', ['C'], ['+',['_n3'], ['0']], ['+', ['_n1'], ['0']], ['_n1'], ['_n2'], ['_n3']]], ['*', ['ite', ['and', ['=', ['A'], ['C']], ['=', ['+', ['_n3'], ['0']], ['+', ['_n3'], ['0']]], ['=', ['+', ['_n2'], ['0']], ['+', ['_n1'], ['0']]]], ['0'], ['d2array3', ['A'], ['+', ['_n3'], ['0']], ['+', ['_n2'], ['0']], ['_n1'], ['_n2'], ['_n3']]], ['ite', ['and', ['=', ['B'], ['C']], ['=', ['+', ['_n2'], ['0']], ['+', ['_n3'], ['0']]], ['=', ['+', ['_n1'], ['0']], ['+', ['_n1'], ['0']]]], ['0'], ['d2array3', ['B'], ['+', ['_n2'], ['0']], ['+', ['_n1'], ['0']], ['_n1'], ['_n2'], ['_n3']]]]], ['ite', ['and', ['=', ['_x1'], ['C']], ['=', ['_x2'], ['+', ['_n3'], ['0']]], ['=', ['_x3'], ['+', ['_n1'], ['0']]]], ['0'], ['d2array3', ['_x1'], ['_x2'], ['_x3'], ['_n1'], ['_n2'], ['_n3']]]]]
#array_list=['A','B','C']

def simplify_ind_equation(e,array_list):
        if e[:1]==['ite']:
        	temp=[]
        	count=0
        	ifcase=None
        	elsecase=None
        	status=None
        	for x in expr_args(e):
        		parameter=simplify_ind_equation(x,array_list)
        		if count==0:
        			status=evaluateCondition(parameter,array_list)
                                if status == 'Unknown':
                                    parameter = evaluateConditionModify(parameter,array_list)
        		elif count==1:
        			ifcase=parameter
        		elif count==2:
        			elsecase=parameter
        		temp.append(parameter)
        		count=count+1
        	if status=='True':
        		return ifcase
        	elif status=='False':
        		return elsecase
        	else:
        		return e[:1]+temp
        else:
        	return e[:1]+list(simplify_ind_equation(x,array_list) for x in expr_args(e))




def simplify_ind_equation_array(e,array_list):
        if e[:1]==['ite']:
        	temp=[]
        	count=0
        	ifcase=None
        	elsecase=None
        	status=None
        	for x in expr_args(e):
        		parameter=simplify_ind_equation_array(x,array_list)
        		if count==0:
        			status=evaluateConditionArray(parameter,array_list)
                                if status is not None:
                                    parameter=status
        		elif count==1:
        			ifcase=parameter
        		elif count==2:
        			elsecase=parameter
        		temp.append(parameter)
        		count=count+1
        	if status is None:
        		return ifcase
        	else:
        		return e[:1]+temp
        else:
        	return e[:1]+list(simplify_ind_equation_array(x,array_list) for x in expr_args(e))


def evaluateConditionArray(e,array_list):
	if e[:1]==['and']:
		status=None
                temp=[]
		for x in expr_args(e):
			parameter=simplify_ind_equation(x,array_list)
                        left=expr2string1(parameter[1])
                        right=expr2string1(parameter[2])
			expression=expr2string1(parameter)
			if  parameter[0]== '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression and left in array_list and right in array_list:
                                    c_status=simplify(left)==simplify(right)
                                    if c_status==False :
                                        return 
                        else:
                            temp.append(x)
                if len(temp)>0:
                    return e[:1]+temp
                else:
                    return None
        else:
            return e







#def evaluateCondition(e,array_list):
#	if e[:1]==['and']:
#		status=None
#		for x in expr_args(e):
#			parameter=simplify_ind_equation(x,array_list)
#			expression=expr2string1(parameter)
#			if  parameter[0]== '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
#				left=expr2string1(parameter[1])
#				right=expr2string1(parameter[2])
#				c_status=simplify(left)==simplify(right)
#				if c_status==True:
#					if status==None:
#						status='True'
#					elif status=='Unknown':
#						status='Unknown'
#					elif status=='False':
#						status='False'
#					elif status=='True':
#						status='True'
#					else:
#						status='Unknown'
#				elif c_status==False and left in array_list and right in array_list:
#					status='False'
#                                elif c_status==False and status==None:
#                                        status='False'
#				else:
#					if status=='False':
#                                                #status_ieq1=simplify(left)>=simplify(right)
#                                                #status_ieq2=simplify(left)<=simplify(right)
#                                                #if status_ieq1==False
#						status='False'
#					else:
#						status_ieq2=simplify(simplify(left)<=simplify(right))
#						status_ieq1=simplify(simplify(left)>=simplify(right))
#                                                if status_ieq1==True and status_ieq2==False:
#                                                    status='False'
#                                                elif status_ieq1==False and status_ieq2==True:
#                                                    status='False'
#                                                else:
#                                                    status='Unknown'
#			else:
#				if status=='False':
#					status='False'
#				else:
#					status='Unknown'
#		return status
#	elif e[:1]==['or']:
#		status=None
#		for x in expr_args(e):
#			parameter=simplify_ind_equation(x,array_list)
#			expression=expr2string1(parameter)
#			if  parameter[0] is '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
#				left=expr2string1(expr2string1(parameter[1]))
#				right=expr2string1(expr2string1(parameter[2]))
#				c_status=simplify(left)==simplify(right)
#				if c_status==True:
#					if status==None:
#						status='True'
#					elif status=='Unknown':
#						status='True'
#					elif status=='False':
#						status='True'
#					elif status=='True':
#						status='True'
#					else:
#						status='Unknown'
#				elif c_status==False and left in array_list and right in array_list:
#					status='False'
#				else:
#					if status=='True':
#						status='True'
#					else:
#						status='Unknown'
#			else:
#				if status=='True':
#					status='True'
#				else:
#					status='Unknown'
#		return status




#def evaluateConditionModify(e,array_list):
#        modify_parameter=[]
#	if e[:1]==['and']:
#		status=None
#		for x in expr_args(e):
#			parameter=simplify_ind_equation(x,array_list)
#			expression=expr2string1(parameter)
#			if  parameter[0]== '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
#				left=expr2string1(parameter[1])
#				right=expr2string1(parameter[2])
#				c_status=simplify(left)==simplify(right)
#				if c_status!=True:
#                                    modify_parameter.append(x)
#			else:
#                                modify_parameter.append(x)
#		if len(modify_parameter)==1:
#                    return modify_parameter[0]
#                else:
#                    return e[:1]+modify_parameter
#	elif e[:1]==['or']:
#		status=None
#		for x in expr_args(e):
#			parameter=simplify_ind_equation(x,array_list)
#			expression=expr2string1(parameter)
#			if  parameter[0] is '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
#				left=expr2string1(expr2string1(parameter[1]))
#				right=expr2string1(expr2string1(parameter[2]))
#				c_status=simplify(left)==simplify(right)
#				if c_status!=True:
#                                    modify_parameter.append(x)
#                        else:
#                            modify_parameter.append(x)
#		if len(modify_parameter)==1:
#                    return modify_parameter[0]
#                else:
#                    return e[:1]+modify_parameter



def evaluateCondition(e,array_list):
	if e[:1]==['and']:
		status=None
		for x in expr_args(e):
			parameter=simplify_ind_equation(x,array_list)
			expression=expr2string1(parameter)
			if  parameter[0]== '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
				left=expr2string1(parameter[1])
				right=expr2string1(parameter[2])
				c_status=simplify(left)==simplify(right)
				if c_status==True:
					if status==None:
						status='True'
					elif status=='Unknown':
						status='Unknown'
					elif status=='False':
						status='False'
					elif status=='True':
						status='True'
					else:
						status='Unknown'
				elif c_status==False and left in array_list and right in array_list:
					status='False'
                                elif c_status==False and status==None:
                                        status='False'
				else:
					if status=='False':
                                                #status_ieq1=simplify(left)>=simplify(right)
                                                #status_ieq2=simplify(left)<=simplify(right)
                                                #if status_ieq1==False
						status='False'
					else:
						status_ieq2=simplify(simplify(left)<=simplify(right))
						status_ieq1=simplify(simplify(left)>=simplify(right))
                                                if status_ieq1==True and status_ieq2==False:
                                                    status='False'
                                                elif status_ieq1==False and status_ieq2==True:
                                                    status='False'
                                                else:
                                                    status='Unknown'
			else:
				if status=='False':
					status='False'
				else:
					status='Unknown'
		return status
	elif e[:1]==['or']:
		status=None
		for x in expr_args(e):
			parameter=simplify_ind_equation(x,array_list)
			expression=expr2string1(parameter)
			if  parameter[0] is '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
				left=expr2string1(expr2string1(parameter[1]))
				right=expr2string1(expr2string1(parameter[2]))
				c_status=simplify(left)==simplify(right)
				if c_status==True:
					if status==None:
						status='True'
					elif status=='Unknown':
						status='True'
					elif status=='False':
						status='True'
					elif status=='True':
						status='True'
					else:
						status='Unknown'
				elif c_status==False and left in array_list and right in array_list:
					status='False'
				else:
					if status=='True':
						status='True'
					else:
						status='Unknown'
			else:
				if status=='True':
					status='True'
				else:
					status='Unknown'
		return status
        elif e[:1]==['='] and e[1][0] in array_list and  e[1][0] in array_list and e[1][0]!=e[2][0]:
            status='False'
            return status
        elif e[:1]==['='] and e[1][0] in array_list and  e[1][0] in array_list and e[1][0]==e[2][0]:
            status='True'
            return status
            


def evaluateConditionModify(e,array_list):
        modify_parameter=[]
	if e[:1]==['and']:
		status=None
		for x in expr_args(e):
			parameter=simplify_ind_equation(x,array_list)
			expression=expr2string1(parameter)
			if  parameter[0]== '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
				left=expr2string1(parameter[1])
				right=expr2string1(parameter[2])
				c_status=simplify(left)==simplify(right)
				if c_status!=True:
                                    modify_parameter.append(x)
			else:
                                modify_parameter.append(x)
		if len(modify_parameter)==1:
                    return modify_parameter[0]
                else:
                    return e[:1]+modify_parameter
	elif e[:1]==['or']:
		status=None
		for x in expr_args(e):
			parameter=simplify_ind_equation(x,array_list)
			expression=expr2string1(parameter)
			if  parameter[0] is '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
				left=expr2string1(expr2string1(parameter[1]))
				right=expr2string1(expr2string1(parameter[2]))
				c_status=simplify(left)==simplify(right)
				if c_status!=True:
                                    modify_parameter.append(x)
                        else:
                            modify_parameter.append(x)
		if len(modify_parameter)==1:
                    return modify_parameter[0]
                else:
                    return e[:1]+modify_parameter
















def expr2python(e,tab):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2python(args[0],tab)
            else:
                return '('+(' '+op+' ').join(list(expr2python(x,tab) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2python(args[0],tab)
        elif op=='implies' and len(args)==2:
            return expr2python(args[0],tab)+ ' -> '+expr2python(args[1],tab)
        elif op in _infix_op and len(args)==2:
            return '(' + expr2python(args[0],tab)+ op+expr2python(args[1],tab)+')'
        else:
            if op is 'ite':
            	cond = expr2python(args[0],tab+'\t')
            	expresion1 = expr2python(args[1],tab+'\t')
            	expresion2 =  expr2python(args[2],tab+'\t')
            	return '\n'+tab+'if '+cond+' : \n'+tab+'\treturn '+expresion1+'\n'+tab+'else : \n'+tab+'\treturn '+expresion2+'\n'
            else:
            	return op +'('+ ','.join(list(expr2python(x,tab) for x in args))+ ')'









#Get Variable Type

def getVariableType(variable,allvariablelist):
	for var in allvariablelist.keys():
		if var in variable and variable[0] is not '_':
                        if var+var in variable:
                            #print '$$$$$$$$$$$$$$'
                            variableType=allvariablelist[var+var]
                            #print allvariablelist['bb'].
                            #print allvariablelist
                            #print variableType.getVariableType()
                            #print '$$$$$$$$$$$$$$'
                            return variableType.getVariableType()
                        else:
                            variableType=allvariablelist[var]
                            return variableType.getVariableType()
                elif '__VERIFIER_nondet_double' in variable:
                        return 'double'
                elif '__VERIFIER_nondet_float' in variable:
                        return 'float'
                elif '__VERIFIER_nondet_int' in variable:
                        return 'int'
                elif '__VERIFIER_nondet_uint' in variable:
                        return 'int'
	return None


#Is Variable a Array

def isVariableArray(variable,allvariablelist):
    
	for var in allvariablelist.keys():
		#if var in variable:                    
                if isTempVar(variable,var)==True or variable==var:
                        if isTempVar(variable,var+var)==True:
                            variableType=allvariablelist[var+var]
                            return variableType.getDimensions()
                        else:
                            variableType=allvariablelist[var]
                            return variableType.getDimensions()
	return None

#variable='maker1'
#pattern='maker'
#isTempVar( 'maker1', 'maker')
def isTempVar( variable, pattern):
	status=False
        reg_expreesion=""+pattern+"\d"
        find=regex.compile(reg_expreesion)
	group = find.search(variable)
        find1=regex.compile(""+pattern+"\d[_]")
	group1 = find1.search(variable)
	if group is not None:
		status=True
        if group1 is not None:
		status=False
	return status



#expression to z3 constraint
def expr2z3(e,var_cstr_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if isvariable(op)==True:
    		var_cstr_map[op]=op+">=0"
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2z3(args[0],var_cstr_map)
            else:
                parameter1=None
                parameter2=None
                for x in args:
                    if parameter1==None:
                    	parameter1=expr2z3(x,var_cstr_map)
                    else:
                    	parameter2=expr2z3(x,var_cstr_map)
                if op=='or':
                	return 'Or('+parameter1+','+parameter2+')'
                else:
                	if op=='and':
                		return 'And('+parameter1+','+parameter2+')'
                #return '('+(' '+op+' ').join(list(expr2z3(x,var_cstr_map) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'Not('+expr2z3(args[0],var_cstr_map)+')'
        elif op=='implies' and len(args)==2:
            
            if len(var_cstr_map)==0:
            	return 'Implies('+expr2z3(args[0],var_cstr_map)+ ','+expr2z3(args[1],var_cstr_map)+')'
            else:
            	list_constrn=""
                for x in var_cstr_map:
            		if list_constrn=="":
            			list_constrn="And("+expr2z3(args[0],var_cstr_map)+","+var_cstr_map[x]+")"
            		else:
            			list_constrn="And("+list_constrn+","+var_cstr_map[x]+")"
            	return 'Implies('+list_constrn+ ','+expr2z3(args[1],var_cstr_map)+')'
        elif op in _infix_op and len(args)==2:
            return '((' + expr2z3(args[0],var_cstr_map)+')'+ op+'('+expr2z3(args[1],var_cstr_map)+'))'
        else:
            return op +'('+ ','.join(list(trim_p(expr2z3(x,var_cstr_map)) for x in args))+ ')'





#expression to z3 constraint

#e=['or', ['or', ['or', ['<=', ['B'], ['0']], ['<=', ['A'], ['0']]], ['<=', ['+', ['A'], ['B']], ['B']]], ['<=', ['+',['A'], ['B']], ['A']]]

#e=['+', ['*', ['*', ['/', ['B'], ['']], ['/', ['A'], ['C']]], ['+', ['+', ['A'], ['B']], ['B']]], ['-', ['+',['A'], ['B']], ['A']]]

#e=['Y3', ['+', ['_n1'], ['1']], ['A'], ['B']], ['ite', ['>', ['A'], ['B']], ['Y3', ['_n1'], ['A'], ['B']], ['+', ['A'], ['*', ['2'], ['B']]]]

#e=['ite', ['>', ['A'], ['B']], ['Y3', ['_n1'], ['A'], ['B']], ['+', ['A'], ['*', ['2'], ['B']]]]

#e=['==', ['d1array3', ['a'], ['+', ['+', ['_k1'], ['1']], ['0']], ['+', ['+', ['_k1'], ['1']], ['1']]], ['d1array3', ['b'], ['+', ['*', ['9'], ['+', ['_k1'], ['1']]], ['1']], ['+', ['_k1'], ['1']]]]

#var_cstr_map={}

def expr2z3_update(e,var_cstr_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if isvariable(op)==True:
    		var_cstr_map[op]=op+">=0"
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
            	expression=expr2z3_update(args[0],var_cstr_map)
            	if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'If' not in expression and 'Implies' not in expression:
            		expression=simplify_expand_sympy(expression)
                return expression
            else:
                e_array=[]
                for x in args:
                	parameter1=expr2z3_update(x,var_cstr_map)
                    	if '/' not in parameter1 and 'Or' not in parameter1 and '==' not in parameter1 and 'And' not in parameter1 and 'If' not in parameter1 and 'Implies' not in parameter1:                    		
                    		parameter1=convert_pow_op_fun(simplify_expand_sympy(parameter1))
                                
                    	elif 'Or' not in parameter1 and 'And' not in parameter1 and 'If' not in parameter1 and 'Implies' not in parameter1:
                    		parameter1=convert_pow_op_fun(parameter1)
                    	e_array.append(parameter1)
                if op=='or':
                	#return 'Or('+parameter1+','+parameter2+')'
                	return constructAndOr(e_array,'Or')
                else:
                	if op=='and':
                		#return 'And('+parameter1+','+parameter2+')'
                		return constructAndOr(e_array,'And')
        elif op=='not' and len(args)==1:
            expression=expr2z3_update(args[0],var_cstr_map)
            if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'If' not in expression and 'Implies' not in expression:
            	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            elif 'Or' not in expression and 'And' not in expression and 'If' not in expression and 'Implies' not in expression:
            	expression=convert_pow_op_fun(expression)
            return 'Not('+expression+')'
        elif op=='implies' and len(args)==2:
            if len(var_cstr_map)==0:
            	expression1=expr2z3_update(args[0],var_cstr_map)
            	expression2=expr2z3_update(args[1],var_cstr_map)
            	if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
            		expression1=convert_pow_op_fun(simplify_expand_sympy(expression1))
            	elif 'Or' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
			expression1=convert_pow_op_fun(expression1)
            	if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
            		expression2=convert_pow_op_fun(simplify_expand_sympy(expression2))
            	elif 'Or' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
			expression2=convert_pow_op_fun(expression2)
            	return 'Implies('+expression1+ ','+expression2+')'
            else:
            	list_constrn=""
                for x in var_cstr_map:
            		if list_constrn=="":
            			expression1=expr2z3_update(args[0],var_cstr_map)
            			if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
            				expression1=convert_pow_op_fun(simplify_expand_sympy(expression1))
            			elif 'Or' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
					expression1=convert_pow_op_fun(expression1)
            			list_constrn="And("+expression1+","+var_cstr_map[x]+")"
            		else:
            			list_constrn="And("+list_constrn+","+var_cstr_map[x]+")"
            	expression2=expr2z3_update(args[1],var_cstr_map)
            	if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
            		expression1=simplify_expand_sympy(expression2)
            	elif 'Or' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
			expression2=convert_pow_op_fun(expression2)
            	return 'Implies('+list_constrn+ ','+expression2+')'
        elif op in _infix_op and len(args)==2:
        	expression1=expr2z3_update(args[0],var_cstr_map)
        	expression2=expr2z3_update(args[1],var_cstr_map)
        	if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
        		expression1=simplify_expand_sympy(expression1)
        	if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
        		expression2=simplify_expand_sympy(expression2)
        	if op=='/':
        		return '((' + expression1+')'+op+'('+expression2+'))'
                elif op=='**':
                        if expression2=='2':
                            return expression1+'*'+expression1
                        else:
                            return 'power((' + expression1+')'+','+'('+expression2+'))'
        	elif op=='=':
                    
        		return '((' + expression1+ ')==('+expression2+'))'
        	else:
        		if op=='*':
                            expression='((' + expression1+')'+ op+'('+expression2+'))'
                        else:
                            expression='((' + expression1+')'+ op+'('+expression2+'))'
        		if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and '.' not in expression:
        			return simplify_expand_sympy(expression)
        		else:
        			return expression
        else:
            if op=='ite':
            	return 'If('+ ','.join(list(conditionSimplifyPower(expr2z3_update(x,var_cstr_map)) for x in args))+ ')'
            else:
            	if isArrayFunction(op)==True:
            		parameter_list=[]
            		defineDetailtemp=[]
            		defineDetailtemp.append(op)
            		parameter_list.append('array')
            		for x in range(0, len(args)):
            			parameter_list.append('int')
            		defineDetailtemp.append(len(args))
            		defineDetailtemp.append(parameter_list)
            		defineDetaillist.append(defineDetailtemp)
            	return op +'('+ ','.join(list(expr2z3_update(x,var_cstr_map) for x in args))+ ')'





def expr2z3_update1(e,var_cstr_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if isvariable(op)==True:
    		var_cstr_map[op]=op+">=0"
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
            	expression=expr2z3_update1(args[0],var_cstr_map)
                return expression
            else:
                e_array=[]
                for x in args:
                	parameter1=expr2z3_update1(x,var_cstr_map)
                    	e_array.append(parameter1)
                if op=='or':
                	#return 'Or('+parameter1+','+parameter2+')'
                	return constructAndOr(e_array,'Or')
                else:
                	if op=='and':
                		#return 'And('+parameter1+','+parameter2+')'
                		return constructAndOr(e_array,'And')
        elif op=='not' and len(args)==1:
            expression=expr2z3_update1(args[0],var_cstr_map)
            return 'Not('+expression+')'
        elif op=='implies' and len(args)==2:
            if len(var_cstr_map)==0:
            	expression1=expr2z3_update1(args[0],var_cstr_map)
            	expression2=expr2z3_update1(args[1],var_cstr_map)
            	return 'Implies('+expression1+ ','+expression2+')'
            else:
            	list_constrn=""
                for x in var_cstr_map:
            		if list_constrn=="":
            			expression1=expr2z3_update1(args[0],var_cstr_map)
            			list_constrn="And("+expression1+","+var_cstr_map[x]+")"
            		else:
            			list_constrn="And("+list_constrn+","+var_cstr_map[x]+")"
            	expression2=expr2z3_update1(args[1],var_cstr_map)
            	return 'Implies('+list_constrn+ ','+expression2+')'
        elif op in _infix_op and len(args)==2:
        	expression1=expr2z3_update1(args[0],var_cstr_map)
        	expression2=expr2z3_update1(args[1],var_cstr_map)
        	if op=='/':
        		return '((' + expression1+')'+op+'('+expression2+'))'
                elif op=='**':
                        if expression2=='2':
                            return expression1+'*'+expression1
                        else:
                            return 'power((' + expression1+')'+','+'('+expression2+'))'
        	elif op=='=':
                    
        		return '((' + expression1+ ')==('+expression2+'))'
        	else:
        		if op=='*':
                            expression='((' + expression1+')'+ op+'('+expression2+'))'
                        else:
                            expression='((' + expression1+')'+ op+'('+expression2+'))'
                        return expression
        else:
            if op=='ite':
            	return 'If('+ ','.join(list(expr2z3_update1(x,var_cstr_map) for x in args))+ ')'
            else:
            	if isArrayFunction(op)==True:
            		parameter_list=[]
            		defineDetailtemp=[]
            		defineDetailtemp.append(op)
            		parameter_list.append('array')
            		for x in range(0, len(args)):
            			parameter_list.append('int')
            		defineDetailtemp.append(len(args))
            		defineDetailtemp.append(parameter_list)
            		defineDetaillist.append(defineDetailtemp)
            	return op +'('+ ','.join(list(expr2z3_update1(x,var_cstr_map) for x in args))+ ')'














def constructAndOr(e_array,operator):
	if len(e_array)>2:
		return operator+'('+e_array[0]+','+constructAndOr(e_array[1:],operator)+')'
	if len(e_array)==2:
		return operator+'('+e_array[0]+','+e_array[1]+')'
	else:
		return e_array[0]
                
                
def constructAndOrArray(e_array,operator):
	if len(e_array)>2:
		return eval("['"+operator+"',"+str(e_array[0])+','+str(constructAndOrArray(e_array[1:],operator))+']')
	if len(e_array)==2:
		return eval("['"+operator+"',"+str(e_array[0])+','+str(e_array[1])+']')
	else:
		return e_array[0]





def expr2z3_update_postCond(e,var_cstr_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if isvariable(op)==True:
    		var_cstr_map[op]=op+">=0"
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
            	expression=expr2z3_update_postCond(args[0],var_cstr_map)
            	if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'Implies' not in expression and 'If' not in expression:
            		expression=simplify_expand_sympy(expression)
                return expression
            else:
                parameter1=None
                parameter2=None
                for x in args:
                    if parameter1==None:
                    	parameter1=expr2z3_update_postCond(x,var_cstr_map)
                    	if '/' not in parameter1 and 'Or' not in parameter1 and '==' not in parameter1 and 'And' not in parameter1 and 'Implies' not in parameter1 and 'If' not in parameter1:
                    		parameter1=convert_pow_op_fun(simplify_expand_sympy(parameter1))
                    	elif 'Or' not in parameter1 and 'And' not in parameter1 and 'If' not in parameter1 and 'Implies' not in parameter1 and 'If' not in parameter1:
                    		parameter1=convert_pow_op_fun(parameter1)
                    else:
                    	parameter2=expr2z3_update_postCond(x,var_cstr_map)
                    	if '/' not in parameter2 and 'Or' not in parameter2 and '==' not in parameter2 and 'And' not in parameter2 and 'Implies' not in parameter2 and 'If' not in parameter2:
                    		parameter2=convert_pow_op_fun(simplify_expand_sympy(parameter2))
                    	elif 'Or' not in parameter2 and 'And' not in parameter2 and 'If' not in parameter2 and 'Implies' not in parameter2 and 'If' not in parameter2:
                    		parameter2=convert_pow_op_fun(parameter2)
                if op=='or':
                	return 'Or('+parameter1+','+parameter2+')'
                else:
                	if op=='and':
                		return 'And('+parameter1+','+parameter2+')'
        elif op=='not' and len(args)==1:
            expression=expr2z3_update_postCond(args[0],var_cstr_map)
            if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'Implies' not in expression and 'If' not in expression:
            	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            elif 'Or' not in expression and 'And' not in expression and 'Implies' not in expression and 'If' not in expression:
            	expression=convert_pow_op_fun(expression)
            return 'Not('+expression+')'
        elif op=='implies' and len(args)==2:
            if len(var_cstr_map)==0:
            	expression1=expr2z3_update_postCond(args[0],var_cstr_map)
            	expression2=expr2z3_update_postCond(args[1],var_cstr_map)
            	if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
            		expression1=convert_pow_op_fun(simplify_expand_sympy(expression1))
            	elif 'Or' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
			expression1=convert_pow_op_fun(expression1)
            	if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
            		expression2=convert_pow_op_fun(simplify_expand_sympy(expression2))
            	elif 'Or' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
			expression2=convert_pow_op_fun(expression2)
            	return 'Implies('+expression1+ ','+expression2+')'
            else:
            	list_constrn=""
                for x in var_cstr_map:
            		if list_constrn=="":
            			expression1=expr2z3_update_postCond(args[0],var_cstr_map)
            			if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
            				expression1=convert_pow_op_fun(simplify_expand_sympy(expression1))
            			elif 'Or' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
					expression1=convert_pow_op_fun(expression1)
            			list_constrn="And("+expression1+","+var_cstr_map[x]+")"
            		else:
            			list_constrn="And("+list_constrn+","+var_cstr_map[x]+")"
            	expression2=expr2z3_update_postCond(args[1],var_cstr_map)
            	if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
            		expression1=simplify_expand_sympy(expression2)
            	elif 'Or' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
			expression2=convert_pow_op_fun(expression2)
            	return 'Implies('+list_constrn+ ','+expression2+')'
        elif op in _infix_op and len(args)==2:
        	expression1=expr2z3_update_postCond(args[0],var_cstr_map)
        	expression2=expr2z3_update_postCond(args[1],var_cstr_map)
        	if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
        		expression1=simplify_expand_sympy(expression1)
        	if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
        		expression2=simplify_expand_sympy(expression2)
        	if op=='/':
        		return '(' + expression1+ op+expression2+')'
                elif op=='**':
                    if is_number(expression1)==True and is_number(expression2)==True:
                        return str(simplify(expression1+"**"+expression2))
                    else:
                        return 'power((' + expression1+')'+','+'('+expression2+'))'
        	elif op=='=':
        		return '((' + expression1+ ')==('+expression2+'))'
        	else:
        		expression='((' + expression1+')'+ op+'('+expression2+'))'
        		if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'Implies' not in expression and 'If' not in expression:
        			return simplify_expand_sympy(expression)
        		else:
        			return expression
        else:
            if op=='ite':
            	stmt_list=[]
            	final_stmt=''
            	for x in args:
            		stmt=conditionSimplifyPower(expr2z3_update_postCond(x,var_cstr_map))
            		if str(stmt)!='0':
            			stmt_list.append(stmt)
                        elif str(stmt)=='0' and '>' not in args[1] and '<' not in args[1] :
                                stmt_list.append(stmt)
            	if len(stmt_list)==2:
            		final_stmt='Implies('+final_stmt+','.join(stmt_list)+')'
            	else:
            		final_stmt='If('+final_stmt+','.join(stmt_list)+')'
            	return final_stmt
            else:
                if isArrayFunction(op)==True:
	        	parameter_list=[]
	                defineDetailtemp=[]
	                defineDetailtemp.append(op)
	                parameter_list.append('array')
	                for x in range(0, len(args)):
	                	parameter_list.append('int')
	                defineDetailtemp.append(len(args))
	                defineDetailtemp.append(parameter_list)
            		defineDetaillist.append(defineDetailtemp)
            	return op +'('+ ','.join(list(expr2z3_update_postCond(x,var_cstr_map) for x in args))+ ')'









def conditionSimplifyPower(expression):
	if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'If' not in expression and 'char(' not in expression and 'Implies' not in expression:
		return convert_pow_op_fun(simplify_expand_sympy(expression))
	elif 'Or' not in expression and 'And' not in expression and 'If' not in expression and 'char(' not in expression and 'Implies' not in expression:
		return convert_pow_op_fun(expression)
	else:
		return expression

#get variable
def expr2varlist(e,variable_list):
    args=expr_args(e)    
    op=expr_op(e)
    if len(args)==0:
    	if '_n' not in op and is_number(op)==False:
    		variable_list.append(op)
    else:
        if op=='and' or op=='or':
            if len(args)==1:
               expr2varlist(args[0],variable_list)
            else:
                for x in args:
                    expr2varlist(x,variable_list)
        elif op=='not' and len(args)==1:
            expr2varlist(args[0],variable_list)
        elif op=='implies' and len(args)==2:
        	expr2varlist(args[0],variable_list)
        	expr2varlist(args[1],variable_list)
        elif op in _infix_op and len(args)==2:
        	expr2varlist(args[0],variable_list)
        	expr2varlist(args[1],variable_list)
        else:
            for x in args:
        	expr2varlist(x,variable_list)


#return the list of program variables in an expression 

def expr_func(e,v): #e - expr
    ret = []
    f = expr_op(e)
    if is_program_var(f,v) or '__VERIFIER_nondet' in f:
        ret.append(f)
    for e1 in expr_args(e):
        ret = ret + expr_func(e1,v)
    return ret
    

#substitution of functors: in e, replace functor n1 by n2
def expr_sub(e,n1,n2): # e - expr; n1,n2 - strings
    e1=list(expr_sub(x,n1,n2) for x in e[1:])
    if e[0]==n1:
        return [n2]+e1
    else:
        return e[:1]+e1
        

#substitution of functors in a set: in e, for all x in v1 but not in v2, replace x+n1 by x+n2
def expr_sub_set(e,n1,n2,v1,v2): #e - expr; n1,n2 - strings, v1, v2 - sets of strings
    e1 = list(expr_sub_set(e2,n1,n2,v1,v2) for e2 in e[1:])
    if e[0].endswith(n1):
        x = e[0][:len(e[0])-len(n1)]
        if (x in v1) and (not x in v2):
            return [x+n2]+e1
        else:
            return e[:1]+e1
    else:
        return e[:1]+e1
        
        

# expr_replace(e,e1,e2): replace all subterm e1 in e by e2

def expr_replace(e,e1,e2): #e,e1,e2: expr
    if e==e1:
        return e2
    else:
        return e[:1]+list(expr_replace(x,e1,e2) for x in expr_args(e))
        
        

# expr_sub_dict(e,d): d is a dictonary of substitutions: functor 'f' to e1=d['f'] so that in e, each f term f(t1,...,tk) is replaced by e1(_x1/t1,...,_xk/tk)

def expr_sub_dict(e,d):
    args = expr_args(e)
    args1 = list(expr_sub_dict(x,d) for x in args)
    if expr_op(e) in d:
        return expr_sub_var_list(d[expr_op(e)],list(expres('_x'+str(i+1)) for i in range(len(args))),args1)
    else:
        return expres(expr_op(e),args1)
        

# expr_sub_var_list(e,l1,l2): in e, replace all terms in l1 by the corresponding terms in l2

def expr_sub_var_list(e,l1,l2): #e: expr, l1,l2: lists of the same length of exprs
    for i,x in enumerate(l1):
        if e==x:
            return l2[i]
    return e[:1]+list(expr_sub_var_list(y,l1,l2) for y in expr_args(e))


# compute E[n] extend(e,n,excl,v). n is an expr like ['_n1'], excl is a container of strings that are not to be extended
def extend(e,n,excl,v):
    op = expr_op(e)
    x = [n] if (is_program_var(op,v) and not (op in excl)) or '__VERIFIER_nondet' in op else []
    return expres(op, list(extend(e1,n,excl,v) for e1 in expr_args(e)) + x)


#A dictionary of dependencies para is such that, if x is an input variable, then para[x] is a list whose first element is 1 and the second element is the variable's parameter name; otherwise, para[x] is the list of input variables that x is depended on. 
#example: para = { 'X':[1,['_y1']], 'X11':[0,['_y1','_y2'], ['X','Y']],...} meaning 'X' is an input variable parameterized as '_y1' and 'X11' is a function depending on X and Y whose corresponding parameters are '_y1' and '_y2', respectively.
#So after parameterization, X11(a,X) will become X11(a,_y1,_y1,_y2)

def parameterize_expres(e,para): 
    if e[0] in para:
        if para[e[0]][0] == 1:
            return para[e[0]][1]+list(parameterize_expres(x,para) for x in e[1:])
        else:
            return e[:1]+list(parameterize_expres(x,para) for x in e[1:])+para[e[0]][1]
    else:
        return e[:1]+list(parameterize_expres(x,para) for x in e[1:])


#parameterize non-input functions then restore the input variables to its name
#given above para, X11(a,X) will become X11(a,X,X,Y), assuming that _y2 corresponds to Y

def parameterize_expr_sub(e,para): 
    if e[0] in para:
        if para[e[0]][0] == 1:
            return [e[0]]+list(parameterize_expr_sub(x,para) for x in e[1:])
        else:
            return e[:1]+list(parameterize_expr_sub(x,para) for x in e[1:])+para[e[0]][2]
    else:
        return e[:1]+list(parameterize_expr_sub(x,para) for x in e[1:])




        


"""
 Formulas:
 1. equations f(x) = e: ['e',e1,e2], 
    where e1 is expression for f(x) and e2 for e
 2. inductive definition:
 - base case f(x1,...,xk,0,...,xm)=e: ['i0',k,e1,e2] 
   where e1 is Expr for f(x1,...,xk,0,...,xm) and e2 the Expr for e
 - inductive case f(x1,...,xk,n+1,...,xm)=e: ['i1',k,'n',e1,e2] 
    where e1 is Expr for f(x1,...,xk,n+1,...,xm) and e2 the Expr for e
 3. inductive definition for functions that return natural numbers 
    (like N in smallest macro):
 - base case f(x) = 0 iff C: ['d0',e,c] 
   where e is the Expr for f(x) and c an expression for condition C
 - inductive case f(x) = n+1 iff C(n): ['d1','n',e,c] 
   where e is the Expr for f(x) and c an Expr for condition C
 4. any other axioms: A: ['a',e], where e is the Expr for A
 5. constraints from smallest macro smallest(N,n,e):
    ['s0', e(N)] 
    ['s1', forall n<N -> not e]

 Examples: a' = a+1: ['e', ['a\''], ['+',['a'],['1']]]
 N(x) = 0 if x<I else N(x-1)+1 is divided into two axioms:
 N(x) = 0 iff x<I:  
 ['d0', ['N',['x']], ['<', ['x'],['I']]] and
 N(x) = n+1 iff n=N(x-1): 
 ['d1','n', ['N',['x']], ['=',['n'], ['N', ['-', ['x'],['1']]]]]
"""


# constructors
def wff_e(e1,e2): #e1,e2: expr
    return ['e',e1,e2]

def wff_i0(k,e1,e2): #k: int; e1,e2: expr
    return ['i0',k,e1,e2]

def wff_i1(k,v,e1,e2): #k: int; v: string; e1,e2: expr
    return ['i1',k,v,e1,e2]

def wff_d0(e,c): #e: expr; c: expr
    return ['d0',e,c]

def wff_d1(v,e,c): #v: string, e and c: expr
    return ['d1',v,e,c]

def wff_a(e): #e: expr
    return ['a',e]

def wff_s0(e):
    return ['s0',e]
def wff_s1(e):
    return ['s1',e]
    
def wff_c1(e):
    return ['c1',e]

    
    
#print in prefix notation
def wff2string(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 'R':
            return '(= '+expr2string(w[-2])+' '+expr2string(w[-1]) +')'
        elif w[0] == 'd0':
            return '(iff (= '+expr2string(w[1])+' 0) '+ expr2string(w[2])+')'
        elif w[0] == 'd1':
            return '(iff (= '+expr2string(w[2])+' (+ '+w[1]+' 1)) '+expr2string(w[3])+')'
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1' or w[0]=='c1' or w[0] == 'R':
            return expr2string(w[1])

#print in normal infix notation
def wff2string1(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 'i2' or w[0] == 'R':
            return expr2string1(w[-2])+' = '+ expr2string1(w[-1])
        elif w[0] == 'd0':
            return expr2string1(w[1])+'=0 <=> '+ expr2string1(w[2])
        elif w[0] == 'd1':
            return expr2string1(w[2])+'='+w[1]+'+1 <=> '+expr2string1(w[3])
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1' or w[0]=='c1':
            return expr2string1(w[1])

            
#print in normal infix notation
def wff2stringvfact(w,var_map):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 'R':
            return expr2stringvfact(w[-2],var_map)+' = '+ expr2stringvfact(w[-1],var_map)
        elif w[0] == 'd0':
            return expr2stringvfact(w[1],var_map)+'=0 <=> '+ expr2stringvfact(w[2],var_map)
        elif w[0] == 'd1':
            return expr2stringvfact(w[2],var_map)+'='+w[1]+'+1 <=> '+expr2stringvfact(w[3],var_map)
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1' or w[0]=='c1':
            return expr2stringvfact(w[1],var_map)



#print in normal infix notation
def wff2stringvfact2(w,var_map,allvariablelist,constraints):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 'R':
            return expr2stringvfact2(w[-2],var_map,allvariablelist,constraints)+' = '+ expr2stringvfact2(w[-1],var_map,allvariablelist,constraints)
        elif w[0] == 'd0':
            return expr2stringvfact2(w[1],var_map,allvariablelist,constraints)+'=0 <=> '+ expr2stringvfact2(w[2],var_map,allvariablelist,constraints)
        elif w[0] == 'd1':
            return expr2stringvfact2(w[2],var_map,allvariablelist,constraints)+'='+w[1]+'+1 <=> '+expr2stringvfact2(w[3],var_map,allvariablelist,constraints)
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1' or w[0]=='c1' :
            return expr2stringvfact2(w[1],var_map,allvariablelist,constraints)



def getConstraints_Eq(w,allvariablelist,constraints):
    if w[0] == 'i1':
        temp_eq=copy.deepcopy(w[3])
        temp_eq=expr_replace(temp_eq,eval("['+',['"+w[2]+"'],['1']]"),eval("['"+w[2]+"']"))
        if isArrayFunction(w[3][0])==False:
            typename=getVariableType(w[3][0],allvariablelist)
            if typename=='unsigned':
                con_equ=[]
                con_equ.append('c1')
                con_equ1=[]
                con_equ1.append('>=')
                con_equ1.append(temp_eq)
                con_equ1.append(eval("['0']"))
                con_equ.append(con_equ1)
                return wff2z3_update_postCond(con_equ)
    return None

    




#strip '(' at the beginning and matching ')' in the end of a string
def trim_p(s):
    if s.startswith('(') and s.endswith(')'):
        return trim_p(s[1:-1])
    else:
        return s


#convert wff to z3 constraint
def wff2z3(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            lhs=expr2z3(w[-2],var_cstr_map)
            rhs=expr2z3(w[-1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
            	if w[0] == 'i1':
                	return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                	#return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
                else:
                	return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3(w[1],var_cstr_map)
            rhs=expr2z3(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                #return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+'=0 == '+ rhs+"))"
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3(w[2],var_cstr_map)
            rhs=expr2z3(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            lhs=convert_pow_op_fun(simplify_expand_sympy(w[1]+'+1'))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                #return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+rhs+"))"
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
	    expression=expr2z3(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                        #return 'ForAll(['+list_var_str+'],Implies('+arg_list[0]+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    #return 'ForAll(['+list_var_str+'],'+expression+')'
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
	    expression=expr2z3(w[1],var_cstr_map)
	    list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())
                    old_arg_list=arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))')
                        #equations.append('ForAll(['+str(list_var_str_new)+'],Implies('+str(list_cstr_str_new)+','+arg_list[1]+'))')
                        #return equations
                        #return 'ForAll(['+list_var_str+'],Implies('+arg_list[0]+','+arg_list[1]+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))')
                        #equations.append(arg_list[1])
                        #return equations
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    #return 'ForAll(['+list_var_str+'],'+expression+')'
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3(w[2],var_cstr_map)
            rhs=expr2z3(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs

        else:
            return expression







#convert wff to z3 constraint
def wff2z3_update(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[-2],var_cstr_map)
            rhs=expr2z3_update(w[-1],var_cstr_map) 
            list_var_str=qualifier_list(var_cstr_map.keys())
            if isArrayFunction(w[-2][0])==True:
            	if '_x1' in var_cstr_map.keys():
            		del var_cstr_map['_x1']
            	flag_constr=True
            if '_s1' in var_cstr_map.keys():
                del var_cstr_map['_s1']
            	flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if w[-1][0] in ['==','<=','>=','>','<','!=','or','and']:
                rhs='If(('+rhs+')==0,0,1)'
            if list_var_str is not None and list_cstr_str is not None:
            	if w[0] == 'i1':
                	return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                else:
                	if flag_constr==True:
                		return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                	else:
                		return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update(w[1],var_cstr_map)
            rhs=expr2z3_update(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
	    expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
	    expression=expr2z3_update(w[1],var_cstr_map)
	    list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())

                    new_w = copy.deepcopy(w)
                    for element in var_cstr_map.keys():
                    	fun=[]
                    	fun.append('_f')
                    	parameter=[]
                    	parameter.append(element)
                    	fun.append(parameter)
                    	sub=[]
                    	sub.append(element)
                    	new_w[1]=expr_replace(new_w[1],sub,fun) #expr_replace_const(new_w[1],element,fun)
		    new_expression=expr2z3_update(new_w[1],var_cstr_map)
		    new_arg_list=extract_args(new_expression)
                    
                    #old_arg_list=arg_list[1]
                    old_arg_list=new_arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
         	var_cstr_map={}
	      	equations=[]
	    	expression=expr2z3_update(w[1],var_cstr_map)
	    	list_var_str=qualifier_list(var_cstr_map.keys())
	    	list_cstr_str=cstr_list(var_cstr_map.values())
	    	if list_var_str is not None and list_cstr_str is not None:
        		 return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
        	else:
        		 return expression
        elif w[0]=='L1':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update(w[-2],var_cstr_map)
            	rhs=expr2z3_update(w[-1],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())
            	if isArrayFunction(w[-2][0])==True:
            		if '_x1' in var_cstr_map.keys():
            			del var_cstr_map['_x1']
            		flag_constr=True
                if '_s1' in var_cstr_map.keys():
                    del var_cstr_map['_s1']
                    flag_constr=True
            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())
            	if list_cstr_str is not None:
            		constant=w[2].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[2]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str2+','+w[2]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		if w[0] == 'i1':
                		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                	else:
                		if flag_constr==True:
                			return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                		else:
                			return "Implies("+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+","+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+")"
            	else:
                	return "Implies("+lhs+' == '+ rhs+","+lhs+' == '+ rhs+")"
        elif w[0]=='L2':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update(w[2],var_cstr_map)
            	rhs=expr2z3_update(w[3],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())

            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())

            	if list_cstr_str is not None:
            		constant=w[1].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[1]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str+','+w[1]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+rhs+"))"+")"
            	else:
                	return "Implies("+lhs+","+rhs+")"
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            if len(w[2])==0:
                lhs=None
            else:
                lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            if len(w[1])==0:
                list_var_str=None
            else:
                list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+rhs+")"
            elif lhs!='' and lhs is not None:
                return 'Implies('+lhs+','+rhs+")"
            else:
                return rhs

        else:
            return expression





def wff2z3_update_power(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[-2],var_cstr_map)
            rhs=expr2z3_update(w[-1],var_cstr_map) 
            list_var_str=qualifier_list(var_cstr_map.keys())
            if isArrayFunction(w[-2][0])==True:
            	if '_x1' in var_cstr_map.keys():
            		del var_cstr_map['_x1']
            	flag_constr=True
            if '_s1' in var_cstr_map.keys():
                del var_cstr_map['_s1']
            	flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if w[-1][0] in ['==','<=','>=','>','<','!=','or','and']:
                rhs='If(('+rhs+')==0,0,1)'
            if list_var_str is not None and list_cstr_str is not None:
            	if w[0] == 'i1':
                	return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                else:
                	if flag_constr==True:
                		return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                	else:
                		return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update(w[1],var_cstr_map)
            rhs=expr2z3_update(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
	    expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
	    expression=expr2z3_update(w[1],var_cstr_map)
	    list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())

                    new_w = copy.deepcopy(w)
		    new_expression=expr2z3_update(new_w[1],var_cstr_map)
		    new_arg_list=extract_args(new_expression)
                    
                    #old_arg_list=arg_list[1]
                    old_arg_list=new_arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
         	var_cstr_map={}
	      	equations=[]
	    	expression=expr2z3_update(w[1],var_cstr_map)
	    	list_var_str=qualifier_list(var_cstr_map.keys())
	    	list_cstr_str=cstr_list(var_cstr_map.values())
	    	if list_var_str is not None and list_cstr_str is not None:
        		 return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
        	else:
        		 return expression
        elif w[0]=='L1':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update(w[-2],var_cstr_map)
            	rhs=expr2z3_update(w[-1],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())
            	if isArrayFunction(w[-2][0])==True:
            		if '_x1' in var_cstr_map.keys():
            			del var_cstr_map['_x1']
            		flag_constr=True
                if '_s1' in var_cstr_map.keys():
                    del var_cstr_map['_s1']
                    flag_constr=True
            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())
            	if list_cstr_str is not None:
            		constant=w[2].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[2]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str2+','+w[2]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		if w[0] == 'i1':
                		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                	else:
                		if flag_constr==True:
                			return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                		else:
                			return "Implies("+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+","+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+")"
            	else:
                	return "Implies("+lhs+' == '+ rhs+","+lhs+' == '+ rhs+")"
        elif w[0]=='L2':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update(w[2],var_cstr_map)
            	rhs=expr2z3_update(w[3],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())

            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())

            	if list_cstr_str is not None:
            		constant=w[1].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[1]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str+','+w[1]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+rhs+"))"+")"
            	else:
                	return "Implies("+lhs+","+rhs+")"
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            if len(w[2])==0:
                lhs=None
            else:
                lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            if len(w[1])==0:
                list_var_str=None
            else:
                list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+rhs+")"
            elif lhs!='' and lhs is not None:
                return 'Implies('+lhs+','+rhs+")"
            else:
                return rhs

        else:
            return expression










#convert wff to z3 constraint
def wff2z3_update1(w,const_var_map):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[-2],var_cstr_map)
            rhs=expr2z3_update(w[-1],var_cstr_map) 
            list_var_str=qualifier_list(var_cstr_map.keys())
            #print '----------------------'
            #print list_var_str
            #print '----------------------'
            if isArrayFunction(w[-2][0])==True:
            	if '_x1' in var_cstr_map.keys():
            		del var_cstr_map['_x1']
            	flag_constr=True
            if '_s1' in var_cstr_map.keys():
                del var_cstr_map['_s1']
                flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if w[-1][0] in ['==','<=','>=','>','<','!=','or','and']:
                rhs='If(('+rhs+')==0,0,1)'
            if list_var_str is not None and list_cstr_str is not None:
            	if w[0] == 'i1':
                	return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+",("+lhs+') == ('+ rhs+")))"
                else:
                	if flag_constr==True:
                		return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+",("+lhs+') == ('+ rhs+"))"
                	else:
                		return 'ForAll(['+list_var_str+'],('+lhs+') == ('+ rhs+"))"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update(w[1],var_cstr_map)
            rhs=expr2z3_update(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],('+lhs+'=0) == ('+ rhs+"))"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
	    expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    if '<' in arg_list[0]:
                        constr=simplify(arg_list[0])
                        axms=str(constr).split('<')
                        axms[0]=axms[0].strip()
                        axms[1]=axms[1].strip()
                        arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                        if list_var_str is not None and list_cstr_str is not None:
                            return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                        else:
                            return arg_list[1]
                    else:
                        return expression
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
	    expression=expr2z3_update(w[1],var_cstr_map)
	    list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())

                    new_w = copy.deepcopy(w)
                    for element in var_cstr_map.keys():
                    	fun=[]
                    	fun.append('_f')
                    	parameter=[]
                    	parameter.append(element)
                    	fun.append(parameter)
                    	sub=[]
                    	sub.append(element)
                    	new_w[1]=expr_replace(new_w[1],sub,fun) #expr_replace_const(new_w[1],element,fun)
		    new_expression=expr2z3_update(new_w[1],var_cstr_map)
		    new_arg_list=extract_args(new_expression)
                    
                    #old_arg_list=arg_list[1]
                    old_arg_list=new_arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
         	var_cstr_map={}
	      	equations=[]
	    	expression=expr2z3_update(w[1],var_cstr_map)
	    	list_var_str=qualifier_list(var_cstr_map.keys())
	    	list_cstr_str=cstr_list(var_cstr_map.values())
                #add by pritom 30/08/2017
                list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
	    	if list_var_str is not None and list_cstr_str is not None:
        		 return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
        	else:
        		 return expression
        elif w[0]=='L1':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update(w[-2],var_cstr_map)
            	rhs=expr2z3_update(w[-1],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())
            	if isArrayFunction(w[-2][0])==True:
            		if '_x1' in var_cstr_map.keys():
            			del var_cstr_map['_x1']
            		flag_constr=True
                if '_s1' in var_cstr_map.keys():
                    del var_cstr_map['_s1']
                    flag_constr=True
            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())
                #add by pritom 30/08/2017
            	if list_cstr_str is not None:
            		constant=w[2].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[2]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str2+','+w[2]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		if w[0] == 'i1':
                		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                	else:
                		if flag_constr==True:
                			return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                		else:
                			return "Implies("+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+","+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+")"
            	else:
                	return "Implies("+lhs+' == '+ rhs+","+lhs+' == '+ rhs+")"
        elif w[0]=='L2':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update(w[2],var_cstr_map)
            	rhs=expr2z3_update(w[3],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())

            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())

            	if list_cstr_str is not None:
            		constant=w[1].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[1]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str+','+w[1]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+rhs+"))"+")"
            	else:
                	return "Implies("+lhs+","+rhs+")"
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            if len(w[2])==0:
                lhs=None
            else:
                lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            if len(w[1])==0:
                list_var_str=None
            else:
                list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+rhs+")"
            elif lhs!='' and lhs is not None:
                return 'Implies('+lhs+','+rhs+")"
            else:
                return rhs
        else:
            return expression







#convert wff to z3 constraint
def wff2z3_update4(w,var_dim_map,const_var_map):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[-2],var_cstr_map)
            rhs=expr2z3_update(w[-1],var_cstr_map) 
            list_var_str=qualifier_list(var_cstr_map.keys())
            #print '----------------------'
            #print list_var_str
            #print '----------------------'
            if isArrayFunction(w[-2][0])==True:
            	if '_x1' in var_cstr_map.keys():
            		del var_cstr_map['_x1']
            	flag_constr=True
            if '_s1' in var_cstr_map.keys():
                del var_cstr_map['_s1']
                flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            if flag_constr==True:
                if  w[-2][1][0] in var_dim_map.keys():
                    list_cstr_str_temp=None
                    list_cstr_str_temp=cstr_list_additional1(list_cstr_str_temp,var_cstr_map.keys(),var_dim_map[w[-2][1][0]].getDimensions().keys(),var_dim_map[w[-2][1][0]].getDimensions())
                    if list_cstr_str_temp is not None:
                        if list_cstr_str is None:
                            list_cstr_str = list_cstr_str_temp
                        else:
                            list_cstr_str = "And("+list_cstr_str +','+ list_cstr_str_temp+")"
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if w[-1][0] in ['==','<=','>=','>','<','!=','or','and']:
                rhs='If(('+rhs+')==0,0,1)'
            if list_var_str is not None and list_cstr_str is not None:
            	if w[0] == 'i1':
                	return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                else:
                	if flag_constr==True:
                		return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                	else:
                		return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update(w[1],var_cstr_map)
            rhs=expr2z3_update(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
	    expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            #print '----------------------'
            #print list_var_str
            #print '----------------------'
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
	    expression=expr2z3_update(w[1],var_cstr_map)
	    list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())

                    new_w = copy.deepcopy(w)
                    for element in var_cstr_map.keys():
                    	fun=[]
                    	fun.append('_f')
                    	parameter=[]
                    	parameter.append(element)
                    	fun.append(parameter)
                    	sub=[]
                    	sub.append(element)
                    	new_w[1]=expr_replace(new_w[1],sub,fun) #expr_replace_const(new_w[1],element,fun)
		    new_expression=expr2z3_update(new_w[1],var_cstr_map)
		    new_arg_list=extract_args(new_expression)
                    
                    #old_arg_list=arg_list[1]
                    old_arg_list=new_arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
         	var_cstr_map={}
	      	equations=[]
	    	expression=expr2z3_update(w[1],var_cstr_map)
	    	list_var_str=qualifier_list(var_cstr_map.keys())
	    	list_cstr_str=cstr_list(var_cstr_map.values())
                #add by pritom 30/08/2017
                list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
	    	if list_var_str is not None and list_cstr_str is not None:
        		 return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
        	else:
        		 return expression
        elif w[0]=='L1':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update(w[-2],var_cstr_map)
            	rhs=expr2z3_update(w[-1],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())
            	if isArrayFunction(w[-2][0])==True:
            		if '_x1' in var_cstr_map.keys():
            			del var_cstr_map['_x1']
            		flag_constr=True
            	
            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())
                #add by pritom 30/08/2017
            	if list_cstr_str is not None:
            		constant=w[2].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[2]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str2+','+w[2]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		if w[0] == 'i1':
                		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                	else:
                		if flag_constr==True:
                			return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                		else:
                			return "Implies("+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+","+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+")"
            	else:
                	return "Implies("+lhs+' == '+ rhs+","+lhs+' == '+ rhs+")"
        elif w[0]=='L2':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update(w[2],var_cstr_map)
            	rhs=expr2z3_update(w[3],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())

            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())

            	if list_cstr_str is not None:
            		constant=w[1].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[1]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str+','+w[1]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+rhs+"))"+")"
            	else:
                	return "Implies("+lhs+","+rhs+")"
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            if len(w[2])==0:
                lhs=None
            else:
                lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            if len(w[1])==0:
                list_var_str=None
            else:
                list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+rhs+")"
            elif lhs!='' and lhs is not None:
                return 'Implies('+lhs+','+rhs+")"
            else:
                return rhs
        else:
            return expression





#convert wff to z3 constraint for array tilling
def wff2z3_update5(w,var_dim_map,const_var_map):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update1(w[-2],var_cstr_map)
            rhs=expr2z3_update1(w[-1],var_cstr_map) 
            list_var_str=qualifier_list(var_cstr_map.keys())
            #print list_var_str
            if isArrayFunction(w[-2][0])==True:
            	if '_x1' in var_cstr_map.keys():
            		del var_cstr_map['_x1']
            	flag_constr=True
            if '_s1' in var_cstr_map.keys():
                del var_cstr_map['_s1']
                flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            if flag_constr==True:
                if  w[-2][1][0] in var_dim_map.keys():
                    list_cstr_str_temp=None
                    list_cstr_str_temp=cstr_list_additional1(list_cstr_str_temp,var_cstr_map.keys(),var_dim_map[w[-2][1][0]].getDimensions().keys(),var_dim_map[w[-2][1][0]].getDimensions())
                    if list_cstr_str_temp is not None:
                        if list_cstr_str is None:
                            list_cstr_str = list_cstr_str_temp
                        else:
                            list_cstr_str = "And("+list_cstr_str +','+ list_cstr_str_temp+")"
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if w[-1][0] in ['==','<=','>=','>','<','!=','or','and']:
                rhs='If(('+rhs+')==0,0,1)'
            if list_var_str is not None and list_cstr_str is not None:
            	if w[0] == 'i1':
                	return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                else:
                	if flag_constr==True:
                		return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                	else:
                		return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update1(w[1],var_cstr_map)
            rhs=expr2z3_update1(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update1(w[2],var_cstr_map)
            rhs=expr2z3_update1(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
	    expression=expr2z3_update1(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            #print '----------------------'
            #print list_var_str
            #print '----------------------'
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
	    expression=expr2z3_update1(w[1],var_cstr_map)
	    list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())

                    new_w = copy.deepcopy(w)
                    for element in var_cstr_map.keys():
                    	fun=[]
                    	fun.append('_f')
                    	parameter=[]
                    	parameter.append(element)
                    	fun.append(parameter)
                    	sub=[]
                    	sub.append(element)
                    	new_w[1]=expr_replace(new_w[1],sub,fun) #expr_replace_const(new_w[1],element,fun)
		    new_expression=expr2z3_update1(new_w[1],var_cstr_map)
		    new_arg_list=extract_args(new_expression)
                    
                    #old_arg_list=arg_list[1]
                    old_arg_list=new_arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
         	var_cstr_map={}
	      	equations=[]
	    	expression=expr2z3_update1(w[1],var_cstr_map)
	    	list_var_str=qualifier_list(var_cstr_map.keys())
	    	list_cstr_str=cstr_list(var_cstr_map.values())
                #add by pritom 30/08/2017
                list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
	    	if list_var_str is not None and list_cstr_str is not None:
        		 return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
        	else:
        		 return expression
        elif w[0]=='L1':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update1(w[-2],var_cstr_map)
            	rhs=expr2z3_update1(w[-1],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())
            	if isArrayFunction(w[-2][0])==True:
            		if '_x1' in var_cstr_map.keys():
            			del var_cstr_map['_x1']
            		flag_constr=True
            	
            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())
                #add by pritom 30/08/2017
            	if list_cstr_str is not None:
            		constant=w[2].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[2]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str2+','+w[2]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		if w[0] == 'i1':
                		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                	else:
                		if flag_constr==True:
                			return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                		else:
                			return "Implies("+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+","+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+")"
            	else:
                	return "Implies("+lhs+' == '+ rhs+","+lhs+' == '+ rhs+")"
        elif w[0]=='L2':
        	var_cstr_map={}
        	flag_constr=False
            	lhs=expr2z3_update1(w[2],var_cstr_map)
            	rhs=expr2z3_update1(w[3],var_cstr_map)           
            	list_var_str=qualifier_list(var_cstr_map.keys())

            	list_cstr_str=cstr_list(var_cstr_map.values())
            	list_cstr_str2=cstr_list(var_cstr_map.values())

            	if list_cstr_str is not None:
            		constant=w[1].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[1]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str+','+w[1]+'<'+constant+'+1),'+constant+'>0'+')'
            	if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            	if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            	if list_var_str is not None and list_cstr_str is not None:
            		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+rhs+"))"+")"
            	else:
                	return "Implies("+lhs+","+rhs+")"
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update1(w[2],var_cstr_map)
            rhs=expr2z3_update1(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            if len(w[2])==0:
                lhs=None
            else:
                lhs=expr2z3_update1(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            if len(w[1])==0:
                list_var_str=None
            else:
                list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+rhs+")"
            elif lhs!='' and lhs is not None:
                return 'Implies('+lhs+','+rhs+")"
            else:
                return rhs
        else:
            return expression















#convert wff to z3 constraint
def wff2z3_update_postCond(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update_postCond(w[-2],var_cstr_map)
            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
            
            list_var_str=qualifier_list(var_cstr_map.keys())
            
            if isArrayFunction(w[-2][0])==True:
	    	del var_cstr_map['_x1']
            	flag_constr=True
            if '_s1' in var_cstr_map.keys():
                del var_cstr_map['_s1']
                flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    
            if list_var_str is not None and list_cstr_str is not None:
            	if w[0] == 'i1':
                	return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                else:
                	if flag_constr==True:
                		return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update_postCond(w[1],var_cstr_map)
            rhs=expr2z3_update_postCond(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
	    lhs=expr2z3_update_postCond(w[2],var_cstr_map)
            rhs=expr2z3_update_postCond(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
	    	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
	    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
	    expression=expr2z3_update_postCond(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
	    expression=expr2z3_update_postCond(w[1],var_cstr_map)
	    list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())
                    old_arg_list=arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
         	var_cstr_map={}
	      	equations=[]
	    	expression=expr2z3_update(w[1],var_cstr_map)
	    	list_var_str=qualifier_list(var_cstr_map.keys())
	    	list_cstr_str=cstr_list(var_cstr_map.values())
	    	if list_var_str is not None and list_cstr_str is not None:
        		 return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
        	else:
        		 return expression     
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update_postCond(w[2],var_cstr_map)
            rhs=expr2z3_update_postCond(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+lhs+")"
            else:
                return lhs
        else:
            return expression






#convert wff to z3 constraint(Special Case N=0 V E(n/(N-1)))
def wff2z3SC_update(w):
	if w[0]=='s1':
            var_cstr_map={}
            equations=[]
	    expression=expr2z3_update(w[1],var_cstr_map)
	    list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression and 'Implies' not in expression:
	    	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())
                    old_arg_list=arg_list[1]
                    
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                        return 'ForAll(['+str(list_var_str_new)+'],Implies('+str(list_cstr_str_new)+','+arg_list[1]+'))'
                        #return equations
                        #return 'ForAll(['+list_var_str+'],Implies('+arg_list[0]+','+arg_list[1]+'))'
                    else:
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))')
                        return arg_list[1]
                        #return equations
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    #return 'ForAll(['+list_var_str+'],'+expression+')'
                    
                    
                    
#convert wff to z3 constraint(Special Case N=0 V E(n/(N-1)))
def wff2z3SC(w):
	if w[0]=='s1':
            var_cstr_map={}
            equations=[]
	    expression=expr2z3(w[1],var_cstr_map)
	    list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())
                    old_arg_list=arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                        return 'ForAll(['+str(list_var_str_new)+'],Implies('+str(list_cstr_str_new)+','+arg_list[1]+'))'
                        #return equations
                        #return 'ForAll(['+list_var_str+'],Implies('+arg_list[0]+','+arg_list[1]+'))'
                    else:
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))')
                        return arg_list[1]
                        #return equations
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    #return 'ForAll(['+list_var_str+'],'+expression+')'



#Function Collect Condition From All Recursive  Formulas

def getAllCondtion(w,condition_map):
	if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
		var_cstr_map={}
	        lhs=expr2z3(w[-2],var_cstr_map)
	        rhs=expr2z3(w[-1],var_cstr_map)
	        if 'ite' not in str(rhs):
	        	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
	        extract_conditions(rhs,condition_map)
        

def extract_conditions(expression,condition_map):
	if 'If' in expression:
		axioms=extract_args(expression)
	        condition_map[axioms[0]]=axioms[0]
	        if 'If' in axioms[1]:
			extract_conditions(axioms[1],condition_map)
		if 'If' in axioms[2]:
			extract_conditions(axioms[2],condition_map)









#print in normal infix notation
def wff2subslist(w):
        if w[0] == 'e':
            return expr2string1(w[-2]),expr2string1(w[-1])
 


#construct constraints for qualified variables
        
def qualifier_list(list_var):
    if len(list_var)==0:
        return None;
    else:
        var=list_var[-1]
        del list_var[-1]
        list_var_str=qualifier_list(list_var)
        if list_var_str is None:
            return var
        else:
            return var+","+list_var_str


#construct map of all array functions

def array_element_list(e,array_map): #e,e1,e2: expr
	if isArrayFunction(e[:1][0])==True:
            array_map[e[:1][0]]=e[:1][0]
            for x in expr_args(e):
                array_element_list(x,array_map)
        else:
            for x in expr_args(e):
                array_element_list(x,array_map)

#construct constraints for qualified variables

def cstr_list(list_cstr):
    if len(list_cstr)==0:
        return None;
    else:
        var=list_cstr[-1]
        del list_cstr[-1]
        list_cstr_str=cstr_list(list_cstr)
        if list_cstr_str is None:
            return var
        else:
            return "And("+var+","+list_cstr_str+")"
        
        
        
#construct constraints for qualified variables

def cstr_list_additional(list_cstr_str,list_cstr,const_var_map):
    if len(list_cstr)==0:
        return list_cstr_str;
    else:
        var=list_cstr[-1]
        del list_cstr[-1]
        if list_cstr_str is None:
            list_cstr_str=cstr_list_additional(list_cstr_str,list_cstr,const_var_map)
        else:
            list_cstr_str = cstr_list_additional(list_cstr_str,list_cstr,const_var_map)
        if var in const_var_map.keys():
            if list_cstr_str is None:
                return var+"<"+const_var_map[var]
            else:
                return "And("+var+"<"+const_var_map[var]+","+list_cstr_str+")"
        else:
            return list_cstr_str;


def cstr_list_additional1(list_cstr_str,variable_list,list_cstr,const_var_map):
    if len(list_cstr)==0:
        return list_cstr_str;
    else:
        var=list_cstr[-1]
        del list_cstr[-1]
        if list_cstr_str is None:
            list_cstr_str = cstr_list_additional1(list_cstr_str,variable_list,list_cstr,const_var_map)
        else:
            result = cstr_list_additional1(list_cstr_str,variable_list,list_cstr,const_var_map)
            if result is not None:
                list_cstr_str="And("+result+","+list_cstr_str+")"
        if var in const_var_map.keys() and var in variable_list:
            if list_cstr_str is None:
                return var+"<"+const_var_map[var]
            else:
                return "And("+var+"<"+const_var_map[var]+","+list_cstr_str+")"
        else:
            return list_cstr_str;




#strip '(' at the beginning and matching ')' in the end of a string
def trim_p(s):
    if s.startswith('(') and s.endswith(')'):
        return trim_p(s[1:-1])
    else:
        return s



#for a formula w, compute w[n]
def wff_extend(w,n,excl,v): #w: wff, n: expr, excl: container of strings
    if w[0]=='e': #['e',e1,e2]
        return ['e',extend(w[1],n,excl,v),extend(w[2],n,excl,v)]
    elif w[0]=='i0': #['i0',k,e1,e2]
        return ['i0',w[1],extend(w[2],n,excl,v),extend(w[3],n,excl,v)]
    elif w[0]=='i1': #['i1',k,v,e1,e2]
        return ['i1',w[1],w[2],extend(w[3],n,excl,v),extend(w[4],n,excl,v)]
    elif w[0]=='d0': #['d0',e,c]
        return ['d0',extend(w[1],n,excl,v),extend(w[2],n,excl,v)]
    elif w[0]=='d1': #['d1',v,e,c]
        return ['d1',w[1],extend(w[2],n,excl,v),extend(w[3],n,excl,v)]
    elif w[0]=='a' or w[0]=='s0' or w[0]=='s1': 
        return [w[0], extend(w[1],n,excl,v)]
    else:
        print('Not a wff')
        return
        

#for a formula w, replace functor old by new
def wff_sub(w,old,new): #w - wff; old, new - string
    if w[0]=='e': #['e',e1,e2]
        return ['e',expr_sub(w[1],old,new),expr_sub(w[2],old,new)]
    elif w[0]=='i0': #['i0',k,e1,e2]
        return ['i0',w[1],expr_sub(w[2],old,new),expr_sub(w[3],old,new)]
    elif w[0]=='i1': #['i1',k,v,e1,e2]
        return ['i1',w[1],w[2],expr_sub(w[3],old,new),expr_sub(w[4],old,new)]
    elif w[0]=='d0': #['d0',e,c]
        return ['d0',expr_sub(w[1],old,new),expr_sub(w[2],old,new)]
    elif w[0]=='d1': #['d1',v,e,c]
        return ['d1',w[1],expr_sub(w[2],old,new),expr_sub(w[3],old,new)]
    elif w[0]=='a' or w[0]=='s0' or w[0]=='s1': #['a',e]
        return [w[0],expr_sub(w[1],old,new)]
    else:
        print('Not a wff')
        return
        

#for a formula w, replace functor x+old by x+new for those in v1 but not in v2
def wff_sub_set(w,old,new,v1,v2): #w - wff; old, new - string; v1,v2: sets
    if w[0]=='e': #['e',e1,e2]
        return ['e',expr_sub_set(w[1],old,new,v1,v2),expr_sub_set(w[2],old,new,v1,v2)]
    elif w[0]=='i0': #['i0',k,e1,e2]
        return ['i0',w[1],expr_sub_set(w[2],old,new,v1,v2),expr_sub_set(w[3],old,new,v1,v2)]
    elif w[0]=='i1': #['i1',k,v,e1,e2]
        return ['i1',w[1],w[2],expr_sub_set(w[3],old,new,v1,v2),expr_sub_set(w[4],old,new,v1,v2)]
    elif w[0]=='d0': #['d0',e,c]
        return ['d0',expr_sub_set(w[1],old,new,v1,v2),expr_sub_set(w[2],old,new,v1,v2)]
    elif w[0]=='d1': #['d1',v,e,c]
        return ['d1',w[1],expr_sub_set(w[2],old,new,v1,v2),expr_sub_set(w[3],old,new,v1,v2)]
    elif w[0]=='a' or w[0]=='s0' or w[0]=='s1': #['a',e]
        return [w[0],expr_sub_set(w[1],old,new,v1,v2)]
    else:
        print('Not a wff')
        return

#like expr_sub_dict(e,d) but on wffs

def wff_sub_dict(w,d): #w - wff; d - a dictionary as in expr_sub_dict(e,d)
    if w[0]=='e': #['e',e1,e2]
        return w[:2]+[expr_sub_dict(w[2],d)]
    elif w[0]=='i0': #['i0',k,e1,e2]
        return w[:3]+[expr_sub_dict(w[3],d)]
    elif w[0]=='i1': #['i1',k,v,e1,e2]
        return w[:4]+[expr_sub_dict(w[4],d)]
    elif w[0]=='d0': #['d0',e,c]
        return w[:2]+[expr_sub_dict(w[2],d)]
    elif w[0]=='d1': #['d1',v,e,c]
        return w[:3]+[expr_sub_dict(w[3],d)]
    elif w[0]=='a' or w[0]=='s0' or w[0]=='s1': #['a',e]
        return [w[0],expr_sub_dict(w[1],d)]
    else:
        print('Not a wff')
        return

#parameterize a set of axioms by making program functions as input variables
#para = { 'X':[1,['_y1']], 'X11':[0,['_y1','_y2'],['X','Y']],...} meaning 'X' is an input variable parameterized as '_y1' and 'X11' is a function taking two new parameters '_y1','_y2'
#X11(a,X)=X11(a+b,1) will become X11(a,_y1,_y1,_y2)=X11(a+b,1,_y1,_y2)
 
def parameterize_wff(ax,para):
    if not (ax[0] == 'a' or ax[0]=='s0' or ax[0]=='s1'):
        e1 = parameterize_expres(ax[-2],para)
        e2 = parameterize_expres(ax[-1],para)
        return ax[:-2]+[e1,e2]
    else:
        e2 = parameterize_expres(ax[-1],para)
        return [ax[0],e2]
        

#for all x in dep_set, add dep_set[x] as arguments, except when x is RET+OUT,
#replace it by foo()

def parameterize_axioms_fun(axioms,dep_set):
    for x in axioms:
        parameterize_wff_fun(x,dep_set)

def parameterize_wff_fun(ax,dep_set):
    if not (ax[0] == 'a' or ax[0]=='s0' or ax[0]=='s1'):
        e1 = parameterize_expres_fun(ax[-2],dep_set)
        e2 = parameterize_expres_fun(ax[-1],dep_set)
        return ax[:-2]+[e1,e2]
    else:
        e2 = parameterize_expres_fun(ax[-1],dep_set)
        return [ax[0],e2]

def parameterize_expres_fun(e,dep_set): 
    if e[0]==RET+OUT:
        if len(e) != 1:
            print 'Something is wrong '+RET+OUT+' should not have arguments'
            return
        else:
            return dep_set[RET+OUT]
    elif e[0] in dep_set:
        return expres(e[0],list(parameterize_expres_fun(x,dep_set) for x in e[1:])+dep_set[e[0]])
    else:
        return expres(e[0],list(parameterize_expres_fun(x,dep_set) for x in e[1:]))
        
        
    

def eqset2string(d):
    for x in d:
        print wff2string(d[x])
def eqset2string1(d):
    for x in d:
        print wff2string1(d[x])
 
def eqset2stringvfact(d,var_map):
    for x in d:
        wff2stringvfact(d[x],var_map)
        
def eqset2constraintlist(d):
    equation_list=[]
    for x in d:
        equation_list.append(wff2z3(d[x]))
    return equation_list
    

def eqset2constraintlist_update(d):
    equation_list=[]
    for x in d:
        equation_list.append(wff2z3_update(d[x]))
    return equation_list    
    


def eqset2constraintlist4_update(d,var_dim_map,const_var_map):
    equation_list=[]
    for x in d:
        equation_list.append(wff2z3_update4(d[x],var_dim_map,const_var_map))
    return equation_list 
    
    
    
    
def eqset2subs_list(d):
    subs_list={}
    for x in d:
        lhs,rhs=wff2subslist(d[x])
        if 'ite' not in rhs and 'E' not in str(lhs) and 'e' not in str(lhs):
        	subs_list[simplify(lhs)]=simplify_sympy(rhs)
        elif 'E' not in str(lhs) and 'e' not in str(lhs):
                subs_list[lhs]=rhs
    return subs_list
def eqset2subs_list_ind(d):
    subs_list={}
    for x in d:
        if x[0]=='i1':
            lhs=expr2string1(x[-2])
            rhs=expr2string1(x[-1])
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            subs_list[lhs]=rhs
    return subs_list
    
"""
 A program variable has the attributes: its name, its type, 
 and its corresponding logical variable when parameterized. 
 A set of program variables is represented by a dictionary 
 with variable names as keys.
 examples: { 'X':['_y1','init','int','char'], 'I':['_y2','int'] }
 This set contains two program variables: 
 constant I of int value and function X from int*int to char
 Notice that the arity of a variable x in a set d is len(d[x])-2
 We assume no local function definitions, so the p in 'if b then p else p'
 'while b do p', 'foo(x,...,y) {b}' is a normal body of program statements.

 Program representations:
1. an assignment (l is the label, l='-1' means no label)
 l: left = right
 by [l,'=',e1,e2], 
 where e1,e2 are expressions representing left and right, respectively
2. a sequence
 p1; p2
 by ['-1','seq',p1,p2]
 where p1 and p2 are programs
3. if-then:
 l: if C then P
by [l,'if1', c,p], where c is the expression for C and p a program for P
4. if-then-else
 l: if c then p1 else p2
by [l,'if2', c,p1,p2], 
where c is Expr, p1 and p2 are Prog
5. while loop
 l: while c {b} by
[l,'while', c,b], 
where c is Expr, b is Prog
6. function definition
 foo(x,...,y) { B }
['-1','fun',['foo','x',..,'y'], b]
where 'foo' is the name of the function, 'x',...,'y' parameters, and
b the Prog representing B. We assume that B has no local function, i.e.
a normal body of statements. 
We assume a unique string 'RET' representing return
value because we do not have a special return statement.
Instead, a return statement
 l: return E
is represented as a normal assignment
 l: RET = e
We expect this will be the last statement of the body b
7. sequence of functions
 foo1(...) {B1}, ..., fook(...) {Bk}
['-1', 'prog', [f1,...,fk]]
where fi is the program representation of fooi(...) {Bi}. For this, the list
of variables v needs to be a dictionary indexed by the function names 
'foo1',...,'fook' whose value v['foo'] is the list of variables used in the function

"""



# for testing flag=1 (original translation), flag=2 (inductive definition for smallest N)
def translate1(p,v,flag):
    global TC
    global LC
    TC=0
    LC=0
    if p[1]=='prog':
        f_map={}
        a_map={}
        o_map={}
        cm_map={}
        assert_list_map={}
        assume_list_map={}
        assert_key_map={}
        res = translate0(p,v,flag)
        for fn in res:
            x,f,o,a,l = res[fn]
            #print f
	    #print o
            #print('Output for '+fn+':')
            

            
            f,o,a,cm = rec_solver(f,o,a)
            #cm=[]          
            #print f
            #print o
            #print a

            
            organizeFreeVariable(f,o,a,v)
            
            f,o,a,cm = getDummyFunction(f,o,a,cm)
            #f,o,a,cm = update__VERIFIER_nondet(f,o,a,cm)
            
    
            f,o,a,assert_list,assume_list,assert_key=getAssertAssume(f,o,a,cm)
            
            
            #assert_list=[]
            
            #assume_list=[]
            
            #assert_key=[]
            
            #assert_key_map={}
            
            
            f_map[fn]=f
	    o_map[fn]=o
	    a_map[fn]=a
            cm_map[fn]=cm
            
            assert_list_map[fn]=assert_list
            assume_list_map[fn]=assume_list
            assert_key_map[fn]=assert_key
            
            f,o,a=organizeOutput(f,o,a,v)
            
            
            f_map[fn]=f
	    o_map[fn]=o
	    a_map[fn]=a
            cm_map[fn]=cm
            
            output_axioms_fn(f,o,a)
            print('\n4. Assumption :')
            for x in assume_list:
            	if x[0]=='i1':
	     		print 'ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) '
	    	else:
	     		if x[0]!='i0':
                    		print wff2string1(x)
            print('\n5. Assertion :')
            for x in assert_list:
                if x[0]=='i1':
                    print 'ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) '
                else:
                	if x[0]!='i0':
                    		print wff2string1(x)
        return f_map,o_map,a_map,cm_map,assert_list_map,assume_list_map,assert_key_map
        
    elif p[1]=='fun':
        fn,f,o,a,l = translate0(p,v,flag)
        print('Output for ')
        print(fn)
        f,o,a,cm = rec_solver(f,o,a)
        f,o,a,cm = getDummyFunction(f,o,a,cm)
        f,o,a,assert_list,assume_list,assert_key=getAssertAssume(f,o,a,cm)
        f,o,a=organizeOutput(f,o,a,v)
        output_axioms_fn(f,o,a)
    	print('\n4. Assumption :')
	for x in assume_list:
        	if x[0]=='i1':
			print 'ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) '
		else:
			if x[0]!='i0':
                    		print wff2string1(x)
    	print('\n5. Assertion :')
	for x in assert_list:
                if x[0]=='i1':
                    print 'ForAll '+x[2]+' ( '+ expr2string1(x[4]) +' ) '
                else:
                	if x[0]!='i0':
                    		print wff2string1(x)
        return f,o,a,cm,assert_list,assume_list,assert_key
    else:
        f,o,a,l = translate0(p,v,flag)
        #Add by Pritom Rajkhowa 10 June 2016
    	f,o,a,cm = rec_solver(f,o,a)
    	f,o,a,cm = getDummyFunction(f,o,a,cm)
    	f,o,a,assert_list,assume_list,assert_key=getAssertAssume(f,o,a,cm)
        f,o,a=organizeOutput(f,o,a,v)
    	output_axioms_fn(f,o,a)
    	print('\n4. Assumption :')
	for x in assume_list:
	         if x[0]=='i1':
	         	print 'ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) '
	         else:
	                if x[0]!='i0':
                    		print wff2string1(x)
    	print('\n5. Assertion :')
	for x in assert_list:
                if x[0]=='i1':
                    print 'ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) '
                else:
                	if x[0]!='i0':
                    		print wff2string1(x)
    
    	return f,o,a,cm,assert_list,assume_list,assert_key




def output_axioms_fn(f,o,a):
    #print('Output in prefix notation:')
    #print('1. Frame axioms:')
    #eqset2string(f)
    #print('\n2. Output equations:')
    #eqset2string(o)
    #print('\n3. Other axioms:')
    #for x in a: 
    #    print wff2string(x)
    print('\nOutput in normal notation:')
    print('1. Frame axioms:')
    eqset2string1(f)
    print('\n2. Output equations:')
    eqset2string1(o)
    print('\n3. Other axioms:')
    for x in a: 
        print wff2string1(x)


def organizeOutput(f,o,a,vfacts):
    array_list=[]
    new_f={}
    duplicate_map={}
    new_f={}
    new_o={}
    new_a=[]
    for vfact in vfacts.keys():
        info_list=vfacts[vfact]
        if type(info_list) is dict:
            for info in info_list:
                element_list=info_list[info]
                if type(element_list) is list:
                    if element_list[1]=='array' and '_PROVE' not in info and '_ASSUME' not in info and len(element_list)==2:
                        array_list.append(info)
        else:
            if info_list[1]=='array' and '_PROVE' not in vfact and '_ASSUME' not in vfact and len(element_list)==2:
                array_list.append(vfact)
    

    for e in f:
        if isArrayFunction(e)==True:
            if len(array_list)>0:
                new_f[e]=f[e]
        else:
            new_f[e]=f[e]
    for e in o:
        if isArrayFunction(e)==True:
            if len(array_list)>0:
                new_o[e]=o[e]
        else:
            new_o[e]=o[e]
    for e in a:
        if e[0]=='i1':
            if isArrayFunction(e[3][0])==True:
                if len(array_list)>0:
                    new_a.append(e)
            else:
                new_a.append(e)
        elif e[0]=='i0':
            if isArrayFunction(e[2][0])==True:
                if len(array_list)>0:
                    new_a.append(e)
            else:
                new_a.append(e)
        else:
            new_a.append(e)
    
    return new_f,new_o,new_a


def organizeFreeVariable(f,o,a,vfacts):
    struct_type_list=[]
    for vfact in vfacts.keys():
        info_list=vfacts[vfact]
        for info in info_list:
            if info_list[info][1] not in ['int','short','unsigned','long','char','float','double','array']:
                struct_type_list.append(info)
    
    for x in o:
        e=o[x]
        if  e[0]=='e':
            if is_Stuct(e[-2][0],struct_type_list):
                e[-1] = expr_replace(e[-1],eval("['_x1']"),eval("['_s1']"))
                e[-2] = expr_replace(e[-2],eval("['_x1']"),eval("['_s1']"))
    
    for e in a:
        if e[0]=='i1' or e[0]=='i0':
            if is_Stuct(e[-2][0],struct_type_list):
                e[-1] = expr_replace(e[-1],eval("['_x1']"),eval("['_s1']"))
                e[-2] = expr_replace(e[-2],eval("['_x1']"),eval("['_s1']"))

            



def is_Stuct(var,struct_type_list):
    status=False
    for x in struct_type_list:
        temp=var.replace(x,'').strip()
        if is_number(temp)==True:
            status=True
    return status
        
        



# translate0(program,set of program variables) returns a dictionary of frame axioms, output equations, a list of other axioms and a label

def translate0(p,v,flag):
    if p[1]=='while':
        return translateWhile(p,v,flag)
    if p[1]=='seq':
        return translateSeq(p,v,flag)
    if p[1]=='if1':
        return translateIf1(p,v,flag)
    if p[1]=='if2':
        return translateIf2(p,v,flag)
    if p[1]=='=':
        return translateAssign(p,v,flag)
    if p[1]=='fun':
        return translateFun(p,v,flag)
    if p[1]=='prog':
        return translateProgram(p,v,flag)
     
     
# function definition
def translateFun(p,v,flag): #p=['-1','fun',['foo','x',..,'y'], b]
    #global TC
    #global LC
    #TC=0
    #LC=0
    f,o,a,l = translate0(p[-1],v,flag)
    axioms=a
    for x in f:
        axioms=axioms+[f[x]]
    for x in o:
        axioms=axioms+[o[x]]
    g = graph(axioms,v) #construct dependency graph
    param = list(expres(a) for a in p[-2][1:]) #parameters of the function
    dep_set = {} #dependency set for each variables in the axiom
    dep_set[RET+OUT]=expres(p[-2][0],param) #initialize it to the return function
    for (x,y) in g:
        if (not x in dep_set) and (not expres(x) in param):
            dep = []
            for x1 in reach_set([x],g):
                if (expres(x1) in param) and not (expres(x1) in dep):
                    dep.append(expres(x1))
            dep_set[x] = dep
    
    
    for x in f:
        f[x]=parameterize_wff_fun(f[x],dep_set)
    for x in o:
        o[x]=parameterize_wff_fun(o[x],dep_set)
    for i,ax in enumerate(a):
        a[i]=parameterize_wff_fun(ax,dep_set)
    return [dep_set[RET+OUT],f,o,a,l]
    
      
    
    
# program: a set of functions   
#p=['-1','prog',[f1,...,fk]] 
#for each fi, v[fi] is the list of variables used in the function fi
def translateProgram(p,v,flag): 
    result = {}
    for x in p[-1]:
        funcName = x[2][0]
        result[funcName] = translate0(x,v[funcName],flag)
    return result


# assignment translation: p a program and v a set of program variables

map___VERIFIER_nondet={}

def translateAssign(p,v,flag): #p=[l,'=',left,right]
    global map___VERIFIER_nondet
    if p[1] != '=':
        print('Not an assignment')
        return
    left = p[2] #left side of the assigment
    op = left[0] #the functor in left
    arity = len(left)-1 #arity of op
    right = p[3] #right side of the assignment
    right = update__VERIFIER_nondet_stmt(right,map___VERIFIER_nondet)
    out=OUT if p[0] == '-1' else LABEL+p[0]
    out_axioms = {}
    frame_axioms = {}
    for x in v:
        if x == op:
            args = list(expres('_x'+str(i+1)) for i in range(arity))
            cond = expres('=',[expres('_x1'),left[1]]) if arity==1 else \
                   expres('and', list(expres('=', [expres('_x'+str(i2+1)),y]) for \
                                    i2,y in zip(range(arity),left[1:])))
            if arity == 0:
                out_axioms[x]=wff_e(expres(op+out),right)
            else:
                out_axioms[x]=wff_e(expres(op+out,args), expres('ite',[cond,right,expres(op,args)]))
        else:
            args = list(expres('_x'+str(i+1)) for i in range(len(v[x])-2))
            frame_axioms[x]=wff_e(expres(x+out,args), expres(x,args))
    return frame_axioms, out_axioms, [], p[0]
    
    
    

def translateIf1(p,v,flag): # p=[l,'if1',c,e]
    global map___VERIFIER_nondet
    if p[1] != 'if1':
        print('Not an if-then')
        return
    global TC
    frame_axioms,out_axioms,axioms,llabel = translate0(p[3],v,flag)
    old_out = OUT if llabel=='-1' else LABEL+llabel
    out=OUT if p[0] == '-1' else LABEL+p[0]
    if llabel=='-1': # body has no final label
        TC += 1
    body_out = TEMP+str(TC) if llabel=='-1' else LABEL+llabel
    
    p[2] = update__VERIFIER_nondet_stmt(p[2],map___VERIFIER_nondet)
    
    for x in v:
        if x in frame_axioms: 
            ax = frame_axioms[x] #ax = ['e',e1,e2]
            if llabel != '-1': #body has label: keep axioms about it
                axioms.append(ax)
            #generate the new frame axiom
            frame_axioms[x] = wff_e(expr_sub(ax[1],x+old_out,x+out), ax[2])
        else:
            ax = out_axioms[x] #ax = ['e',e1,e2]
            if llabel != '-1': #body has label: keep axioms about it
                axioms.append(ax)
            out_axioms[x] = wff_e(expres(x+out, ax[1][1:]),
                                  expres('ite', [p[2], ax[2], expres(x,ax[1][1:])]))
    return frame_axioms, out_axioms, axioms, p[0]
    
            
def translateIf2(p,v,flag): # p=[l,'if2',c,e1,e2]
    global map___VERIFIER_nondet
    if p[1] != 'if2':
        print('Not an if-then-else')
        return
    global TC
    frame_axioms0,out_axioms0,axioms0,llabel0 = translate0(p[3],v,flag)
    frame_axioms1,out_axioms1,axioms1,llabel1 = translate0(p[4],v,flag)
    axioms = axioms0+axioms1
    old_out0 = OUT if llabel0=='-1' else LABEL+llabel0
    old_out1 = OUT if llabel1=='-1' else LABEL+llabel1
    out=OUT if p[0] == '-1' else LABEL+p[0]
    if llabel0=='-1': # if body has no final label
        TC += 1
    body_out0 = TEMP+str(TC) if llabel0=='-1' else LABEL+llabel0 # if body new out
    if llabel1=='-1': # else body has no final label
        TC += 1
    body_out1 = TEMP+str(TC) if llabel1=='-1' else LABEL+llabel1 # else body new out
    frame_axioms = {}
    out_axioms = {}
    
    p[2] = update__VERIFIER_nondet_stmt(p[2],map___VERIFIER_nondet)
    
    for x in v:
        if x in frame_axioms0 and x in frame_axioms1: 
            ax0 = frame_axioms0[x] #ax0 = ['e',e1,e2]
            ax1 = frame_axioms1[x] #ax1 = ['e',e1,e2]
            if llabel0 != '-1': #if body has label: keep axioms about it
                axioms.append(ax0)
            if llabel1 != '-1': #else body has label: keep axioms about it
                axioms.append(ax1)
            #generate the new frame axiom
            frame_axioms[x] = wff_e(expr_sub(ax0[1],x+old_out0,x+out), ax0[2])
        else:
            if x in frame_axioms0:
                ax0=frame_axioms0[x]
            else:
                ax0=out_axioms0[x]
            if x in frame_axioms1:
                ax1=frame_axioms1[x]
            else:
                ax1=out_axioms1[x]
            if llabel0 != '-1': #if body has label: keep axioms about it
                axioms.append(ax0)
            if llabel1 != '-1': #else body has label: keep axioms about it
                axioms.append(ax1)
            out_axioms[x] = wff_e(expres(x+out, ax0[1][1:]),
                                  expres('ite', [p[2], ax0[2], ax1[2]]))
    return frame_axioms, out_axioms, axioms, p[0]
    
            
def translateSeq(p,v,flag): # p=['-1','seq',p1,p2]
    if p[1] != 'seq':
        print('Not a sequence')
        return
    global TC
    frame_axioms0,out_axioms0,axioms0,llabel0 = translate0(p[2],v,flag)
    frame_axioms1,out_axioms1,axioms1,llabel1 = translate0(p[3],v,flag)
    old_out0 = OUT if llabel0=='-1' else LABEL+llabel0
    if llabel0=='-1': # if p1 has no final label
        TC += 1
    new_out0 = TEMP+str(TC) if llabel0=='-1' else LABEL+llabel0 # p1 new out
    frame_axioms = {}
    out_axioms = {}
    para = {} #a dictonary of substitution: para[x] is the expression to replace x(t) in p2's axioms
    for x in v:
        if x in frame_axioms0 and x in frame_axioms1:
            if llabel0 !='-1': #p1 has label, keep its axioms
                axioms0.append(frame_axioms0[x])
            frame_axioms[x]=frame_axioms1[x]
        else:
            if x in frame_axioms0:
                ax0=frame_axioms0[x] #ax0=['e',e1,e2]
            else:
                ax0=out_axioms0[x]
            if llabel0 != '-1': #p1 has label: keep equations about it
                axioms0.append(ax0)
            para[x]=ax0[2]
    for i,ax in enumerate(axioms1): #substituting p1's output into p2's input in p2's axioms
        axioms1[i] = wff_sub_dict(ax,para)
    for x in v: #do the same for the p2's output equations and frame axioms
        if not x in frame_axioms:
            if x in frame_axioms1:
                out_axioms[x] = frame_axioms1[x][:2]+[expr_sub_dict(frame_axioms1[x][2],para)]
            else:
                out_axioms[x] = out_axioms1[x][:2]+[expr_sub_dict(out_axioms1[x][2],para)]
    
    return frame_axioms, out_axioms, axioms0+axioms1, llabel1
    


def translateWhile(p,v,flag): #p=[l, 'while', c, b]
    global map___VERIFIER_nondet
    if p[1] != 'while':
        print('Not a while statement')
        return
    global LC
    global TC
    frame_axioms, out_axioms0, axioms,llabel = translate0(p[3],v,flag) # axioms and output labels for the body of the loop
    LC += 1
    if llabel=='-1': # if body has no final label
        if TC==0:
            TC += 2
        else:
            TC += 1
        
    loop_var = expres('_n'+str(LC)) #a new natural number variable for the loop
    smallest = expres('_N'+str(LC)) #a new natural number variable for the loop
    init=TEMP+str(TC) if llabel=='-1' else LABEL+llabel #iterating functions
    old_out=OUT if llabel=='-1' else LABEL+llabel #original output functions in body
    out=OUT if p[0]=='-1' else LABEL+p[0] #new output functions for the loop

    for i0, ax0 in enumerate(axioms): #extend the axioms with [n]
        ax0 = wff_sub_set(ax0,'',init,v,frame_axioms)
        axioms[i0]=wff_extend(ax0, loop_var, frame_axioms,v)

    for x in frame_axioms:
        ax = frame_axioms[x] #ax = ['e',e1,e2]
        if llabel != '-1': #body has label: keep axioms about it
            axioms.append(ax)
        #generate the new frame axiom
        frame_axioms[x] = wff_e(expr_sub(ax[1],x+old_out,x+out), ax[2])
    out_axioms00={}
    for x in out_axioms0: 
        ax = out_axioms0[x] #ax = ['e',e1,e2]
        #change output and input variable names to loop and extend e2[loop_var]
        ax = wff_sub_set(ax,old_out,init,v,frame_axioms)
        ax = wff_sub_set(ax,'',init,v,frame_axioms)
        out_axioms00[x]=ax[:2]+[extend(ax[2],loop_var,frame_axioms,v)]

    # using Pritom's solve_rec() to try to get closed-form solution
    found_solution=True
    variable=None
    while found_solution:
        found1=False
        for x in out_axioms00.keys():
            ax=out_axioms00[x]
            if expr_func(ax[2],v)==[]:
                found1=True
                e=extend(ax[1],loop_var,frame_axioms,v)
                axioms.append(wff_e(e,ax[2]))
                del out_axioms00[x]
                for y in out_axioms00:
                    ax1= out_axioms00[y]
                    out_axioms00[y]=ax1[:2]+[expr_sub_dict(ax1[2],{expr_op(ax[1]):ax[2]})]
            else:
                e1=wff_i1(0,expr_op(loop_var),extend(ax[1],expres('+',[loop_var,['1']]),frame_axioms,v),ax[2])
                e2=wff_i0(0,extend(ax[1],expres('0'),frame_axioms,v),expres(x,expr_args(ax[1])))
                res=solve_rec(e1,e2)
                if res != None: #res = ['i2',k,n,e1,e2]
                    found1=True
                    variable=res[2] # Variable add by Pritom Rajkhowa
                    axioms.append(wff_e(res[3],res[4]))
                    del out_axioms00[x]
                    for y in out_axioms00:
                        ax1= out_axioms00[y]
                        out_axioms00[y]=ax1[:2]+[expr_sub_dict(ax1[2],{expr_op(res[3]):res[4]})]
        if not found1:
            found_solution=False
    for x in out_axioms00:
        ax = out_axioms00[x] #ax = ['e',e1,e2]
        e1=extend(ax[1],expres('+',[loop_var,['1']]),frame_axioms,v)
        e2=ax[2]
        axioms.append(wff_i1(len(expr_args(e1))-1,expr_op(loop_var),e1,e2))
    
    #base case
    for x in out_axioms00:
        arity = len(v[x])-2
        args = list(expres('_x'+str(i+1)) for i in range(arity))
        axioms.append(wff_i0(arity,expres(x+init,args+[expres('0')]), expres(x,args)))
    c=p[2] #loop condition
    c = update__VERIFIER_nondet_stmt(c,map___VERIFIER_nondet)
    c=expr_sub_set(c,'',init,v,frame_axioms)
    c = extend(c,loop_var,frame_axioms,v) #add the smallest macro
     #Add by pritom
    cc = copy.deepcopy(c)
    axioms.append(wff_s0(expr_sub(expr_complement(cc),expr_op(loop_var),expr_op(smallest))))  
    #axioms.append(wff_s0(expres('not',[expr_sub(c,expr_op(loop_var),expr_op(smallest))])))
    axioms.append(wff_s1(expres('implies',
                             [expres('<', [loop_var, smallest]),c])))
    out_axioms = {}
    for x in v: # generate out_axioms
        if not x in frame_axioms:
            args = list(expres('_x'+str(i+1)) for i in range(len(v[x])-2))
            e1=expres(x+out,args)
            args.append(smallest)
            e2=expres(x+init,args)
            out_axioms[x]=wff_e(e1,e2)
    #substitution of closed form solution by pritom rajkhowa
    constant='_N'+str(LC)
    variable='_n'+str(LC)
    update_axioms=[]
    equations=[]

    for ax in axioms:
    	if ax[0]=='e':
    		equations.append(ax)
    	else:
    		update_axioms.append(ax)
    
    for equation in equations:
    	equation1=copy.deepcopy(equation)
    	update_axioms=solnsubstitution(update_axioms,equation[1],equation[2])
    	equation1[1]=expr_replace_const(equation1[1],variable,constant)
    	equation1[2]=expr_replace_const(equation1[2],variable,constant)
    	update_axioms=solnsubstitution(update_axioms,equation1[1],equation1[2])
    	for x in out_axioms:
		stmt=out_axioms[x]
    		stmt[2]=expr_replace(stmt[2],equation1[1],equation1[2])
    axioms=update_axioms
    updated_axioms=[]
    for ax in axioms:
    	if ax[0]=='s0':
        	expression=expr2string1(ax[1])
        	if '->' not in expression and constant in expression:
        		if '>=' in expression and 'and' not in expression and 'or' not in expression:
                                if '**' not in expression:
                                    expression=normal_form_constant(expression, constant) 
                                    #pp = getParser()
                                    #tree = pp.parse_expression(str(expression))
                                    if '**' not in str(expression):
                                        parser = c_parser.CParser()
                                        ast = parser.parse("void test(){"+str(expression)+";}")
                                        statement_temp=ast.ext[0].body.block_items[0]
                                        axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                                        #axupdate=construct_expression_normal(tree)
                                        if axupdate is not None:
                                                updated_axioms.append(axupdate)
                                        else:
                                                updated_axioms.append(ax)
                                    else:
                                        updated_axioms.append(ax)
                                else:
                                    updated_axioms.append(ax)
        		elif '<=' in expression and 'and' not in expression and 'or' not in expression:
    				if '**' not in expression:
                                    expression=normal_form_constant(expression, constant)
                                    #pp = getParser()
                                    if '**' not in str(expression):
                                        parser = c_parser.CParser()
                                        ast = parser.parse("void test(){"+str(expression)+";}")
                                        statement_temp=ast.ext[0].body.block_items[0]
                                        #tree = pp.parse_expression(str(expression))		 
                                        #axupdate=construct_expression_normal(tree)
                                        axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                                        if axupdate is not None:
                                                updated_axioms.append(axupdate)
                                        else:
                                                updated_axioms.append(ax)
                                    else:
                                        updated_axioms.append(ax)
                                else:
                                    updated_axioms.append(ax)
    			else:
    				updated_axioms.append(ax)
    		else:
    			updated_axioms.append(ax)
    		
    	else:
     		updated_axioms.append(ax)
    axioms=[]
    for ax in updated_axioms:
    	axioms.append(ax)

    #substitution of closed form solution by pritom rajkhowa  
    if flag==2:
        g = graph(axioms,v) #construct dependency graph
        for x in expr_func(p[2],v):
            if not ['_N'+str(LC), x] in g:
                g.append(['_N'+str(LC), x])
                g.append(['_N'+str(LC), x+init])
        for x in out_axioms00:
            if not [x+init,x] in g:
                g.append([x+init,x])
            if not [x,x+init] in g:
                g.append([x,x+init])
            for y in expr_func(out_axioms00[x][2],v):
                if not [x,y] in g:
                    g.append([x,y])
        #build a dictionary para = { 'X':[1,['_y1']], 'X11':[0,['_y1','_y2'],['X','Y'],...} 
        #meaning 'X' is an input variable parameterized as '_y1' and 
        #'X11' is a function taking two new parameters '_y1' and '_y2' which correspond 
        # to 'X' and 'Y', respectively
        para={} 
        for [x,x1] in g: #compute the dependency sets
            if x in v and not x in frame_axioms:
                para[x] = [1,[v[x][0]]]
            else:
                if not x in para and not x in frame_axioms:
                    t=[]
                    t1=[]
                    for y in reach_set([x],g):
                        if y in v and (not expres(y) in t1) and (not y in frame_axioms):
                            t.append(expres(v[y][0]))
                            t1.append(expres(y))
                    if t != []:
                        para[x] = [0,t,t1]
        #parameterize input variables that N depends on and all associated functions
        for i,ax in enumerate(axioms):
            axioms[i] = parameterize_wff(ax,para)
        #construct inductive definition for N
        s_args = para['_N'+str(LC)][1]
        smallest1=expres('_N'+str(LC), s_args)
        next_args=[]
        for i,y in enumerate(s_args):
            x=expr_op(para['_N'+str(LC)][2][i])
            next_args.append(parameterize_expres(out_axioms0[x][2],para))
        axioms.append(['d0',smallest1, parameterize_expres(expres('not',[p[2]]),para)])
        axioms.append(['d1','_n'+str(LC), smallest1, 
                       expres('=',[loop_var,expres('_N'+str(LC),next_args)])])
        #parameterize output axioms
        for x in out_axioms:
            out_axioms[x]=out_axioms[x][:2]+[parameterize_expr_sub(out_axioms[x][2],para)]
        new_axioms = [] #for creating new inductive definitions
        for ax in axioms:
            if ax[0]=='i1':
                x=expr_op(ax[3])
                if x.endswith(init) and x[:len(x)-len(init)] in v:
                    next_args=[]
                    for k,arg in enumerate(expr_args(ax[3])):
                        if k==ax[1]:
                            next_args.append(expres(ax[2]))
                        else:
                            a=expr_op(arg)
                            if a.startswith('_y'):
                                for b in v:
                                    if v[b][0]==a:
                                        next_args.append(parameterize_expres(out_axioms0[b][2],para))
                            else:
                                next_args.append(arg)
                    new_axioms.append(ax[0:4]+[expres(x,next_args)])
        axioms=axioms+new_axioms

    return frame_axioms, out_axioms, axioms, p[0]






#construct a graph of dependency relation in a set of equations axioms 
def graph(axioms,v):
    ret = []
    for ax in axioms:
        if ax[0]=='e' or ax[0]=='i0' or ax[0]=='i1' or ax[0]=='d0' or ax[0]=='d1':
            op=expr_op(ax[-2])
            for x in expr_func(ax[-1],v):
                if not [op,x] in ret:
                    ret.append([op,x])
        elif ax[0]=='s1':
            op=expr_op(expr_args(expr_args(ax[1])[0])[1])
            for x in expr_func(expr_args(ax[1])[1],v):
                if not [op,x] in ret:
                    ret.append([op,x])
    return ret

#given a list s of nodes, return the list of nodes that are reachable from the nodes in s
def reach_set(s,g):
    s1=[]
    for [n1,n2] in g:
        if (n1 in s) and not (n2 in s):
            s1.append(n2)
    if s1==[]:
        return s
    else:
        return reach_set(s+s1,g)

                            
# testing examples. 
x=expres('x')
y=expres('y')
ex1 = ['-1','=',x, expres('+',[y,['1']])] #x=y+1
ex2 = ['-1','=',y, ['+',y,['1']]] #y=y+1
ex21 = ['1','=',y, ['+',y,['1']]] #1: y=y+1
ex22 = ['-1','if1',['>', y,['1']],ex2] # if y>1 then y=y+1
ex23 = ['-1','if1',['>', y,['1']],ex21] # if y>1 then l: y=y+1
ex24 = ['-1','if2',['>', y,['1']],ex21,ex1] # if y>1 then l: y=y+1 else x=y+1
ex3 = ['-1','seq',ex1,ex2]  #x=y+1; y=y+1
v1 = {'x':['_y1','int'], 'y':['_y2','int']}
ex4 = ['-1', '=', ['t',x], ['+', ['+', ['z', x, ['t', x]], ['1']], x]]
ex42 = ['-1', '=', ['z',x,y], ['+', ['+', ['z', x, ['t', x]], ['1']], x]]
v2 = {'x':['_y1','int'], 'y':['_y2','int'], 't':['_y3','int','int'], 'z':['_y4','int','int','int']}
ex41 = ['-1','if1',['>', y,['1']],ex4] # if y>1 then ex4

ex25 = ['-1','if2',['>', y,['1']],ex1,ex4] 

ex5 = ['-1','if2',expres('and', [expres('=', [expres('x'),expres('t',[expres('1')])]), expres('<', [expres('y'), expres('z',[expres('x'),expres('y')])])]), ex1, ex4]

ex6 = ['-1','while',expres('<',[expres('x'),expres('y')]),ex4]

#translate1(ex3,v1,1)
#translate1(ex4,v2,1)
#translate1(ex5,v2,1)

# factorial function
"""
i=1;
F=1;
while(i <= X) {
 F=F*i;
 i=i+1;
}
"""
i=expres('i')
F=expres('F')
X=expres('X')
fact0 = ['-1','seq',['-1','=',i,['1']],['-1','=',F,['1']]]
fact1 = ['-1','seq',['-1','=',F,['*',F,i]],['-1','=',i,['+',i,['1']]]]
fact2 = ['-1','while', ['<=',i,X], fact1]
fact = ['-1','seq',fact0,fact2]
vfact = {'i':['_y1','int'], 'X':['_y2','int'], 'F':['_y3','int'],RET:['_y0','int']}
#translate1(fact,vfact)

#factorial as a function: return F
fact3 = ['-1','=',expres(RET),F]
funfact = ['-1','fun',['factorial', 'X'],['-1','seq',fact,fact3]]
#a main() that uses factorial
# main1() { X=factorial(2) }
main1 = ['-1','fun',['main1'],['-1','=',X,expres('factorial',[expres('2')])]]
# variable list for main1()
man1v = {'X':['_y1','int']}
# variable lists for main1p, one for each function
main1pv = {'main1':man1v,'factorial':vfact}
main1p = ['-1','prog',[funfact,main1]]
# translate1(main1p, main1pv,1)

# in-place list reversing - see Lin and Yang 2015
"""
J = null;
while I != null do {
    K = next(I);
    next(I) = J;
    J=I;
    I=K;
}
I=J;
"""

lr6 = ['-1','=',['I'],['K']]
lr5 = ['-1','seq',['-1','=',['J'],['I']], lr6]
lr4 = ['-1','seq',['-1','=', ['next', ['I']],['J']], lr5]
lr3 = ['-1','seq',['-1','=',['K'],['next',['I']]], lr4]
lr2 = ['-1','while',['!=', ['I'], ['null']], lr3]
lr1 = ['-1','seq',lr2,['-1','=',['I'],['J']]]
lr = ['-1','seq',['-1','=',['J'],['null']], lr1]
vlr = {'J':['_y1','list'],'I':['_y2','list'],'K':['_y3','list'],'next':['_y4','list','list']}

#Cohen's division algorithm
"""
//XandYaretwoinputintegers;Y>0 
Q=0; // quotient
R=X; // remainder
while (R >= Y) do {
    A=1; // A and B are some that at any time for
    B=Y; // some n, A=2^n and B=2^n*Y
    while (R >= 2*B) do {
       A = 2*A;
       B = 2*B; }
    R = R-B;
    Q = Q+A }
//
return Q = X/Y;
"""

A=expres('A')
B=expres('B')
R=expres('R')
Q=expres('Q')
Y=expres('Y')
A2=expres('*',[expres('2'),A]) #2*A
B2=expres('*',[expres('2'),B]) #2*B
RB=expres('-',[R,B]) #R-B
QA=expres('+',[Q,A]) #Q+A
c1=expres('>=',[R,B2]) #R>=2*B
c2=expres('>=',[R,Y]) #R >= Y

cohen9=['-1','seq',['-1','=',A,A2],['-1','=',B,B2]]
cohen8=['-1','seq',['-1','=',R,RB],['-1','=',Q,QA]]
cohen7=['-1','while',c1, cohen9]
cohen6=['-1','seq',cohen7,cohen8]
cohen1=['-1','=',Q,['0']]
cohen5=['-1','seq',['-1','=',B,Y],cohen6]
cohen4=['-1','seq',['-1','=',A,['1']],cohen5]
cohen3=['-1','while',c2, cohen4]
cohen2=['-1','seq',['-1','=',R,X],cohen3]
cohen = ['-1', 'seq', cohen1,cohen2]
vcohen={'X':['_y1','int'],'Y':['_y2','int'],'Q':['_y3','int'],'R':['_y4','int'],'A':['_y5','int'],'B':['_y6','int']}

#product of two integers
"""
Z = 0;
while( Y!=0 ) {
 if ( Y % 2 ==1 ) {
     Z = Z+X;
     Y =(Y-1);
  }
  X = 2*X;
  Y = Y/2;
}
"""
Z=expres('Z')
prod1=['-1','seq',['-1','=',Z,expres('+',[Z,X])],['-1','=',Y,expres('-',[Y,['1']])]]
prod2=['-1','seq',['-1','=',X,expres('*',[['2'],X])],['-1','=',Y,expres('/',[Y,['2']])]]
prod3=['-1', 'if1', expres('=',[expres('%',[Y,['2']]), ['1']]), prod1]
prod4=['-1','seq',prod3,prod2]
prod5=['-1','while',expres('!=',[Y,['0']]),prod4]
prod = ['-1','seq',['-1','=',Z,['0']],prod5]
vprod = {'X':['_y1','int'],'Y':['_y2','int'],'Z':['_y3','int']}

#array sum array represented as a reference, and element represented by at predicate
"""
i=0;
sum=0;
while (i<size(A)) {
 sum=at(A,i)+sum
 i=i+1
}
"""
sum3=['-1','while',expres('<',[i,expres('size',[A])]),['-1','seq',['-1','=',['sum'],expres('+',[expres('at',[A,i]),['sum']])],['-1','=',i,expres('+',[i,['1']])]]]
sum2=['-1','seq',['-1','=',['sum'],['0']],sum3]
sum1=['-1','seq',['-1','=',i,['0']],sum2]
vsum = {'i':['_y1','int'],'sum':['_y2','int'],'size':['_y3','array','int'],'A':['_y4','array'],'at':['_y5','array','int','int']}

#Dijkstra's LCM algorithm
"""
X=A;  Y=B;  U=B;  V=A;
while (X!=Y) { 
  if (X>Y) {X=X-Y; V=V+U;} 
      else {Y=Y-X; U=U+V;}
}
"""

A=expres('A')
B=expres('B')
X=expres('X')
V=expres('V')
U=expres('U')
XY=expres('-',[X,Y])
YX=expres('-',[Y,X])
UV=expres('+',[U,V])
lcm1=['-1','seq',['-1','=',X,A],['-1','=',Y,B]]
lcm2=['-1','seq',lcm1,['-1','=',U,B]]
lcm3=['-1','seq',lcm2,['-1','=',V,A]]
lcm4=['-1','seq',['-1','=',X,XY],['-1','=',V,UV]]
lcm5=['-1','seq',['-1','=',Y,YX],['-1','=',U,UV]]
c1=expres('>',[X,Y])
lcm6=['-1', 'if2', c1, lcm4,lcm5]
c2=expres('!=',[X,Y])
lcm7=['-1','while',c2,lcm6]
lcm = ['-1','seq',lcm3,lcm7]
vlcm={'A':['_y1','int'],'B':['_y2','int'],'X':['_y3','int'],'Y':['_y4','int'],'U':['_y5','int'],'V':['_y6','int']}

"""
matrix multiplication from verifythis-2016 competition

int[][] matrixMultiply(int[][] A, int[][] B) {
	int n = A.length;

	// initialise C
	int[][] C = new int[n][n];

	for (int i = 0; i < n; i++) {
   		for (int k = 0; k < n; k++) {
       			for (int j = 0; j < n; j++) {
           			C[i][j] += A[i][k] * B[k][j];
       			}
   		}
	}
	return C;
 }
"""
def less(x,y):
    return expres('<',[x,y])
def passign(l,le,ri):
    return [l,'=',le,ri]
def initialize_array2(x,i,j,m,n):
    a=passign('-1',expres('d2array',[x,i,j]),expres('0')) #d2array(x,i,j)=0
    a1=passign('-1',i,expres('+',[i,expres('1')])) #i++
    a2=passign('-1',j,expres('+',[j,expres('1')])) #j++
    while1 = ['-1','while', less(j,n), ['-1','seq',a,a2]]
    body1 = ['-1','seq',while1,a1]
    body2 = ['-1','seq',passign('-1',j,expres('0')),body1]
    while2 = ['-1','while', less(i,m), body2]
    return ['-1','seq',passign('-1',i,expres('0')),while2]

mM1 = ['-1','seq',passign('-1',expres('n'),expres('length',[expres('a')])),
       initialize_array2(expres('c'),expres('i'),expres('j'),expres('n'),expres('n'))]
mM = ['-1','seq',mM1,passign('-1',expres(RET),expres('c'))]
# for now matrixMuliply only initializes C
matrixMultipy = ['-1','fun', ['matrixMultiply','a','b'],mM]
mMv = {'a':['_y1','array'],'b':['_y2','array'],'c':['_y3','array'],RET:['_y0','array'],'i':['_y4','int'],'j':['_y5','int'],'k':['_y6','int'],'n':['_y7','int'],'d2array':['_y7','array','int','int','int']}

# translate1(matrixMultipy,mMv,1)

"""

#Add by Pritom 

"""


#Function Get list of parameters 

def find_between( s, first, last ):
    try:
        start = s.index( first ) + len( first )
        end = s.index( last, start )
        return s[start:end]
    except ValueError:
        return ""
        
#Get the parameter 

def getParameter( parameterlist ):
	try:
	 	parameters=parameterlist.split(',')
		for index, parameter  in enumerate(parameters):
			if '+1' in parameter:
				return parameter.replace("\n","").strip()
	except ValueError:
        	return ""





"""
Function to Take care of the parentheses During 

#substitutor='(X2(_N1(B,A),A,B)'
#left=None
#right=None

"""
def parenthesesOrganizer( substitutor ,left ,right):
	if left is None:
		left=""
	if right is None:
		right=""
	if substitutor[0]=="(":
		left=left+"("
		substitutor=substitutor[1:len(substitutor)]
		if substitutor[len(substitutor)-1]==")":
			right=right+")"
			substitutor=substitutor[0:len(substitutor)-1]
			leftin=None
			rightin=None
			leftin,rightin,substitutor_update=parenthesesOrganizer(substitutor,leftin ,rightin)
			if leftin is not None and rightin is not None:
				substitutor=leftin+substitutor_update+rightin
		else:
			substitutor="("+substitutor
			left=left[0:len(left)-1]
	return left,right,substitutor


"""

#Get Function Name 
#This can be done using Regular expression ...Need to update
"""
def getFunctionName(function,parameters ):
	for parameter in parameters:
		function=function.replace(parameter,"")
	blanklist=find_between( function,'(',')')
	function=function.replace("("+str(blanklist)+")","")
	return function


"""

axiomes to Z3 statements

"""


"""
#Test Case 1
#variable="n1"

#Test Case 2
#variable="_n1"

"""


def isConstant( variable ):
	status=False
	find=regex.compile(r'[_]N\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status


def isFunCallbyRef( variable ):
	status=False
	find=regex.compile(r'f\d[_]\d[_]RET')
	group = find.search(variable)
	if group is not None:
		status=True
	return status


#fun_name="ackermann_2"

#fun_list=['ackermann']

def isRecurrenceFun( fun_name, fun_list ):
	status=False
        for fun in fun_list:
            if fun_name.startswith(fun+'_')==True:
                digit=fun_name.replace(fun+'_', '')
                if is_number(digit)==True:
                    return fun
	return None




"""
#Test Case 1
#variable="n1"

#Test Case 2
#variable="_n1"

"""


def isLoopvariable( variable ):
	status=False
	find=regex.compile(r'[_]n\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status


"""
#Test Case 1
#variable="C1"

#Test Case 2
#variable="C0"

"""


def isConstInResult( variable ):
	status=False
	find=regex.compile(r'C\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status


#Test Case 1
#variable="d1array4"

#Test Case 2
#variable="d1ar4"	
	
def isArrayFunction( variable ):
	status=False
	find=regex.compile(r'([d]\d[a][r][r][a][y]\d|[d]\d[a][r][r][a][y])')
	group = find.search(variable)
	if group is not None:
		status=True
	return status


#Is Boolean Variable

#Test Case 1
#variable="bool_go_error1"

#Test Case 2
#variable="bool_go_error2"	
	
def isBoolVariable( variable ):
	status=False
	find=regex.compile(r'([b][o][o][l][_][g][o][_])')
	group = find.search(variable)
	if group is not None:
		status=True
	return status




#expression='n+1'

def replaceAddOperator(expression):
	p = regex.compile(r'[A-Za-z|\d|\)|\]][+][A-Za-z|\d|\(|\]]')
	result=(p.sub(lambda m: m.group().replace("+", " + "), expression))
	result=replaceAddOperator1(result)
	return result

def replaceAddOperator1(expression):
	p = regex.compile(r'[A-Za-z|\d|\s][+][A-Za-z|\d]')
	result=(p.sub(lambda m: m.group().replace("+", "+ "), expression))
	return result
	



#Is Varible is Substitution Variable
# variable = 'f1_1_i'
def isSubsVar( variable ):
	status=False
	find=regex.compile(r'f\d[_]\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status



"""
#Extract arguments from smallest function

#Example 1: expr="smallest(n,_N1,su(n)>X(n))"
#extract_args(expr):

"""
def extract_args(expr):
    paren = 0
    start = 0
    ret = []
    for i, c in enumerate(expr):
        if c=='(':
            paren+=1
            if paren==1:
                start=i+1
        elif c==')':
            if paren==1 and start:
                ret.append(expr[start: i]) 
            paren-=1
        elif c==',' and paren==1:
            ret.append(expr[start:i])
            start=i+1
    return ret


# expr_replace(e,e1,e2): replace all subterm e1 in e by e2

#e=['a', ['implies', ['<', ['_n1'], ['_N1']], ['<', ['x2', ['_n1']], ['y2', ['_n1']]]]]

#e=['a', ['<', ['x2', ['_N1']], ['y2', ['_N1']]]]

def expr_complement(e): #e,e1,e2: expres
    if e[:1]==['<']:
    	e[:1]=['>=']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['>']:
    	e[:1]=['<=']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['>=']:
        e[:1]=['<']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['<=']:
        e[:1]=['>']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['==']:
        e[:1]=['!=']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['!=']:
        e[:1]=['==']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['&&']:
        e[:1]=['||']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['||']:
        e[:1]=['&&']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['and']:
        e[:1]=['or']
        return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['or']:
        e[:1]=['and']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    else:
        return e[:1]+list(expr_complement(x) for x in expr_args(e))



""" 
#Function to replace variable by constant
#Test Case
#e=['a', ['<', ['x2', ['_n1']], ['y2', ['_n1']]]]
#variable='_n1'
#constant='_N1'
#expr_replace_const(e,variable,constant)
"""

def expr_replace_const(e,variable,constant):
	if e[:1]==expres(variable):
		e[:1]=expres(constant)
	return e[:1]+list(expr_replace_const(x,variable,constant) for x in expr_args(e))


def get_All_Var(e,var_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
    	if is_number(op)==False and is_hex(op)==None and op not in _base:
        	var_map.append(op)
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                get_All_Var(args[0],var_map)
            else:
            	for x in args:
            		get_All_Var(x,var_map)
        elif op=='not' and len(args)==1:
            get_All_Var(args[0],var_map)
        elif op=='implies' and len(args)==2:
            get_All_Var(args[0],var_map)
            get_All_Var(args[1],var_map)
        elif op in _infix_op and len(args)==2:
            get_All_Var(args[0],var_map)
            get_All_Var(args[1],var_map)
        else:
        	if is_number(op)==False and is_hex(op)==None and op not in _base:
        		var_map.append(op)
        	for x in args:
        		get_All_Var(x,var_map)




#substituting close form solution in rest of the axiomes
def solnsubstitution(axioms,key,substituter):
	update_axioms=[]
    	for axiom in axioms:
    		if axiom[0]!='i0' and axiom[0]!='i1':
               		update_axioms.append(expr_replace(axiom,key,substituter))
    		else:
                        if axiom[0]=='i1':
                            axiom[4]=expr_replace(axiom[4],key,substituter)
                            update_axioms.append(axiom)
                        elif axiom[0]=='i0':
                            axiom[3]=expr_replace(axiom[3],key,substituter)
                            update_axioms.append(axiom)
                        else:
                            update_axioms.append(axiom)
    	return update_axioms



    
def solnsubstitution_Array(axioms,key,substituter):
	update_axioms=[]
    	for axiom in axioms:
    		if axiom[0]!='i0' and axiom[0]!='i1':
               		update_axioms.append(expr_array_replace(axiom,key,substituter))
    		else:
                        if axiom[0]=='i1':
                            axiom[4]=expr_array_replace(axiom[4],key,substituter)
                            update_axioms.append(axiom)
                        elif axiom[0]=='i0':
                            axiom[3]=expr_array_replace(axiom[3],key,substituter)
                            update_axioms.append(axiom)
                        else:
                            update_axioms.append(axiom)
    	return update_axioms






"""
Reading the contain of the file 
"""
def readingFile( filename ):
	content=None
	with open(currentdirectory+"/"+filename) as f:
    		content = f.readlines()
    	return content
 
"""
Wrtitting the contain on file 
"""
def writtingFile( filename , content ):
	file = open(currentdirectory+"/"+filename, "w")
	file.write(str(content))
	file.close()
        #if '.graphml' in filename:
        #    st = os.stat(currentdirectory+"/"+filename)
        #    print st.st_size

"""
Appending the contain on file 
"""
def appendingFile( filename , content ):
	file = open(currentdirectory+"/"+filename, "a")
	file.write(str(content))
	file.close()

"""

write logs

"""

def writeLogFile(filename , content):
	if os.path.isfile(currentdirectory+"/"+filename):
    		appendingFile( filename , content )
	else:
    		writtingFile( filename , content )
                

"""
Wrtitting the contain on file 
"""
def writtingWittness( filename , content ):
	if os.path.isfile(filename):
    		writtingFile( filename , content )
	else:
    		writtingFile( filename , content )


"""
Convert Inequality to Normal Form

"""


def normal_form_constant(expression, constant):
    #print "*************"
    #print expression
    #print "*************"
    mult_by_minus_one_map = {
    	None: '==',
    	'>=': '<=',
    	'<=': '>=',
    	'>': '<',
    	'<': '>',
	}
    ineq=simplify(expression)
    l = ineq.lhs
    r = ineq.rhs
    op = ineq.rel_op
    all_on_left = l - r
    coeff_dict = all_on_left.as_coefficients_dict()
    var_types = coeff_dict.keys()
    new_rhs = sympify(0)
    for s in var_types:
    	if s != simplify(constant):
    		factor=s.coeff(simplify(constant))
        	if factor==0:
            		all_on_left = (all_on_left - (coeff_dict[s]*s))
            		new_rhs = (new_rhs - (coeff_dict[s]*s))
    all_on_left=all_on_left.expand(basic=True)
    coeff_dict = all_on_left.as_coefficients_dict()
    var_types = coeff_dict.keys()
    if len(var_types)==1:
    	for s in var_types:
    		if coeff_dict[s]<0:
    			all_on_left = all_on_left * -1
        		new_rhs = new_rhs * -1
        		op = mult_by_minus_one_map[op]	
    	factor=all_on_left.coeff(simplify(constant))
    	if factor!=0:
		all_on_left=all_on_left/factor
    		new_rhs=new_rhs/factor
    else:
    	all_on_left=simplify(all_on_left)
    	new_rhs=simplify(new_rhs)
    	coeff_dict = all_on_left.as_coefficients_dict()
    	var_types = coeff_dict.keys()
    	if len(var_types)==1:
	 	for s in var_types:
	 		if coeff_dict[s]<0:
	    			all_on_left = all_on_left * -1
	        		new_rhs = new_rhs * -1
        			op = mult_by_minus_one_map[op]	
    
    #print "*************"
    #print all_on_left
    #print new_rhs
    #print "*************"
    return Relational(all_on_left,new_rhs,op)



def solve_for_constant(expression, constant):
    #print "*************"
    #print expression
    #print "*************"
    mult_by_minus_one_map = {
    	None: '==',
    	'>=': '<=',
    	'<=': '>=',
    	'>': '<',
    	'<': '>',
	}
    all_on_left=simplify(expression)
    coeff_dict = all_on_left.as_coefficients_dict()
    var_types = coeff_dict.keys()
    new_rhs = sympify(0)
    for s in var_types:
    	if s != simplify(constant):
    		factor=s.coeff(simplify(constant))
        	if factor==0:
            		all_on_left = (all_on_left - (coeff_dict[s]*s))
            		new_rhs = (new_rhs - (coeff_dict[s]*s))
    all_on_left=all_on_left.expand(basic=True)
    coeff_dict = all_on_left.as_coefficients_dict()
    var_types = coeff_dict.keys()
    if len(var_types)==1:
    	for s in var_types:
    		if coeff_dict[s]<0:
    			all_on_left = all_on_left * -1
        		new_rhs = new_rhs * -1
        		op = mult_by_minus_one_map[op]	
    	factor=all_on_left.coeff(simplify(constant))
    	if factor!=0:
            if new_rhs is not None:
                if '**' not in str(new_rhs):
                    parser = c_parser.CParser()
                    ast = parser.parse("void test(){"+str(new_rhs)+";}")
                    statement_temp=ast.ext[0].body.block_items[0]
                    axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                    new_rhs=eval("['/',"+str(axupdate[1])+",['"+str(factor)+"']]")
                    return new_rhs
                else:
                    return None
        else:
            if new_rhs is not None:
                if '**' not in str(new_rhs):
                    parser = c_parser.CParser()
                    ast = parser.parse("void test(){"+str(new_rhs)+";}")
                    statement_temp=ast.ext[0].body.block_items[0]
                    axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                    return axupdate[1]
                else:
                    return None
    else:
    	all_on_left=simplify(all_on_left)
    	new_rhs=simplify(new_rhs)
    	coeff_dict = all_on_left.as_coefficients_dict()
    	var_types = coeff_dict.keys()
    	if len(var_types)==1:
	 	for s in var_types:
	 		if coeff_dict[s]<0:
	    			all_on_left = all_on_left * -1
	        		new_rhs = new_rhs * -1
        			op = mult_by_minus_one_map[op]	
    
    return None








#To construct vfact
def wff2fvact(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            return expr2string1(w[-2])
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1':
            return expr2string1(w[1])
            
"""
Construct vfact by analysis translated equation equation 
"""

def getVariFunDetails(f,o,a,variableMapIp,variableMapOp):
	constaints=[]
	loopvariablesMap={}
	functionMap={}
	vfacts=""
	for variable in variableMapIp:
            values=variableMapIp[variable]
            if values.getDimensions()>0:
            	vfact="['"+variable+"',0,['array']]"
	    else:
	    	if values.getVariableType()=='int':	
		        vfact="['"+variable+"',0,['int']]"
                elif values.getVariableType()=='long':	
		        vfact="['"+variable+"',0,['int']]"
		elif values.getVariableType()=='unsigned':	
		        vfact="['"+variable+"',0,['int']]"
		elif values.getVariableType()=='float':
		        vfact="['"+variable+"',0,['float']]"
		elif values.getVariableType()=='double':
			vfact="['"+variable+"',0,['double']]"
                elif values.getVariableType()=='_Bool':
			vfact="['"+variable+"',0,['Bool']]"
		elif values.getVariableType()=='array':
			vfact="['"+variable+"',0,['array']]"
            if vfacts=="":
            	#vfact=''
                vfacts=vfact
            else:
                if vfact!="":
                    vfacts+=","+vfact
	
	
	for variable in variableMapOp:
            values=variableMapOp[variable]
	    if values[1]=='int':	
                vfact="['"+variable+"',0,['int']]"
	    elif values[1]=='unsigned':	
		vfact="['"+variable+"',0,['int']]"
	    elif values[1]=='long':	
		vfact="['"+variable+"',0,['int']]"
	    elif values[1]=='float':
                vfact="['"+variable+"',0,['float']]"
	    elif values[1]=='double':
		vfact="['"+variable+"',0,['double']]"
	    elif values[1]=='array':
	    	vfact="['"+variable+"',0,['array']]"
	    elif values[1]=='unsigned':
	    	vfact="['"+variable+"',0,['int']]"
            elif values[1]=='_Bool':
	    	vfact="['"+variable+"',0,['Bool']]"
	    elif values[1]=='array':
	    	vfact="['"+variable+"',0,['array']]"
            if vfacts=="":
                vfacts=vfact
            else:
                if vfact!="":
                    vfacts+=","+vfact
	
	equations=[]
        for x in a: 
        	equations.append(wff2fvact(x))
            
	for equation in equations:
		if equation is not None and '->' not in equation and '>' not in equation and '<' not in equation and '=' not in equation :
			loopvariables=extract_args(equation)
			equation=equation.strip()
			vfact=""
			if len(loopvariables)==0:	
				if equation not in variableMapOp.keys():
					if equation in variableMapIp.keys():
						values=variableMapIp[equation]
						if values[1]=='int':	
							vfact="['"+equation+"',0,['int']]"
						elif values[1]=='unsigned':	
							vfact="['"+equation+"',0,['int']]"
						elif values[1]=='float':
							vfact="['"+equation+"',0,['float']]"
						elif values[1]=='double':
							vfact="['"+equation+"',0,['double']]"
                                                elif values[1]=='_Bool':
							vfact="['"+equation+"',0,['Bool']]"
					else:
						vfact="['"+equation+"',0,['int']]"
				
			else:
				function_name=getFunctionName(str(equation),loopvariables )
				if function_name not in functionMap.keys() and isArrayFunction(function_name)==False:
					functionMap[function_name]=function_name
					fact="['int'"
					for x in xrange(len(loopvariables)):
						fact+=",'int'"
					fact+="]"
					vfact="['"+function_name+"',"+str(len(loopvariables))+","+fact+"]"	
			if vfacts=="":
				vfacts=vfact
			else:
				if vfact!="":
					vfacts+=","+vfact
		elif equation is not None and '->' in equation:
			axiomes=equation.split('->')
			axiomes[0]=simplify(str(axiomes[0]))
			variables=str(axiomes[0]).split('<')
			variables[0]=variables[0].strip()
			variables[1]=variables[1].strip()
			loopvariables=extract_args(variables[1])
			loopvariablesMap[variables[0]]=variables[0]
			parameter=""
			for variable in  loopvariables:
				variable=variable.strip()
				if parameter=="":
                                        if '__VERIFIER_nondet' in variable:
                                            tem_var_list = extract_args(variable)
                                            for tem_var in tem_var_list:
                                                if parameter=="":
                                                    parameter="["+tem_var
                                                else:
                                                    parameter+=" ,"+tem_var
                                        else:
                                            parameter="["+variable
				else:
					parameter+=" ,"+variable
					loopvariablesMap[variable]=variable
			if parameter=="":
				constaint=variables[1]+">=0"
			else:
				parameter+="]"
				constaint="ForAll("+parameter+","+variables[1]+">=0)"
			constaints.append(constaint)
			vfact=""
			if len(loopvariables)==0:	
				vfact="['"+variables[1]+"',0,['int']]"			
			else:
				fact="['int'"
				for x in xrange(len(loopvariables)):
					fact+=",'int'"
				fact+="]"
				function_name=getFunctionName(str(variables[1]),loopvariables )
				if isArrayFunction(function_name)==False:
					vfact="['"+getFunctionName(str(variables[1]),loopvariables )+"',"+str(len(loopvariables))+","+fact+"]"	
			if vfacts=="":
				vfacts=vfact
			else:
				if vfact!="":
					vfacts+=","+vfact
	
	for loopvariable in loopvariablesMap:

		if vfacts=="":
			vfacts="['"+loopvariable+"',0,['int']]"
		else:
		 	vfacts+=","+"['"+loopvariable+"',0,['int']]"
	vfacts=eval("["+vfacts+"]")
	return vfacts,constaints


#Collect all Function and Variable defination for Translation 2

def getVariFunDetails2(f,o,a,allvariablelist,constraints,assert_list,assume_list):
	var_map={}
	for x in f:
            wff2stringvfact2(f[x],var_map,allvariablelist,constraints)
	for x in o:
            wff2stringvfact2(o[x],var_map,allvariablelist,constraints)
        for x in a:
            wff2stringvfact2(x,var_map,allvariablelist,constraints)
        for x in assert_list:
            wff2stringvfact2(x,var_map,allvariablelist,constraints)
        for x in assume_list:
            wff2stringvfact2(x,var_map,allvariablelist,constraints)
        return var_map



"""
Expanding algebraic powers
"""

def pow_to_mul(expression):
    """
    Convert integer powers in an expression to Muls, like a**2 => a*a(Only for Squre).
    """
    #expression=simplify(expression).expand(basic=True)
    #expression=simplify(expression)
    pows=list(expression.atoms(Pow))
    if any(not e.is_Integer for b, e in (i.as_base_exp() for i in pows)):
    	#A power contains a non-integer exponent
    	return expression
    repl=None
    for b,e in (i.as_base_exp() for i in pows):
    	if e==2:
    		repl = zip(pows,((Mul(*[b]*e,evaluate=False)) for b,e in (i.as_base_exp() for i in pows)))
    if repl is not None:
    	return expression.subs(repl)
    else:
    	return expression



"""
#Function to Simplify and Expand an expression using sympy
"""
def simplify_expand_sympy(expression):
    if 'If' in str(expression) or '%' in str(expression):
    	return expression
    if 'Implies' not in expression and 'ite' not in expression and '==' not in  expression and '!=' not in  expression and 'And' not in  expression and 'Or' not in  expression and 'Not' not in  expression and 'ForAll' and 'Exists' not in  expression and 'Implies' not in expression:
    	return str(simplify_sympy(expression))
    elif 'Implies' in expression :
        axioms=extract_args(expression)
        if len(axioms)==2:
            #return 'Implies('+simplify_expand_sympy(axioms[0])+','+simplify_expand_sympy(axioms[1])+')'
            return 'Implies('+axioms[0]+','+simplify_expand_sympy(axioms[1])+')'
        else:
            return expression
    elif 'ite' in expression and 'And' not in  expression and 'Or' not in  expression and 'Not' not in  expression and 'ForAll' and 'Exists' not in  expression and 'Implies' not in expression:
        axioms=extract_args(expression)
        if len(axioms)==3:
            return 'If('+simplify_expand_sympy(axioms[0])+','+simplify_expand_sympy(axioms[1])+','+simplify_expand_sympy(axioms[2])+')'
        else:
            return expression
    elif '==' in  expression and '!=' not in  expression and 'and' not in  expression and 'or' not in  expression and 'And' not in  expression and 'Or' not in  expression and 'Not' not in  expression and 'ForAll' and 'Exists' not in  expression and 'Implies' not in expression:
        left =None
        right =None
        left,right,expression=parenthesesOrganizer( expression ,left ,right)
        axioms=expression.split('==')
        if len(axioms)!=2:
            return expression
        if left is not None and right is not None:
        	if '%' in axioms[0]:
        		leftin =None
			rightin =None
        		leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
        		axm=axioms[0].split('%')
        		if left is not None and right is not None:
        			expression="("+left+leftin+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+rightin+')==('+str(simplify_sympy(axioms[1]))+right+")"
        		else:
        			expression="("+left+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+')==('+str(simplify_sympy(axioms[1]))+right+")"
        	
        	else:
        		expression="("+left+str(simplify_sympy(axioms[0]))+')==('+str(simplify_sympy(axioms[1]))+right+")"
        		#expression=left+str(pow_to_mul(powsimp(sympify(axioms[0])).expand(basic=True)))+'=='+str(powsimp(pow_to_mul(sympify(axioms[1])).expand(basic=True)))+right
        else:
        	if '%' in axioms[0]:
			leftin =None
			rightin =None
			leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
			axm=axioms[0].split('%')
			if left is not None and right is not None:
				expression=left+leftin+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+rightin+'=='+str(simplify_sympy(axioms[1]))+right
			else:
				expression=left+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+'=='+str(simplify_sympy(axioms[1]))+right
		        	
        	else:
        		expression=str(simplify_sympy(axioms[0]))+'=='+str(simplify_sympy(axioms[1]))
        		#expression=str(pow_to_mul(powsimp(sympify(axioms[0])).expand(basic=True)))+'=='+str(pow_to_mul(powsimp(sympify(axioms[1])).expand(basic=True)))
        return expression
    elif '!=' in  expression and 'and' not in  expression and 'or' not in  expression and 'And' not in  expression and 'Or' not in  expression and 'Not' not in  expression and 'ForAll' and 'Exists' not in  expression and 'Implies' not in expression:
        left =None
        right =None
        left,right,expression=parenthesesOrganizer( expression ,left ,right)
        axioms=expression.split('!=')
        if len(axioms)!=2:
            return expression
        if left is not None and right is not None:
              	if '%' in axioms[0]:
	        	leftin =None
			rightin =None
	        	leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
	        	axm=axioms[0].split('%')
	        	if leftin is not None and rightin is not None:
	        		expression=left+leftin+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+rightin+'=='+str(simplify_sympy(axioms[1]))+right
	        	else:
        			expression=left+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+'=='+str(simplify_sympy(axioms[1]))+right
        	else:
        		expression=left+str(simplify_sympy(axioms[0]))+'!='+str(simplify_sympy(axioms[1]))+right
        		#expression=left+str(powsimp(pow_to_mul(sympify(axioms[0])).expand(basic=True)))+'!='+str(pow_to_mul(powsimp(sympify(axioms[1])).expand(basic=True)))+right
        else:
        	 if '%' in axioms[0]:
		 	leftin =None
			rightin =None
			leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
			axm=axioms[0].split('%')
			if leftin is not None and rightin is not None:
				expression=left+leftin+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+rightin+'=='+str(simplify_sympy(axioms[1]))+right
			else:
		        	expression=left+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+'=='+str(simplify_sympy(axioms[1]))+right

        	 else:
        		expression=str(simplify_sympy(axioms[0]))+'!='+str(simplify_sympy(axioms[1]))
        		#expression=str(pow_to_mul(powsimp(sympify(axioms[0])).expand(basic=True)))+'!='+str(pow_to_mul(powsimp(sympify(axioms[1])).expand(basic=True)))
        return expression
    else:
        return  expression

"""
#convert all power operator to power function
"""
def convert_pow_op_fun(expression):
    return expression


def convert_pow_op_fun1(expression):
    if 'Implies' not in expression and 'ite' not in expression and 'If' not in expression and '==' not in  expression and '!=' not in  expression and 'and' not in  expression and 'or' not in  expression:
        return  translatepowerToFun(expression)
    elif 'Implies' in expression:
        axioms=extract_args(expression)
        return 'Implies('+convert_pow_op_fun(axioms[0])+','+convert_pow_op_fun(axioms[1])+')'
    elif 'ite' in expression:
        axioms=extract_args(expression)
        return 'If('+convert_pow_op_fun(axioms[0])+','+convert_pow_op_fun(axioms[1])+','+convert_pow_op_fun(axioms[2])+')'
    elif 'If' in expression:
        axioms=extract_args(expression)
        return 'If('+convert_pow_op_fun(axioms[0])+','+convert_pow_op_fun(axioms[1])+','+convert_pow_op_fun(axioms[2])+')'
    elif '==' in  expression and '!=' not in  expression and 'and' not in  expression and 'or' not in  expression:
        expression=translatepowerToFun(expression)
        return expression
    elif '!=' in  expression and 'and' not in  expression and 'or' not in  expression:
        expression=translatepowerToFun(expression)
        return expression
    else:
        return  translatepowerToFun(expression)


def simplify_sympy(expression):
        #if '/' in str(expression) and '>' not in str(expression) and '<' not in str(expression) and '=' not in str(expression):  
        if '<<' in str(expression) or '>>' in str(expression) or 'ite' in str(expression) or 'and' in str(expression) or '&' in  str(expression) or '|' in str(expression) or '^' in str(expression):
		return expression 
        try:
            sympify(expression)
        except Exception as e:
            return expression
        
        if sympify(expression)==True or sympify(expression)==False:
		return expression        
        if '/' in str(expression):
        	expression,flag=expressionChecking(expression)
        	if flag==True:
        		expression_mod=expression 
        	else:
        		expression_mod=powsimp(expression)
        else:
            if 'array' not in str(expression):
                expression_mod=powsimp(expression)
            else:
                expression_mod=expression 
    
	if '/' not in str(expression_mod) and 'E' not in str(expression_mod) and 'e' not in str(expression_mod):
		expression=expression_mod
	if '/' in str(expression):
		no,deno=fraction(together(expression))
		no=sympify(no).expand(basic=True)
		deno=sympify(deno).expand(basic=True)
		if deno==1:
			expression,flag=expressionChecking(expression)
			if flag==True:
				return expression
				#return pow_to_mul(powsimp(expression))
			else:
				return pow_to_mul(powsimp(expression))
			#return pow_to_mul(powsimp(no))
		else:
                 	return Mul(pow_to_mul(powsimp(no)), Pow(pow_to_mul(powsimp(deno)), -1), evaluate=False)
	
	else:
		#return str(sympify(expression).expand(basic=True))
		if type(expression) is str:
                    return expression
                else:
                    expressiontemp=sympify(expression).expand(basic=True)
                    if '/' in str(expressiontemp):
                            return pow_to_mul(powsimp(sympify(expression)))
                    else:
                            return pow_to_mul(powsimp(sympify(expression).expand(basic=True)))
	

def substituteValue(expression,key,value):
	if '/' in str(expression):
		#no,deno=fraction(together(expression))
		no,deno=fraction(expression)
		no=sympify(no).expand(basic=True)
		no=no.subs(simplify(key),simplify(value))
		deno=deno.subs(simplify(key),simplify(value))
		if deno==1:
			return powsimp(no)
		else:
                 	return Mul(powsimp(no), Pow(powsimp(deno), -1), evaluate=False)
	
	else:
		return simplify(expression).subs(simplify(key),simplify(value))




"""
#Function to Simplify and Expand an expression using sympy
"""
def sub_ind_def(expression,variable,constant):
    if 'Implies' not in expression and 'ite' not in expression and '==' not in  expression and '!=' not in  expression and 'and' not in  expression and 'or' not in  expression:
    	return expression.replace(variable,constant)
    elif 'Implies' in expression :
        axioms=extract_args(expression)
        #return 'Implies('+simplify_expand_sympy(axioms[0])+','+simplify_expand_sympy(axioms[1])+')'
        return 'Implies('+axioms[0]+','+sub_ind_def(axioms[1],variable,constant)+')'
    elif 'ite' in expression:
        axioms=extract_args(expression)
        return 'If('+sub_ind_def(axioms[0],variable,constant)+','+sub_ind_def(axioms[1],variable,constant)+','+sub_ind_def(axioms[2],variable,constant)+')'
    elif '==' in  expression and '!=' not in  expression and 'and' not in  expression and 'or' not in  expression:
        left =None
        right =None
        left,right,expression=parenthesesOrganizer( expression ,left ,right)
        axioms=expression.split('==')
        if left is not None and right is not None:
        	if '%' in axioms[0]:
        		leftin =None
			rightin =None
        		leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
        		axm=axioms[0].split('%')
        		if left is not None and right is not None:
        			expression=left+leftin+str(sub_ind_def(axm[0],variable,constant))+'%'+str(sub_ind_def(axm[1],variable,constant))+rightin+'=='+str(sub_ind_def(axioms[1],variable,constant))+right
        		else:
        			expression=left+str(sub_ind_def(axm[0],variable,constant))+'%'+str(sub_ind_def(axm[1],variable,constant))+'=='+str(sub_ind_def(axioms[1],variable,constant))+right
        	
        	else:
        		expression=left+str(sub_ind_def(axioms[0]))+'=='+str(sub_ind_def(axioms[1]))+right
        		#expression=left+str(pow_to_mul(powsimp(sympify(axioms[0])).expand(basic=True)))+'=='+str(powsimp(pow_to_mul(sympify(axioms[1])).expand(basic=True)))+right
        else:
        	if '%' in axioms[0]:
			leftin =None
			rightin =None
			leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
			axm=axioms[0].split('%')
			if left is not None and right is not None:
				expression=left+leftin+str(sub_ind_def(axm[0],variable,constant))+'%'+str(sub_ind_def(axm[1],variable,constant))+rightin+'=='+str(sub_ind_def(axioms[1],variable,constant))+right
			else:
				expression=left+str(sub_ind_def(axm[0],variable,constant))+'%'+str(sub_ind_def(axm[1],variable,constant))+'=='+str(sub_ind_def(axioms[1],variable,constant))+right
		        	
        	else:
        		expression=str(simplify_sympy(axioms[0]))+'=='+str(simplify_sympy(axioms[1]))
        		#expression=str(pow_to_mul(powsimp(sympify(axioms[0])).expand(basic=True)))+'=='+str(pow_to_mul(powsimp(sympify(axioms[1])).expand(basic=True)))
        return expression
    elif '!=' in  expression and 'and' not in  expression and 'or' not in  expression:
        left =None
        right =None
        left,right,expression=parenthesesOrganizer( expression ,left ,right)
        axioms=expression.split('!=')
        if left is not None and right is not None:
              	if '%' in axioms[0]:
	        	leftin =None
			rightin =None
	        	leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
	        	axm=axioms[0].split('%')
	        	if leftin is not None and rightin is not None:
	        		expression=left+leftin+str(sub_ind_def(axm[0],variable,constant))+'%'+str(sub_ind_def(axm[1],variable,constant))+rightin+'=='+str(sub_ind_def(axioms[1],variable,constant))+right
	        	else:
        			expression=left+str(sub_ind_def(axm[0],variable,constant))+'%'+str(sub_ind_def(axm[1],variable,constant))+'=='+str(sub_ind_def(axioms[1],variable,constant))+right
        	else:
        		expression=left+str(sub_ind_def(axioms[0],variable,constant))+'!='+str(sub_ind_def(axioms[1],variable,constant))+right
        		#expression=left+str(powsimp(pow_to_mul(sympify(axioms[0])).expand(basic=True)))+'!='+str(pow_to_mul(powsimp(sympify(axioms[1])).expand(basic=True)))+right
        else:
        	 if '%' in axioms[0]:
		 	leftin =None
			rightin =None
			leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
			axm=axioms[0].split('%')
			if leftin is not None and rightin is not None:
				expression=left+leftin+str(sub_ind_def(axm[0],variable,constant))+'%'+str(simplify_sympy(axm[1],variable,constant))+rightin+'=='+str(sub_ind_def(axioms[1],variable,constant))+right
			else:
		        	expression=left+str(sub_ind_def(axm[0],variable,constant))+'%'+str(sub_ind_def(axm[1],variable,constant))+'=='+str(sub_ind_def(axioms[1],variable,constant))+right

        	 else:
        		expression=str(sub_ind_def(axioms[0],variable,constant))+'!='+str(sub_ind_def(axioms[1],variable,constant))
        		#expression=str(pow_to_mul(powsimp(sympify(axioms[0])).expand(basic=True)))+'!='+str(pow_to_mul(powsimp(sympify(axioms[1])).expand(basic=True)))
        return expression
    else:
        return  expression





"""
Recurrences Solving Module
#Add by Pritom Rajkhowa
#June 8

Test cases

Test Case 1

#e1=['i1', 2, '_n1', ['a3', ['+', ['_n1'], ['1']]], ['+', ['a3', ['_n1']], ['1']]]
#e2=['i0', 0, ['a3', ['0']], ['0']]

Test Case 2

#e1=['i1', 2, '_n1', ['a3', ['+', ['_n1'], ['1']]], ['*', ['a3', ['_n1']], ['+', ['_n1'], ['1']]]]
#e2=['i0', 0, ['a3', ['0']], ['1']]

Test Case 3

#e1=['i1', 2, '_n1', ['t3', ['+', ['_n1'], ['1']]], ['+', ['t3', ['_n1']], ['2']]]
#e2=['i0', 0, ['a3', ['0']], ['1']]

Test Case 4

#e1=['i1', 2, '_n1', ['a3', ['+', ['_n1'], ['1']]], ['*', ['a3', ['_n1']], ['2']]]
#e2=['i0', 0, ['a3', ['0']], ['1']]

"""
def solve_rec(e1,e2):
        global fun_call_map
	lefthandstmt=None
	righthandstmt=None
	righthandstmt_d=None
	lefthandstmt_base=None
	righthandstmt_base=None
	righthandstmt_base_d=None
	variable=None
	closed_form_soln=None
	if e1[0]=='i1':
		lefthandstmt=expr2string1(e1[3])
		righthandstmt=expr2string1(e1[4])
		lefthandstmt=lefthandstmt.strip()
		righthandstmt=righthandstmt.strip()
		variable=e1[2]
		if lefthandstmt.find('_PROVE')>0:
			return None
		elif lefthandstmt.find('_ASSUME')>0:
        		return None
		if 'ite' not in righthandstmt and '>' not in righthandstmt and '<' not in righthandstmt and '==' not in righthandstmt and '|' not in righthandstmt and '&' not in righthandstmt: 
		    	lefthandstmt=simplify(lefthandstmt)
		    	righthandstmt=simplify(righthandstmt)
		    	variable=simplify(variable)
		else:
			if '|' not in righthandstmt and '&' not in righthandstmt and '<<' not in righthandstmt and '>>' not in righthandstmt:
                            righthandstmt=expr2stringSimplify(e1[4])
			righthandstmt=righthandstmt.strip()
			if 'ite' not in righthandstmt and '>' not in righthandstmt and '<' not in righthandstmt and '==' not in righthandstmt and '<' not in righthandstmt and '==' not in righthandstmt and '|' not in righthandstmt and '&' not in righthandstmt: 
				lefthandstmt=simplify(lefthandstmt)
				righthandstmt=simplify(righthandstmt)
		    		variable=simplify(variable)
			else:
				lefthandstmt=None
				righthandstmt=None
				variable=None
	if e2[0]=='i0':
		lefthandstmt_base=expr2string1(e2[2])
		righthandstmt_base=expr2string1(e2[3])
		variable_list=[]
		expr2varlist(e2[3],variable_list)
		lefthandstmt_base=lefthandstmt_base.strip()
		righthandstmt_base=righthandstmt_base.strip()
		if 'ite' in righthandstmt_base or '|' in righthandstmt_base or '&' in righthandstmt_base or '<<' in righthandstmt_base or '>>' in righthandstmt_base: 
			return None
		lefthandstmt_base=simplify(lefthandstmt_base)
		righthandstmt_base=simplify(righthandstmt_base)

	if variable is not None and lefthandstmt is not None and righthandstmt is not None and lefthandstmt_base is not None and righthandstmt_base is not None:
		righthandstmt_d=righthandstmt
		righthandstmt_base_d=righthandstmt_base
		term1=lefthandstmt.subs(simplify(str(variable)+"+1"),0)
		term2=lefthandstmt.subs(simplify(str(variable)+"+1"),simplify(variable))
		if term1==lefthandstmt_base and  str(term2) in str(righthandstmt):
			righthandstmt=simplify(righthandstmt).subs({simplify(term2):simplify('T(n)'),simplify(variable):simplify('n')})
			result=None
			#Try to solve recurrences
			try:
				
				result = getSympyCache(righthandstmt,righthandstmt_base)
                                
                                if result is None:
                                    #result=recurreSolver_wolframalpha(righthandstmt,righthandstmt_base,variable_list)
                                    result=recurreSolver_sympy(righthandstmt,righthandstmt_base)
				#if result is None:
					#result=recurreSolver_sympy(righthandstmt,righthandstmt_base)
					#result=recurreSolver_wolframalpha(righthandstmt,righthandstmt_base,variable_list)
			except ValueError:
				result=None
			if result is not None:
				result=substituteValue(simplify_sympy(result),simplify('n'),simplify(variable))
				writeLogFile( "j2llogs.logs" , "\nOriginal Axoims \n"+str(lefthandstmt)+"="+str(righthandstmt_d)+","+str(lefthandstmt_base)+"="+str(righthandstmt_base_d)+"\n Closed Form Solution\n"+str(result)+"\n" )
				if "**" in str(result):
					result=translatepowerToFun(str(result))
                                        
				expression=str(str(term2)+"="+str(result))
				fun_call_map={}
				parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+expression+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                
                                closed_form_soln = construct_expressionC(e1[1],e1[2],expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue))),expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue))))
				#tree = p.parse_expression(expression)
				#closed_form_soln=construct_expression(tree,e1[1],e1[2])
                                
			
	#return None
	return closed_form_soln



# expr_replace(e,e1,e2): replace all subterm e1 in e by e2


def expr_replace_power(e): #e,e1,e2: expr
    args=expr_args(e)
    op=expr_op(e)
    if len(args)>0:
        if op=='power' or 'power_' in op :
            return eval("['**']")+list(expr_replace_power(x) for x in expr_args(e))
        else:
            return e[:1]+list(expr_replace_power(x) for x in expr_args(e))
    else:
        return e





"""

Simplification Of Conditional Statements 

"""
def simplifyIteStatement(statement):
	print '############################'
	print expr2stringSimplify(statement[4])
	print '*************************'


"""
#Code Add by Pritom Rajkhowa
#Following Code will Translate Java Program to a Array of Statements 
"""
"""
Recurrence Solver After Translation
"""
def rec_solver(f,o,a):
    global fun_call_map
    constant_fun_map={}
    equation_map={}
    base_map={}
    for axiom in a:
        if axiom[0]=='i1':
             lefthandstmt=expr2string1(axiom[3])
	     lefthandstmt=lefthandstmt.strip()
             equation_map[str(simplify(lefthandstmt))]=axiom
	if axiom[0]=='i0':
	     lefthandstmt=expr2string1(axiom[2])
	     lefthandstmt=lefthandstmt.strip()
	     base_map[str(simplify(lefthandstmt))]=axiom
	if axiom[0]=='s1':
	     equ=expr2string1(axiom[1])
	     if '->' in equ:
                 axiomes=equ.split('->')
		 axiomes[0]=simplify(str(axiomes[0]))
		 variables=str(axiomes[0]).split('<')
		 variables[0]=variables[0].strip()
		 variables[1]=variables[1].strip()
		 constant_fun_map[variables[0]]=variables[1]
    while True:
        solution_map={} 
	for equation in equation_map:
            e1=equation_map[equation]
	    equation_base=str(simplify(equation).subs(simplify(str(e1[2])+"+1"),0))
	    if equation_base in base_map.keys():
                e2=base_map[equation_base]
                result=solve_rec(e1,e2)
                if result is not None:
                    a.remove(base_map[equation_base])
                    del base_map[equation_base]
                    solution_map[equation]=result
    
	for equation in solution_map:
            a.remove(equation_map[equation])
	    del equation_map[equation]
	    e=solution_map[equation]
	    e1=copy.deepcopy(e)
	    variable=e[2]
	    a=solnsubstitution(a,e[3],e[4])
	    constant=constant_fun_map[variable]
	    #p = getParser()
	    #tree = p.parse_expression(constant)
	    #constant=eval(expressionCreator(tree))
            fun_call_map={}
            parser = c_parser.CParser()
            ast = parser.parse("void test(){"+str(constant)+";}")
            statement_temp=ast.ext[0].body.block_items[0]
            constant=eval(expressionCreator_C(statement_temp))
	    variable_list=eval("expres('"+variable+"')")
	    e1[3]=expr_replace(e1[3],variable_list,constant)
	    e1[4]=expr_replace(e1[4],variable_list,constant)
	    a=solnsubstitution(a,e1[3],e1[4])
	    for x in o:
                stmt=o[x]
		stmt[2]=expr_replace(stmt[2],e1[3],e1[4])
	if len(equation_map)==0 or len(solution_map)==0:
            break
    return f,o,a,constant_fun_map



def rec_solver_tactic8(f,o,a,assertion):
    global fun_call_map
    constant_fun_map={}
    equation_map={}
    base_map={}
    for axiom in a:
        if axiom[0]=='i1':
             lefthandstmt=expr2string1(axiom[3])
	     lefthandstmt=lefthandstmt.strip()
             if 'array' not in lefthandstmt:
                equation_map[str(simplify(lefthandstmt))]=axiom
	if axiom[0]=='i0':
	     lefthandstmt=expr2string1(axiom[2])
	     lefthandstmt=lefthandstmt.strip()
	     base_map[str(simplify(lefthandstmt))]=axiom
	if axiom[0]=='s1':
	     equ=expr2string1(axiom[1])
	     if '->' in equ:
                 axiomes=equ.split('->')
		 axiomes[0]=simplify(str(axiomes[0]))
		 variables=str(axiomes[0]).split('<')
		 variables[0]=variables[0].strip()
		 variables[1]=variables[1].strip()
		 constant_fun_map[variables[0]]=variables[1]
    while True:
        solution_map={} 
	for equation in equation_map:
            e1=equation_map[equation]
	    equation_base=str(simplify(equation).subs(simplify(str(e1[2])+"+1"),0))
	    if equation_base in base_map.keys():
                e2=base_map[equation_base]
                result=solve_rec(e1,e2)
                if result is not None:
                    a.remove(base_map[equation_base])
                    del base_map[equation_base]
                    solution_map[equation]=result
	
		
	for equation in solution_map:
            a.remove(equation_map[equation])
	    del equation_map[equation]
	    e=solution_map[equation]
	    e1=copy.deepcopy(e)
	    variable=e[2]
	    a=solnsubstitution(a,e[3],e[4])
	    constant=constant_fun_map[variable]
	    #p = getParser()
	    #tree = p.parse_expression(constant)
	    #constant=eval(expressionCreator(tree))
            fun_call_map={}
            parser = c_parser.CParser()
            ast = parser.parse("void test(){"+str(constant)+";}")
            statement_temp=ast.ext[0].body.block_items[0]
            constant=eval(expressionCreator_C(statement_temp))
	    variable_list=eval("expres('"+variable+"')")
            
	    e1[3]=expr_replace(e1[3],variable_list,constant)
	    e1[4]=expr_replace(e1[4],variable_list,constant)
	    a=solnsubstitution(a,e1[3],e1[4])
            
            for w in o:
                conditional_list = getAssumptionCondition(o[w][-1],e1[3])
                if conditional_list is not None:
                    for condition in conditional_list:
                        a.append(wff_a(condition))
            
            if assertion[0]=='s0':
                assertion[-1]=expr_replace(assertion[-1],e[3],e[4])
                assertion[-1]=expr_replace(assertion[-1],e1[3],e1[4])
            else:
                if assertion[0]=='c1':
                    assertion[-1]=expr_replace(assertion[-1],e[3],e[4])
                    assertion[-1]=expr_replace(assertion[-1],e1[3],e1[4])
                else:
                    if len(assertion)==1 and assertion[0][0]=='s0':
                        assertion[0][-1]=expr_replace(assertion[0][-1],e[3],e[4])
                        assertion[0][-1]=expr_replace(assertion[0][-1],e1[3],e1[4])
                    else:
                        assertion=expr_replace(assertion,e[3],e[4])
                        assertion=expr_replace(assertion,e1[3],e1[4])
	    for x in o:
                stmt=o[x]
		stmt[2]=expr_replace(stmt[2],e1[3],e1[4])
	if len(equation_map)==0 or len(solution_map)==0:
            break
    return f,o,a,constant_fun_map,assertion


    
"""

#Solving Recurrences using wolframalpha

"""

def recurreSolver_wolframalpha(righthandstmt,righthandstmt_base,variable_list):
    var=None
    query1="T(n+1)="+str(righthandstmt)
    var_map={}
    count=1
    #print query1
    if Mathematica_id is None:
    	return None
    base_expression=None
    if is_number(str(righthandstmt_base))==False:
    	if len(str(righthandstmt_base))>1:
    		var=righthandstmt_base
    		query2="T(0)=N_1"
    		base_expression="N_1"
    	else:
    		for x in variable_list:
    			righthandstmt_base=righthandstmt_base.replace(x,'N_'+str(count))
    			var_map[x]='N_'+str(count)
    			count=count+1
    		query2="T(0)="+str(righthandstmt_base)
    		base_expression=str(righthandstmt_base)
    		
    else:
    	query2="T(0)="+str(righthandstmt_base)
    	base_expression=str(righthandstmt_base)
    query1=transferToFunctionSyntax(str(query1))
    query2=transferToFunctionSyntax(str(query2))
    query1=query1.replace('T[n+1]','T(n+1)')
    query1=query1.replace('T[n]','T(n)')
    query2=query2.replace('T[0]','T(0)')
    query=query2+","+query1
    if '[' in query1:
    	return None
    if query is not None:
        query=query.replace('_N','m_1')
    finalResult=None
    #app_id="YRL93R-5AYL87GHRY"
    #app_id="TQT2K7-5AK3PPJYVX"
    app_id=Mathematica_id
    
    result_cache=getWolframalphaCache(str(righthandstmt),base_expression)
    if result_cache is not None:
    	result_cache=result_cache.replace('m_1','_N')
    	if var is not None:
		result_cache=result_cache.replace('N_1',str(var))
	for x in var_map.keys():
		result_cache=result_cache.replace(var_map[x],x)
	try:
		temp=simplify(result_cache)
		result_cache=str(simplify_expand_sympy(result_cache))
		writeLogFile( "j2llogs.logs" , "\nEquation Pass to Wolfram Mathematica  \n"+str(query1)+"------Base Case---"+str(query2)+"\n" )
		writeLogFile( "j2llogs.logs" , "\nClosed form solution return by Wolfram Mathematica \n"+str(result_cache)+"\n" )
	except ValueError:
		result_cache=None
    	return result_cache
    
    
    try:
        client = wolframalpha.Client(app_id)
    	res = client.query(query)
    except ValueError:
    	return None
    for pod in res.pods:
	if 'Recurrence equation solution' in pod.title:
            result=pod.text
            flag=False
            flag=isConstInResult( result )
            if flag==False and ')_' not in result and 'Gamma' not in result and 'Pochhammer' not in result and 'Beta' not in result and 'zeta' not in result and 'alpha' not in result :
            	results=result.split('=')
	    	results[1]=results[1].strip()
	    	results[1]=results[1].replace(' ','*')
	    	results[1]=results[1].replace('^','**')
	    	results[1]=results[1].replace('m_1','_N')
	    	try:
	    		results[1]=replaceAddOperator(results[1])
			filtered_program = SyntaxFilter.SLexer(results[1])
			filtered_program.build()
			results[1]=filtered_program.wolframalphaConstruct()
		except SyntaxFilter.SLexerError as e:
			return None
	    	if var is not None:
	    		results[1]=results[1].replace('N_1',str(var))
	    	for x in var_map.keys():
	    		results[1]=results[1].replace(var_map[x],x)	
	    	try:
			temp=simplify(results[1])
	    		finalResult=str(simplify_expand_sympy(results[1]))

	    		writeLogFile( "j2llogs.logs" , "\nEquation Pass to Wolfram Mathematica  \n"+str(query1)+"------Base Case---"+str(query2)+"\n" )
	    		writeLogFile( "j2llogs.logs" , "\nClosed form solution return by Wolfram Mathematica \n"+str(finalResult)+"\n" )
	    	except ValueError:
			finalResult=None
			#writeLogFile( "j2llogs.logs" , "\nFailed to find close form solution\n" )
	    else:
                finalResult=None
                #writeLogFile( "j2llogs.logs" , "\nFailed to find close form solution\n" )
    
    return finalResult
 




def getWolframalphaCache(expression,base_expression):
	#cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/2'],'(i + n + 1)**3 + T(n)':['N_1','N_1 + (n*(n + (1 + 2*i) )*(- (2 - 2*i)  + n*(n + (1 + 2*i) )))/4']}
	cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/4'],'T(n) - 1':['N_1','N_1 - n']}
	for element in cache_map.keys():
		if simplify(element)==simplify(expression):
			if simplify(cache_map[element][0])==simplify(base_expression):
				return cache_map[element][1]
	return None






def getSympyCache(expression,base_expression):
        #print '~~~~~~~~~~~~~~'
        #print expression
        #print base_expression
        #print '~~~~~~~~~~~~~~'
	#cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/2'],'(i + n + 1)**3 + T(n)':['N_1','N_1 + (n*(n + (1 + 2*i) )*(- (2 - 2*i)  + n*(n + (1 + 2*i) )))/4']}
	cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/4'],'T(n) - 1':['N_1','N_1 - n'],'4000 + T(n)':['0','4000*n'],'2000 + T(n)':['0','2000*n']}
	for element in cache_map.keys():
		if simplify(element)==simplify(expression):
                        try:
                                        
                            return simplify(cache_map[element][1]).subs(simplify(cache_map[element][0]),simplify(base_expression))
                            
                        except ValueError:
                            return None
			
	return None





"""
 
#Solving Recurrences using sympy
 
"""
def recurreSolver_sympy(righthandstmt,righthandstmt_base):
	expression="T(n+1)-("+str(righthandstmt)+")"
	#print expression
	f=simplify(expression)
	#Register n as Symbol
	n=Symbol('n')
	#Register T as Function
	T=Function('T')
	result=None
	#Converting String to Sympy Expression
	terminationList={sympify("T(0)"):righthandstmt_base}
	#Try to solve recurrences
	try:
		result=rsolve(f, T(n), terminationList)
		flag=False
            	flag=isConstInResult( str(result) )
		if flag==False and result is not None and 'RisingFactorial' not in str(result) and 'binomial' not in str(result) and 'gamma' not in str(result) and 'rgamma' not in str(result) and 'gammaprod' not in str(result) and 'loggamma' not in str(result) and 'beta' not in str(result) and 'superfac' not in str(result) and 'barnesg' not in str(result):
			result=simplify(result)
			writeLogFile( "j2llogs.logs" ,"\nEquation Pass to sympy\n"+str(expression)+"=0"+"------"+"Base Case--T(0)="+str(righthandstmt_base)+"\n" )
			writeLogFile( "j2llogs.logs" ,"\nClosed form solution return by sympy \n"+str(result)+"\n" )
		else:
                    result=None
                    #writeLogFile( "j2llogs.logs" , "\nFailed to find close form solution\n" )
	except ValueError:
		result=None
		#writeLogFile( "j2llogs.logs" , "\nFailed to find close form solution\n" )

	return result




"""
#Axiom Class
#Plain Python object to store Information about a Axiom
"""
class axiomclass(object):
 	def __init__(self, frame_axioms , output_equations , other_axioms, inputvariable, vfact, constraints, const_var_map, asserts, assumes,variables):
        	self.frame_axioms = frame_axioms
        	self.output_equations = output_equations
        	self.other_axioms = other_axioms
        	self.inputvariable = inputvariable
        	self.vfact = vfact
        	self.constraints = constraints
        	self.const_var_map = const_var_map
        	self.asserts = asserts
        	self.assumes = assumes
                self.variables = variables
                
        def getFrame_axioms(self):
        	return self.frame_axioms
        def getOutput_equations(self):
        	return self.output_equations
        def getOther_axioms(self):
        	return self.other_axioms
        def getInputvariable(self):
        	return self.inputvariable
        def getVfact(self):
        	return self.vfact
        def getConstraints(self):
        	return self.constraints
        def getConst_var_map(self):
        	return self.const_var_map
        def getAsserts(self):
    	        return self.asserts
    	def setAsserts(self,asserts):
		self.asserts=asserts
    	def getAssumes(self):
        	return self.assumes
    	def getVariables(self):
        	return self.variables
        def setFrame_axioms(self,frame_axioms):
        	self.frame_axioms=frame_axioms
        def setOutput_equations(self,output_equations):
        	self.output_equations=output_equations
        def setOther_axioms(self,other_axioms):
        	self.other_axioms=other_axioms
        def setInputvariable(self,inputvariable):
        	self.inputvariable=inputvariable
        def setVfact(self,vfact):
        	self.vfact=vfact
        def setConstraints(self,constraints):
        	self.constraints=constraints
        def setConst_var_map(self,const_var_map):
        	self.const_var_map=const_var_map
        def setAsserts(self,asserts):
    	        self.asserts=asserts
    	def setAssumes(self,assumes):
        	self.assumes=assumes
    	def setVariables(self,variables):
        	self.variables=variables

"""
#Sort Class
#Plain Python object to store Information about a Java  Class 
"""
class sortclass(object):
 	def __init__(self, sortname , varmap):
        	self.sortname = sortname
        	self.varmap = varmap
        def getSortname(self):
        	return self.sortname
        def getVarmap(self):
        	return self.varmap
        
        
"""

#Member Method Class
#Plain Python object to store Information about Member Method of a Java Class 
"""
class membermethodclass(object):
 	def __init__(self, methodname, returnType , inputvar, localvar, body, usedCounter, serialNo,tempoary, analysis_module, fun_decl):
        	self.methodname = methodname
        	self.inputvar = inputvar
        	self.returnType = returnType
        	self.localvar = localvar
        	self.body = body
        	self.usedCounter = usedCounter
        	self.serialNo = serialNo
        	self.tempoary = tempoary
                self.analysis_module = analysis_module
                self.fun_decl = fun_decl
        def getMethodname(self):
        	return self.methodname
        def getreturnType(self):
        	return self.returnType
        def getInputvar(self):
        	return self.inputvar
        def getLocalvar(self):
        	return self.localvar
        def getBody(self):
		return self.body
	def getUsedCounter(self):
		return self.usedCounter
	def getSerialNo(self):
		return self.serialNo
	def getTempoary(self):
		return self.tempoary
	def getFun_decl(self):
		return self.fun_decl
	def getAnalysis_module(self):
		return self.analysis_module
	def setInputvar(self, inputvar):
	        self.inputvar=inputvar
	def setLocalvar(self, localvar):
	        self.localvar=localvar
	def setBody(self, body):
		self.body=body
	def setUsedCounter(self, usedCounter):
		self.usedCounter=usedCounter
	def setSerialNo(self, serialNo):
		self.serialNo=serialNo
	def setTempoary(self,tempoary):
		self.tempoary=tempoary
	def setAnalysis_module(self,analysis_module):
		self.analysis_module=analysis_module
	def setFun_decl(self,fun_decl):
		self.fun_decl=fun_decl
"""

#Variable Class 

#Plain Python Object to store information about variable

"""
class variableclass(object):
	def __init__(self, variablename, variableType, modifiers, dimensions, initialvalue, structType):
        	self.variablename = variablename
        	self.variableType = variableType
        	self.modifiers = modifiers
        	self.dimensions = dimensions
        	self.initialvalue = initialvalue
        	self.structType = structType
	def getVariablename(self):
		return self.variablename
	def getVariableType(self):
		return self.variableType
	def getModifiers(self):
		return self.modifiers
	def getDimensions(self):
		return self.dimensions
	def getInitialvalue(self):
		return self.initialvalue
        def setInitialvalue(self,initialvalue):
		self.initialvalue=initialvalue
	def getStructType(self):
		return self.structType
	def setStructType(self,initialvalue):
		self.structType=structType


"""

#Expression Class
#Plain Python object to store Information about Java Expression 
"""
class expressionclass(object):
 	def __init__(self, expression, serialNo, isPrime, degree):
        	self.expression = expression
        	self.serialNo = serialNo
        	self.isPrime = isPrime
        	self.degree = degree
        def getExpression(self):
        	return self.expression
        def getSerialNo(self):
        	return self.serialNo
        def getIsPrime(self):
        	return self.isPrime
        def getDegree(self):
        	return self.degree
        def setExpression(self, expression):
		self.expression=expression
	def setSerialNo(self, serialNo):
		self.serialNo=serialNo
	def setIsPrime(self, isPrime):
		self.isPrime=isPrime
	def setDegree(self, degree):
		self.degree=degree


"""

#Block Class
#Plain Python object to store Information about Block of Java Expression 
"""
class blockclass(object):
 	def __init__(self, expression, predicate, serialNo ,isPrime ,degree):
        	self.expression = expression
        	self.predicate = predicate
        	self.serialNo = serialNo
        	self.isPrime = isPrime
        	self.degree = degree
        def getExpression(self):
        	return self.expression
        def getPredicate(self):
        	return self.predicate
        def getSerialNo(self):
        	return self.serialNo
        def getIsPrime(self):
        	return self.isPrime
        def getDegree(self):
        	return self.degree
        def setExpression(self, expression):
		self.expression=expression
	def setPredicate(self, predicate):
		self.predicate=predicate
	def setSerialNo(self, serialNo):
		self.serialNo=serialNo
	def setIsPrime(self, isPrime):
		self.isPrime=isPrime
       	def setDegree(self, degree):
		self.degree=degree


"""

#Block Class
#Plain Python object to store Information about if else Java Loop 
"""
class Ifclass(object):
 	def __init__(self, predicate, expressionif, expressionelse, serialNo ,isPrime ,degree):
        	self.predicate = predicate
        	self.expressionif = expressionif
        	self.expressionelse = expressionelse
        	self.serialNo = serialNo
        	self.isPrime = isPrime
        	self.degree = degree
        def getExpressionif(self):
        	return self.expressionif
        def getExpressionelse(self):
        	return self.expressionelse
        def getPredicate(self):
        	return self.predicate
        def getSerialNo(self):
        	return self.serialNo
        def getIsPrime(self):
        	return self.isPrime
        def getDegree(self):
        	return self.degree
        def setExpressionif(self, expressionif):
		self.expressionif=expressionif
	def setExpressionelse(self, expressionelse):
		self.expressionelse=expressionelse
	def setPredicate(self, predicate):
		self.predicate=predicate
	def setSerialNo(self, serialNo):
		self.serialNo=serialNo
	def setIsPrime(self, isPrime):
		self.isPrime=isPrime
       	def setDegree(self, degree):
		self.degree=degree


"""

#Struct Class
#Plain Python object to store Information about Struct (C Expression) 
"""
class structclass(object):
 	def __init__(self, name, isTypeDef, variablemap , defName, isPointer):
        	self.name = name
        	self.isTypeDef = isTypeDef
        	self.variablemap = variablemap
        	self.defName = defName
        	self.isPointer = isPointer
        def getName(self):
        	return self.name
        def getIsTypeDef(self):
        	return self.isTypeDef
        def getVariablemap(self):
        	return self.variablemap
        def getDefName(self):
        	return self.defName
        def getIsPointer(self):
        	return self.isPointer
        def setName(self, name):
		self.name=name
	def setIsTypeDef(self, isTypeDef):
		self.isTypeDef=isTypeDef
	def setVariablemap(self, variablemap):
		self.variablemap=variablemap
	def setDefName(self, defName):
		self.defName=defName
       	def setIsPointer(self, isPointer):
		self.isPointer=isPointer






"""

Organization of AST 

"""
               
def organizeStatementToObject(statements):
	count=0
	degree=0
	expressions=[]
	for statement in statements:
		if type(statement) is m.Assignment:
			count=count+1
			expression=expressionclass(statement, count, True,degree)
			expressions.append(expression)
		elif type(statement) is m.While:
			if type(statement.predicate) is m.Unary:
				if type(statement.predicate.expression) is m.ConditionalOr:
					blockexpressions=[]
					if statement.body is not None:
						degree=degree+1
						count,blockexpressions=blockToExpressions(statement.body, degree, count)
						degree=degree-1
					block=blockclass( blockexpressions, statement.predicate, count , True, degree)
					expressions.append(block)
				elif type(statement.predicate.expression) is m.ConditionalAnd:
					blockexpressions=[]
					if statement.body is not None:
						degree=degree+1
						count,blockexpressions=blockToExpressions(statement.body, degree, count)
						degree=degree-1
					block=blockclass( blockexpressions, statement.predicate, count , True, degree)
					expressions.append(block)
				elif type(statement.predicate.expression) is m.Relational:
					blockexpressions=[]
					if statement.body is not None:
						degree=degree+1
						count,blockexpressions=blockToExpressions(statement.body, degree, count)
						degree=degree-1
					block=blockclass( blockexpressions, statement.predicate, count , True, degree)
					expressions.append(block)
				elif type(statement.predicate.expression) is m.Equality:
					blockexpressions=[]
					if statement.body is not None:
						degree=degree+1
						count,blockexpressions=blockToExpressions(statement.body, degree, count)
						degree=degree-1
					block=blockclass( blockexpressions, statement.predicate, count , True, degree)
					expressions.append(block)
			elif type(statement.predicate) is m.ConditionalAnd:
				blockexpressions=[]
				if statement.body is not None:
					degree=degree+1
					count,blockexpressions=blockToExpressions(statement.body, degree, count)
					degree=degree-1
				block=blockclass( blockexpressions, statement.predicate, count , True, degree)
				expressions.append(block)
			elif type(statement.predicate) is m.ConditionalOr:
				blockexpressions=[]
				if statement.body is not None:
					degree=degree+1
					count,blockexpressions=blockToExpressions(statement.body, degree, count)
					degree=degree-1
				block=blockclass( blockexpressions, statement.predicate, count , True, degree)
				expressions.append(block)
			elif type(statement.predicate) is m.Relational:
				blockexpressions=[]
				if statement.body is not None:
					degree=degree+1
					count,blockexpressions=blockToExpressions(statement.body, degree, count)
					degree=degree-1
				block=blockclass( blockexpressions, statement.predicate, count , True, degree)
				expressions.append(block)
			elif type(statement.predicate) is m.Equality:
				blockexpressions=[]
				if statement.body is not None:
					degree=degree+1
					count,blockexpressions=blockToExpressions(statement.body, degree, count)
					degree=degree-1
				block=blockclass( blockexpressions, statement.predicate, count , True, degree)
				expressions.append(block)
		else:
			if type(statement) is m.IfThenElse:
				count,ifclass=ifclassCreator(statement, degree, count)
				expressions.append(ifclass)
					
     	return expressions		

"""

#Finding last expression or block inside a block

"""

def primeStatement(expressions):
	previous=None
	if type(expressions) is Ifclass:
		primeStatement(expressions.getExpressionif())
		primeStatement(expressions.getExpressionelse())
		previous=expressions
        else:
         	if expressions is not None:
         		for expression in expressions:
	 			if previous is not None:
	 				previous.setIsPrime(False)
	 			if type(expression) is blockclass:
	 				primeStatement(expression.getExpression())
	 			if type(expression) is Ifclass:
	 				primeStatement(expression.getExpressionif())
	 				if expression.getExpressionelse() is not None:
	 					primeStatement(expression.getExpressionelse())
				previous=expression

"""

Converting code block,while loop ,conditional expression and expression to corresponding Classes

"""

def blockToExpressions(body, degree, count):
	expressions=[]
	if body is not None:
		for statement in body:
			if type(statement) is m.Assignment:
				count=count+1
				expression=expressionclass(statement, count, True,degree)
				expressions.append(expression)
			elif type(statement) is m.While:
				if type(statement.predicate) is m.Relational:
					blockexpressions=[]
					if statement.body is not None:
						degree=degree+1
						count,blockexpressions=blockToExpressions(statement.body, degree, count)
						degree=degree-1
					block=blockclass( blockexpressions, statement.predicate, count , True, degree)
					expressions.append(block)
				elif type(statement.predicate) is m.Equality:
					blockexpressions=[]
					if statement.body is not None:
						degree=degree+1
						count,blockexpressions=blockToExpressions(statement.body, degree, count)
						degree=degree-1
					block=blockclass( blockexpressions, statement.predicate, count , True, degree)
					expressions.append(block)
			else:
				if type(statement) is m.IfThenElse:
					count,ifclass=ifclassCreator(statement, degree, count)
					expressions.append(ifclass)
	return count,expressions



"""

Block of Statement to Array of Statement Compatible to Translator Program 

"""
def programToinductiveDefination(expressions, allvariable):
	programsstart=""
	programsend=""
	statements=""
	for expression in expressions:
		if type(expression) is expressionclass:
			if type(expression.getExpression()) is m.Assignment:
				if type(expression.getExpression().lhs) is m.Name:
					var=expression.getExpression().lhs.value
					if expression.getIsPrime()==False:
						if programsstart=="":
							programsstart="['-1','seq',['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"
							programsend="]"
						else:
							programsstart+=",['-1','seq',['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"
							programsend+="]"
					else:
                                                if programsstart=="":
                                                     programsstart+="['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
                                                else:
                                                    programsstart+=",['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
                                else:
                                	stmt=createArrayList(expression.getExpression().lhs)
                                	#var="'gt"+str(stmt.count(','))+"',["+stmt+"]"
                                	var="'gt"+"',["+stmt+"]"
					if expression.getIsPrime()==False:
						if programsstart=="":
							programsstart="['-1','seq',['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"
							programsend="]"
						else:
							programsstart+=",['-1','seq',['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"
							programsend+="]"
					else:
				                if programsstart=="":
				                        programsstart+="['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
				                else:
				                        programsstart+=",['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend

		elif type(expression) is blockclass:
			predicatestmt="['-1','while',"+predicateCreator(expression.predicate)+","+programToinductiveDefination( expression.getExpression(), allvariable)+"]"
			if expression.getIsPrime()==False:
				if programsstart=="":
					programsstart="['-1','seq',"+predicatestmt
					programsend="]"
				else:
					programsstart+=",['-1','seq',"+predicatestmt
					programsend+="]"
			else:
				programsstart+=","+predicatestmt+programsend
		elif type(expression) is Ifclass:
			condition=predicateCreator(expression.predicate)
			expressionif=None
			expressionelse=None
			predicatestmt=""
			if expression.getExpressionif() is not None:
				expressionif=programToinductiveDefination( expression.getExpressionif(), allvariable)
			if expression.getExpressionelse() is not None:
				if type(expression.getExpressionelse()) is Ifclass:
					#expressionelse=programToinductiveDefination( expression.getExpressionelse().getExpressionif(), allvariable)
					expressionelse=programToinductiveDefinationIfElse( expression.getExpressionelse(), allvariable)
				else:
					expressionelse=programToinductiveDefination( expression.getExpressionelse(), allvariable)
			if expressionif is not None and expressionelse is not None:
                          	predicatestmt="['-1','if2',"+condition+","+expressionif+","+expressionelse+"]"
			elif expressionif is not None and expressionelse is None:
				predicatestmt="['-1','if1',"+condition+","+expressionif+"]"
			if expression.getIsPrime()==False:
				if programsstart=="":
					programsstart="['-1','seq',"+predicatestmt
					programsend="]"
				else:
					programsstart+=",['-1','seq',"+predicatestmt
					programsend+="]"
			else:
				if programsstart=="":
					programsstart=predicatestmt+programsend
				else:
					programsstart+=","+predicatestmt+programsend
	if programsstart[0]==',':
		programsstart=programsstart[1:]	
	return programsstart		


"""

IfElse Block Statement to Array of Statement Compatible to Translator Program 

"""
def programToinductiveDefinationIfElse(expression, allvariable):
	programsstart=""
	programsend=""
	statements=""
	if type(expression) is expressionclass:
		if type(expression.getExpression()) is m.Assignment:
			if type(expression.getExpression().lhs) is m.Name:
				var=expression.getExpression().lhs.value
				if expression.getIsPrime()==False:
					if programsstart=="":
						programsstart="['-1','seq',['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"
						programsend="]"
					else:
						programsstart+=",['-1','seq',['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"
						programsend+="]"
				else:
                                	if programsstart=="":
                                        	programsstart+="['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
                                        else:
                                               	programsstart+=",['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
                        else:
                                stmt=createArrayList(expression.getExpression().lhs)
			        #var="'gt"+str(stmt.count(','))+"',["+stmt+"]"
			        var="'gt"+"',["+stmt+"]"
				if expression.getIsPrime()==False:
					if programsstart=="":
						programsstart="['-1','seq',['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"
						programsend="]"
					else:
						programsstart+=",['-1','seq',['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"
						programsend+="]"
				else:
					if programsstart=="":
						programsstart+="['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
					else:
						programsstart+=",['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend

	elif type(expression) is blockclass:
		predicatestmt="['-1','while',"+predicateCreator(expression.predicate)+","+programToinductiveDefination( expression.getExpression(), allvariable)+"]"
		if expression.getIsPrime()==False:
			if programsstart=="":
				programsstart="['-1','seq',"+predicatestmt
				programsend="]"
			else:
				programsstart+=",['-1','seq',"+predicatestmt
				programsend+="]"
		else:
			if programsstart=="":
				programsstart+=","+predicatestmt+programsend
			
	elif type(expression) is Ifclass:
		condition=predicateCreator(expression.predicate)
		expressionif=None
		expressionelse=None
		predicatestmt=""
		if expression.getExpressionif() is not None:
			expressionif=programToinductiveDefination( expression.getExpressionif(), allvariable)
		if expression.getExpressionelse() is not None:
			if type(expression.getExpressionelse()) is Ifclass:
				#expressionelse=programToinductiveDefination( expression.getExpressionelse().getExpressionif(), allvariable)
				expressionelse=programToinductiveDefinationIfElse( expression.getExpressionelse(), allvariable)
			else:
				expressionelse=programToinductiveDefination( expression.getExpressionelse(), allvariable)
		if expressionif is not None and expressionelse is not None:
                	predicatestmt="['-1','if2',"+condition+","+expressionif+","+expressionelse+"]"
		elif expressionif is not None and expressionelse is None:
			predicatestmt="['-1','if1',"+condition+","+expressionif+"]"
		if expression.getIsPrime()==False:
			if programsstart=="":
				programsstart="['-1','seq',"+predicatestmt
				programsend="]"
			else:
				programsstart+=",['-1','seq',"+predicatestmt
				programsend+="]"
		else:
			if programsstart=="":
				programsstart=predicatestmt+programsend
			else:
				programsstart+=","+predicatestmt+programsend
 	return programsstart
"""

Conditionl Expression of If Loop or While Loop to a Array of Statement Compatible to Translator Program 

"""
    
def predicateCreator(statement):
	expression=""
	if type(statement) is m.Unary:
		if type(statement.expression) is m.Relational:
			if type(statement.expression.lhs) is m.Name:
		    		expression+="['"+getOperatorCmpl(statement.expression.operator)+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
		    	elif type(statement.expression.lhs) is m.Literal:
    				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
    			elif type(statement.expression.lhs) is m.Additive:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
			else:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
		elif type(statement.expression) is m.Equality:
			if type(statement.expression.lhs) is m.Name:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Literal:
    				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
    			elif type(statement.expression.lhs) is m.Additive:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
			else:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
    		elif type(statement.expression) is m.ConditionalOr:    
			expression+="['and',"+predicateCreatorCmpl(statement.expression.lhs)+","+predicateCreatorCmpl(statement.expression.rhs)+"]"
		elif type(statement.expression) is m.ConditionalAnd:    
	    		expression+="['or',"+predicateCreatorCmpl(statement.expression.lhs)+","+predicateCreatorCmpl(statement.expression.rhs)+"]"
	elif type(statement) is m.Relational:    
    		if type(statement.lhs) is m.Name:
    			expression+="['"+statement.operator+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Literal:
    			expression+="['"+statement.operator+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Additive:
    			expression+="['"+statement.operator+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
    		else:
    			expression+="['"+statement.operator+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
    	elif type(statement) is m.Equality:    
    		if type(statement.lhs) is m.Name:
    			expression+="['"+statement.operator+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Literal:
    			expression+="['"+statement.operator+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Additive:
		    	expression+="['"+statement.operator+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
		else:
    			expression+="['"+statement.operator+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
	elif type(statement) is m.ConditionalOr:    
	    	expression+="['or',"+predicateCreator(statement.lhs)+","+predicateCreator(statement.rhs)+"]"
	elif type(statement) is m.ConditionalAnd:    
	    	expression+="['and',"+predicateCreator(statement.lhs)+","+predicateCreator(statement.rhs)+"]"
	return expression
	


"""

Program Expression to a Array of Statement Compatible to Translator Program 

"""

def expressionCreator(statement):
    expression=""
    if type(statement) is m.Name:
    	if '.length' in statement.value:
    		axm=statement.value.split('.')
    		expression+="expres('length',["+axm[0]+"])"
    	else:
    		expression+="expres('"+statement.value+"')"
    elif type(statement) is m.Literal:
    	expression+="expres('"+statement.value+"')"
    elif type(statement) is m.MethodInvocation:
    	function=""
    	parameter=""
    	for argument in statement.arguments:
    		if parameter=="":
    			parameter=expressionCreator(argument)
    		else:
    			parameter+=","+expressionCreator(argument)
    	if "power"==statement.name:
    		function="['**',"+parameter+"]"
    	else:
		function="['"+statement.name+"',"+parameter+"]"
    	expression+=function
    elif type(statement) is m.Unary:
    	expression+="['-',"+expressionCreator(statement.expression)+"]"
    elif type(statement) is m.ArrayAccess:
    	stmt=createArrayList(statement)
    	#expression+="expres('at"+str(stmt.count(','))+"',["+stmt+"])"
    	expression+="expres('at"+"',["+stmt+"])"
    else:
    	if type(statement.lhs) is m.Name:
    		if '.length' in statement.lhs.value:
    		    	axm=statement.lhs.value.split('.')
    			expression+="expres('length',["+axm[0]+"])"
    		else:
        		expression+="expres('"+statement.operator+"',[expres('"+statement.lhs.value+"')"
    	elif type(statement.lhs) is m.Literal:
    		expression+="expres('"+statement.operator+"',[expres('"+statement.lhs.value+"')"
    	else:
        	if type(statement.lhs) is m.Additive:
            		expression+="expres('"+statement.operator+"',["+expressionCreator(statement.lhs)
        	else :
            		expression+="expres('"+statement.operator+"',["+expressionCreator(statement.lhs)
    	if type(statement.rhs) is m.Name:
        	expression+=",expres('"+statement.rhs.value+"')])"
    	elif type(statement.rhs) is m.Literal:
        	expression+=",expres('"+statement.rhs.value+"')])"
    	elif type(statement.rhs) is m.ArrayAccess:
    		stmt=createArrayList(statement.rhs)
    		#expression+="expres('at"+str(stmt.count(','))+"',["+stmt+"])"
    		expression+="expres('at"+"',["+stmt+"])"
    	else:
        	if type(statement.rhs) is m.Additive:
        		expression+=","+expressionCreator(statement.rhs)+"])"
        	else :
        		expression+=","+expressionCreator(statement.rhs)+"])"
    return expression
    
"""

Construct Array List

"""
def createArrayList(statement):
	if type(statement) is m.ArrayAccess:
		stmt=''
		if type(statement) is m.ArrayAccess:
			stmt=createArrayList(statement.target)
		stmt+=",expres('"+statement.index.value+"')"
		return stmt
	else:
		return "expres('"+statement.value+"')"







"""
 
Program Expression to Collect literal parameters
 
"""
 
def expressionCollectConstant(statement,fun_parameter):
     expression=""
     if type(statement) is m.Name:
     	expression+=statement.value
     elif type(statement) is m.Literal:
     	expression+=statement.value
     elif type(statement) is m.MethodInvocation:
     	function=""
     	parameter=""
     	key=None
     	if "power"==statement.name:
		function="['**',"+parameter+"]"
	else:
		key=statement.name
 		function="['"+statement.name+"',"+parameter+"]"
     	parameterlist=[]
     	for argument in statement.arguments:
     		if parameter=="":
     			parameter=expressionCollectConstant(argument,fun_parameter)
     			if '_n' not in parameter:
     				parameterlist.append(parameter)     				
     		else:
     			parameterstr=expressionCollectConstant(argument,fun_parameter)
     			parameter+=","+expressionCollectConstant(argument,fun_parameter)
     			if '_n' not in parameterstr:
     				parameterlist.append(parameterstr)
     				
     	if key is not None:
     		fun_parameter[key]=parameterlist
     	expression+=function
     elif type(statement) is m.Unary:
     	expression+="['-',"+expressionCollectConstant(statement.expression,fun_parameter)+"]"
     else:
     	if type(statement.lhs) is m.Name:
         	expression+="expres('"+statement.operator+"',[expres('"+statement.lhs.value+"')"
     	elif type(statement.lhs) is m.Literal:
     		expression+="expres('"+statement.operator+"',[expres('"+statement.lhs.value+"')"
     	else:
         	if type(statement.lhs) is m.Additive:
             		expression+="expres('"+statement.operator+"',["+expressionCollectConstant(statement.lhs,fun_parameter)
         	else :
             		expression+="expres('"+statement.operator+"',["+expressionCollectConstant(statement.lhs,fun_parameter)
     	if type(statement.rhs) is m.Name:
         	expression+=",expres('"+statement.rhs.value+"')])"
     	elif type(statement.rhs) is m.Literal:
         	expression+=",expres('"+statement.rhs.value+"')])"
     	else:
         	if type(statement.rhs) is m.Additive:
         		expression+=","+expressionCollectConstant(statement.rhs,fun_parameter)+"])"
         	else :
         		expression+=","+expressionCollectConstant(statement.rhs,fun_parameter)+"])"
     return expression
   


	
"""

Complement of Conditionl Expression of If Loop or While Loop to a Array of Statement Compatible to Translator Program 

"""
    
def predicateCreatorCmpl(statement):
	expression=""
	if type(statement) is m.Unary:
		if type(statement.expression) is m.Relational:
			if type(statement.expression.lhs) is m.Name:
		    		expression+="['"+statement.expression.operator+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
		    	elif type(statement.expression.lhs) is m.Literal:
    				expression+="['"+statement.expression.operator+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
    			elif type(statement.expression.lhs) is m.Additive:
				expression+="['"+statement.expression.operator+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
			else:
				expression+="['"+statement.expression.operator+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
    		if type(statement.expression) is m.Equality:
			if type(statement.expression.lhs) is m.Name:
				expression+="['"+statement.expression.operator+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Literal:
    				expression+="['"+statement.expression.operator+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
    			elif type(statement.expression.lhs) is m.Additive:
				expression+="['"+statement.expression.operator+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
			else:
				expression+="['"+statement.expression.operator+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
		elif type(statement.expression) is m.ConditionalOr:    
			expression+="['and',"+predicateCreator(statement.expression.lhs)+","+predicateCreator(statement.expression.rhs)+"]"
		elif type(statement.expression) is m.ConditionalAnd:    
	    		expression+="['or',"+predicateCreator(statement.expression.lhs)+","+predicateCreator(statement.expression.rhs)+"]"
	elif type(statement) is m.Relational:    
    		if type(statement.lhs) is m.Name:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Literal:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Additive:
		    	expression+="['"+getOperatorCmpl(statement.operator)+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
		else:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
    	elif type(statement) is m.Equality:    
    		if type(statement.lhs) is m.Name:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Literal:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Additive:
			expression+="['"+getOperatorCmpl(statement.operator)+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
		else:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
    	elif type(statement) is m.ConditionalOr:    
		expression+="['and',"+predicateCreatorCmpl(statement.lhs)+","+predicateCreatorCmpl(statement.rhs)+"]"
	elif type(statement) is m.ConditionalAnd:    
		expression+="['or',"+predicateCreatorCmpl(statement.lhs)+","+predicateCreatorCmpl(statement.rhs)+"]"
	
	return expression



"""

Conditionl Loop to a Array of Statement Compatible to Translator Program 
IfClass Creator

"""

def ifclassCreator(statement, degree, count):
	if type(statement.predicate) is m.Relational:
		predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	elif type(statement.predicate) is m.Equality:
            	predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	elif type(statement.predicate) is m.ConditionalOr:
	        predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	elif type(statement.predicate) is m.ConditionalAnd:
		predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	elif type(statement.predicate) is m.Unary:
		predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	ifclass=Ifclass(predicate, blockexpressions1, blockexpressions2, count ,True ,degree)
	return count,ifclass

"""

Validation of Variables

"""

def validationOfInput(allvariable):
	for variable in allvariable.keys():
		if variable=='S' or variable=='Q' or variable=='N' or variable=='in' or variable=='is':
			return True
	return False


"""

Translate Program to Logic 

"""


#def translate(file_name):
#	if not(os.path.exists(file_name)): 
#		print "File not exits"
#		return
#	filename, file_extension = os.path.splitext(file_name)
#	if file_extension=='.java' or file_extension=='.Java' or file_extension=='.JAVA':
#		return translate_Java(file_name)
#	elif file_extension=='.c' or file_extension=='.C' :
#		return translate_C(file_name)
#	else:
#		return None
#	print file_extension

"""

Translate Program to Logic 

#file_name='Utils7.java'

#file_name='cohendiv.java'

#file_name='sample3.java'

#file_name='benchmark/sqrt.java'

#flag=1

#file_name='benchmark/Utils1.java'

#file_name='TestCases/cubes_Cohen.java'

flag=2

#file_name='sqrt.java'

#file_name='benchmark/cohendiv.java'

#axiom=translate(file_name)

#file_name='cohendiv.java'

"""
  
def translate_Java1(file_name):
	if not(os.path.exists(file_name)): 
		print "File not exits"
		return
	#if flag<1 and flag>3: 
	#	print "Invalid"
	#	return

	start_time=current_milli_time()
	p = getParser()
	#tree = p.parse_file("Utils7.java")
	tree = p.parse_file(file_name)
	#print tree
	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Translate \n"+"\nParameters--\n File Name--"+file_name+"\n")
	if tree is None:
		print "Error present in code. Please verify you input file"
		return
	sort=None
	for type_decl in tree.type_declarations:
                #sort=sortclass(type_decl.name)
                print type_decl.name
                if type_decl.extends is not None:
                        print(' -> extending ' + type_decl.extends.name.value)
                menbermap={}
                menbermethods=[]
                returnType=None
                for field_decl in [decl for decl in type_decl.body if type(decl) is m.FieldDeclaration]:
                        for var_decl in field_decl.variable_declarators:
                                if type(field_decl.type) is str:
                                        type_name = field_decl.type
                                else:
                                        type_name = field_decl.type.name.value
                                menbermap[var_decl.variable.name]=type_name

                for method_decl in [decl for decl in type_decl.body if type(decl) is m.MethodDeclaration]:
                        parametermap={}
                        returnType=None
                        localvarmap={}
                        statements=[]
                        if type(method_decl.return_type) is str:
                                returnType=method_decl.return_type
                        else:
                                returnType=method_decl.return_type.name.value
                        
                        for param in method_decl.parameters:
                                if type(param.type) is str:
                                	variable=variableclass(param.variable.name, param.type,param.modifiers,param.variable.dimensions,None)
                                	parametermap[param.variable.name]=variable
                                        #parametermap[param.variable.name]=param.type         
                                else:
                                	#variable=variableclass(param.type.name.value, param.type,param.modifiers,param.variable.dimensions,None)
                                        variable=variableclass(param.variable.name, param.type.name,param.modifiers,param.variable.dimensions,None)
                                        parametermap[param.variable.name]=variable
                                        #parametermap[param.type.name.value]=param.type
                        if method_decl.body is not None:
                                for statement in method_decl.body:
                                # note that this misses variables in inner blocks such as for loops
                                # see symbols_visitor.py for a better way of handling this
                                        if type(statement) is m.VariableDeclaration:
                                                for var_decl in statement.variable_declarators:
                                                        if type(statement.type) is str:
                                                        	variable=variableclass(var_decl.variable.name, statement.type,None,var_decl.variable.dimensions,var_decl.initializer)
                                                                #type_name = statement.type
                                                        else:
                                                        	variable=variableclass(var_decl.variable.name, statement.type.name,None,statement.type.dimensions,var_decl.initializer)
                                                                #type_name = statement.type.name.value
                                                        #localvarmap[var_decl.variable.name]=type_name
                                                        localvarmap[var_decl.variable.name]=variable
                                        else:
                                        	statements.append(statement)
                        membermethod=membermethodclass(method_decl.name,returnType,parametermap,localvarmap,None,None,None)
                        menbermethods.append(membermethod)
                allvariable={}
                sort=sortclass(type_decl.name, menbermap)
                program_dec_start=""
                program_dec_end=""
                for lvap in localvarmap:
                	var=localvarmap[lvap]
                	if var is not None and var.getInitialvalue() is not None and type(var.getInitialvalue()) is not m.ArrayCreation:
                		if program_dec_start=="":
                			program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue().value)+"')]"
                			program_dec_end="]"
                		else:
                	        	program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue().value)+"')]"
                			program_dec_end+="]"

                if sort is not None:
			print " Class Name:"
			print sort.getSortname()
			print " Class Variables:"
			print sort.getVarmap()
			for membermethod in menbermethods:
				print "Method Name:"
		        	print membermethod.getMethodname()
		        	print "Return Type:"
		                print membermethod.getreturnType()
		                print "Input Variables:"
		                var_list="{"
		                for x in membermethod.getInputvar():
		                	if membermethod.getInputvar()[x].getDimensions()>0:
		                		var_list+=' '+x+':array'
		                	else:
		                		var_list+=' '+x+':'+membermethod.getInputvar()[x].getVariableType()
		                var_list+='}'
                                print var_list
		                print "Local Variables:"
		                var_list="{"
		                for x in membermethod.getLocalvar():
		                	if membermethod.getLocalvar()[x].getDimensions()>0:
						var_list+=' '+x+':array'
					else:
		                		var_list+=' '+x+':'+membermethod.getLocalvar()[x].getVariableType()
                                var_list+='}'
                                print var_list
                                for x in membermethod.getInputvar():
                                	allvariable[x]=membermethod.getInputvar()[x]
                                for x in membermethod.getLocalvar():
                                	allvariable[x]=membermethod.getLocalvar()[x]
                                	
          	if validationOfInput(allvariable)==True:
          		print "Please Rename variable Name {S,Q,N,in,is} to other Name"
          		return
                print "All Variables:"
                var_list="{"
             	for x in allvariable:
			if allvariable[x].getDimensions()>0:
				var_list+=' '+x+':array'
			else:
		        	var_list+=' '+x+':'+allvariable[x].getVariableType()
                var_list+='}'
                print var_list
                syntaxTranslate_Java(statements)
                expressions=organizeStatementToObject(statements)
                primeStatement(expressions)
                variablesarray={}
                opvariablesarray={}
                count=0
                arrayFlag=False
                for variable in allvariable:
                	count+=1
                	if allvariable[variable].getDimensions()>0:
                		variablesarray[variable]=eval("['_y"+str(count)+"','array']")
                		opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','array']")
                		list_parameter="'array'"
                		for i in range(0, allvariable[variable].getDimensions()):
                			if list_parameter=='':
                				list_parameter="'int'"
                			else:
                				list_parameter+=",'int'"
                		list_parameter+=",'"+allvariable[variable].getVariableType()+"'"
                		#key1='at'+str(allvariable[variable].getDimensions())
                		#key2='gt'+str(allvariable[variable].getDimensions())
                		key1='at'
                		key2='gt'
                		arrayFlag=True
                		if key1 not in variablesarray.keys():
                			count+=1
                			variablesarray[key1]=eval("['_y"+str(count)+"',"+list_parameter+"]")
                			opvariablesarray[key1+"1"]=eval("['_y"+str(count)+"',"+list_parameter+"]")
                		if key2 not in variablesarray.keys():
                			count+=1
                			variablesarray[key2]=eval("['_y"+str(count)+"',"+list_parameter+"]")
                			opvariablesarray[key2+"1"]=eval("['_y"+str(count)+"',"+list_parameter+"]")
                	else:
                		variablesarray[variable]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")
                		opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")
                if arrayFlag==True:
                	count+=1
                	variablesarray['length']=eval("['_y"+str(count)+"','array','int']")
                	opvariablesarray['length1']=eval("['_y"+str(count)+"','array','int']")
                
                #print "#################1"
		#print variablesarray
		#print opvariablesarray
                #print "#################1"
                if program_dec_start=="":
                	str_program=programToinductiveDefination(expressions , allvariable)
                else:
                	str_program=program_dec_start+','+programToinductiveDefination(expressions , allvariable)+program_dec_end

                print str_program
                program=eval(str_program)
                print ""
                print "Output of The Translator Written By Prof Lin"
                print ""
                print "Inputs to Translator"
                print "Parameter One:"
                print program
                print "Parameter Two:"
                print variablesarray
                print "Parameter Two Three:"
                print 1             
                f,o,a,cm=translate1(program,variablesarray,1)
                #f,o,a,cm=translate1(program,variablesarray,2)
                vfacts,constraints=getVariFunDetails(f,o,a,allvariable,opvariablesarray)
                end_time=current_milli_time()
                print "Times to Translate"
                print end_time-start_time
                writeLogFile( "j2llogs.logs" , getTimeStamp()+"\n End of Translation\n")
                axiom=axiomclass(f,o,a,membermethod.getInputvar(), vfacts, constraints,cm)
                return axiom








#Parsing Method Starts

# define some basic operand expressions
number = Regex(r'\d+(\.\d*)?([Ee][+-]?\d+)?')
ident = Word(alphas+'_', alphanums+'_')
#fn_call = ident + '(' + Optional(delimited_list(expr)) + ')'

# forward declare our overall expression, since a slice could 
# contain an arithmetic expression
expr = Forward()
#slice_ref = '[' + expr + ']'

slice_ref = '[' + expr + ZeroOrMore("," + expr) + ']'

# define our arithmetic operand
operand = number | Combine(ident + Optional(slice_ref))
#operand = number | fn_call | Combine(ident + Optional(slice_ref))
inequalities = oneOf("< > >= <= = == !=")

# parse actions to convert parsed items
def convert_to_pow(tokens):
    tmp = tokens[0][:]
    ret = tmp.pop(-1)
    tmp.pop(-1)
    while tmp:
        base = tmp.pop(-1)
        # hack to handle '**' precedence ahead of '-'
        if base.startswith('-'):
            ret = '-power(%s,%s)' % (base[1:], ret)
        else:
            ret = 'power(%s,%s)' % (base, ret)
        if tmp:
            tmp.pop(-1)
    return ret

def unary_as_is(tokens):
    return '(%s)' % ''.join(tokens[0])

def as_is(tokens):
    return '%s' % ''.join(tokens[0])


# simplest infixNotation - may need to add a few more operators, but start with this for now
arith_expr = infixNotation( operand,
    [
    ('-', 1, opAssoc.RIGHT, as_is),
    ('**', 2, opAssoc.LEFT, convert_to_pow),
    ('-', 1, opAssoc.RIGHT, unary_as_is),
    ((inequalities,inequalities), 3, opAssoc.LEFT, as_is),
    (inequalities, 2, opAssoc.LEFT, as_is),
    (oneOf("* /"), 2, opAssoc.LEFT, as_is),
    (oneOf("+ -"), 2, opAssoc.LEFT, as_is),
    (oneOf('and or'), 2, opAssoc.LEFT, as_is),
    ])
#('-', 1, opAssoc.RIGHT, as_is),
# now assign into forward-declared expr
expr <<= arith_expr.setParseAction(lambda t: '(%s)' % ''.join(t))

"""
#expression="2**3"
#expression="2**-3"
#expression="2**3**x5"
#expression="2**-3**x6[-1]"
#expression="2**-3**x5+1"
#expression="(a+1)**2"
#expression="((a+b)*c)**2"
#expression="B**2"
#expression="-B**2"
#expression"(-B)**2"
#expression="B**-2"
#expression="B**(-2)"
#expression="((Z**(_N1+1)-1)/(Z-1))*(Z-1))"
#expression="((_N1+1)**2)<=X"
#expression="_n2*_n3*_N1(_n2, _n3)**2/2"
#translatepowerToFun(expression)
#expression="_n2*_n3*_N1(_n2, X(_n3))**2/2"

#expression="(((2.00000000000000)+_n2*_n3*_N1(_n2, X(_n3))**2/2))"

"""

def translatepowerToFun(expression):
    if "**" in expression:
        try:
            backup_expression=expression
            if ("<" in  expression or ">" in  expression) and '/' not in expression :
                expression=simplify(expression)
            expression=transferToFunctionSyntax(str(expression))
            xform = expr.transformString(expression)[1:-1]
            #xform = expr.transformString(expression)
            xform=xform.replace('[','(')
            expression=xform.replace(']',')')
        except Exception as e:
            expression=backup_expression
   	#print expression
    return expression
 
 
 

"""
Example 1:
>>> expression="x(n)+(y(n)+1)*n"
>>> transferToMathematicaSyntax(expression)
'x[n]+(y[n]+1)*n'

Example 2:

>>> expression="x(n(a,b),a,b)+2^(y(_N1(a,b),a,b)+1)"
>>> transferToMathematicaSyntax(expression)
'x[n[a,b],a,b]+2^(y[_N1[a,b],a,b]+1)'

Example 3:

>>> expression="x(n)+(y(n)/(_N1(n)))"
>>> transferToMathematicaSyntax(expression)
'x[n]+(y[n]/(_N1(n)))'

"""

#Changing function of the formate f(n) to f[n]. It assist the pasring 

def transferToFunctionSyntax(expression):
	if "(" in expression and ")" in expression:
		p = regex.compile(r'\b[a-zA-Z_]\w*(\((?>[^()]|(?1))*\))')
		result=(p.sub(lambda m: m.group().replace("(", "[").replace(")", "]"), expression))
	else:
		result=expression
	return result


#Parsing Method Ends

def isConstInResult( variable ):
	status=False
	find=regex.compile(r'C\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status

"""

Construction Parser

"""
#p = plyj.parser.Parser()

#def getParser():
	#global p
	#return p




def construct_expressionC(postion,variable,e1,e2):
	expression=[]
        expression.append('i2')
        expression.append(postion)
        expression.append(variable)
        expression.append(e1)
        expression.append(e2)
	return expression

def construct_expression(tree,postion,variable):
	expression=""
	if type(tree) is m.Assignment:
		expression="['i2',"+str(postion)+",'"+variable+"',"+expressionCreator(tree.lhs)+","+expressionCreator(tree.rhs)+"]"
	return eval(expression)



def construct_expression_normalC(e):
	if e is not None:
		expression=[]
                expression.append('s0')
                expression.append(e)
		return expression
	else:
		return None


	
def construct_expression_normal(tree):
	if tree is not None:
		expression=""
		if type(tree) is m.Relational:
			expression="['s0',"+expressionCreator(tree)+"]"
		return eval(expression)
	else:
		return None




"""

#Simplify conclusion 

"""


def simplify_conclusion(conclusion,subs_list):
	if conclusion is not None and conclusion!='':
		term=isFunction(conclusion)
		if term is None:
			return None
		if 'ForAll' in conclusion and term=='ForAll':
			arg_list=extract_args(conclusion)
			result=simplify_conclusion(arg_list[1],subs_list)
			if result is not None:
				return 'ForAll('+arg_list[0]+','+result+')'
			else:
				return None
		elif 'Or' in conclusion and term=='Or':
			arg_list=extract_args(conclusion)
			result1=simplify_conclusion(arg_list[0],subs_list)
			result2=simplify_conclusion(arg_list[1],subs_list)
			if result1 is not None and result2 is not None:
				return 'Or('+result1+','+result2+')'
			else:
				return None
		elif 'And' in conclusion and term=='And':
			arg_list=extract_args(conclusion)
			result1=simplify_conclusion(arg_list[0],subs_list)
			result2=simplify_conclusion(arg_list[1],subs_list)
			if result1 is not None and result2 is not None:
				return 'And('+result1+','+result2+')'
			else:
				return None
		elif 'Exists' in conclusion and term=='Exists':
			arg_list=extract_args(conclusion)
			result=simplify_conclusion(arg_list[1],subs_list) 
			if result is not None:
				return 'Exists('+arg_list[0]+','+result+')'
			else:
				return None
		elif 'Not' in conclusion and term=='Not':
			arg_list=extract_args(conclusion)
			result=simplify_conclusion(arg_list[1],subs_list) 
			if result is not None:
				return 'Not('+result+')'
			else:
				return None
		elif 'Implies' in conclusion and term=='Implies':
			arg_list=extract_args(conclusion)
			result1=simplify_conclusion(arg_list[0],subs_list)
			result2=simplify_conclusion(arg_list[1],subs_list)
			if result1 is not None and result2 is not None:
				return 'Implies('+result1+','+result2+')'
			else:
				return None

		else:
			if '==' not in conclusion and '!=' not in conclusion:
				modified_conclusion=conclusion
				for element in subs_list.keys():
					modified_conclusion=str(modified_conclusion).replace(str(element),str(subs_list[element]))
				if '/' in modified_conclusion:
					conclusion=modified_conclusion
				else:
					conclusion=str(pow_to_mul(powsimp(simplify_sympy(conclusion).subs(subs_list))))
				return conclusion
			elif '!=' in conclusion:
				axm=conclusion.split('!=')
				left_side=None
				right_side=None
				conclusion=None
				if isinstance(simplify_sympy(axm[0]), (str, unicode)) or isinstance(simplify_sympy(axm[1]), (str, unicode)):
					left_side=str(simplify_sympy(axm[0]))
					for element in subs_list.keys():
						left_side=left_side.replace(str(element),str(subs_list[element]))
					right_side=str(simplify_sympy(axm[1]))
					for element in subs_list.keys():
						right_side=right_side.replace(str(element),str(subs_list[element]))
				else:
					left_side=str(simplify_sympy(axm[0]))
					for element in subs_list.keys():
						left_side=left_side.replace(str(element),str(subs_list[element]))
					right_side=str(simplify_sympy(axm[1]))
					for element in subs_list.keys():
						right_side=right_side.replace(str(element),str(subs_list[element]))
					#left_side=str(simplify_sympy(axm[0]).subs(subs_list))
					#right_side=str(simplify_sympy(axm[1]).subs(subs_list))
				if left_side is not None and right_side is not None:
					conclusion=left_side+'!='+right_side
				return conclusion
			
			else:
				axm=conclusion.split('==')
				left_side=None
				right_side=None
				conclusion=None
				leftin=None
				rightin=None
				leftin,rightin,axm[0]=parenthesesOrganizer( axm[0] ,leftin ,rightin)
				if leftin is not None and rightin is not None:
					axm[0]=leftin+axm[0]+rightin
				leftin=None
				rightin=None
				leftin,rightin,axm[1]=parenthesesOrganizer( axm[1] ,leftin ,rightin)
				if leftin is not None and rightin is not None:
					axm[1]=leftin+axm[1]+rightin
				if isinstance(simplify_sympy(axm[0]), (str, unicode)) or isinstance(simplify_sympy(axm[1]), (str, unicode)):
					left_side=str(simplify_sympy(axm[0]))
					for element in subs_list.keys():
						left_side=left_side.replace(str(element),str(subs_list[element]))
					right_side=str(simplify_sympy(axm[1]))
					for element in subs_list.keys():
						right_side=right_side.replace(str(element),str(subs_list[element]))
				else:
					left_side=str(simplify_sympy(axm[0]))
					for element in subs_list.keys():
						left_side=left_side.replace(str(element),str(subs_list[element]))
					right_side=str(simplify_sympy(axm[1]))
					for element in subs_list.keys():
						right_side=right_side.replace(str(element),str(subs_list[element]))
					#left_side=str(simplify_sympy(axm[0]).subs(subs_list))
					#right_side=str(simplify_sympy(axm[1]).subs(subs_list))
				if left_side is not None and right_side is not None:
					conclusion=left_side+'=='+right_side
				return conclusion




"""

Function Display Axioms

"""

def displayAxioms(axiom):
	if axiom is not None:
	    print('1. Frame axioms:')
	    eqset2string1(axiom.getFrame_axioms())
	    print('\n2. Output equations:')
	    eqset2string1(axiom.getOutput_equations())
	    print('\n3. Other axioms:')
	    for x in axiom.getOther_axioms(): 
            	print wff2string1(x)
            

"""

Function Display Vfact

"""

def displayVfact(axiom):
	if axiom is not None:
	    print axiom.getVfact()
	    
	   
"""

Function Display Input Variable

"""

def displayInputVariables(axiom):
	if axiom is not None:
	    print axiom.getInputvariable()


"""
Prove command used to prove post condition of a program 

"""


def prove1(axiom,pre_condition,post_condition,flag):
	if len(post_condition)==0:
		print "Nothing To Prove"
		return
	if axiom is not None and post_condition is not None and flag>0 and flag<5:
	        if flag==1:
	        	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(post_condition)+"\n Strategy--Direct")
                	start_time=current_milli_time()
                	tactic1(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints())
                	end_time=current_milli_time()
                	print "Times to Get Result"
                	print end_time-start_time
                elif flag==2:
                	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(post_condition)+"\n Strategy--Induction")
                	start_time=current_milli_time()
			#tactic2(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
			end_time=current_milli_time()
			print "Times to Get Result"
                	print end_time-start_time
                writeLogFile( "j2llogs.logs" , getTimeStamp()+"\n End of Proof\n")


"""
Prove command used to prove post condition of a program 

"""


def prove(axiom,pre_condition,post_condition):
	if len(post_condition)==0:
		print "Nothing To Prove"
		return
	if axiom is not None and post_condition is not None:
		start_time=current_milli_time()
		writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(post_condition)+"\n Strategy--Direct")
		status=tactic1(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints())
		if "Successfully Proved" in status:
			print "Successfully Proved"			
		elif "Counter Example" in status:
			print status		
		else:
			status=tactic2(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
		
			if "Successfully Proved" in status:
				print "Successfully Proved"			
			elif "Counter Example" in status:
				print status		
			else:
				print "Failed to Prove"
		end_time=current_milli_time()
		print end_time-start_time
	
	
# Test Case

#function_name='main'
#pre_condition=[]
#post_condition=['Z1 == 230']

#function_name='product'
#pre_condition=['a>=0','b>=0']
#post_condition=['RET1 == a*b']

#function_name='add'
#pre_condition=['a>=0','b>=0']
#post_condition=['RET1 == a+b']


def prove_auto_process(program,property,program_analysis,program_analysis_decl):
    
        start_time=current_milli_time()
        rec_program=False
	if program is None:
		print "Something is Wrong"
		return
	if program is not None:
		#print '\n----Proving Process----\n'
		for name in program.getAxiomeMap():
                        if 'main' in name:
                            #print
                            #print 'Function Name--'+name
                        
                            axiom=program.getAxiomeMap()[name]
                            
                            
                            
                            #print '$$$$$$$$$$$$$$$$$$$$$----------'
                            #print axiom.getVfact()
                            #print axiom.getOther_axioms()
                            #print axiom.getConstraints()
                            #print '$$$$$$$$$$$$$$$$$$$$$----------'
                            
                            witnessXml=program.getWitnessXmlMap()[name]
                            #writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(post_condition)+"\n Strategy--Direct")
                            post_condition={}
                            for w in axiom.getAsserts():
                                    #print '-------------'
                                    #print w
                                    #print wff2string1(w)
                                    #print w[-1][:1]
                                    #print '-------------'
                                    if w[-1][:1]==['ite']:
                                                w[-1]=simplifyPostCondition(w[-1])
                                                
                                    if w[0]=='i1':
                                        
                                            var_cstr_map={}
                                            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                            list_var_str=qualifier_list(var_cstr_map.keys())
                                            list_cstr_str=cstr_list(var_cstr_map.values())
                                            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                            if list_var_str is not None and list_cstr_str is not None:
                                                    if w[0] == 'i1':
                                                            post_condition["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                    else:
                                                            post_condition['ForAll(['+list_var_str+'],'+rhs+")"]=w
                                            else:
                                                    post_condition[rhs]=w
                                    elif w[0]=='c1':
                                            var_cstr_map={}
                                            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                            list_var_str=qualifier_list(var_cstr_map.keys())
                                            list_cstr_str=cstr_list(var_cstr_map.values())
                                            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                            if list_var_str is not None and list_cstr_str is not None:
                                                    if w[0] == 'i1':
                                                            post_condition["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                    else:
                                                            post_condition['ForAll(['+list_var_str+'],'+rhs+")"]=w
                                            else:
                                                    post_condition[rhs]=w
                                    else:
                                            if w[0]!='i0':
                                                    var_cstr_map={}
                                                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                                    list_var_str=qualifier_list(var_cstr_map.keys())
                                                    list_cstr_str=cstr_list(var_cstr_map.values())
                                                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                                    if list_var_str is not None and list_cstr_str is not None:
                                                            if w[0] == 'i1':
                                                                    post_condition["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                            else:
                                                                    post_condition['ForAll(['+list_var_str+'],'+rhs+")"]=w
                                                    else:
                                                            post_condition[rhs]=w
                            
                            
                            main_status=None
                            if len(post_condition)==0:
                                print 'VIAP_STANDARD_OUTPUT_True'
                                return
                            
                            
                            
                            for p_condition in post_condition.keys():
                                    axiom.setAsserts((p_condition,post_condition[p_condition]))
                                    
                                    #print '-----------------------------'
                                    #prove_assert_tactic_tempory2(axiom,witnessXml)
                                    #print prove_assert_tactic_tempory(axiom,witnessXml)
                                    #print p_condition
                                    #tactic1_update_terminate_unsigned(axiom,witnessXml)
                                    #prove_assert_tactic_conditional_rec(axiom,witnessXml)
                                    #prove_assert_tactic_approximation(axiom,witnessXml)
                                    #print '-----------------------------'
                                    #return

                                    
                                    
                                    #update_assertion(post_condition[p_condition],axiom,witnessXml)
                                    var_cstr_map={}
                                    array_map={}
                                    isQuantified=None
                                    if post_condition[p_condition][0]=='s0':
                                        rhs=expr2z3_update_postCond(post_condition[p_condition][1],var_cstr_map)
                                        isQuantified=qualifier_list(var_cstr_map.keys())
                                        array_element_list(post_condition[p_condition][1],array_map)
                                        if len(array_map.keys())>0:
                                            isQuantified=True
                                    elif post_condition[p_condition][0]=='c1':
                                        rhs=expr2z3_update_postCond(post_condition[p_condition][1],var_cstr_map)
                                        isQuantified=qualifier_list(var_cstr_map.keys())
                                        array_element_list(post_condition[p_condition][1],array_map)
                                        if len(array_map.keys())>0:
                                            isQuantified=True
                                    #print '~~~~~~~~~~`'
                                    if isQuantified is None or len(array_map.keys())==0:
                                        #status=prove_assert_tactic4_update3(axiom,witnessXml)
                                        #status=prove_assert_tactic10(axiom,witnessXml)
                                        #return
                                        
                                        termination_status=prove_assert_tactic1_termination(axiom,witnessXml)
                                        
                                        yy_status=False
                                        
                                        for yy in axiom.getOther_axioms():
                                            if yy[0]=='R':
                                                yy_status=True

                                        
                                        
                                        if "Successfully Proved" in termination_status and yy_status==False:
                                            
                                            #line_no,stmt2 = getLineNumber_terminate('__VERIFIER_error();',None)
                                            #hashcode=sha1(program.getFilename())
                                            #if property is None:
                                            #    property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
                                            #else:
                                            #        if '=' in property:
                                            #            value_names=property.split('=')
                                            #            fd = open(value_names[0])
                                            #            property = "".join(fd.readlines())
                                            #        else:
                                            #            property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
                                            
                                            
                                            #violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\"?>"+"\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\""+"\n"+"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" +"\n"+"xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">"+"\n"+"<key id=\"programfile\" attr.name=\"programfile\" for=\"graph\"/>"+"\n"+"<key id=\"programhash\" attr.name=\"programhash\" for=\"graph\"/>"+"\n"+"<key id=\"sourcecodelang\" attr.name=\"sourcecodelang\" for=\"graph\"/>"+"\n"+"<key id=\"producer\" attr.name=\"producer\" for=\"graph\"/>"+"\n"+"<key id=\"specification\" attr.name=\"specification\" for=\"graph\"/>"+"\n"+"<key id=\"creationtime\" attr.name=\"creationtime\" for=\"graph\"/>"+"\n"+"<key id=\"witness-type\" attr.name=\"witness-type\" for=\"graph\"/>"+"\n"+"<key id=\"architecture\" attr.name=\"architecture\" for=\"graph\"/>"+"\n"+"<key id=\"entry\" attr.name=\"entry\" for=\"node\">"+"\n"+"<default>false</default>"+"\n"+"</key>"+"\n"+"<key id=\"nodetype\" attr.name=\"nodetype\" for=\"node\">"+"\n"+"<default>path</default>"+"\n"+"</key>"+"\n"+"<key id=\"violation\" attr.name=\"violation\" for=\"node\">"+"\n"+"<default>false</default>"+"\n"+"</key>"+"\n"+"<key id=\"invariant\" attr.name=\"invariant\" for=\"node\">"+"\n"+"<default>true</default>"+"\n"+"</key>"+"\n"+"<key id=\"endline\" attr.name=\"endline\" for=\"edge\"/>"+"\n"+"<key id=\"enterFunction\" attr.name=\"enterFunction\" for=\"edge\"/>"+"\n"+"<key id=\"startline\" attr.name=\"startline\" for=\"edge\"/>"+"\n"+"<key id=\"returnFrom\" attr.name=\"returnFrom\" for=\"edge\"/>"+"\n"+"<key id=\"assumption\" attr.name=\"assumption\" for=\"edge\"/>"+"\n"+"<key id=\"tokens\" attr.name=\"tokens\" for=\"edge\"/>"+"\n"+"<key id=\"control\" attr.name=\"control\" for=\"edge\"/>"+"\n"+"<key id=\"originfile\" attr.name=\"originfile\" for=\"edge\">"+"\n"+"<default>"+filename+"</default>"+"\n"+"</key>"+"\n"+"<key id=\"sourcecode\" attr.name=\"sourcecode\" for=\"edge\"/>"+"\n"+"<graph edgedefault=\"directed\">"+"\n"+"<data key=\"programfile\">"+filename+"</data>"+"\n"+"<data key=\"programhash\">"+hashcode+"</data>"+"\n"+"<data key=\"sourcecodelang\">C</data>"+"\n"+"<data key=\"producer\">VIAP</data>"+"\n"+"<data key=\"specification\">"+property+"</data>"+"\n"+"<data key=\"creationtime\">"+str(datetime.datetime.now().strftime("%y-%m-%dT%H:%MZ"))+"</data>"+"\n"+"<data key=\"witness-type\">violation_witness</data>"+"\n"+"<data key=\"architecture\">64bit</data>"+"\n"+"<node id=\"N0\">"+"\n"+"<data key=\"entry\">true</data>"+"\n"+"</node>"
                                            #violation_witness2=''
                                            #violation_witness2+="<node id=\"N"+str(1)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no)+"</data>\n"+"</node>\n"
                                            #violation_witness2+="<edge source=\"N"+str(0)+"\" target=\"N"+str(1)+"\">\n"
                                            #violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                                            #violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                                            #violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                                            #violation_witness2+="</edge>\n"
                                            #result_xml=violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n"
                                            #if result_xml is not None:
                                            #    writtingFile( "errorWitness.graphml" , result_xml )
                                            #    writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(result_xml)+"\n" )
                                            t_smallest = tactic1_update_terminate_unsigned(axiom,witnessXml)
                                            if t_smallest is not None:
                                                axiom.getOther_axioms().remove(t_smallest)
                                            else:
                                                print 'Unknown'
                                                #print 'VIAP_STANDARD_OUTPUT_False'
                                                return

                                        
                                        #print '======================='
                                        #print main_status
                                        #print p_condition
                                        #print post_condition[p_condition]
                                        #print axiom.getOutput_equations()
                                        #isReturnVoid(axiom.getOutput_equations(),axiom.getOther_axioms())
                                        #prove_assert_break_handle(axiom,witnessXml)
                                        #prove_selected_failed_assert(axiom,witnessXml)
                                        #print '======================='
                                        #return
                                        #print 'XXXXXXXXXXmain'
                                        map_fun_bitwise={}
                                        getAllBitWiseFunction_assert(post_condition[p_condition][-1],map_fun_bitwise,False)
                                        if len(map_fun_bitwise)>0:
                                            
                                            for [x,k,l] in axiom.getVfact():
                                                map_fun_bitwise[x]=x
                                            print 'Strategy applied 1(a)'
                                            status = prove_assert_tactic1_bitwise(axiom,map_fun_bitwise,witnessXml)
                                        
                                        elif isCallByRef(axiom.getOutput_equations())==True:
                                            print 'Strategy applied 1(b)'
                                            status=prove_assert_CallByRef(axiom,witnessXml)
                                            
                                        else:
                                            #print '1-S'
                                            print 'Strategy applied 1'
                                            status=prove_assert_tactic1(axiom,witnessXml)
                                            #print status
                                            
                                            if "Successfully Proved" not in status and isRecursiveCall(axiom.getOther_axioms())==True:
                                            
                                                print 'Strategy applied 1(c)'
                                                status = prove_assert_abstract_rec(axiom,witnessXml)
                                                
                                                if "Successfully Proved" not in status and isReturnVoid(axiom.getOutput_equations(),axiom.getOther_axioms())==True:
                                                    print axiom.getOutput_equations()
                                                    
                                                    filter_equations=[]
                                                    for x in axiom.getOther_axioms():
                                                        if x[0]=='R' and '_FAILED' in x[2][0]:
                                                            filter_equations.append(wff_a(eval("['=',"+str(x[2][1])+","+str(axiom.getOutput_equations().values()[0][2][1])+"]")))
                                                            filter_equations.append(x)
                                                    axiom.setOther_axioms(filter_equations)
                                                    status=prove_assert_tactic1(axiom,witnessXml)
                                                    
                                                    
                                            
                                            for xx in axiom.getOutput_equations():
                                                if 'RET'==xx:
                                                    main_condition_map={}
                                                    get_conditions_all(axiom.getOutput_equations()[xx][-1],main_condition_map)
                                                    for yy in main_condition_map:
                                                        add_assume = get_conditions_and_part(main_condition_map[yy])
                                                        if add_assume is not None:
                                                            axiom.getAssumes().append(wff_a(add_assume))
                                                     
                                        #for xx in axiom.getOutput_equations():
                                        #for xx in axiom.getOther_axioms():
                                        #    if isFunCallbyRef( xx )==True:
                                        #        print xx
                                        #    print isFunCallbyRef( xx )
                                        #    print wff2string1(axiom.getOutput_equations()[xx])
                                        #print status
                                        #print '-------------'
                                        #if 'Counter Example' in status:
                                        #    return 
                                        #print 'XXXXXXXXXXX'

                                        if "Successfully Proved" in status:
                                            main_status="True"
                                            xx_status=False
                                            for xx in axiom.getOther_axioms():
                                                if xx[0]=='R':
                                                    xx_status=True
                                                    rec_program=True
                                            if xx_status==True:
                                                try:
                                                    program_analysis = AssetionAnalysis13(program_analysis)
                                                except Exception as e:
                                                    print str(e)

                                                
                                                result=AssetionAnalysis4(program_analysis,program_analysis_decl,program.getFilename(),property)
                                                
                                                
                                                #print '~~~~~~~~~~~~~~~~~~~~~~~'
                                                #print result
                                                #print '~~~~~~~~~~~~~~~~~~~~~~~'
                                                if result is not None:
                                                    #print "Error Witness Generated"
                                                    writtingFile( "correctnessWitness.graphml" , result )
                                                    writeLogFile( "j2llogs.logs" , "\ncorrectnessWitness \n"+str(result)+"\n" )
                                                else:
                                                   if property is None:
                                                        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
                                                   else:
                                                        
                                                        if '=' in property:
                                                            value_names=property.split('=')
                                                            fd = open(value_names[1])
                                                            property = "".join(fd.readlines())
                                                        else:
                                                            property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
                                                   hashcode=sha1(program.getFilename())
                                                   violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+program.getFilename()+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">correctness_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+program.getFilename()+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"
                                                    
                                                   writtingFile( "correctnessWitness.graphml" , violation_witness1+'\n'+"\n</graph>\n</graphml>\n"  )
                                                   writeLogFile( "j2llogs.logs" , "\ncorrectnessWitness \n"+str(violation_witness1+'\n'+"\n</graph>\n</graphml>\n" )+"\n" )

                                        #elif "Counter Example" in status:
                                        #    main_status="Unknown"
                                            #print status
                                        #elif "Nothing To Prove" in status:
                                        #    print 'No Assertion to Prove'
                                        else:
                                            #return
                                            #if 'array' in p_condition:
                                            #    status=prove_assert_tactic4(axiom,witnessXml)
                                            #    if "Successfully Proved" in status:
                                            #        print "Successfully Proved"
                                            #    elif "Counter Example" in status:
                                            #        print status
                                            #    else:
                                            #        print "Failed to Prove"
                                            #print "Failed to Prove1"
                                            if len(array_map.keys())==0:
                                                #print '2-S'
                                                print 'Strategy applied 2'
                                                status=prove_assert_abstract_summation(axiom,witnessXml)
                                                if "Successfully Proved" in status:
                                                    main_status="True"
                                                else:
                                                    #print 'XXXXXXXXXX1111'
                                                    #print '3-S'
                                                    print 'Strategy applied 3'
                                                    status=prove_assert_tactic2(axiom,witnessXml)
                                                    if "Successfully Proved" in status:
                                                        main_status="True"
                                                    #elif "Counter Example" in status:
                                                    #    main_status='Unknown'
                                                    #elif "Nothing To Prove" in status:
                                                    #    print 'No Assertion to Prove'
                                                    else:
                                                        #print 'XXXXXXXXXX111'
                                                        #print '4-S'
                                                        print 'Strategy applied 4'
                                                        status=prove_assert_tactic3(axiom,witnessXml)
                                                        if "Successfully Proved" in status:
                                                            main_status="True"
                                                        #elif "Counter Example" in status:
                                                        #    main_status="True"
                                                        else:
                                                            #print 'XXXXXXXXXX11'
                                                            #print '5-S'
                                                            print 'Strategy applied 5'
                                                            status=prove_assert_tactic8(axiom,witnessXml)
                                                            if "Successfully Proved" in status:
                                                                main_status="True"
                                                                #elif "Counter Example" in status:
                                                                #    main_status="Unknown"
                                                            else:
                                                                #print 'XXXXXXXXXX1'
                                                                #print '6-S'
                                                                print 'Strategy applied 6'
                                                                status=prove_assert_tactic_approximation(axiom,witnessXml)
                                                                #return
                                                                if "Successfully Proved" in status:
                                                                    main_status="True"
                                                                #elif "Counter Example" in status:
                                                                #   main_status = "Unknown"
                                                                else:
                                                                    #print 'XXXXXXXXXX2'
                                                                    #print '7-S'
                                                                    print 'Strategy applied 7'
                                                                    status=prove_assert_tactic9(axiom,witnessXml)
                                                                    if "Successfully Proved" in status:
                                                                        main_status="True"
                                                                    #elif "Counter Example" in status:
                                                                    #    main_status = "Unknown"
                                                                    else:
                                                                        #print 'XXXXXXXXXX3'
                                                                        #print '8-S'
                                                                        print 'Strategy applied 8'
                                                                        status=prove_assert_tactic10(axiom,witnessXml)
                                                                        if "Successfully Proved" in status:
                                                                            main_status = "True"
                                                                        else:
                                                                            #print 'XXXXXXXXXX4'
                                                                            #print '9-S'
                                                                            print 'Strategy applied 9'
                                                                            status=prove_assert_tactic11(axiom,witnessXml)
                                                                            if "Successfully Proved" in status:
                                                                                main_status="True"
                                                                            else:
                                                                                #print 'XXXXXXXXXX5'
                                                                                #print '10-S'
                                                                                print 'Strategy applied 10'
                                                                                status=prove_assert_tactic4_update2(axiom,witnessXml)
                                                                                if "Successfully Proved" in status:
                                                                                    main_status="True"
                                                                                else:
                                                                                    print 'Strategy applied 11'
                                                                                    status=prove_assert_break_handle(axiom,witnessXml)
                                                                                    
                                                                                    if "Successfully Proved" in status:
                                                                                        main_status="True"
                                                                                    else:
                                                                                        print 'Strategy applied 12'
                                                                                        status=prove_selected_failed_assert(axiom,witnessXml)
                                                                                        
                                                                                        if "Successfully Proved" in status:
                                                                                            main_status="True"
                                                                                        else:
                                                                                            print 'Strategy applied 13'
                                                                                            status = prove_assert_tactic_tempory(axiom,witnessXml)
                                                                                            
                                                                                            if "Successfully Proved" in status:
                                                                                                main_status="True"
                                                                                            else:
                                                                                                
                                                                                                status = prove_assert_tactic_tempory2(axiom,witnessXml)
                                                                                                
                                                                                                if "Successfully Proved" in status:
                                                                                                    main_status="True"
                                                                                                else:
                                                                                                    main_status="Unknown"
                                                                                    #print 'XXXXXXXXXX6'
                                                                                    #print '11-S'
                                                                                    #status=prove_assert_assertion_rearrage(axiom,witnessXml)
                                                                                    #if "Successfully Proved" in status:
                                                                                    #    main_status="True"
                                                                                    #else:
                                                                                    #    main_status="Unknown"
                                                                                        #print '12-S'
                                                                                        #status= prove_assert_tactic_conditional_rec(axiom,witnessXml)
                                                                                        #if "Successfully Proved" in status:
                                                                                        #    main_status="True"
                                                                                        #else:
                                                                                        #    main_status="Unknown"
                                                    
                                            #print "Failed to Prove"
                                    else:
                                        print 'Strategy applied A-1'
                                        status=prove_assert_abstract_array(axiom,witnessXml)
                                        #status='Failed'
                                        #return
                                        if "Successfully Proved" in status:
                                            main_status="True"
                                        else:
                                            
                                            max_axiom = getMaxLength(axiom.getOther_axioms())
                                                                                
                                            if max_axiom>4000:
                                                status='Failed to prove'
                                            else:
                                                print 'Strategy applied A-2'
                                                status=prove_assert_tactic4_update1(axiom,witnessXml)
                                                #print '1'
                                                #status=prove_assert_tactic4(axiom,witnessXml)
                                            if "Successfully Proved" in status:
                                                main_status="True"
                                            else:
                                                print 'Strategy applied A-3'
                                                status=prove_assert_tactic4_update4(axiom,witnessXml)
                                                #print '2'
                                                if "Successfully Proved" in status:
                                                    main_status="True"
                                                else:
                                                    print 'Strategy applied A-4'
                                                    status=prove_assert_tactic4_update5(axiom,witnessXml)
                                                    #print '3'
                                                    if "Successfully Proved" in status:
                                                        main_status="True"
                                                    else:
                                                        main_status= "Unknown"
                                    if main_status is "Unknown" or main_status is None:
                                        print "Unknown"
                                        return
                if main_status is "True":
                    print 'VIAP_STANDARD_OUTPUT_True'
                    if rec_program==False:
                        if property is not None:
                            if '=' in property:
                                value_names=property.split('=')
                                fd = open(value_names[1])
                                property = "".join(fd.readlines())
                        else:
                            property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
                        hashcode=sha1(program.getFilename())
                        violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+program.getFilename()+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">correctness_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+program.getFilename()+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"<node id=\"N0\">\n<data key=\"entry\">true</data>\n</node>"+"\n<edge id=\"E0\" source=\"N0\" target=\"N1\"></edge>\n"+"\n<node id=\"N1\">\n<data key=\"invariant\">1</data>\n<data key=\"invariant.scope\">main</data>\n</node>"
                        #"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"                     
                        writtingFile( "correctnessWitness.graphml" , violation_witness1+'\n'+"\n</graph>\n</graphml>\n"  )
                        writeLogFile( "j2llogs.logs" , "\ncorrectnessWitness \n"+str(violation_witness1+'\n'+"\n</graph>\n</graphml>\n" )+"\n" )

                else:
                    print "Unknown"
                
                end_time=current_milli_time()
                #print "Time Taken by Proving Process--"
                #print end_time-start_time
			
#w=['s0', ['ite', ['>', ['__VERIFIER_nondet_int2'], ['0']], ['ite', ['>', ['__VERIFIER_nondet_int3'], ['0']], ['ite', ['>=', ['__VERIFIER_nondet_int4'], ['0']], ['ite', ['and', ['!=', ['__VERIFIER_nondet_int4'], ['0']], ['>=', ['-', ['__VERIFIER_nondet_int2'], ['1']], ['__VERIFIER_nondet_int4']]], ['ite', ['>', ['__VERIFIER_nondet_int8'], ['0']], ['<=', ['0'], ['cp7', ['_N1']]], ['0']], ['0']], ['0']], ['0']], ['0']]]

def isReturnVoid(e_list,e_list_others):
    status=False
    if len(e_list)==1 and 'DUMMY' in e_list.keys()[0]:
        for x in e_list_others:
            if x[0]=='R' and e_list.keys()[0] in x[2][0]:
                status=True
                
    return status



            
def isCallByRef(e_list):
    status=False
    for e in e_list:
        if isFunCallbyRef( e )==True:
            status=True
    return status

def isRecursiveCall(e_list):
    status=False
    for e in e_list:
        if e[0]=='R':
            status=True
        #if isFunCallbyRef( e )==True:
        #    
    return status


def getParameters_rec_list(e,list_function,list_con_function):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)>0:
        if op in list_function:
            
            map_parameter={}  
            
            map_parameter[op]=args  
            
            list_con_function.append(map_parameter) 
               
        else:
            
            for x in args:
    
                getParameters_rec_list(x,list_function,list_con_function)




def prove_selected_failed_assert(axiom,witnessXml):
    
    post_condition=[]
    
    pre_condition=[]
    
    for x in axiom.getOutput_equations():
        if '_FAILED' in x:
            #print wff2string1(axiom.getOutput_equations()[x])
            
            inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
            
            map_failed_assert = {}     
                 
            prev_cond=None
            
            getAllFailedZeroValue(axiom.getOutput_equations()[x][-1],map_failed_assert,prev_cond)
            
            for e in map_failed_assert:
                
                map_fun={}
                
                map_var={}
                
                map_const={}
                
                getAllVarFun_failed(map_failed_assert[e],map_fun,map_var,map_const)
                                
                
                if len(map_fun)==0 and len(map_var)==0 and len(map_const)==0:
                    
                    map_failed_assert[e]=eval("['not',"+str(map_failed_assert[e])+"]")
                    
                    inst_other_axioms.append(wff_a(map_failed_assert[e]))
                    
                elif len(map_fun)==0 and len(map_var)==0 and len(map_const)>0:
                    
                    list_and_assert=[]
                    
                    getAllAssertAnd(map_failed_assert[e],list_and_assert)
                    
                    if len(list_and_assert)>0:
                        

                        for y in list_and_assert:
                            
                            map_fun={}
                
                            map_var={}
                
                            map_const={}
                            
                            getAllVarFun_failed(y,map_fun,map_var,map_const)
                            
                            if len(map_fun)==0 and len(map_var)==0 and len(map_const)==0:
                                
                                inst_other_axioms.append(wff_a(y))
                                
                            elif len(map_fun)==0 and len(map_var)==0 and len(map_const)>0:

                                post_condition.append(y)
                        
                    else:
                        
                        post_condition.append(map_failed_assert[e])
    
    if len(post_condition)>0:
        
        for w in axiom.getAssumes():
            if w[0]=='i1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'i1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
            elif w[0]=='c1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'c1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
            else:
                if w[0]!='i0':
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                    list_var_str=qualifier_list(var_cstr_map.keys())
                    list_cstr_str=cstr_list(var_cstr_map.values())
                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'i1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)

        status="Failed to Prove"
        
        for x in post_condition:
                #print('\nAssertion To Prove:'+x)
                temp_post_condition=[]
                temp_post_condition.append(wff2z3_update(wff_a(x))) 
                if post_condition is not None:
                    start_time=current_milli_time()
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+expr2string1(x)+"\n Strategy--Direct")
                    status=tactic1_update([],[],inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                    #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                    #print status
                    if "Successfully Proved" in status:
                        inst_other_axioms.append(wff_a(x))
                        status = "Successfully Proved"			
                    elif "Counter Example" in status:
                        return status
                    else:
                        return "Failed to Prove"
                    
        return status
    else:
        
        return "Failed to Prove"
        
    



def getAllBitWiseFunction_assert(e,map_fun_bitwise,flag):
    args=expr_args(e)
    op=expr_op(e)
    if op=='and' or op=='or':
        if len(args)==1:
            getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
        else:
            for x in args:
                getAllBitWiseFunction_assert(x,map_fun_bitwise,flag)
    elif op=='not' and len(args)==1:
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
    elif op=='implies' and len(args)==2:
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
        getAllBitWiseFunction_assert(args[1],map_fun_bitwise,flag)
    elif op=='ite':
        getAllBitWiseFunction_assert(args[1],map_fun_bitwise,flag)
        getAllBitWiseFunction_assert(args[2],map_fun_bitwise,flag)
    elif op in {'|','&','^'}:
        flag=True
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
        getAllBitWiseFunction_assert(args[1],map_fun_bitwise,flag)
    elif op in _infix_op and len(args)==2:
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
        getAllBitWiseFunction_assert(args[1],map_fun_bitwise,flag)
    elif op in _infix_op and len(args)==1:
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
    else:
        if flag==True and len(args)>0:
            map_fun_bitwise[op]=op
            for x in args:
                getAllBitWiseFunction_assert(x,map_fun_bitwise,flag)
        elif flag==True and len(args)==0:
            if is_number(op)!=True:
                map_fun_bitwise[op]=op
        elif op in map_fun_bitwise:
            flag=True
            for x in args:
                getAllBitWiseFunction_assert(x,map_fun_bitwise,flag)
        else:
            for x in args:
                getAllBitWiseFunction_assert(x,map_fun_bitwise,flag)



def getAllAssertAnd(e,list_and_assert):
        if e[:1]==['and']:
            argument=expr_args(e)
            if argument[0][:1]==['and']:
                
                getAllAssertAnd(argument[0],list_and_assert)
                
            else:
                
                list_and_assert.append(argument[0])
                
            if argument[1][:1]==['and']:
                
                getAllAssertAnd(argument[1],list_and_assert)
                
            else:
                
                list_and_assert.append(argument[1])






def getAllFailedZeroValue(e,map_failed_assert,prev_cond):
        if e[:1]==['ite']:
                argument=expr_args(e)
                
                
                if argument[0][0] in ['<=','>=','==','!=','<','>'] and len(argument[0][1])>0 and argument[0][1][0] in ['<=','>=','==','!=','<','>'] and argument[0][2] in [['0'],['1']]:
                    
                    if argument[0][2] == ['1']:
                        
                        argument[0][2]=['True']
                        
                    elif argument[0][2] == ['0']:
                        
                        argument[0][2]=['False']

                elif argument[0][0] in ['<=','>=','==','!=','<','>'] and len(argument[0][2])>0 and argument[0][2][0] in ['<=','>=','==','!=','<','>'] and argument[0][1] in [['0'],['1']]:
                    
                    if argument[0][1] == ['1']:
                        
                        argument[0][1]=['True']
                        
                    elif argument[0][1] == ['0']:
                        
                        argument[0][1]=['False']


                
                
                compl_cond = copy.deepcopy(argument[0])
                
                if compl_cond[0]=='<':
                    compl_cond[0]='>='
                elif compl_cond[0]=='<=':
                    compl_cond[0]='>'
                elif compl_cond[0]=='>=':
                    compl_cond[0]='<'
                elif compl_cond[0]=='>':
                    compl_cond[0]='<='
                elif compl_cond[0]=='==':
                    compl_cond[0]='!='
                elif compl_cond[0]=='!=':
                    compl_cond[0]='=='
                elif compl_cond[0]=='not':
                    compl_cond[0]=compl_cond[0][1]


                if argument[1]==['0']:
                    
                    if prev_cond is None:
                        
                        map_failed_assert[expr2string1(argument[0])]=argument[0]
                        
                    else:
                        
                        update_cond = eval("['and',"+str(prev_cond)+","+str(argument[0])+"]")
                        
                        map_failed_assert[expr2string1(update_cond)]=update_cond

                        
                    if argument[2][:1]==['ite']:
                        
                        
                        getAllFailedZeroValue(argument[2],map_failed_assert,prev_cond)
                        
                        

                elif argument[1]==['1']:
                    
                    if prev_cond is None:
                        
                        map_failed_assert[expr2string1(compl_cond)]=compl_cond
            
                        
                    else:
                        
                        update_cond = eval("['and',"+str(prev_cond)+","+str(compl_cond)+"]")
                        
                        map_failed_assert[expr2string1(update_cond)]=update_cond
                        
                        
                        
                    if argument[2][:1]==['ite']:
                
                        
                        getAllFailedZeroValue(argument[2],map_failed_assert,prev_cond)
                        

                elif argument[1][:1]==['ite']:
                    
                    if prev_cond is None:
                    
                        getAllFailedZeroValue(argument[1],map_failed_assert,argument[0])
                        
                    else:
                        
                        new_prev_cond =eval("['and',"+str(prev_cond)+","+str(argument[0])+"]")
                        
                        getAllFailedZeroValue(argument[1],map_failed_assert,new_prev_cond)
                    
                    if argument[2][:1]==['ite']:
                        
                        new_prev_cond_compl =eval("['and',"+str(prev_cond)+","+str(compl_cond)+"]")
                        
                        getAllFailedZeroValue(argument[2],map_failed_assert,new_prev_cond_compl)







def prove_assert_break_handle(axiom,witnessXml):
    
    break_lists=[]
    condition_list=[]
    post_condition=[]
    pre_condition=[]
    
    str_value,word=axiom.getAsserts()
    
    size_after=0
    size_before=-1
    
    for e in axiom.getOther_axioms():
        if e[0]=='i1' and 'break_' in e[3][0]:
            getBreakConditions(e[4],condition_list)
            
    if len(condition_list)>0:
        
        inst_word=copy.deepcopy(word)
        inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
        inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
        
        size_before=len(inst_other_axioms)
        
        var=None
        
        for cond in condition_list:
            for e in inst_other_axioms:
                if e[0]=='i1':
                    var=e[2]
                    result = simplify_break_condition(e[4],cond,axiom.getVfact())
                    if result is not None:
                        e[4]=result
                        
                        

        
        f,inst_output_equations,inst_other_axioms,cm,inst_word = rec_solver_tactic8(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,inst_word)

        if var is not None:
            
            list_of_equations=[]
            
            
            for e in inst_other_axioms:
                if e[0]=='i1' and 'break_' not in e[3][0]:
                    var=e[2]
                    list_of_equations.append(e)
                elif e[0]=='i0' and 'break_' not in e[2][0]:
                    list_of_equations.append(e)
            try:
            
                close_form_soln,add_axoims,left_out_eq = solve_recurrenceCall(list_of_equations,var)
            
                del_fun_list=[]
            
                for e in close_form_soln:
                
                    if e[0]=='i2':
                    
                        del_fun_list.append(e[3][0])
                    
                    
                for e in inst_other_axioms:
                
                    if e[0]=='i1' and e[3][0] in del_fun_list:
                    
                        inst_other_axioms.remove(e)
                
                    elif e[0]=='i0' and e[2][0] in del_fun_list:
                    
                        inst_other_axioms.remove(e)
                    
                for e in close_form_soln:
                
                    new_e=copy.deepcopy(e)
                
                    new_e[-1] = expr_replace(new_e[-1],eval("['"+var+"']"),eval("['"+axiom.getConst_var_map()[var]+"']"))
                    new_e[-2] = expr_replace(new_e[-2],eval("['"+var+"']"),eval("['"+axiom.getConst_var_map()[var]+"']"))
                                
                    for e1 in inst_other_axioms:
                    
                        e1[-1] = expr_replace(e1[-1],e[-2],e[-1])
                    
                        e1[-1] = expr_replace(e1[-1],new_e[-2],new_e[-1])
                        
                    for e1 in inst_output_equations:
                        
                        inst_output_equations[e1][-1] = expr_replace(inst_output_equations[e1][-1],e[-2],e[-1])
                    
                        inst_output_equations[e1][-1] = expr_replace(inst_output_equations[e1][-1],new_e[-2],new_e[-1])

                    
            
                size_after=len(inst_other_axioms)
            
                vfacts = getAllVFacts(add_axoims)
            
                inst_other_axioms =inst_other_axioms+add_axoims
            
                axiom.setVfact(axiom.getVfact()+vfacts)
            except Exception as e:
                print 'Conditional Rec Solve Failed'
                print e
            
    
        #solve_recurrenceCall(list_equations,var)
        
    
        
        post_condition.append(wff2z3_update(inst_word))
        
        
        for w in axiom.getAssumes():
            if w[0]=='i1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'i1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
            elif w[0]=='c1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'c1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
            else:
                if w[0]!='i0':
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                    list_var_str=qualifier_list(var_cstr_map.keys())
                    list_cstr_str=cstr_list(var_cstr_map.values())
                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'i1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
                        
        if size_before!=size_after:
            for x in post_condition:
                #print('\nAssertion To Prove:'+x)
                temp_post_condition=[]
                temp_post_condition.append(x)
                if post_condition is not None:
                    start_time=current_milli_time()
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                    status=tactic1_update(f,inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                    #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                    if "Successfully Proved" in status:
                        return "Successfully Proved"			
                    elif "Counter Example" in status:
                        return status
                    else:
                        return "Failed to Prove"
        else:
            
            return "Failed to Prove"
    else:
        print '-----Conditional Rec Solver ------'
        condition_Eq_list=[]
        var=None
        for e in axiom.getOther_axioms():
            if e[0]=='i1' and e[-1][:1]==['ite']:
                var=e[2]
                condition_Eq_list.append(e)
            elif e[0]=='i0':
                condition_Eq_list.append(e)
                

        if len(condition_Eq_list)==2 and var is not None:
            
            inst_word=copy.deepcopy(word)
            inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
            inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
        
            size_before=len(inst_other_axioms)

            
            try:
                
                close_form_soln,add_axoims,left_out_eq = solve_recurrenceCall(condition_Eq_list,var)
            
                del_fun_list=[]
            
                for e in close_form_soln:
                
                    if e[0]=='i2':
                    
                        del_fun_list.append(e[3][0])
                    
                    
                for e in inst_other_axioms:
                
                    if e[0]=='i1' and e[3][0] in del_fun_list:
                    
                        inst_other_axioms.remove(e)
                
                    elif e[0]=='i0' and e[2][0] in del_fun_list:
                    
                        inst_other_axioms.remove(e)
                    
                for e in close_form_soln:
                
                    new_e=copy.deepcopy(e)
                
                    new_e[-1] = expr_replace(new_e[-1],eval("['"+var+"']"),eval("['"+axiom.getConst_var_map()[var]+"']"))
                    new_e[-2] = expr_replace(new_e[-2],eval("['"+var+"']"),eval("['"+axiom.getConst_var_map()[var]+"']"))
                    
                    inst_word[-1] = expr_replace(inst_word[-1],new_e[-2],new_e[-1])
                    inst_word[-1] = expr_replace(inst_word[-1],e[-2],e[-1])

                    
                    
                                
                    for e1 in inst_other_axioms:
                    
                        e1[-1] = expr_replace(e1[-1],e[-2],e[-1])
                    
                        e1[-1] = expr_replace(e1[-1],new_e[-2],new_e[-1])
                        
                    for e1 in inst_output_equations:
                        
                        inst_output_equations[e1][-1] = expr_replace(inst_output_equations[e1][-1],e[-2],e[-1])
                    
                        inst_output_equations[e1][-1] = expr_replace(inst_output_equations[e1][-1],new_e[-2],new_e[-1])

                    
            
                size_after=len(inst_other_axioms)
            
                vfacts = getAllVFacts(add_axoims)
            
                inst_other_axioms =inst_other_axioms+add_axoims
            
                axiom.setVfact(axiom.getVfact()+vfacts)
            except Exception as e:
                print 'Conditional Rec Solve Failed'
                
                
            post_condition.append(wff2z3_update(inst_word))
        
        
            for w in axiom.getAssumes():
                if w[0]=='i1':
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                    list_var_str=qualifier_list(var_cstr_map.keys())
                    list_cstr_str=cstr_list(var_cstr_map.values())
                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                            if w[0] == 'i1':
                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                            else:
                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                            pre_condition.append(rhs)
                elif w[0]=='c1':
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                    list_var_str=qualifier_list(var_cstr_map.keys())
                    list_cstr_str=cstr_list(var_cstr_map.values())
                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                            if w[0] == 'c1':
                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                            else:
                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                            pre_condition.append(rhs)
                else:
                    if w[0]!='i0':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                            if w[0] == 'i1':
                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                            else:
                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                            pre_condition.append(rhs)
                        
            if size_before!=size_after:
                for x in post_condition:
                    #print('\nAssertion To Prove:'+x)
                    temp_post_condition=[]
                    temp_post_condition.append(x)
                    if post_condition is not None:
                        start_time=current_milli_time()
                        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                        status=tactic1_update(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                        if "Successfully Proved" in status:
                            return "Successfully Proved"			
                        elif "Counter Example" in status:
                            return status
                        else:
                            return "Failed to Prove"


            

        return "Failed to Prove"

        
        
            



def simplify_break_condition(e,cond,vfact):
        if e[:1]==['ite']:
        	temp=[]
                argument=expr_args(e)
        	for x in argument:
        		parameter=simplify_ind_condition_tactic8(x,vfact)
        		temp.append(parameter)
                temp_conl=[]
                temp_conl.append('c1')
                temp_conl.append(argument[0])
                equation_list=[]
                equation_list.append(wff2z3_update(wff_a(eval("['not',"+str(cond)+"]"))))
        	status=query2z3_cond(equation_list,wff2z3_update(temp_conl),vfact)
                #print status
        	if 'Successfully Proved' in status:
        		return argument[1]
        	else:
        		return None









def prove_assert_abstract_rec(axiom,witnessXml):
    
    map_min={}
    
    map_max={}
    
    list_function=[]
    
    map_parameter={}
    
    list_con_function=[]
    
    str_value,word=axiom.getAsserts()
    
    for e in axiom.getOther_axioms():
        
        if e[0]=='R':
                
            list_function.append(e[-2][0])
            
            args=expr_args(e[-2])
            
            parameter_list=[]
            
            for x in args:
                parameter_list=parameter_list+x
            
            e[1]=parameter_list
            
            map_parameter[e[-2][0]]=args
            
    for e in axiom.getOutput_equations():
        
        
        if '_FAILED' in e:
        
            e1 = axiom.getOutput_equations()[e]
                        
            new_cond = expr4extractCond(e1[2])
            for e_cond in new_cond:
                #print '$$$$$$$$$$$$$$$$$'
                #print e_cond
                #print '$$$$$$$$$$$$$$$$$'
                expr4extractValue(e_cond,map_max,map_min)
                getParameters_rec_list(e_cond,list_function,list_con_function)
                
                
    if len(map_min)==0 and len(map_max)>0:
        
        
        return "Failed to Prove"
    
    #print '%%%%%%%%%%%%%%%%%%%%%%%%'
    #print map_min
    #print map_max
    #print '%%%%%%%%%%%%%%%%%%%%%%%%'
    
    if len(map_min)>0 and len(map_max)==0:
    
        for x in map_min:
            
            axiom.getOther_axioms().append(wff_a(eval("['>',['"+x+"'],['0']]")))
            
            abs_value=map_min[x]
            
            while abs_value>10:
                
                abs_value=int(abs_value/10)
            
            axiom.getOther_axioms().append(wff_a(eval("['<=',['"+x+"'],['"+str(abs_value)+"']]")))
            
    elif len(map_min)>0 and len(map_max)>0:
        
        for x in map_min:
            
            print x
            
            axiom.getOther_axioms().append(wff_a(eval("['>=',['"+x+"'],['"+str(map_min[x])+"']]")))
            
            if x in map_max:
                
                abs_value= map_max[x] 
                
                while abs_value>map_min[x]+10:
                
                    abs_value=int(abs_value/10)
                
                axiom.getOther_axioms().append(wff_a(eval("['<=',['"+x+"'],['"+str(abs_value)+"']]")))
                
    
    else:
        
        for map_parameter in list_con_function:  
              
            for x in map_parameter:
            
                for args in map_parameter[x]:
                                
                    for arg in args:
            
                        axiom.getOther_axioms().append(wff_a(eval("['<=',['"+str(arg)+"'],['10']]")))
            
    
    post_condition=[]
    pre_condition=[]
    post_condition.append(wff2z3_update(word))
                        
                        
    for w in axiom.getAssumes():
        if w[0]=='i1':
            var_cstr_map={}
            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                if list_var_str is not None and list_cstr_str is not None:
                    if w[0] == 'i1':
                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                    else:
                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                else:
                    pre_condition.append(rhs)
            elif w[0]=='c1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'c1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
                else:
                    if w[0]!='i0':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                            if list_var_str is not None and list_cstr_str is not None:
                                if w[0] == 'i1':
                                    pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                else:
                                    pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                            else:
                                pre_condition.append(rhs)
    for x in post_condition:
        #print('\nAssertion To Prove:'+x)
        temp_post_condition=[]
        temp_post_condition.append(x)
        if post_condition is not None:
            start_time=current_milli_time()
            writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
            status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
            #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
            #print status
            if "Successfully Proved" in status:
                return status
            elif "Counter Example" in status:
                return status
            else:
                return "Failed to Prove"

    



def getAllBitWiseFunction(e,map_fun_bitwise,flag):
    args=expr_args(e)
    op=expr_op(e)
    if op=='and' or op=='or':
        if len(args)==1:
            getAllBitWiseFunction(args[0],map_fun_bitwise,flag)
        else:
            for x in args:
                getAllBitWiseFunction(x,map_fun_bitwise,flag)
    elif op=='not' and len(args)==1:
        getAllBitWiseFunction(args[0],map_fun_bitwise,flag)
    elif op=='implies' and len(args)==2:
        getAllBitWiseFunction(args[0],map_fun_bitwise,flag)
        getAllBitWiseFunction(args[1],map_fun_bitwise,flag)
    elif op=='ite':
        getAllBitWiseFunction(args[1],map_fun_bitwise,flag)
        getAllBitWiseFunction(args[2],map_fun_bitwise,flag)
    elif op in {'|','&','^'}:
        flag=True
        getAllBitWiseFunction(args[0],map_fun_bitwise,flag)
        getAllBitWiseFunction(args[1],map_fun_bitwise,flag)
    elif op in _infix_op:
        
        getAllBitWiseFunction(args[0],map_fun_bitwise,flag)
        getAllBitWiseFunction(args[1],map_fun_bitwise,flag)
    else:

        if flag==True and len(args)>0:
            map_fun_bitwise[op]=op
            for x in args:
                getAllBitWiseFunction(x,map_fun_bitwise,flag)
        #elif flag==True and len(args)==0:
        #    if is_number(op)!=True:
        #        map_fun_bitwise[op]=op
        elif op in map_fun_bitwise:
            flag=True
            for x in args:
                getAllBitWiseFunction(x,map_fun_bitwise,flag)
        else:
            for x in args:
                getAllBitWiseFunction(x,map_fun_bitwise,flag)





def getAllBitWiseFunction_assert(e,map_fun_bitwise,flag):
    args=expr_args(e)
    op=expr_op(e)
    if op=='and' or op=='or':
        if len(args)==1:
            getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
        else:
            for x in args:
                getAllBitWiseFunction_assert(x,map_fun_bitwise,flag)
    elif op=='not' and len(args)==1:
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
    elif op=='implies' and len(args)==2:
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
        getAllBitWiseFunction_assert(args[1],map_fun_bitwise,flag)
    elif op=='ite':
        getAllBitWiseFunction_assert(args[1],map_fun_bitwise,flag)
        getAllBitWiseFunction_assert(args[2],map_fun_bitwise,flag)
    elif op in {'|','&','^'}:
        flag=True
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
        getAllBitWiseFunction_assert(args[1],map_fun_bitwise,flag)
    elif op in _infix_op and len(args)==2:
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
        getAllBitWiseFunction_assert(args[1],map_fun_bitwise,flag)
    elif op in _infix_op and len(args)==1:
        getAllBitWiseFunction_assert(args[0],map_fun_bitwise,flag)
    else:
        if flag==True and len(args)>0:
            map_fun_bitwise[op]=op
            for x in args:
                getAllBitWiseFunction_assert(x,map_fun_bitwise,flag)
        elif flag==True and len(args)==0:
            if is_number(op)!=True:
                map_fun_bitwise[op]=op
        elif op in map_fun_bitwise:
            flag=True
            for x in args:
                getAllBitWiseFunction_assert(x,map_fun_bitwise,flag)
        else:
            for x in args:
                getAllBitWiseFunction_assert(x,map_fun_bitwise,flag)







def prove_assert_CallByRef(axiom,witnessXml):
    
        solution_map={}
        abstract_map={}
        abstract_nondet_map={}
        smallest_list=[]
        or_operator=eval("['|']")
        and_operator=eval("['&']")
        xor_operator=eval("['^']")
        map_fun_bitwise={}
        non_deter={}
        
        
        str_value,word=axiom.getAsserts()
        
    
        
        for x in axiom.getOther_axioms():
            
            if x[0] == 'i1':
                
                if expr_find(x[-1],or_operator)==True or expr_find(x[-1],and_operator)==True or expr_find(x[-1],xor_operator)==True:
                    
                    getAllBitWiseFunction(x[-1],map_fun_bitwise,False)
                
        if len(map_fun_bitwise)>0:
            

            
            for e in axiom.getOutput_equations():
                
            
                x=expr2string1(axiom.getOutput_equations()[e][-1])
            
                temp_list =  map_fun_bitwise.keys()
                
                for y in temp_list:
                    
                    final_e=e+'1'
                    
                    if y in x and e not in map_fun_bitwise and '_FAILED' not in e:
                    
                        
                        init_e=e
                        map_fun_bitwise[final_e]=final_e
                        map_fun_bitwise[init_e]=init_e
                        
                    elif y in x and final_e not in map_fun_bitwise and '_FAILED' not in e:
                        
                        map_fun_bitwise[final_e]=final_e

                        
            for x in axiom.getOther_axioms():
            
                if x[0] == 'i1':
                    
                    if x[-2][0] in map_fun_bitwise:
                        
                        getAllBitWiseFunction(x[-1],map_fun_bitwise,True)
                    


            
            
            if expr_find(x[-1],or_operator)==True or expr_find(x[-1],and_operator)==True or expr_find(x[-1],xor_operator)==True:
                
                getAllBitWiseFunction(x[-1],map_fun_bitwise,False)



    
        for x in axiom.getOther_axioms():
            if x[0] == 's1':
                smallest_list.append(x[-1][1][2])
                if x[-1][2][0] == '<=' or x[-1][2][0] == '>=':
                    x_new = copy.deepcopy(x[-1][2])
                    x_new = expr_replace(x_new, x[-1][1][1], eval("['-'," + str(x[-1][1][2]) + ",['1']]"))
                    x_new[0]='-'                    
                    solve_equ = expr2string1(expr_replace(x_new, x[-1][1][2], eval("['_x']")))
                    solution = solve(simplify(solve_equ), simplify("_x"))
                    if len(solution)==1:
                        
                        if is_number(str(solution[0]))==True:
                            abs_value=solution[0]
                            while abs_value>10:
                                abs_value=int(abs_value/10)
                                
                            if len(map_fun_bitwise)>0:
                                abs_value=int((abs_value+2)/4)
                                
                            fun_call_map={}
                            parser = c_parser.CParser()
                            ast = parser.parse("void test(){"+str(abs_value)+";}")
                            statement_temp=ast.ext[0].body.block_items[0]
                            abstract_value=eval(expressionCreator_C( statement_temp))
                            abstract_map[expr2string1(x[-1][1][2])]=abstract_value
                        else:
                            
                            if '__VERIFIER_nondet' in str(solution[0]):
                                
                                if len(map_fun_bitwise)>0:
                                    abstract_nondet_map[solution[0]]=eval("['2']")
                                else:
                                    
                                    
                                    
                                    abstract_nondet_map[solution[0]]=eval("['10']")
                                
                        fun_call_map={}
                        parser = c_parser.CParser()
                        ast = parser.parse("void test(){"+str(solution[0])+";}")
                        statement_temp=ast.ext[0].body.block_items[0]
                        constant=eval(expressionCreator_C(statement_temp))
                        solution_map[expr2string1(x[-1][1][2])]=constant
                elif x[-1][2][0] == '<' or x[-1][2][0] == '>':
                    x_new = copy.deepcopy(x[-1][2])
                    x_new = expr_replace(x_new, x[-1][1][1], x[-1][1][2])
                    x_new[0]='-'
                    solve_equ = expr2string1(expr_replace(x_new, x[-1][1][2], eval("['_x']")))
                    solution = solve(simplify(solve_equ), simplify("_x"))
                    if len(solution)==1:
                        
                        if is_number(str(solution[0]))==True:
                            abs_value=solution[0]
                            while abs_value>10:
                                abs_value=int(abs_value/10)
                                
                            if len(map_fun_bitwise)>0:
                                abs_value=int((abs_value+2)/4)

                            fun_call_map={}
                            parser = c_parser.CParser()
                            ast = parser.parse("void test(){"+str(abs_value)+";}")
                            statement_temp=ast.ext[0].body.block_items[0]
                            abstract_value=eval(expressionCreator_C( statement_temp))
                            abstract_map[expr2string1(x[-1][1][2])]=abstract_value

                        else:
                            if '__VERIFIER_nondet' in str(solution[0]):
                                if len(map_fun_bitwise)>0:
                                    abstract_nondet_map[solution[0]]=eval("['2']")
                                else:
                                    abstract_nondet_map[solution[0]]=eval("['10']")

                        
                        
                        fun_call_map={}
                        parser = c_parser.CParser()
                        ast = parser.parse("void test(){"+str(solution[0])+";}")
                        statement_temp=ast.ext[0].body.block_items[0]
                        constant=eval(expressionCreator_C(statement_temp))
                        solution_map[expr2string1(x[-1][1][2])]=constant


        if len(solution_map)==len(smallest_list):
            
            inst_other_axioms=[]
            
            inst_output_equations={}
            
            sub_flag_div=False
            
            for x in axiom.getOther_axioms():
                if x[0]=='i1' and 'f2_' in x[3][0]:    
                    if len(x[4])>=3 and len(x[4][1])>=3 and len(x[4][1][2])>=3 and x[4][1][2][0]=='/':
                        sub_flag_div=True
            
            if sub_flag_div==True:
                
                for x in abstract_map:
                    
                    if is_number(str(abstract_map[x][0]))==True and 2>=int(abstract_map[x][0]):
                        abstract_map[x][0]=str(int(abstract_map[x][0])+3)

            
            
            for x in axiom.getOutput_equations():
                
                new_eq=copy.deepcopy(axiom.getOutput_equations()[x])
                                
                for bigN in smallest_list:
                    
                    strbigN=expr2string1(bigN)
                    
                    if strbigN in solution_map:
                        
                        new_eq[-1] = expr_replace(new_eq[-1], solution_map[strbigN], bigN)
                        
                inst_output_equations[x]=new_eq
                
            for x in axiom.getOther_axioms():
                
                if x[0] != 's1' and x[0] != 's0':
                    
                    new_eq=copy.deepcopy(x)
                                
                    for bigN in smallest_list:
                    
                        strbigN=expr2string1(bigN)
                    
                        if strbigN in solution_map:
                        
                            new_eq[-1] = expr_replace(new_eq[-1], solution_map[strbigN], bigN)
                        
                    inst_other_axioms.append(new_eq)

            if len(abstract_map)>0:
                
                for bigN in smallest_list:
                    
                    strbigN=expr2string1(bigN)
                    
                    if strbigN in abstract_map:
                    
                        inst_other_axioms.append(wff_a(eval("['==',"+str(bigN)+","+str(abstract_map[strbigN])+"]")))
            else:
                
                for bigN in smallest_list:
                    
                    strbigN=expr2string1(bigN)
                    
                    if strbigN in solution_map:
                    
                        inst_other_axioms.append(wff_a(eval("['==',"+str(bigN)+","+str(solution_map[strbigN])+"]")))
                        
                non_deter_filter=[]
                
                for non_det in abstract_nondet_map:
                    
                    add_flag=False
                    
                    for z in non_deter_filter:
                        
                        if z in str(non_det) or str(non_det) in z:
                            
                            add_flag=True
                            
                        
                    if add_flag==False:
                        ##inst_other_axioms.append(wff_a(eval("['==',['"+str(non_det)+"'],"+str(solution_map[strbigN])+"]")))
                        inst_other_axioms.append(wff_a(eval("['==',['"+str(non_det)+"'],"+str(abstract_nondet_map[non_det])+"]")))
                        
                        non_deter_filter.append(str(non_det))



                    
            post_condition=[]
            pre_condition=[]
            post_condition.append(wff2z3_update(word))
                        
                        
            for w in axiom.getAssumes():
                if w[0]=='i1':
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                    list_var_str=qualifier_list(var_cstr_map.keys())
                    list_cstr_str=cstr_list(var_cstr_map.values())
                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                            if w[0] == 'i1':
                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                            else:
                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                            pre_condition.append(rhs)
                    elif w[0]=='c1':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                            if list_var_str is not None and list_cstr_str is not None:
                                if w[0] == 'c1':
                                    pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                else:
                                    pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                            else:
                                pre_condition.append(rhs)
                        else:
                            if w[0]!='i0':
                                var_cstr_map={}
                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                list_var_str=qualifier_list(var_cstr_map.keys())
                                list_cstr_str=cstr_list(var_cstr_map.values())
                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                    if list_var_str is not None and list_cstr_str is not None:
                                        if w[0] == 'i1':
                                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                        else:
                                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                    else:
                                        pre_condition.append(rhs)
			
            for x in post_condition:
                #print('\nAssertion To Prove:'+x)
                temp_post_condition=[]
                temp_post_condition.append(x)
                if post_condition is not None:
                    start_time=current_milli_time()
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                    if len(map_fun_bitwise)>0:
                        status=tactic1_update_bitwise(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),map_fun_bitwise,witnessXml)
                    else:
                        status=tactic1_update(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                    #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                    #print status
                    if "Successfully Proved" in status:
                        return status
                    elif "Counter Example" in status:
                        return status
                    else:
                        return "Failed to Prove"
                    

def isSummationOfNonDeter(e1,e2):
    args=expr_args(e1)
    op=expr_op(e1)
    if op in {'+','-'}:
        if e2==args[0]:
            if isArrayFunction( args[1][0] )==True:
                return True
        if e2==args[1]:
            if isArrayFunction( args[0][0] )==True:
                return True

    return False
    
    
    

                    
                    
def prove_assert_abstract_summation(axiom,witnessXml):
    
        solution_map={}
        abstract_map={}
        abstract_nondet_map={}
        smallest_list=[]
        non_deter={}
        map_fun_bitwise={}
        counter=0
        
        
        str_value,word=axiom.getAsserts()
        
    
        
        for x in axiom.getOther_axioms():
            
            if x[0] == 'i1':
                left_x=copy.deepcopy(x[-2])
                left_x = expr_replace(left_x,eval("['+',['"+x[-3]+"'],['1']]"),eval("['"+x[-3]+"']"))
                if isSummationOfNonDeter(x[-1],left_x)==True:
                    counter=counter+1
                
                
        if counter==0:
            return "Failed to prove"

        for x in axiom.getOther_axioms():
            if x[0] == 's1':
                smallest_list.append(x[-1][1][2])
                if x[-1][2][0] == '<=' or x[-1][2][0] == '>=':
                    x_new = copy.deepcopy(x[-1][2])
                    x_new = expr_replace(x_new, x[-1][1][1], eval("['-'," + str(x[-1][1][2]) + ",['1']]"))
                    x_new[0]='-'                    
                    solve_equ = expr2string1(expr_replace(x_new, x[-1][1][2], eval("['_x']")))
                    solution = solve(simplify(solve_equ), simplify("_x"))
                    if len(solution)==1:
                        fun_call_map={}
                        parser = c_parser.CParser()
                        ast = parser.parse("void test(){"+str(solution[0])+";}")
                        statement_temp=ast.ext[0].body.block_items[0]
                        constant=eval(expressionCreator_C(statement_temp))
                        solution_map[expr2string1(x[-1][1][2])]=constant
                elif x[-1][2][0] == '<' or x[-1][2][0] == '>':
                    x_new = copy.deepcopy(x[-1][2])
                    x_new = expr_replace(x_new, x[-1][1][1], x[-1][1][2])
                    x_new[0]='-'
                    solve_equ = expr2string1(expr_replace(x_new, x[-1][1][2], eval("['_x']")))
                    solution = solve(simplify(solve_equ), simplify("_x"))
                    if len(solution)==1:
                        fun_call_map={}
                        parser = c_parser.CParser()
                        ast = parser.parse("void test(){"+str(solution[0])+";}")
                        statement_temp=ast.ext[0].body.block_items[0]
                        constant=eval(expressionCreator_C(statement_temp))
                        solution_map[expr2string1(x[-1][1][2])]=constant

        if len(solution_map)==len(smallest_list)==counter+1 or len(solution_map)==len(smallest_list)==counter:
            
            for x in solution_map:
                
                non_deter[expr2string1(solution_map[x])]=solution_map[x]
                
            if len(non_deter)==1:
                
                
                if '__VERIFIER_nondet' in str(non_deter.keys()[0]):
                    
                    inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
                
                    inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
                    
                    inst_other_axioms.append(wff_a(eval("['==',['"+non_deter.keys()[0]+"'],['10']]")))
                    
                    post_condition=[]
                    pre_condition=[]
                    post_condition.append(wff2z3_update(word))
                        
                        
                    for w in axiom.getAssumes():
                        if w[0]=='i1':
                            var_cstr_map={}
                            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                            list_var_str=qualifier_list(var_cstr_map.keys())
                            list_cstr_str=cstr_list(var_cstr_map.values())
                            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                if list_var_str is not None and list_cstr_str is not None:
                                    if w[0] == 'i1':
                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                    else:
                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                else:
                                    pre_condition.append(rhs)
                            elif w[0]=='c1':
                                var_cstr_map={}
                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                list_var_str=qualifier_list(var_cstr_map.keys())
                                list_cstr_str=cstr_list(var_cstr_map.values())
                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                    if list_var_str is not None and list_cstr_str is not None:
                                        if w[0] == 'c1':
                                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                        else:
                                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                    else:
                                        pre_condition.append(rhs)
                                else:
                                    if w[0]!='i0':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                            if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'i1':
                                                    pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                    pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                            else:
                                                pre_condition.append(rhs)
                                                
                    for x in post_condition:
                        #print('\nAssertion To Prove:'+x)
                        temp_post_condition=[]
                        temp_post_condition.append(x)
                        if post_condition is not None:
                            start_time=current_milli_time()
                            writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                            status=tactic1_update(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                            #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                            #print status
                            if "Successfully Proved" in status:
                                return status
                            elif "Counter Example" in status:
                                return status
                            else:
                                return "Failed to Prove"
                else:
                    return "Failed to prove"
                    
            
            else:
                
                return "Failed to prove"
                    
        else:
            
            return "Failed to prove"
                        

    




def prove_assert_abstract_array(axiom,witnessXml):
    
        solution_map={}
        abstract_map={}
        abstract_nondet_map={}
        array_size_list={}
        non_deter={}
        index_var_map={}
        counter=0
        
        
        str_value,word=axiom.getAsserts()
        
        for v in axiom.getVariables():
            
            dimesnsion=axiom.getVariables()[v].getDimensions()
            
            if dimesnsion is not None and '_PROVE' not in v:
                
                for x in dimesnsion:
                    
                    array_size_list[x]=dimesnsion[x]
                


        
    
        
        for e in axiom.getOther_axioms():
            
            if e[0]=='i0' and isArrayFunction(e[-2][0]):
                
                getIndexVaribles(e[-1],index_var_map)
                            
                
            elif e[0]=='i1' and isArrayFunction(e[-2][0]):
                                
                getIndexVaribles(e[-1],index_var_map)
                
                
                
        if len(index_var_map)>0:
            
            return "Failed to prove"
        
    

        if len(array_size_list)>0:
            
            inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
                
            inst_output_equations=copy.deepcopy(axiom.getOutput_equations())

            
            for x in array_size_list:
                
                if is_number(str(array_size_list[x]))==True:
                    
                    abs_value=int(array_size_list[x])
                    
                    
                    
                    while abs_value>10:
                        
                        abs_value=int(abs_value/10)
                        
                    abs_value=int(abs_value/2)
                        
                    for e in inst_other_axioms:
                        
                        e[-1]=expr_replace(e[-1],eval("['"+str(array_size_list[x])+"']"),eval("['"+str(abs_value)+"']"))
                        
                    for e in inst_output_equations:
                        
                        e1=inst_output_equations[e]
                        
                        e1[-1]=expr_replace(e1[-1],eval("['"+str(array_size_list[x])+"']"),eval("['"+str(abs_value)+"']"))
                        
                else:
                    
                    
                    fun_call_map={}
                    
                    parser = c_parser.CParser()
                    
                    ast = parser.parse("void test(){"+str(array_size_list[x])+";}")
                    
                    statement_temp=ast.ext[0].body.block_items[0]
                    
                    constant=eval(expressionCreator_C(statement_temp))
                    
                    flag=False
                    
                    for e in inst_output_equations:
                        
                        e1=inst_output_equations[e]
                        
                        if e1[-2]==constant:
                            
                            if is_number(expr2string1(e1[-1]))==True:
                                
                                flag=True
                                
                                for e in inst_other_axioms:
                                    
                                    e[-1]=expr_replace(e[-1],e1[-1],eval("['8']"))
                                    
                                for e in inst_output_equations:
                                    
                                    e1=inst_output_equations[e]
                                    
                                    e1[-1]=expr_replace(e1[-1],e1[-1],eval("['8']"))
                        
                            
                    if flag==False:
                        
                        inst_other_axioms.append(wff_a(eval("['==',"+str(constant)+",['8']]")))
                    
                    #for e in inst_other_axioms:
                        
                    #    e[-1]=expr_replace(e[-1],constant,eval("['10']"))
                        
                    #for e in inst_output_equations:
                        
                    #    e1=inst_output_equations[e]
                        
                    #    e1[-1]=expr_replace(e1[-1],constant,eval("['10']"))
                        
                        
            post_condition=[]
            pre_condition=[]
            
            #print '----------------'
            #print word
            #print '----------------'
            post_condition.append(wff2z3_update1(word,axiom.getConst_var_map()))

                        
                        
            for w in axiom.getAssumes():
                if w[0]=='i1':
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                    list_var_str=qualifier_list(var_cstr_map.keys())
                    list_cstr_str=cstr_list(var_cstr_map.values())
                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                            if w[0] == 'i1':
                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                            else:
                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                            pre_condition.append(rhs)
                    elif w[0]=='c1':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                            if list_var_str is not None and list_cstr_str is not None:
                                if w[0] == 'c1':
                                    pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                else:
                                    pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                            else:
                                pre_condition.append(rhs)
                        else:
                            if w[0]!='i0':
                                var_cstr_map={}
                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                list_var_str=qualifier_list(var_cstr_map.keys())
                                list_cstr_str=cstr_list(var_cstr_map.values())
                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                    if list_var_str is not None and list_cstr_str is not None:
                                        if w[0] == 'i1':
                                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                        else:
                                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                    else:
                                        pre_condition.append(rhs)
			
            for x in post_condition:
                #print('\nAssertion To Prove:'+x)
                temp_post_condition=[]
                temp_post_condition.append(x)
                if post_condition is not None:
                    start_time=current_milli_time()
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                    #status=tactic1_update_array_abstract(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                    status=tactic1_update(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                    #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                    print status
                    if "Successfully Proved" in status:
                        return status
                    elif "Counter Example" in status:
                        return status
                    else:
                        return "Failed to Prove"
        else:
            return "Failed to Prove"

                    
                

    
    
    






def prove_auto_loop_bound(program,property,program_analysis,program_analysis_decl):
        start_time=current_milli_time()
	if program is None:
		print "Something is Wrong"
		return
	if program is not None:
		#print '\n----Proving Process----\n'
		for name in program.getAxiomeMap():
                    
                    axiom=program.getAxiomeMap()[name]
                    
                    witnessXml=program.getWitnessXmlMap()[name]
                    
                    smallest_result = update_bound_smallest(axiom,witnessXml)
                    
                    
                    for e in smallest_result:
                        #axiom.setFrame_axioms(solnsubstitution(axiom.getFrame_axioms(),e[0],e[1]))
                        #axiom.setOutput_equations(solnsubstitution(axiom.getOutput_equations(),e[0],e[1]))
                        axiom.setOther_axioms(solnsubstitution(axiom.getOther_axioms(),e[0],e[1]))
                        o = axiom.getOutput_equations()
                        for x in o:
                            o[x][2]=expr_replace(o[x][2],e[0],e[1])
                    f,o,a,cm = rec_solver(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms())
                    
                    axiom.setFrame_axioms(f)
                    
                    axiom.setOutput_equations(o)
                    
                    axiom.setOther_axioms(a)
                    
                    output_axioms_fn(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms())



# Rearrage expression
def changeToPower(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return e
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return e[:1]+list(changeToPower(args[0]))
            else:
                return e[:1]+list(changeToPower(x) for x in expr_args(e))
        elif op=='not' and len(args)==1:
            return e[:1]+list(changeToPower(args[0]))
        elif op=='implies' and len(args)==2:
            return e[:1]+[changeToPower(args[0])]+[changeToPower(args[1])]
        elif op == '**' and len(args)==2:
            return ['power']+list(changeToPower(x) for x in expr_args(e))
        elif op in _infix_op and len(args)==2:
            return e[:1]+list(changeToPower(x) for x in expr_args(e))
        else:
            return e[:1]+list(changeToPower(x) for x in expr_args(e))






def prove_assert_tactic_tempory2(axiom,witnessXml):
    isPower=False
    if axiom is not None:
        for x in axiom.getOther_axioms():
            x[-1] = changeToPower(x[-1])
            if 'power' in expr2string1(x[-1]):
                isPower=True
        for x in axiom.getOutput_equations():
            e = axiom.getOutput_equations()[x]
            e[-1] = changeToPower(e[-1])
            if 'power' in expr2string1(e[-1]):
                isPower=True
        if isPower==True:
            status=prove_assert_tactic1_power(axiom,witnessXml)
            if "Successfully Proved" in status:
                return "Successfully Proved"
            else:
                status=prove_assert_tactic2_power(axiom,witnessXml)
                if "Successfully Proved" in status:
                    return "Successfully Proved"
                else:
                    status = prove_assert_tactic_tempory(axiom,witnessXml)
                    if "Successfully Proved" in status:
                        return "Successfully Proved"
                    else:
                        return "Failed to prove"
        else:
            return "Failed to prove"

















def prove_assert_tactic_tempory(axiom,witnessXml):
    var_map={}
    additional_axioms=[]
    if axiom is not None:
        for x in axiom.getOther_axioms():
            expr2string_non_det(x[-1],var_map)

        for x in var_map:
            new_stmt =eval("['==',"+str(var_map[x])+",'5']")
            additional_axioms.append(wff_a(new_stmt))
            
        
        pre_condition=[]
                
	post_condition=[]
	
	str_value,word=axiom.getAsserts()

	#post_condition.append(str_value)
        post_condition.append(wff2z3_update1(word,axiom.getConst_var_map()))

			
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
			
	if len(pre_condition)==0:
            for x in additional_axioms:
                pre_condition.append(wff2z3_update(x))
        else:
            temp_constraint_list=[]
            for x in additional_axioms:
                temp_constraint_list.append(wff2z3_update(x))
            status=query2z3_update(temp_constraint_list,None,axiom.getVfact(),witnessXml)
            if "Successfully Proved" not in status:
                for x in additional_axioms:
                    pre_condition.append(wff2z3_update(x))


    
	for x in post_condition:
		#print('\nAssertion To Prove:'+x)
		temp_post_condition=[]
		temp_post_condition.append(x)
		if post_condition is not None:
			start_time=current_milli_time()
                        #print '----------------@@@@@@@@@'
                        #for xx in axiom.getOther_axioms():
                        #    print wff2string1(xx)
                        #print '---------------------'
                        #print axiom.getFrame_axioms()
                        #for xx in axiom.getFrame_axioms():
                        #    print wff2string1(axiom.getFrame_axioms()[xx])
                        #print '---------------------'
                        #print axiom.getOutput_equations()
                        #for xx in axiom.getOutput_equations():
                        #    print wff2string1(axiom.getOutput_equations()[xx])
                        #print '---------------------'
                        #print axiom.getConstraints()
                        #print '----------------@@@@@@@@@'
			writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
			status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
			#status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
			if "Successfully Proved" in status:
				return "Successfully Proved"			
			elif "Counter Example" in status:
				return status
			else:
				return "Failed to Prove"
	return "Nothing To Prove"

            




def expr2string_non_det(e,var_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
    	if op not in var_map.keys() and is_number(op)==False and is_hex(op)==None and op not in _base:
            if '__VERIFIER_nondet_int' in op:
                var_map[op]=e
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                expr2string_non_det(args[0],var_map)
            else:
                for x in args:
                    expr2string_non_det(x,var_map)
        elif op=='not' and len(args)==1:
            expr2string_non_det(args[0],var_map)
        elif op=='implies' and len(args)==2:
            expr2string_non_det(args[0],var_map)
            expr2string_non_det(args[1],var_map)
        elif op in _infix_op and len(args)==2:
            expr2string_non_det(args[0],var_map)
            expr2string_non_det(args[1],var_map)
        else:
            if '__VERIFIER_nondet_int' in op:
                var_map[op]=e
            else:
                for x in args:
                    expr2string_non_det(x,var_map)





def simplifyPostCondition(e):
        if e[:1]==['ite']:
        	count=0
                condition=None
                ifexpression=None
                elseexpression=None
                main_expression=None
        	for x in expr_args(e):
        		parameter=simplifyPostCondition(x)
        		if count==0:
        			condition=parameter
        		elif count==1:
        			ifexpression=parameter
        		elif count==2:
                            elseexpression=parameter
                            if '>' not in parameter and '<' not in parameter and '=' not in parameter:
                                temp_exp=[]
                                temp_exp.append('implies')
                                temp_exp.append(condition)
                                temp_exp.append(ifexpression)
                                main_expression=temp_exp
                            else:
                                main_expression=['ite']+condition+ifexpression+elseexpression
                        count=count+1
        	if main_expression is not None:
        		return main_expression
        	else:
        		return e
        elif e[:1]==['<='] or e[:1]==['<'] or e[:1]==['>='] or e[:1]==['>'] or e[:1]==['=='] or e[:1]==['!=']:
                return e[:1]+list(x for x in expr_args(e))
        else:
        	return e[:1]+list(simplifyPostCondition(x) for x in expr_args(e))


def prove_assert_tactic_approximation(axiom,witnessXml):
    
	pre_condition=[]
	post_condition=[]
        condition_map={}
        break_condition_map={}
        #compl_break_condition_map={}
	main_status=None
	str_value,word=axiom.getAsserts()        
        get_conditions_approximate(word[-1],condition_map)
        
        
        for x in axiom.getOther_axioms():
            if x[0]=='i1':
                if 'break_' in x[-2][0]:
                    get_conditions_approximate(x[-1],break_condition_map)
                    #expr_complement()
        
        for x in axiom.getOther_axioms():
            if x[0]=='i1' and len(x[4])>1:
                get_conditions_approximate(x[4],condition_map)
            elif x[0]=='i0' and len(x[3])>1:
                x[3]=simplifyAxioms(x[3])
                get_conditions_approximate(x[3],condition_map)
                
        if len(break_condition_map)>0:
            for x in break_condition_map:
                del condition_map[x]
                
        
        if len(condition_map.keys())>0:
            
            if isElseInductive(axiom.getOther_axioms())==True:
                condition_map[None]=None
            
            for condition in condition_map:
                                
                map_max={}
                
                map_min={}
                
                main_max_min_map=None
                
                if condition is not None:
                    
                    expr4extractValueAxoim(condition_map[condition],map_max,map_min)
                    
                    main_max_min_map=merge_two_dicts(map_max,map_min)
                    
                #print '^^^^^^^^^^^^^^^^^^^^^^'
                #print isSubstNonDeterValue(axiom.getOther_axioms())
                #print map_max
                #print map_min
                #print '^^^^^^^^^^^^^^^^^^^^^^'
                if (len(map_max)>0 or len(map_min)>0) and isSubstNonDeterValue(axiom.getOther_axioms())==True:

                    for x in map_min:
            
                        inst_word=copy.deepcopy(word)
                
                        inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
                
                        inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
                                                
                        var_axm=None
                        
                        for e in inst_other_axioms:
                            
                            if e[0]=='i1':
                                var_axm=e[2]
                                
                            if var_axm is not None:
                                
                                non_det_fun = eval("['"+x+"',['"+var_axm+"']]")
                                
                                non_value = eval("['"+str(map_min[x])+"']")
                                
                                e[-1]=expr_replace(e[-1],non_det_fun,non_value)
                            
        
                        if condition is not None:
        
                            for w in inst_output_equations:
                                    x=inst_output_equations[w]
                                    x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                                    x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                    
                            for x in inst_other_axioms:
                                if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                    x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                                    x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                    
                        else:
        
                            for w in inst_output_equations:
                                    x=inst_output_equations[w]
                                    result = simplify_ind_condition_else(x[-1])
                                    if result is not None:
                                        x[-1] = result
                    
                            for x in inst_other_axioms:
                                if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                    result = simplify_ind_condition_else(x[-1])
                                    if result is not None:
                                        x[-1] = result


                        
                        small_macro_eq = update_assertion1(axiom,witnessXml,inst_other_axioms,inst_output_equations)
                        #print '@@@@@@@@@@@@@@@@@@@1'
                
                        if len(small_macro_eq)>0:
                            for y in small_macro_eq:
                                for x in inst_other_axioms:
                                    if x[0]=='i1':
                                        x[-1]=expr_replace(x[-1],y[1],y[0])
                
                        f,inst_output_equations,inst_other_axioms,cm,inst_word = rec_solver_tactic8(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,inst_word)
                        #print '@@@@@@@@@@@@@@@@@@@2'
                        post_condition=[]
                        post_condition.append(wff2z3_update1(inst_word,axiom.getConst_var_map()))
                        
                        
                        for w in axiom.getAssumes():
                                if w[0]=='i1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'i1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                elif w[0]=='c1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'c1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                else:
                                        if w[0]!='i0':
                                                var_cstr_map={}
                                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                                list_var_str=qualifier_list(var_cstr_map.keys())
                                                list_cstr_str=cstr_list(var_cstr_map.values())
                                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                                if list_var_str is not None and list_cstr_str is not None:
                                                        if w[0] == 'i1':
                                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                        else:
                                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                                else:
                                                        pre_condition.append(rhs)
			
                        for x in post_condition:
                                #print('\nAssertion To Prove:'+x)
                                temp_post_condition=[]
                                temp_post_condition.append(x)
                                if post_condition is not None:
                                        start_time=current_milli_time()
                                        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                                        status=tactic1_update(f,inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                                        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                                        if "Successfully Proved" in status:
                                            if main_status is None:
                                                main_status=True			
                                        elif "Counter Example" in status:
                                                return status
                                        else:
                                                return "Failed to Prove"




                    
                    for x in map_max:
            
                        inst_word=copy.deepcopy(word)
                
                        inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
                
                        inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
                                                
                        var_axm=None
                        
                        for e in inst_other_axioms:
                            
                            if e[0]=='i1':
                                var_axm=e[2]
                                
                            if var_axm is not None:
                                
                                non_det_fun = eval("['"+x+"',['"+var_axm+"']]")
                                
                                non_value = eval("['"+str(map_max[x])+"']")
                                
                                e[-1]=expr_replace(e[-1],non_det_fun,non_value)
                            
        
                        if condition is not None:
        
                            for w in inst_output_equations:
                                    x=inst_output_equations[w]
                                    x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                                    x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())

                            for x in inst_other_axioms:
                                if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                    x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                                    x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                    
                        else:
        
                            for w in inst_output_equations:
                                    x=inst_output_equations[w]
                                    result = simplify_ind_condition_else(x[-1])
                                    if result is not None:
                                        x[-1] = result
                            
                            for x in inst_other_axioms:
                                if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                    result = simplify_ind_condition_else(x[-1])
                                    if result is not None:
                                        x[-1] = result

                        small_macro_eq = update_assertion1(axiom,witnessXml,inst_other_axioms,inst_output_equations)
                
                
                        if len(small_macro_eq)>0:
                            for y in small_macro_eq:
                                for x in inst_other_axioms:
                                    if x[0]=='i1':
                                        x[-1]=expr_replace(x[-1],y[1],y[0])
                
                        f,inst_output_equations,inst_other_axioms,cm,inst_word = rec_solver_tactic8(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,inst_word)
                        post_condition=[]
                        post_condition.append(wff2z3_update1(inst_word,axiom.getConst_var_map()))
                        
                        
                        for w in axiom.getAssumes():
                                if w[0]=='i1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'i1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                elif w[0]=='c1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'c1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                else:
                                        if w[0]!='i0':
                                                var_cstr_map={}
                                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                                list_var_str=qualifier_list(var_cstr_map.keys())
                                                list_cstr_str=cstr_list(var_cstr_map.values())
                                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                                if list_var_str is not None and list_cstr_str is not None:
                                                        if w[0] == 'i1':
                                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                        else:
                                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                                else:
                                                        pre_condition.append(rhs)
			
                        for x in post_condition:
                                #print('\nAssertion To Prove:'+x)
                                temp_post_condition=[]
                                temp_post_condition.append(x)
                                if post_condition is not None:
                                        start_time=current_milli_time()
                                        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                                        status=tactic1_update(f,inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                                        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                                        if "Successfully Proved" in status:
                                            if main_status is None:
                                                main_status=True			
                                        elif "Counter Example" in status:
                                                return status
                                        else:
                                                return "Failed to Prove"

                    
                else:
            
                    inst_word=copy.deepcopy(word)
                
                    inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
                
                    inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
                    
                    addition_conditions={}
                    
                    inst_other_axioms_list=None
                
        
                    if condition is not None:
        
                        #for w in inst_output_equations:
                        #        x=inst_output_equations[w]
                        #        x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                        #        x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                        
                        
                        for x in inst_other_axioms:
                            if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                #print '~~~~~~~~~~~~~~~~~~~~~~~~1'
                                #print expr2string1(condition_map[condition])
                                #print '------------------------'
                                #print wff2string1(x)
                                new_x=copy.deepcopy(x[-1])
                                new_x = simplify_ind_equation_tactic8(new_x,condition_map[condition])
                                new_x = simplify_ind_condition_tactic8(new_x,axiom.getVfact())
                                if x[-1][0]=='ite':
                                    #print '~~~~~~~~~~~~~~~~~~~~~~~~2'
                                    #print wff2string1(x)
                                    #print '~~~~~~~~~~~~~~~~~~~~~~~~3'
                                    if 'RET' not in x[-2][0] and 'break_' not in x[-2][0]:
                                        get_conditions_approximate(x[-1],addition_conditions)
                                        if len(addition_conditions)>=0:
                                            addition_conditions_map={}
                                            addition_conditions_expr_map={}
                                            getlistOfOtherAxoims(x[-1],addition_conditions_map,addition_conditions_expr_map,None)
                                            if len(addition_conditions_map)>1:
                                                
                                                inst_other_axioms_list=[]
                                                
                                                for y in addition_conditions_expr_map:
                                                    
                                                    new_y=copy.deepcopy(x)
                                                    
                                                    new_y[-1] = addition_conditions_expr_map[y]
                                                    
                                                    inst_other_axioms_list.append(new_y)
                                                    
                                            else:
                                                x[-1]=addition_conditions_expr_map[addition_conditions_expr_map.keys()[0]]
                                                
                                    else:
                                        x[-1]=new_x
                                else:
                                    x[-1]=new_x

                    
                    else:
        
                        #for w in inst_output_equations:
                        #        x=inst_output_equations[w]
                        #        result = simplify_ind_condition_else(x[-1])
                        #        if result is not None:
                        #            x[-1] = result
                    
                        for x in inst_other_axioms:
                            if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                result = simplify_ind_condition_else(x[-1])
                                if result is not None:
                                    x[-1] = result
                                    

                        
                    small_macro_eq = update_assertion1(axiom,witnessXml,inst_other_axioms,inst_output_equations)
                
                
                    if len(small_macro_eq)>0:
                        for y in small_macro_eq:
                            for x in inst_other_axioms:
                                if x[0]=='i1':
                                    x[-1]=expr_replace(x[-1],y[1],y[0])
                                    
                    
                    
                    if inst_other_axioms_list is not None and len(inst_other_axioms_list)>0:
                        
                        
                        for x in inst_other_axioms_list:
                            
                            inst_other_axioms_new=copy.deepcopy(inst_other_axioms)
                            
                            
                            inst_output_equations_new={}
                            
                            for z in inst_output_equations:
                                if 'RET' not in z:
                                    inst_output_equations_new[z]=inst_output_equations[z]
                                    
                            for y in inst_other_axioms_new:
                                if y[-2]==x[-2]:
                                    y[-1]=x[-1]
                                    
                                    
                            f,inst_output_equations_new,inst_other_axioms_new,cm,inst_word = rec_solver_tactic8(axiom.getFrame_axioms(),inst_output_equations_new,inst_other_axioms_new,inst_word)

                            post_condition=[]
                            post_condition.append(wff2z3_update1(inst_word,axiom.getConst_var_map()))

                            for w in axiom.getAssumes():
                                    if w[0]=='i1':
                                            var_cstr_map={}
                                            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                            list_var_str=qualifier_list(var_cstr_map.keys())
                                            list_cstr_str=cstr_list(var_cstr_map.values())
                                            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                            if list_var_str is not None and list_cstr_str is not None:
                                                    if w[0] == 'i1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                    else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                            else:
                                                pre_condition.append(rhs)
                                    elif w[0]=='c1':
                                            var_cstr_map={}
                                            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                            list_var_str=qualifier_list(var_cstr_map.keys())
                                            list_cstr_str=cstr_list(var_cstr_map.values())
                                            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                            if list_var_str is not None and list_cstr_str is not None:
                                                    if w[0] == 'c1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                    else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                            else:
                                                    pre_condition.append(rhs)
                                    else:
                                            if w[0]!='i0':
                                                    var_cstr_map={}
                                                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                                    list_var_str=qualifier_list(var_cstr_map.keys())
                                                    list_cstr_str=cstr_list(var_cstr_map.values())
                                                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                                    if list_var_str is not None and list_cstr_str is not None:
                                                        if w[0] == 'i1':
                                                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                        else:
                                                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                                    else:
                                                        pre_condition.append(rhs)
			
                            for x in post_condition:
                                    #print('\nAssertion To Prove:'+x)
                                    temp_post_condition=[]
                                    temp_post_condition.append(x)
                                    if post_condition is not None:
                                            start_time=current_milli_time()
                                            writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                                            status=tactic1_update(f,inst_output_equations_new,inst_other_axioms_new,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                                            #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                                            if "Successfully Proved" in status:
                                                if main_status is None:
                                                    main_status=True			
                                            elif "Counter Example" in status:
                                                return status
                                            else:
                                                return "Failed to Prove"

	else:
            return "Failed to Prove" 
        
        if main_status==True:
            return "Successfully Proved"
        else:
            return "Failed to Prove"





def getlistOfOtherAxoims(e,condition_map,condition_expr_map,con_prev):
        if e[:1]==['ite']:
                argument=expr_args(e)
                if argument[1][:1]==['ite']:
                    getlistOfOtherAxoims(argument[1],condition_map,condition_expr_map,argument[0])
                else:
                    if con_prev is not None:
                        new_cond=eval("['and',"+str(con_prev)+","+str(argument[0])+"]")
                        cond_key=expr2string1(argument[0])
                        condition_map[cond_key]=argument[0]
                        condition_expr_map[cond_key]=argument[1]

                    else:
                        cond_key=expr2string1(argument[0])
                        condition_map[cond_key]=argument[0]
                        condition_expr_map[cond_key]=argument[1]
                        
                new_cond_compl=copy.deepcopy(argument[0])
                new_cond_compl=expr_complement(new_cond_compl)
                
                if argument[2][:1]==['ite']:
                    getlistOfOtherAxoims(argument[2],condition_map,condition_expr_map,new_cond_compl)
                else:
                    if con_prev is not None:
                        if argument[2][0] in {'-','+','-','/'}:
                            new_cond=eval("['and',"+str(con_prev)+","+str(new_cond_compl)+"]")
                            cond_key=expr2string1(new_cond_compl)
                            condition_map[cond_key]=new_cond_compl
                            condition_expr_map[cond_key]=argument[2]

                    else:
                        if argument[2][0] in {'-','+','-','/'}:
                            cond_key=expr2string1(new_cond_compl)
                            condition_map[cond_key]=new_cond_compl
                            condition_expr_map[cond_key]=argument[2]

                

    
    








def prove_assert_tactic_approximation_rec(axiom,witnessXml):
    
	pre_condition=[]
	post_condition=[]
        condition_map={}
        break_condition_map={}
        #compl_break_condition_map={}
	main_status=None
	str_value,word=axiom.getAsserts()        
        get_conditions_approximate(word[-1],condition_map)
        
        
        for x in axiom.getOther_axioms():
            if x[0]=='i1':
                if 'break_' in x[-2][0]:
                    get_conditions_approximate(x[-1],break_condition_map)
                    #expr_complement()
        
        for x in axiom.getOther_axioms():
            if x[0]=='i1' and len(x[4])>1:
                get_conditions_approximate(x[4],condition_map)
            elif x[0]=='i0' and len(x[3])>1:
                x[3]=simplifyAxioms(x[3])
                get_conditions_approximate(x[3],condition_map)
                
        if len(break_condition_map)>0:
            for x in break_condition_map:
                del condition_map[x]
                
        
        if len(condition_map.keys())>0:
            
            if isElseInductive(axiom.getOther_axioms())==True:
                condition_map[None]=None
            
            for condition in condition_map:
                
                #print '^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^'
                #print isSubstNonDeterValue(axiom.getOther_axioms())
                #print condition_map
                #print condition
                #print '^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^'
                
                map_max={}
                
                map_min={}
                
                main_max_min_map=None
                
                if condition is not None:
                    
                    expr4extractValueAxoim(condition_map[condition],map_max,map_min)
                    
                    main_max_min_map=merge_two_dicts(map_max,map_min)
                    
                #print '^^^^^^^^^^^^^^^^^^^^^^'
                #print condition
                #print map_max
                #print map_min
                #print '^^^^^^^^^^^^^^^^^^^^^^'
                if (len(map_max)>0 or len(map_min)>0) and isSubstNonDeterValue(axiom.getOther_axioms())==True:

                    for x in map_min:
            
                        inst_word=copy.deepcopy(word)
                
                        inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
                
                        inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
                        
                        addition_conditions={}
                                                
                        var_axm=None
                        
                        for e in inst_other_axioms:
                            
                            if e[0]=='i1':
                                var_axm=e[2]
                                
                            if var_axm is not None:
                                
                                non_det_fun = eval("['"+x+"',['"+var_axm+"']]")
                                
                                non_value = eval("['"+str(map_min[x])+"']")
                                
                                e[-1]=expr_replace(e[-1],non_det_fun,non_value)
                            
        
                        if condition is not None:
        
                            for w in inst_output_equations:
                                    x=inst_output_equations[w]
                                    x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                                    x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                                    if x[-1][0]=='ite':
                                        get_conditions_approximate(x[-1],addition_conditions)

                    
                            for x in inst_other_axioms:
                                if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                    x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                                    x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                    
                        else:
        
                            for w in inst_output_equations:
                                    x=inst_output_equations[w]
                                    result = simplify_ind_condition_else(x[-1])
                                    if result is not None:
                                        x[-1] = result
                    
                            for x in inst_other_axioms:
                                if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                    result = simplify_ind_condition_else(x[-1])
                                    if result is not None:
                                        x[-1] = result


                        
                        small_macro_eq = update_assertion1(axiom,witnessXml,inst_other_axioms,inst_output_equations)
                
                
                        if len(small_macro_eq)>0:
                            for y in small_macro_eq:
                                for x in inst_other_axioms:
                                    if x[0]=='i1':
                                        x[-1]=expr_replace(x[-1],y[1],y[0])
                                        
                        f,inst_output_equations,inst_other_axioms,cm,inst_word = rec_solver_tactic8(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,inst_word)

                        post_condition=[]
                        post_condition.append(wff2z3_update1(inst_word,axiom.getConst_var_map()))
                        
                        
                        for w in axiom.getAssumes():
                                if w[0]=='i1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'i1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                elif w[0]=='c1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'c1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                else:
                                        if w[0]!='i0':
                                                var_cstr_map={}
                                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                                list_var_str=qualifier_list(var_cstr_map.keys())
                                                list_cstr_str=cstr_list(var_cstr_map.values())
                                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                                if list_var_str is not None and list_cstr_str is not None:
                                                        if w[0] == 'i1':
                                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                        else:
                                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                                else:
                                                        pre_condition.append(rhs)
			
                        for x in post_condition:
                                #print('\nAssertion To Prove:'+x)
                                temp_post_condition=[]
                                temp_post_condition.append(x)
                                if post_condition is not None:
                                        start_time=current_milli_time()
                                        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                                        status=tactic1_update(f,inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                                        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                                        if "Successfully Proved" in status:
                                            if main_status is None:
                                                main_status=True			
                                        elif "Counter Example" in status:
                                                return status
                                        else:
                                                return "Failed to Prove"




                    
                    for x in map_max:
            
                        inst_word=copy.deepcopy(word)
                
                        inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
                
                        inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
                        
                        addition_conditions={}
                                                
                        var_axm=None
                        
                        for e in inst_other_axioms:
                            
                            if e[0]=='i1':
                                var_axm=e[2]
                                
                            if var_axm is not None:
                                
                                non_det_fun = eval("['"+x+"',['"+var_axm+"']]")
                                
                                non_value = eval("['"+str(map_max[x])+"']")
                                
                                e[-1]=expr_replace(e[-1],non_det_fun,non_value)
                            
        
                        if condition is not None:
        
                            for w in inst_output_equations:
                                    x=inst_output_equations[w]
                                    x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                                    x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                                    if x[-1][0]=='ite':
                                        get_conditions_approximate(x[-1],addition_conditions)


                            for x in inst_other_axioms:
                                if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                    x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                                    x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                    
                        else:
        
                            for w in inst_output_equations:
                                    x=inst_output_equations[w]
                                    result = simplify_ind_condition_else(x[-1])
                                    if result is not None:
                                        x[-1] = result
                            
                            for x in inst_other_axioms:
                                if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                    result = simplify_ind_condition_else(x[-1])
                                    if result is not None:
                                        x[-1] = result

                        small_macro_eq = update_assertion1(axiom,witnessXml,inst_other_axioms,inst_output_equations)
                
                
                        if len(small_macro_eq)>0:
                            for y in small_macro_eq:
                                for x in inst_other_axioms:
                                    if x[0]=='i1':
                                        x[-1]=expr_replace(x[-1],y[1],y[0])
                
                

                        f,inst_output_equations,inst_other_axioms,cm,inst_word = rec_solver_tactic8(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,inst_word)
                        post_condition=[]
                        post_condition.append(wff2z3_update1(inst_word,axiom.getConst_var_map()))
                        
                        
                        for w in axiom.getAssumes():
                                if w[0]=='i1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'i1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                elif w[0]=='c1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'c1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                else:
                                        if w[0]!='i0':
                                                var_cstr_map={}
                                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                                list_var_str=qualifier_list(var_cstr_map.keys())
                                                list_cstr_str=cstr_list(var_cstr_map.values())
                                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                                if list_var_str is not None and list_cstr_str is not None:
                                                        if w[0] == 'i1':
                                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                        else:
                                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                                else:
                                                        pre_condition.append(rhs)
			
                        for x in post_condition:
                                #print('\nAssertion To Prove:'+x)
                                temp_post_condition=[]
                                temp_post_condition.append(x)
                                if post_condition is not None:
                                        start_time=current_milli_time()
                                        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                                        status=tactic1_update(f,inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                                        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                                        if "Successfully Proved" in status:
                                            if main_status is None:
                                                main_status=True			
                                        elif "Counter Example" in status:
                                                return status
                                        else:
                                                return "Failed to Prove"

                    
                else:
            
                    inst_word=copy.deepcopy(word)
                
                    inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
                
                    inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
                    
                    addition_conditions={}
                
        
                    if condition is not None:
        
                        #for w in inst_output_equations:
                        #        x=inst_output_equations[w]
                        #        x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                        #        x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                    
                        for x in inst_other_axioms:
                            if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                if 'RET' not in x[-2][0] and 'break_' not in x[-2][0]:
                                    x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                                    x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                                    if x[-1][0]=='ite':
                                        get_conditions_approximate(x[-1],addition_conditions)
                    
                    else:
        
                        #for w in inst_output_equations:
                        #        x=inst_output_equations[w]
                        #        result = simplify_ind_condition_else(x[-1])
                        #        if result is not None:
                        #            x[-1] = result
                    
                        for x in inst_other_axioms:
                            if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                                result = simplify_ind_condition_else(x[-1])
                                if result is not None:
                                    x[-1] = result
                                    

                        
                    small_macro_eq = update_assertion1(axiom,witnessXml,inst_other_axioms,inst_output_equations)
                
                
                    if len(small_macro_eq)>0:
                        for y in small_macro_eq:
                            for x in inst_other_axioms:
                                if x[0]=='i1':
                                    x[-1]=expr_replace(x[-1],y[1],y[0])
                                    
                    if len(addition_conditions)>0:
                        
                        
                        #print 'xxxxx---xxxx'
                        
                        #print len(inst_other_axioms)==axiom.getOther_axioms()
                        
                        new_axiom=axiomclass(axiom.getFrame_axioms(), inst_output_equations, inst_other_axioms,axiom.getInputvariable(), axiom.getVfact(), axiom.getConstraints(), axiom.getConst_var_map(), axiom.getAsserts(), axiom.getAssumes(), axiom.getVariables())
                        
                        test_status = prove_assert_tactic_approximation_rec(new_axiom,witnessXml)
                        
                        if "Successfully Proved" in test_status:
                            if main_status is None:
                                main_status=True			
                        else:
                            return "Failed to prove"

                    else:
                        
                        f,inst_output_equations,inst_other_axioms,cm,inst_word = rec_solver_tactic8(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,inst_word)
                    
                        post_condition=[]
                        post_condition.append(wff2z3_update1(inst_word,axiom.getConst_var_map()))

                        for w in axiom.getAssumes():
                                if w[0]=='i1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'i1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                elif w[0]=='c1':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'c1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
                                else:
                                        if w[0]!='i0':
                                                var_cstr_map={}
                                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                                list_var_str=qualifier_list(var_cstr_map.keys())
                                                list_cstr_str=cstr_list(var_cstr_map.values())
                                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                                if list_var_str is not None and list_cstr_str is not None:
                                                        if w[0] == 'i1':
                                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                        else:
                                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                                else:
                                                        pre_condition.append(rhs)
			
                        for x in post_condition:
                                #print('\nAssertion To Prove:'+x)
                                temp_post_condition=[]
                                temp_post_condition.append(x)
                                if post_condition is not None:
                                        start_time=current_milli_time()
                                        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                                        status=tactic1_update(f,inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                                        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                                        if "Successfully Proved" in status:
                                            if main_status is None:
                                                main_status=True			
                                        elif "Counter Example" in status:
                                                return status
                                        else:
                                                return "Failed to Prove"
	else:
            return "Failed to Prove" 
        
        if main_status==True:
            return "Successfully Proved"
        else:
            return "Failed to Prove"






def isElseInductive(inst_other_axioms):
    status=False
    for x in inst_other_axioms:
        if x[0] == 'i1':
            if 'RET' not in x[-2][0] and 'break_' not in x[-2][0]:
               temp_exp = copy.deepcopy(x[-2])
               temp_exp = expr_replace(temp_exp,eval("['+',['"+x[-3]+"'],['1']]"),eval("['"+x[-3]+"']"))
               elseExp = simplify_ind_condition_else(x[-1])
               if elseExp is not None and elseExp!=temp_exp:
                   status=True
    return status

def isSubstNonDeterValue(inst_other_axioms):
    status=False
    for x in inst_other_axioms:
        if x[0] == 'i1':
            if 'RET' not in x[-2][0] and 'break_' not in x[-2][0]:
               temp_exp = copy.deepcopy(x[-2])
               temp_exp = expr_replace(temp_exp,eval("['+',['"+x[-3]+"'],['1']]"),eval("['"+x[-3]+"']"))
               if isNonDeterFunPresent(x[-1])==True and expr_find(x[-1],temp_exp):
                   print wff2string1(x)
                   status=True
    return status

               
                
                
                

    













def prove_assert_tactic_conditional_rec(axiom,witnessXml):
    
	pre_condition=[]
        
	post_condition=[]
        
        condition_map={}
        
        str_value,word=axiom.getAsserts()	
        
        prev_word=copy.deepcopy(word)
        
        
        rec_equ=None
        
        var_equ = None
        
        equations_str_map={}
        
        equations_map={}
        
        for x in axiom.getOther_axioms():
            if x[0]=='i1':
                
                var_equ=x[2]
                
                if var_equ in equations_str_map:
                    
                    rec_equ = equations_str_map[var_equ]
                    rec_equ += ";"+wff2string1(x)
                    equations_str_map[var_equ]=rec_equ
                    
                    equ_list = equations_map[var_equ]
                    equ_list.append(x)
                    equations_map[var_equ]=equ_list
                    
                    
                else:
                    
                    rec_equ=wff2string1(x)
                    equations_str_map[var_equ]=rec_equ
                    
                    equ_list = []
                    equ_list.append(x)
                    equations_map[var_equ]=equ_list

                    
            elif x[0]=='i0':
                
                if var_equ in equations_str_map:
                    
                    rec_equ = equations_str_map[var_equ]
                    rec_equ += ";"+wff2string1(x)
                    equations_str_map[var_equ]=rec_equ
                    
                    equ_list = equations_map[var_equ]
                    equ_list.append(x)
                    equations_map[var_equ]=equ_list
                    
                else:
                    
                    rec_equ=wff2string1(x)
                    equations_str_map[var_equ]=rec_equ
                    
                    equ_list = []
                    equ_list.append(x)
                    equations_map[var_equ]=equ_list

            
        for var_equ in equations_str_map:
            
            rec_equ = equations_str_map[var_equ]

            constant = axiom.getConst_var_map()[var_equ]
            
            
            close_form_soln,add_axoims,left_out_eq = solution_closed_form.solve_recurrenceCall(rec_equ,var_equ)
            
            #print '---------------ram ------'
            #print close_form_soln
            #print '--------------- ram ------'
            
            
            for x in equations_map[var_equ]:
                
                if x not in left_out_eq:
                    
                    axiom.getOther_axioms().remove(x)
                    
            for x in add_axoims:
                
                axiom.getOther_axioms().append(x)
                
            for equation in close_form_soln:
                equation1=copy.deepcopy(equation)
                update_axioms=solnsubstitution(axiom.getOther_axioms(),equation[-2],equation[-1])
                axiom.setOther_axioms(update_axioms)
                equation1[-2]=expr_replace_const(equation1[-2],var_equ,constant)
                equation1[-1]=expr_replace_const(equation1[-1],var_equ,constant)
                update_axioms=solnsubstitution(axiom.getOther_axioms(),equation1[-2],equation1[-1])
                axiom.setOther_axioms(update_axioms)
                
                word[-1]= expr_replace(word[-1],equation1[-2],equation1[-1])
                
                for x in axiom.getOutput_equations():
                    
                    axiom.getOutput_equations()[x][-1] = expr_replace(axiom.getOutput_equations()[x][-1],equation1[-2],equation1[-1])
                    
                        
        for w in axiom.getAssumes():
            if w[0]=='i1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                if list_var_str is not None and list_cstr_str is not None:
                    if w[0] == 'i1':
                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                    else:
                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                else:
                    pre_condition.append(rhs)
                    
            elif w[0]=='c1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                if list_var_str is not None and list_cstr_str is not None:
                    if w[0] == 'c1':
                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                    else:
                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                else:
                    pre_condition.append(rhs)
            else:
                if w[0]!='i0':
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                    list_var_str=qualifier_list(var_cstr_map.keys())
                    list_cstr_str=cstr_list(var_cstr_map.values())
                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'i1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
        if prev_word != word:
            
            #print '----------------@@@@@@@@@'
            #for xx in axiom.getOther_axioms():
            #    print wff2string1(xx)
            #print '---------------------'

            post_condition.append(wff2z3_update(word))
            for x in post_condition:
                #print('\nAssertion To Prove:'+x)
                
                #print '----------------@@@@@@@@@'
                #for xx in axiom.getOther_axioms():
                #    print wff2string1(xx)
                #print '---------------------'

                temp_post_condition=[]
                temp_post_condition.append(x)
                if post_condition is not None:
                    start_time=current_milli_time()
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                    status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                    #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                    if "Successfully Proved" in status:
                        return "Successfully Proved"                
                    elif "Counter Example" in status:
                        return status
                    else:
                        return "Failed to Prove"
        else:
            return "Failed to Prove"






def prove_assert_assertion_rearrage(axiom,witnessXml):
    
	pre_condition=[]
        
	post_condition=[]
        
        condition_map={}
        
        str_value,word=axiom.getAsserts()
        
        prev_word=copy.deepcopy(word)
        
        word[-1] = getRidOfDiv(word[-1])
        
        for w in axiom.getAssumes():
            if w[0]=='i1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                if list_var_str is not None and list_cstr_str is not None:
                    if w[0] == 'i1':
                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                    else:
                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                else:
                    pre_condition.append(rhs)
                    
            elif w[0]=='c1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                if list_var_str is not None and list_cstr_str is not None:
                    if w[0] == 'c1':
                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                    else:
                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                else:
                    pre_condition.append(rhs)
            else:
                if w[0]!='i0':
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                    list_var_str=qualifier_list(var_cstr_map.keys())
                    list_cstr_str=cstr_list(var_cstr_map.values())
                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'i1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
                        
        if prev_word != word:
            

            post_condition.append(wff2z3_update1(word,axiom.getConst_var_map()))
            for x in post_condition:

                temp_post_condition=[]
                temp_post_condition.append(x)
                if post_condition is not None:
                    start_time=current_milli_time()
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                    status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                    #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                    if "Successfully Proved" in status:
                        return "Successfully Proved"                
                    elif "Counter Example" in status:
                        return status
                    else:
                        return "Failed to Prove"
        else:
            return "Failed to Prove"

        






def expr2string1(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2string1(args[0])
            else:
                return '('+(' '+op+' ').join(list(expr2string1(x) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2string1(args[0])
        elif op=='implies' and len(args)==2:
            return expr2string1(args[0])+ ' -> '+expr2string1(args[1])
        elif op in _infix_op and len(args)==2:
            return '(' + expr2string1(args[0])+ op+expr2string1(args[1])+')'
        else:
            return op +'('+ ','.join(list(expr2string1(x) for x in args))+ ')'









def tactic1_update_terminate_unsigned(axiom,witnessXml):

    for e in axiom.getOther_axioms():
        if e[0]=='s0':
            for x in axiom.getOutput_equations():
                y=axiom.getOutput_equations()[x]
                if expr_find(e[-1],y[-1])==True:
                    var_class = axiom.getVariables()[x]
                    if 'unsigned' in var_class.getVariableType():
                        return e
    return None
                        




def prove_assert_tactic1(axiom,witnessXml):
	pre_condition=[]
	post_condition=[]
	
	str_value,word=axiom.getAsserts()

	#post_condition.append(str_value)
        post_condition.append(wff2z3_update1(word,axiom.getConst_var_map()))

			
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
			
	for x in post_condition:
		#print('\nAssertion To Prove:'+x)
		temp_post_condition=[]
		temp_post_condition.append(x)
		if post_condition is not None:
			start_time=current_milli_time()
                        #print '----------------@@@@@@@@@'
                        #for xx in axiom.getOther_axioms():
                        #    print wff2string1(xx)
                        #print '---------------------'
                        #print axiom.getFrame_axioms()
                        #for xx in axiom.getFrame_axioms():
                        #    print wff2string1(axiom.getFrame_axioms()[xx])
                        #print '---------------------'
                        #print axiom.getOutput_equations()
                        #for xx in axiom.getOutput_equations():
                        #    print wff2string1(axiom.getOutput_equations()[xx])
                        #print '---------------------'
                        #print axiom.getConstraints()
                        #print '----------------@@@@@@@@@'
			writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
			status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
			#status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
			if "Successfully Proved" in status:
				return "Successfully Proved"			
			elif "Counter Example" in status:
				return status
			else:
				return "Failed to Prove"
	return "Nothing To Prove"
    

def prove_assert_tactic1_power(axiom,witnessXml):
	pre_condition=[]
	post_condition=[]
	
	str_value,word=axiom.getAsserts()

	#post_condition.append(str_value)
        post_condition.append(wff2z3_update1(word,axiom.getConst_var_map()))

			
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
			
	for x in post_condition:
		#print('\nAssertion To Prove:'+x)
		temp_post_condition=[]
		temp_post_condition.append(x)
		if post_condition is not None:
			start_time=current_milli_time()
                        #print '----------------@@@@@@@@@'
                        #for xx in axiom.getOther_axioms():
                        #    print wff2string1(xx)
                        #print '---------------------'
                        #print axiom.getFrame_axioms()
                        #for xx in axiom.getFrame_axioms():
                        #    print wff2string1(axiom.getFrame_axioms()[xx])
                        #print '---------------------'
                        #print axiom.getOutput_equations()
                        #for xx in axiom.getOutput_equations():
                        #    print wff2string1(axiom.getOutput_equations()[xx])
                        #print '---------------------'
                        #print axiom.getConstraints()
                        #print '----------------@@@@@@@@@'
			writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
			status=tactic1_update_power(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
			#status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
			if "Successfully Proved" in status:
				return "Successfully Proved"			
			elif "Counter Example" in status:
				return status
			else:
				return "Failed to Prove"
	return "Nothing To Prove"





def prove_assert_tactic1_termination(axiom,witnessXml):
	pre_condition=[]
	post_condition=[]
	
	
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
			
        start_time=current_milli_time()
        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Strategy--Direct")
        status=tactic1_update_termination(copy.deepcopy(axiom.getFrame_axioms()),copy.deepcopy(axiom.getOutput_equations()),copy.deepcopy(axiom.getOther_axioms()),pre_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
        if "Successfully Proved" in status:
            return "Successfully Proved"			
        else:
            return "Failed to Prove"
    
    





def prove_assert_tactic1_bitwise(axiom,map_fun_bitwise,witnessXml):
	pre_condition=[]
	post_condition=[]
	
	str_value,word=axiom.getAsserts()

	#post_condition.append(str_value)
        post_condition.append(wff2z3_update1(word,axiom.getConst_var_map()))

			
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
			
	for x in post_condition:
		#print('\nAssertion To Prove:'+x)
		temp_post_condition=[]
		temp_post_condition.append(x)
		if post_condition is not None:
			start_time=current_milli_time()
                        #print '----------------@@@@@@@@@'
                        #for xx in axiom.getOther_axioms():
                        #    print wff2string1(xx)
                        #print '---------------------'
                        #print axiom.getFrame_axioms()
                        #for xx in axiom.getFrame_axioms():
                        #    print wff2string1(axiom.getFrame_axioms()[xx])
                        #print '---------------------'
                        #print axiom.getOutput_equations()
                        #for xx in axiom.getOutput_equations():
                        #    print wff2string1(axiom.getOutput_equations()[xx])
                        #print '---------------------'
                        #print axiom.getConstraints()
                        #print '----------------@@@@@@@@@'
			writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
			status=tactic1_update_bitwise_assert(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),map_fun_bitwise,witnessXml)
			#status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
			if "Successfully Proved" in status:
				return "Successfully Proved"			
			elif "Counter Example" in status:
				return status
			else:
				return "Failed to Prove"
	return "Nothing To Prove"







def prove_assert_tactic2(axiom,witnessXml):
	global defineDetaillist
	pre_condition=[]
	post_condition={}
	
	
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
	
	str_value,word=axiom.getAsserts()
		
	post_condition[str_value]=word
	

	for conclusion in post_condition.keys():
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+conclusion+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		variable=None
		constant=None
		const_map={}
		var_const_map={}
		count=0
		
		for cm in axiom.getConst_var_map():
			if axiom.getConst_var_map()[cm] in conclusion:
				count=count+1
				const_map[axiom.getConst_var_map()[cm]]=cm
				var_const_map[cm]="_k"+str(count)
		constraint_list=[]
		condition_map={}
		frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
		for x in frame_axioms:
			constraint_list.append(x)
		out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
				
		for x in out_axioms:
			constraint_list.append(x)
		for x in axiom.getOther_axioms():
			equations=wff2z3_update(x)
		        getAllCondtion(x,condition_map)
		        equations_sp=None	
		        constraint_list.append(equations)
		        if x[0]=='s1':
		        	equations_sp=wff2z3SC_update(x)
		        if equations_sp is not None:
		        	constraint_list.append(equations_sp)
		for x in axiom.getConstraints():
			constraint_list.append(x)
		for x in pre_condition:
		        constraint_list.append(x)
		update_vfact=[]
		for [x,k,l] in axiom.getVfact():
			if x in const_map.values():
				if k==0:
					ul=['constant']
					update_vfact.append([var_const_map[x],k,ul])
					update_vfact.append([x,k,l])
				else:
					update_vfact.append([var_const_map[x],k,l])
					update_vfact.append([x,k,l])
			else:
				update_vfact.append([x,k,l])		
		if bool(const_map):
			for x in const_map:
				variable=var_const_map[const_map[x]]			
				constant=x
				loop_var=const_map[x]
				w=post_condition[conclusion]
				e_in_step=w[1]
				e_base=w[1]
				e_assume=w[1]
			
				t=[]
				t.append('+')
				t1=[]
				t2=[]
				t1.append(loop_var)
				t2.append('1')
				t.append(t1)
				t.append(t2)
				t3=[]
				t3.append(x)
				e_in_step=expr_replace(e_in_step,t3,t)

				for x in axiom.getOther_axioms():
					if x[0]=='i1':
						e_in_step=expr_replace(e_in_step,x[3],x[4])
					else:
						if x[0]=='i0':
							e_in_step=expr_replace(e_in_step,x[2],x[3])
				t1=[]
				t2=[]
				t1.append(loop_var)
				t2.append(variable)
				e_in_step=expr_replace(e_in_step,t1,t2)
				e_assume=expr_replace(e_assume,t3,t2)
				t1=[]
				t1.append('0')
				e_base=expr_replace(e_base,t3,t1)
				w1=[]
				w1.append('c1')
				w1.append(e_base)
				w2=[]
				w2.append('c1')
				w2.append(e_assume)
				w3=[]
				w3.append('c1')
				w3.append(e_in_step)
				basecasestmt=wff2z3_update_postCond(w1)
				#invariantstmt=wff2z3_update_postCond(w2)
				inductiveassum=wff2z3_update_postCond(w2)

                                temp_e_assume=copy.deepcopy(e_assume)
                                temp_e_assume=expr_replace(temp_e_assume,t2,eval("['"+loop_var+"']"))
                                
                                invariantstmtdisplay=expr2z3_update_postCond(temp_e_assume,{})
                                
				#print " Try to prove following using induction on "+loop_var
				#print "ForAll("+loop_var+",Implies("+loop_var+">=0,"+str(invariantstmtdisplay)+"))"
				#print "Base Case"
				writeLogFile( "j2llogs.logs" , "\nBase Case \n"+str(basecasestmt)+"\n" )
				status=query2z3(constraint_list,str(basecasestmt),update_vfact,axiom.getInputvariable(),witnessXml)
				writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
				if "Successfully Proved" in status:
					case_list=[]
					case_temp_inductivestep=None
					if len(condition_map)==1:
						for key in condition_map.keys():
							case_list.append(key.replace(loop_var,variable))
							case_list.append('Not('+key.replace(loop_var,variable)+')')
					#print "Successfully Proved"
					#print "Inductive Step"
					#print "Inductive Assumption"
					#print invariantstmt
					#print inductiveassum
					updated_equation=[]
					updated_vfact=[]
					for equation in constraint_list:
						updated_equation.append(equation)
					updated_equation.append(variable+">=0")
					inductivestep='Implies('+str(inductiveassum)+','+wff2z3_update_postCond(w3)+')'
					writeLogFile( "j2llogs.logs" ,"\nInductive Step \n"+str(inductivestep)+"\n" )
					status=query2z3(updated_equation,str(inductivestep),update_vfact,axiom.getInputvariable(),witnessXml)
					writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
					if "Successfully Proved" in status:
						#print "Successfully Proved"
						return "Successfully Proved"
					elif "Counter Example" in status:
						return status
					else:
						if len(case_list)>0:
							case_status=False
							for case in case_list:
								inductivestep='Implies(And('+str(inductiveassum)+','+case+'),'+inductivestep+')'
								#status=query2z3(updated_equation,str(inductivestep),update_vfact,axiom.getInputvariable(),witnessXml)
								status="Failed to Prove"
								if "Successfully Proved" in status:
									case_status=True
								else:
									case_status=False
									break
										
									
							if case_status==True:
				                		writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
								return "Successfully Proved"
							else:
								return "Failed to Prove"
						else:
							return "Failed to Prove"
				elif "Counter Example" in status:
					return status
				else:
					return "Failed to Prove"
		else:
			var_const_map={}
			
			w=post_condition[conclusion]
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			const_map=var_cstr_map.keys()
			#list_var_str=qualifier_list(var_cstr_map.keys())
			#list_cstr_str=cstr_list(var_cstr_map.values())
			count=0
			for x in const_map:
				count=count+1
				var_const_map[x]="_k"+str(count)
			for x in const_map:
				loop_var=x
				variable=var_const_map[x]
				w_new=copy.deepcopy(w)
				e_in_step=w_new[1]
				e_base=w_new[1]
				e_assume=w_new[1]
				
				t=[]
				t.append('+')
				t1=[]
				t2=[]
				t1.append(loop_var)
				t2.append('1')
				t.append(t1)
				t.append(t2)
				t3=[]
				t3.append(x)
				
				e_in_step=expr_replace(e_in_step,t3,t)
				invariantstmtdisplay=expr2z3_update_postCond(e_in_step,{})
				
				t1=[]
				t2=[]
				t1.append(loop_var)
				t2.append(variable)
				e_in_step=expr_replace(e_in_step,t1,t2)
				e_assume=expr_replace(e_assume,t3,t2)
				t1=[]
				t1.append('0')
				e_base=expr_replace(e_base,t3,t1)
				w1=[]
				w1.append('c1')
				w1.append(e_base)
				w2=[]
				w2.append('c1')
				w2.append(e_assume)
				w3=[]
				w3.append('c1')
				w3.append(e_in_step)
				basecasestmt=wff2z3_update_postCond(w1)
				#print basecasestmt
				#invariantstmt=wff2z3_update_postCond(w2)
				inductiveassum=wff2z3_update_postCond(w2)
                                
                                temp_e_assume=copy.deepcopy(e_assume)
                                temp_e_assume=expr_replace(temp_e_assume,t2,eval("['"+loop_var+"']"))
                                
                                invariantstmtdisplay=expr2z3_update_postCond(temp_e_assume,{})
                                
				#print inductiveassum
				#print " Try to prove following using induction on "+loop_var
				#print "ForAll("+loop_var+",Implies("+loop_var+">=0,"+str(invariantstmtdisplay)+"))"
				#print "Base Case"
				writeLogFile( "j2llogs.logs" , "\nBase Case \n"+str(basecasestmt)+"\n" )
				status=query2z3(constraint_list,str(basecasestmt),update_vfact,axiom.getInputvariable(),witnessXml)
				writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
				if "Successfully Proved" in status:
					case_list=[]
					case_temp_inductivestep=None
					if len(condition_map)==1:
						for key in condition_map.keys():
							case_list.append(key.replace(loop_var,variable))
							case_list.append('Not('+key.replace(loop_var,variable)+')')
					#print "Successfully Proved"
					#print "Inductive Step"
					#print "Inductive Assumption"
					#print invariantstmt
					#print inductiveassum
					updated_equation=[]
					updated_vfact=[]
					for equation in constraint_list:
						updated_equation.append(equation)
					updated_equation.append(variable+">=0")
					update_vfact.append(eval("['"+variable+"',0,['int']]"))
					inductivestep='Implies('+str(inductiveassum)+','+wff2z3_update_postCond(w3)+')'
					writeLogFile( "j2llogs.logs" ,"\nInductive Step \n"+str(inductivestep)+"\n" )
					status=query2z3(updated_equation,str(inductivestep),update_vfact,axiom.getInputvariable(),witnessXml)
					writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
					if "Successfully Proved" in status:
						#print "Successfully Proved"
						return "Successfully Proved"
					elif "Counter Example" in status:
						return status
					else:
						if len(case_list)>0:
							case_status=False
							for case in case_list:
								inductivestep='Implies(And('+str(inductiveassum)+','+case+'),'+inductivestep+')'
								#status=query2z3(updated_equation,str(inductivestep),update_vfact,axiom.getInputvariable(),witnessXml)
								status="Failed to Prove"
								if "Successfully Proved" in status:
									case_status=True
								else:
									case_status=False
									break
																								
							if case_status==True:
								writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
								return "Successfully Proved"
							else:
								return "Failed to Prove"
						else:
							return "Failed to Prove"
                                elif "Counter Example" in status:
                                    return status
                                else:
                                    return "Failed to Prove"
				
	return "Nothing To Prove"



def prove_assert_tactic2_power(axiom,witnessXml):
	global defineDetaillist
	pre_condition=[]
	post_condition={}
	
	
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
	
	str_value,word=axiom.getAsserts()
		
	post_condition[str_value]=word
	

	for conclusion in post_condition.keys():
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+conclusion+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		variable=None
		constant=None
		const_map={}
		var_const_map={}
		count=0
		
		for cm in axiom.getConst_var_map():
			if axiom.getConst_var_map()[cm] in conclusion:
				count=count+1
				const_map[axiom.getConst_var_map()[cm]]=cm
				var_const_map[cm]="_k"+str(count)
		constraint_list=[]
		condition_map={}
		frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
		for x in frame_axioms:
			constraint_list.append(x)
		out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
				
		for x in out_axioms:
			constraint_list.append(x)
		for x in axiom.getOther_axioms():
			equations=wff2z3_update_power(x)
		        getAllCondtion(x,condition_map)
		        equations_sp=None	
		        constraint_list.append(equations)
		        if x[0]=='s1':
		        	equations_sp=wff2z3SC_update(x)
		        if equations_sp is not None:
		        	constraint_list.append(equations_sp)
		for x in axiom.getConstraints():
			constraint_list.append(x)
		for x in pre_condition:
		        constraint_list.append(x)
		update_vfact=[]
		for [x,k,l] in axiom.getVfact():
			if x in const_map.values():
				if k==0:
					ul=['constant']
					update_vfact.append([var_const_map[x],k,ul])
					update_vfact.append([x,k,l])
				else:
					update_vfact.append([var_const_map[x],k,l])
					update_vfact.append([x,k,l])
			else:
				update_vfact.append([x,k,l])		
		if bool(const_map):
			for x in const_map:
				variable=var_const_map[const_map[x]]			
				constant=x
				loop_var=const_map[x]
				w=post_condition[conclusion]
				e_in_step=w[1]
				e_base=w[1]
				e_assume=w[1]
			
				t=[]
				t.append('+')
				t1=[]
				t2=[]
				t1.append(loop_var)
				t2.append('1')
				t.append(t1)
				t.append(t2)
				t3=[]
				t3.append(x)
				e_in_step=expr_replace(e_in_step,t3,t)

				for x in axiom.getOther_axioms():
					if x[0]=='i1':
						e_in_step=expr_replace(e_in_step,x[3],x[4])
					else:
						if x[0]=='i0':
							e_in_step=expr_replace(e_in_step,x[2],x[3])
				t1=[]
				t2=[]
				t1.append(loop_var)
				t2.append(variable)
				e_in_step=expr_replace(e_in_step,t1,t2)
				e_assume=expr_replace(e_assume,t3,t2)
				t1=[]
				t1.append('0')
				e_base=expr_replace(e_base,t3,t1)
				w1=[]
				w1.append('c1')
				w1.append(e_base)
				w2=[]
				w2.append('c1')
				w2.append(e_assume)
				w3=[]
				w3.append('c1')
				w3.append(e_in_step)
				basecasestmt=wff2z3_update_postCond(w1)
				#invariantstmt=wff2z3_update_postCond(w2)
				inductiveassum=wff2z3_update_postCond(w2)

                                temp_e_assume=copy.deepcopy(e_assume)
                                temp_e_assume=expr_replace(temp_e_assume,t2,eval("['"+loop_var+"']"))
                                
                                invariantstmtdisplay=expr2z3_update_postCond(temp_e_assume,{})
                                
				#print " Try to prove following using induction on "+loop_var
				#print "ForAll("+loop_var+",Implies("+loop_var+">=0,"+str(invariantstmtdisplay)+"))"
				#print "Base Case"
				writeLogFile( "j2llogs.logs" , "\nBase Case \n"+str(basecasestmt)+"\n" )
				status=query2z3(constraint_list,str(basecasestmt),update_vfact,axiom.getInputvariable(),witnessXml)
				writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
				if "Successfully Proved" in status:
					case_list=[]
					case_temp_inductivestep=None
					if len(condition_map)==1:
						for key in condition_map.keys():
							case_list.append(key.replace(loop_var,variable))
							case_list.append('Not('+key.replace(loop_var,variable)+')')
					#print "Successfully Proved"
					#print "Inductive Step"
					#print "Inductive Assumption"
					#print invariantstmt
					#print inductiveassum
					updated_equation=[]
					updated_vfact=[]
					for equation in constraint_list:
						updated_equation.append(equation)
					updated_equation.append(variable+">=0")
					inductivestep='Implies('+str(inductiveassum)+','+wff2z3_update_postCond(w3)+')'
					writeLogFile( "j2llogs.logs" ,"\nInductive Step \n"+str(inductivestep)+"\n" )
					status=query2z3(updated_equation,str(inductivestep),update_vfact,axiom.getInputvariable(),witnessXml)
					writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
					if "Successfully Proved" in status:
						#print "Successfully Proved"
						return "Successfully Proved"
					elif "Counter Example" in status:
						return status
					else:
						if len(case_list)>0:
							case_status=False
							for case in case_list:
								inductivestep='Implies(And('+str(inductiveassum)+','+case+'),'+inductivestep+')'
								#status=query2z3(updated_equation,str(inductivestep),update_vfact,axiom.getInputvariable(),witnessXml)
								status="Failed to Prove"
								if "Successfully Proved" in status:
									case_status=True
								else:
									case_status=False
									break
										
									
							if case_status==True:
				                		writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
								return "Successfully Proved"
							else:
								return "Failed to Prove"
						else:
							return "Failed to Prove"
				elif "Counter Example" in status:
					return status
				else:
					return "Failed to Prove"
		else:
			var_const_map={}
			
			w=post_condition[conclusion]
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			const_map=var_cstr_map.keys()
			#list_var_str=qualifier_list(var_cstr_map.keys())
			#list_cstr_str=cstr_list(var_cstr_map.values())
			count=0
			for x in const_map:
				count=count+1
				var_const_map[x]="_k"+str(count)
			for x in const_map:
				loop_var=x
				variable=var_const_map[x]
				w_new=copy.deepcopy(w)
				e_in_step=w_new[1]
				e_base=w_new[1]
				e_assume=w_new[1]
				
				t=[]
				t.append('+')
				t1=[]
				t2=[]
				t1.append(loop_var)
				t2.append('1')
				t.append(t1)
				t.append(t2)
				t3=[]
				t3.append(x)
				
				e_in_step=expr_replace(e_in_step,t3,t)
				invariantstmtdisplay=expr2z3_update_postCond(e_in_step,{})
				
				t1=[]
				t2=[]
				t1.append(loop_var)
				t2.append(variable)
				e_in_step=expr_replace(e_in_step,t1,t2)
				e_assume=expr_replace(e_assume,t3,t2)
				t1=[]
				t1.append('0')
				e_base=expr_replace(e_base,t3,t1)
				w1=[]
				w1.append('c1')
				w1.append(e_base)
				w2=[]
				w2.append('c1')
				w2.append(e_assume)
				w3=[]
				w3.append('c1')
				w3.append(e_in_step)
				basecasestmt=wff2z3_update_postCond(w1)
				#print basecasestmt
				#invariantstmt=wff2z3_update_postCond(w2)
				inductiveassum=wff2z3_update_postCond(w2)
                                
                                temp_e_assume=copy.deepcopy(e_assume)
                                temp_e_assume=expr_replace(temp_e_assume,t2,eval("['"+loop_var+"']"))
                                
                                invariantstmtdisplay=expr2z3_update_postCond(temp_e_assume,{})
                                
				#print inductiveassum
				#print " Try to prove following using induction on "+loop_var
				#print "ForAll("+loop_var+",Implies("+loop_var+">=0,"+str(invariantstmtdisplay)+"))"
				#print "Base Case"
				writeLogFile( "j2llogs.logs" , "\nBase Case \n"+str(basecasestmt)+"\n" )
				status=query2z3(constraint_list,str(basecasestmt),update_vfact,axiom.getInputvariable(),witnessXml)
				writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
				if "Successfully Proved" in status:
					case_list=[]
					case_temp_inductivestep=None
					if len(condition_map)==1:
						for key in condition_map.keys():
							case_list.append(key.replace(loop_var,variable))
							case_list.append('Not('+key.replace(loop_var,variable)+')')
					#print "Successfully Proved"
					#print "Inductive Step"
					#print "Inductive Assumption"
					#print invariantstmt
					#print inductiveassum
					updated_equation=[]
					updated_vfact=[]
					for equation in constraint_list:
						updated_equation.append(equation)
					updated_equation.append(variable+">=0")
					update_vfact.append(eval("['"+variable+"',0,['int']]"))
					inductivestep='Implies('+str(inductiveassum)+','+wff2z3_update_postCond(w3)+')'
					writeLogFile( "j2llogs.logs" ,"\nInductive Step \n"+str(inductivestep)+"\n" )
					status=query2z3(updated_equation,str(inductivestep),update_vfact,axiom.getInputvariable(),witnessXml)
					writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
					if "Successfully Proved" in status:
						#print "Successfully Proved"
						return "Successfully Proved"
					elif "Counter Example" in status:
						return status
					else:
						if len(case_list)>0:
							case_status=False
							for case in case_list:
								inductivestep='Implies(And('+str(inductiveassum)+','+case+'),'+inductivestep+')'
								#status=query2z3(updated_equation,str(inductivestep),update_vfact,axiom.getInputvariable(),witnessXml)
								status="Failed to Prove"
								if "Successfully Proved" in status:
									case_status=True
								else:
									case_status=False
									break
																								
							if case_status==True:
								writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
								return "Successfully Proved"
							else:
								return "Failed to Prove"
						else:
							return "Failed to Prove"
                                elif "Counter Example" in status:
                                    return status
                                else:
                                    return "Failed to Prove"
				
	return "Nothing To Prove"













def prove_assert_tactic3(axiom,witnessXml):
	solution={}
	valid_solution={}
	for x in axiom.getOther_axioms(): 
		if x[0] is 's0':
			if x[1][0] == '>=' or x[1][0] == '<=':
				new_w = copy.deepcopy(x)
				var_map=[]
				get_All_Var(new_w[1],var_map)
				equations1=expr2string1(new_w[1][1])
				equations2=expr2string1(new_w[1][2])
				if len(var_map)==1:
					if solution is None:
						solution={}
					soln = solve(simplify(equations1+'-'+equations2),simplify(var_map[0]))
                                        if soln is not None and len(soln)>0:
                                            solution[var_map[0]] = soln[0]
				
		if x[0] is 's1':
			if x[1][2][0] == '>=' or x[1][2][0] == '<=':
				new_w = copy.deepcopy(x)
				sub_exp=[]
                                var_map=[]
				sub_exp.append('-')
				sub_exp.append(new_w[1][1][2])
				sub_exp.append(eval("['1']"))
				new_w[1][2]=expr_replace(new_w[1][2],new_w[1][1][1],sub_exp)
				get_All_Var(new_w[1][2],var_map)
				equations1=expr2string1(new_w[1][2][1])
				equations2=expr2string1(new_w[1][2][2])
				if len(var_map)==1:
					soln = solve(simplify(equations1+'-'+equations2),simplify(var_map[0]))
                                        if soln is not None and len(soln)>0:
                                            solution[var_map[0]] = soln[0]

	pre_condition=[]
	post_condition=[]
        post_condition1=[]
	updated_constrains=[]
	for constrain in axiom.getConstraints():
		updated_constrains.append(constrain)
        
        if bool(solution):
        
	    str_value,word_value=axiom.getAsserts()
            
            #new_word_value = copy.deepcopy deep.(word_value)
            
            #new_word_value=expr_replace()
            
	    
	    if 'ForAll' in str_value:
	    	return "Failed to Prove"
	    
	    post_condition1.append(word_value)
			
            for w in axiom.getAssumes():
                    if w[0]=='i1':
                            var_cstr_map={}
                            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                            list_var_str=qualifier_list(var_cstr_map.keys())
                            list_cstr_str=cstr_list(var_cstr_map.values())
                            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in lhs:
                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                            if list_var_str is not None and list_cstr_str is not None:
                                    if w[0] == 'i1':
                                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                    else:
                                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                            else:
                                    pre_condition.append(rhs)
                    
                    elif w[0]=='c1':
                            var_cstr_map={}
                            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                            list_var_str=qualifier_list(var_cstr_map.keys())
                            list_cstr_str=cstr_list(var_cstr_map.values())

                            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                            if list_var_str is not None and list_cstr_str is not None:
                                    if w[0] == 'c1':
                                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                    else:
                                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                            else:
                                    pre_condition.append(rhs)
                    else:
                            if w[0]!='i0':
                                    var_cstr_map={}
                                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                    list_var_str=qualifier_list(var_cstr_map.keys())
                                    list_cstr_str=cstr_list(var_cstr_map.values())
                                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                    if list_var_str is not None and list_cstr_str is not None:
                                            if w[0] == 'i1':
                                                    pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                            else:
                                                    pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                    else:
        
                                        pre_condition.append(rhs)
        
            
            for var in solution.keys():
                conclusion=str(var)+'=='+str(solution[var])
		temp_post_condition=[]
		temp_post_condition.append(conclusion)
		if post_condition is not None:
			start_time=current_milli_time()
			#writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(x)+"\n Post Condition--"+str(post_condition)+"\n Strategy--Direct")
			status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),updated_constrains,witnessXml)
			#status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
			if "Successfully Proved" in status:
				valid_solution[var]=solution[var]
				updated_constrains.append(var+'=='+str(solution[var]))
        if bool(valid_solution):
                finalProgram=''
                
        	for x in valid_solution.keys():
        		finalProgram+='\n'+str(simplify(x))+'='+str(simplify(valid_solution[x]))+'\n'
                        for word_value in post_condition1:
                            new_word_value = copy.deepcopy(word_value)
                            new_word_value=expr_replace(new_word_value,eval("['"+str(simplify(x))+"']"),eval("['"+str(simplify(valid_solution[x]))+"']"))
                            post_condition.append(new_word_value)
        			
        	
        	
        	program_map={}
        	query_list=[]
        	for e in axiom.getOther_axioms():
        		 if e[0]=='i1':
        		 	new_w = copy.deepcopy(e)
        		 	var_list=[]
        		 	var_list.append(new_w[2])
        		 	var_exp="['-',['"+new_w[2]+"'],['1']]"
        		 	def_fun=expr2string1(new_w[3])
        		 	def_fun=simplify(def_fun).subs(simplify(new_w[2]+'+1'),simplify(new_w[2]))
        		 	key_fun=simplify(def_fun).subs(simplify(new_w[2]),0)
        		 	query_fun=simplify(def_fun).subs(simplify(new_w[2]),simplify(axiom.getConst_var_map()[new_w[2]]))
        		 	query_list.append(str(query_fun))
        		 	body=expr_replace(new_w[4],var_list,eval(var_exp))
        		 	program_list=[]
        		 	program_list.append(new_w[2])
        		 	program_list.append('def '+str(def_fun)+':')
        		 	program_list.append('\t'+expr2python(body,'\t\t'))
                                program_list.append(str(def_fun))
        		 	program_list.append(expr2string1(body))
        		 	program_map[str(key_fun)]=program_list
			 elif e[0]=='i0':
			 	key_fun=expr2string1(e[2])
			 	if key_fun in program_map.keys():
			 		program_list=program_map[key_fun]
                                        program_list.append(key_fun)
                                        program_list.append(expr2string1(e[3]))
                                        program_map[key_fun]=program_list
                                        if finalProgram is not None:
                                            finalProgram+=program_list[1]+'\n'
                                            if 'if' in program_list[2]:
                                                    if is_number(str(expr2string1(e[3])))==True:
                                                        finalProgram+='\tif '+program_list[0]+'==0:\n\t\treturn '+expr2string1(e[3])+'\n\telse :'+program_list[2]
                                                    else:
                                                        #print 'XXXX1'
                                                        finalProgram=None
                                            else:
                                                    if is_number(str(expr2string1(e[3])))==True:
                                                        finalProgram+='\tif '+program_list[0]+'==0:\n\t\treturn '+expr2string1(e[3])+'\n\telse :\n\t\treturn'+program_list[2]+'\n'
                                                    else:
                                                        #print 'XXXX2'
                                                        finalProgram=None
                
                if finalProgram is not None:
                    for query in query_list:
                            try :
                                    writtingFile( "instquery.py" , finalProgram+'\ntry:'+'\n\t'+'print '+query+'\nexcept Exception as e:'+'\n\t'+"print \"Error(InstQuery)\"" )
                                    writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram+'\n'+'print '+query)+"\n" )
                                    proc = subprocess.Popen('python '+currentdirectory+'/instquery.py', stdout=subprocess.PIPE,shell=True)
                                    output = proc.stdout.read()
                                    status=output
                                    status=status.replace('\n','')
                                    status=status.replace('\r','')
                                    if is_number(status)==True:
                                            updated_constrains.append(query+'=='+status)
                            except Error  as err:
                                    print 'error'
                else:
                    sub_map={}
                    for key_fun in program_map.keys():
                        program_list=program_map[key_fun]
                        if len(program_list)>=6:
                            sub_map[simplify(program_list[3])]=simplify(program_list[4])
                            sub_map[simplify(program_list[5])]=simplify(program_list[6])
                        else:
                            return "Failed to Prove"
                    for x in valid_solution.keys():
                    	counter=valid_solution[x]
                    	for key_fun in program_map.keys():
                    		program_list=program_map[key_fun]
                    		expression=program_list[3]
                        	while (counter >= 0):
                        		if x in axiom.getConst_var_map().values():
                            			sub_map[simplify(axiom.getConst_var_map().keys()[axiom.getConst_var_map().values().index(x)])]=counter
                    			expression=simplify(expression).subs(sub_map)
                    			counter=counter-1
                    		#print expression
                    		#print '*****************************'
                    
                for x in post_condition:
                        x=wff2z3_update_postCond(x)
                	#print('\nAssertion To Prove:'+x)
                        wff2z3_update
                        temp_post_condition=[]
                        temp_post_condition.append(x)
                        if post_condition is not None:
                        	start_time=current_milli_time()
                                writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(x)+"\n Post Condition--"+str(post_condition)+"\n Strategy--Direct")
                                status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),updated_constrains,witnessXml)
                                #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),updated_constrains,axiom.getConst_var_map())
                                if "Successfully Proved" in status:
                                	return "Successfully Proved"			
                                elif "Counter Example" in status:
                                	return status
                                else:
                                	return "Failed to Prove"
        return "Failed to Prove"
        
def prove_assert_tactic8(axiom,witnessXml):
	pre_condition=[]
	post_condition=[]
        condition_map={}
	
	str_value,word=axiom.getAsserts()        
        
        getAllCondtion_tactic8(word,condition_map)
        
        
        for x in axiom.getOther_axioms():
            getAllCondtion_tactic8(x,condition_map)
        if len(condition_map.keys())>0:
            for condition in condition_map:
                inst_word=copy.deepcopy(word)
                inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
                inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
            
                for w in inst_output_equations:
                        x=inst_output_equations[w]
                        x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                        x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                    
                for x in inst_other_axioms:
                    if x[0] == 'e' or x[0] == 'i0' or x[0] == 'i1' or x[0] == 's0':
                        x[-1] = simplify_ind_equation_tactic8(x[-1],condition_map[condition])
                        x[-1] = simplify_ind_condition_tactic8(x[-1],axiom.getVfact())
                
                small_macro_eq = update_assertion1(axiom,witnessXml,inst_other_axioms,inst_output_equations)
    
                
                if len(small_macro_eq)>0:
                    for y in small_macro_eq:
                        for x in inst_other_axioms:
                            if x[0]=='i1':
                                x[-1]=expr_replace(x[-1],y[1],y[0])
                
                f,inst_output_equations,inst_other_axioms,cm,inst_word = rec_solver_tactic8(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,inst_word)
                #post_condition.append(str_value)
                post_condition.append(wff2z3_update1(inst_word,axiom.getConst_var_map()))

			
                for w in axiom.getAssumes():
                        if w[0]=='i1':
                                var_cstr_map={}
                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                list_var_str=qualifier_list(var_cstr_map.keys())
                                list_cstr_str=cstr_list(var_cstr_map.values())
                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                if list_var_str is not None and list_cstr_str is not None:
                                        if w[0] == 'i1':
                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                        else:
                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                else:
                                        pre_condition.append(rhs)
                        elif w[0]=='c1':
                                var_cstr_map={}
                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                list_var_str=qualifier_list(var_cstr_map.keys())
                                list_cstr_str=cstr_list(var_cstr_map.values())
                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                if list_var_str is not None and list_cstr_str is not None:
                                        if w[0] == 'c1':
                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                        else:
                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                else:
                                        pre_condition.append(rhs)
                        else:
                                if w[0]!='i0':
                                        var_cstr_map={}
                                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                        list_var_str=qualifier_list(var_cstr_map.keys())
                                        list_cstr_str=cstr_list(var_cstr_map.values())
                                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                        if list_var_str is not None and list_cstr_str is not None:
                                                if w[0] == 'i1':
                                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                                else:
                                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                        else:
                                                pre_condition.append(rhs)
			
                for x in post_condition:
                        #print('\nAssertion To Prove:'+x)
                        temp_post_condition=[]
                        temp_post_condition.append(x)
                        if post_condition is not None:
                                start_time=current_milli_time()
                                writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                                status=tactic1_update(f,inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                                #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                                if "Successfully Proved" in status:
                                        return "Successfully Proved"			
                                elif "Counter Example" in status:
                                        return status
                                else:
                                        return "Failed to Prove"
	else:
            return "Failed to Prove" 
        return "Failed to Prove"

 
def getAllCondtion_tactic8(w,condition_map):
	if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 's0':
                condition_map_temp={}
                get_conditions_tactic8(w[-1],condition_map_temp)
                if len(condition_map_temp.values())>0:
                    t_a=condition_map_temp.values()[0]
                    if len(condition_map_temp.values())>1:
                        for e in condition_map_temp.values()[1:]:
                            t_b=[]
                            t_b.append('and')
                            t_b.append(t_a)
                            t_b.append(e)
                            t_a=t_b
                    key = expr2string1(t_a)
                    if key not in condition_map.keys():
                        condition_map[key]=t_a
                    
                


def getConcreteValue(condition_map):
    values=[]
    for x in condition_map.keys():
        y = condition_map[x]
        if y[0]=='==':
            if '__VERIFIER_nondet_int' in expr2string(y[1]) or '__VERIFIER_nondet_uint' in expr2string(y[1]):
                if is_number(expr2string(y[2]))==True:
                    values.append(expr2string(y[2]))
    return values







def getRangeValues(e_list,program_analysis):
    final_var_list={}
    concret_value_map={}
    map_min={}
    map_max={}
    for e in e_list:
        if '_FAILED' in e:
            #print e_list[e][2]
            new_cond = expr4extractCond(e_list[e][2])
            for e_cond in new_cond:
                #print '%%%%%%%%%%%%%'
                #print new_cond
                #print '%%%%%%%%%%%%%'
                expr4extractValue(e_cond,map_max,map_min)
            print '----------------'
            print map_min
            print map_max
            print '----------------'
        else:
            if 'result' not in e and 'RET' not in e:
                final_var_list[e]=e_list[e]
    
    
    list_concret_value_map=[]
    
    concret_value_map={}
    
    for e in final_var_list:
        
        for x in map_min:
            #print x
            if getVarible_name(final_var_list[e][2],eval("['"+x+"']"))==True:
                concret_value_map[e]=map_min[x]
                if concret_value_map not in list_concret_value_map:
                    list_concret_value_map.append(concret_value_map)
                
    
    
    if bool(map_max):
        concret_value_map={}
        for e in final_var_list:
            
            for x in map_max:
                #print x
                if getVarible_name(final_var_list[e][2],eval("['"+x+"']"))==True:
                    concret_value_map[e]=map_max[x]
                    if concret_value_map not in list_concret_value_map:
                        list_concret_value_map.append(concret_value_map)


    program_analysis_list=[]
    abs_map={}

    for concret_value_map in list_concret_value_map:
        for x in concret_value_map:
    #        #print concret_value_map[x]
    #        #print pow(2,30)
            if int(concret_value_map[x])>=(pow(2,30)-1):
                abs_map[x]=10
    if len(abs_map)>0:
        list_concret_value_map=[]
        list_concret_value_map.append(abs_map)
        
        
            
    for concret_value_map in list_concret_value_map:

        parser = c_parser.CParser()
        ast = parser.parse(program_analysis)
        for ast_y in ast.ext:
        #    print e.decl.name
            if type(ast_y) is not c_ast.Decl:
                for e in ast_y.body.block_items:
                    if type(e) is c_ast.Decl:
                        if e.type.declname in concret_value_map and type(e.init) is c_ast.FuncCall and '__VERIFIER_nondet_' in e.init.name.name:
                            new_value=int(concret_value_map[e.type.declname])
                            if new_value>=(pow(2,30)-1):
                                
                                e.init = c_ast.Constant(type='int', value=str(10))
                            else:

                                e.init = c_ast.Constant(type='int', value=str(new_value))
                    #print '~~~~~~~~~~~~~~~~Ram Ram'
                    
        generator = c_generator.CGenerator()
        #temp_program_analysis = generator.visit(ast)
        program_analysis = generator.visit(ast)
        
        program_analysis_list.append(program_analysis)
    #print '------------------'
    #print program_analysis
    #print '------------------'
    if len(concret_value_map)==0:
        program_analysis_list.append(program_analysis)
        
    return program_analysis_list,list_concret_value_map


def getAssumptionCondition(e,e1):
    args=expr_args(e)
    op=expr_op(e)
    if 'ite' in op:
        if args[1][0]=='ite':
            list_conditions=getAssumptionCondition(args[1],e1)
            if list_conditions is not None:
                list_conditions.append(args[0])
                return list_conditions
            else:
                return None
                
        else:
            if expr_find(args[1],e1)==True:
                list_conditions=[]
                list_conditions.append(args[0])
                return list_conditions
            else:
                return None
            
        if args[2][0]=='ite':
            list_conditions=getAssumptionCondition(args[2],e1)
            if list_conditions is not None:
                new_cond=copy.deepcopy(args[0])
                list_conditions.append(expr_complement(new_cond))
                return list_conditions
            else:
                return None

        else:
            if expr_find(args[1],e1)==True:
                new_cond=copy.deepcopy(args[0])
                list_conditions=[]
                list_conditions.append(expr_complement(new_cond))
                return list_conditions
            else:
                return None

    else:
        return None











def getVarible_name(e,e1):
    args=expr_args(e)
    op=expr_op(e)
    if 'ite' in op:
        result1 =getVarible_name(args[1],e1)
        if result1==True:
            return True
        result1 = getVarible_name(args[2],e1)
        if result1==True:
            return True
    else:
        if expr_find(e,e1)==True:
            return True
    return False


    


def expr4extractCond(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if op=='1':
            return []
        else:
            return None
    elif 'ite' in op:
        ret_value1 = expr4extractCond(args[1])
        if ret_value1 is not None:
            list=[]
            list.append(args[0])
            if len(ret_value1)>0:
                list = list+ret_value1
            return list
        ret_value2 = expr4extractCond(args[2])
        if ret_value2 is not None:
            new_cond=copy.deepcopy(args[0])
            ret_value1=expr_complement(new_cond)
            list=[]
            list.append(ret_value1)
            if len(ret_value2)>0:
                list = list+ret_value2
            return list
        
    return None
            






def expr4extractValue(e,map_max,map_min):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                expr4extractValue(args[0],map_max,map_min)
            else:
                for x in args:
                    expr4extractValue(x,map_max,map_min)
        elif op=='not' and len(args)==1:
            expr4extractValue(args[0],map_max,map_min)
        elif op in _infix_op and len(args)==2:
            if op=='>=':
                if '__VERIFIER_nondet_' in args[0][0]:
                    
                    if args[0][0] in map_min:
                        value=map_min[args[0][0]]
                        if is_number(args[1][0])==True:
                            new_value=int(args[1][0])
                            if value<new_value:
                                map_min[args[0][0]]=new_value
                    else:
                        new_value=int(args[1][0])
                        map_min[args[0][0]]=new_value
                elif '__VERIFIER_nondet_' in args[1][0]:
                    
                    if args[1][0] in map_min:
                        value=map_min[args[1][0]]
                        if is_number(args[0][0])==True:
                            new_value=int(args[0][0])
                            if value>new_value:
                                map_max[args[1][0]]=new_value
                    else:
                        new_value=int(args[0][0])
                        map_max[args[1][0]]=new_value
            elif op=='<=':
                if '__VERIFIER_nondet_' in args[0][0]:
                    if args[0][0] in map_max:
                        value=map_max[args[0][0]]
                        if is_number(args[1][0])==True:
                            new_value=int(args[1][0])
                            if value>new_value:
                                map_max[args[0][0]]=new_value
                    else:
                        new_value=int(args[1][0])
                        map_max[args[0][0]]=new_value
                        
                elif '__VERIFIER_nondet_' in args[1][0]:
                    if args[1][0] in map_min:
                        value=map_min[args[1][0]]
                        if is_number(args[0][0])==True:
                            new_value=int(args[0][0])
                            if value<new_value:
                                map_min[args[1][0]]=new_value
                    else:
                        new_value=int(args[0][0])
                        map_min[args[1][0]]=new_value
            elif op=='<':
                if '__VERIFIER_nondet_' in args[0][0]:
                                        
                    if args[0][0] in map_max:
                        value=map_max[args[0][0]]
                        if is_number(args[1][0])==True:
                            new_value=int(args[1][0])
                            if value>new_value:
                                map_max[args[0][0]]=new_value+1
                    else:
                        new_value=int(args[1][0])
                        map_max[args[0][0]]=new_value+1

                elif '__VERIFIER_nondet_' in args[1][0]:
                    
                    if args[1][0] in map_min:
                        value=map_min[args[1][0]]
                        if is_number(args[0][0])==True:
                            new_value=int(args[0][0])
                            if value<new_value:
                                map_min[args[1][0]]=new_value-1
                    else:
                        new_value=int(args[0][0])
                        map_min[args[1][0]]=new_value-1
            elif op=='>':
                if '__VERIFIER_nondet_' in args[0][0]:
                    
                    if args[0][0] in map_min:
                        value=map_min[args[0][0]]
                        if is_number(args[1][0])==True:
                            new_value=int(args[1][0])
                            if value<new_value:
                                map_min[args[0][0]]=new_value-1
                    else:
                        new_value=int(args[1][0])
                        map_min[args[0][0]]=new_value-1
                elif '__VERIFIER_nondet_' in args[1][0]:
                    if args[1][0] in map_max:
                        value=map_max[args[1][0]]
                        if is_number(args[0][0])==True:
                            new_value=int(args[0][0])
                            if value>new_value:
                                map_max[args[1][0]]=new_value+1
                    else:
                        new_value=int(args[0][0])
                        map_max[args[1][0]]=new_value+1
            elif op=='==':
                if '__VERIFIER_nondet_' in args[0][0]:
                    if args[1][0] in map_min:
                        value=map_min[args[1][0]]
                        if is_number(args[1][0])==True:
                            map_min[args[1][0]]=new_value
                    else:
                        new_value=int(args[1][0])
                        map_min[args[0][0]]=new_value

                elif '__VERIFIER_nondet_' in args[1][0]:
                    if args[1][0] in map_min:
                        value=map_min[args[1][0]]
                        if is_number(args[0][0])==True:
                            map_min[args[0][0]]=new_value
                    else:
                        new_value=int(args[0][0])
                        map_min[args[1][0]]=new_value

                

            else:
                for x in args:
                    expr4extractValue(x,map_max,map_min)
        else:
            for x in args:
                expr4extractValue(x,map_max,map_min)








def expr4extractValueAxoim(e,map_max,map_min):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                expr4extractValueAxoim(args[0],map_max,map_min)
            else:
                for x in args:
                    expr4extractValueAxoim(x,map_max,map_min)
        elif op=='not' and len(args)==1:
            expr4extractValueAxoim(args[0],map_max,map_min)
        elif op in _infix_op and len(args)==2:
            if op=='>=':
                if '__VERIFIER_nondet_' in args[0][0]:
                    
                    if args[0][0] in map_min:
                        value=map_min[args[0][0]]
                        if is_number(args[1][0])==True:
                            new_value=int(args[1][0])
                            if value<new_value:
                                map_min[args[0][0]]=new_value
                    else:
                        new_value=int(args[1][0])
                        map_min[args[0][0]]=new_value
                elif '__VERIFIER_nondet_' in args[1][0]:
                    
                    if args[1][0] in map_min:
                        value=map_min[args[1][0]]
                        if is_number(args[0][0])==True:
                            new_value=int(args[0][0])
                            if value>new_value:
                                map_max[args[1][0]]=new_value
                    else:
                        new_value=int(args[0][0])
                        map_max[args[1][0]]=new_value
            elif op=='<=':
                if '__VERIFIER_nondet_' in args[0][0]:
                    if args[0][0] in map_max:
                        value=map_max[args[0][0]]
                        if is_number(args[1][0])==True:
                            new_value=int(args[1][0])
                            if value>new_value:
                                map_max[args[0][0]]=new_value
                    else:
                        new_value=int(args[1][0])
                        map_max[args[0][0]]=new_value
                        
                elif '__VERIFIER_nondet_' in args[1][0]:
                    if args[1][0] in map_min:
                        value=map_min[args[1][0]]
                        if is_number(args[0][0])==True:
                            new_value=int(args[0][0])
                            if value<new_value:
                                map_min[args[1][0]]=new_value
                    else:
                        new_value=int(args[0][0])
                        map_min[args[1][0]]=new_value
            elif op=='<':
                if '__VERIFIER_nondet_' in args[0][0]:
                    
                    if args[0][0] in map_max:
                        value=map_max[args[0][0]]
                        if is_number(args[1][0])==True:
                            new_value=int(args[1][0])
                            if value>new_value:
                                map_max[args[0][0]]=new_value-1
                    else:
                        new_value=int(args[1][0])
                        map_max[args[0][0]]=new_value-1

                elif '__VERIFIER_nondet_' in args[1][0]:
                    
                    if args[1][0] in map_min:
                        value=map_min[args[1][0]]
                        if is_number(args[0][0])==True:
                            new_value=int(args[0][0])
                            if value<new_value:
                                map_min[args[1][0]]=new_value+1
                    else:
                        new_value=int(args[0][0])
                        map_min[args[1][0]]=new_value+1
            elif op=='>':
                if '__VERIFIER_nondet_' in args[0][0]:
                    if args[0][0] in map_min:
                        value=map_min[args[0][0]]
                        if is_number(args[1][0])==True:
                            new_value=int(args[1][0])
                            if value<new_value:
                                map_min[args[0][0]]=new_value+1
                    else:
                        new_value=int(args[1][0])
                        map_min[args[0][0]]=new_value+1
                elif '__VERIFIER_nondet_' in args[1][0]:
                    if args[1][0] in map_max:
                        value=map_max[args[1][0]]
                        if is_number(args[0][0])==True:
                            new_value=int(args[0][0])
                            if value>new_value:
                                map_max[args[1][0]]=new_value-1
                    else:
                        new_value=int(args[0][0])
                        map_max[args[1][0]]=new_value+1
            elif op=='==':
                if '__VERIFIER_nondet_' in args[0][0]:
                    if args[1][0] in map_min:
                        value=map_min[args[1][0]]
                        if is_number(args[1][0])==True:
                            map_min[args[1][0]]=new_value
                    else:
                        if is_number(args[1][0])==True:
                            new_value=int(args[1][0])
                            map_min[args[0][0]]=new_value

                elif '__VERIFIER_nondet_' in args[1][0]:
                    if args[1][0] in map_min:
                        value=map_min[args[0][0]]
                        if is_number(args[0][0])==True:
                            map_min[args[0][0]]=new_value
                    else:
                        if is_number(args[0][0])==True:
                            new_value=int(args[0][0])
                            map_min[args[1][0]]=new_value

                

            else:
                for x in args:
                    expr4extractValueAxoim(x,map_max,map_min)
        else:
            for x in args:
                expr4extractValueAxoim(x,map_max,map_min)
















def get_conditions_tactic8(e,condition_map):
        if e[:1]==['ite']:
                argument=expr_args(e)
                cond_key=expr2string1(argument[0])
                if 'ite' not in cond_key :
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(argument[0],var_cstr_map)
                    isQuantified=qualifier_list(var_cstr_map.keys())
                    if isQuantified is None:
                        condition_map[cond_key]=argument[0]
                else:
                    get_conditions_tactic8(argument[0],condition_map)
        	get_conditions_tactic8(argument[1],condition_map)
                get_conditions_tactic8(argument[2],condition_map)
        elif e[:1]==['implies']:
                argument=expr_args(e)
                cond_key=expr2string1(argument[0])
                if 'ite' not in cond_key:
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(argument[0],var_cstr_map)
                    isQuantified=qualifier_list(var_cstr_map.keys())
                    if isQuantified is None:
                        condition_map[cond_key]=argument[0]
                else:
                    get_conditions_tactic8(argument[0],condition_map)
        	get_conditions_tactic8(argument[1],condition_map)
        else:
        	for x in expr_args(e):
                    get_conditions_tactic8(x,condition_map) 






def get_conditions_all(e,condition_map):
        
        if e[:1]==['ite']:
                argument=expr_args(e)
                cond_key=expr2string1(argument[0])
                if 'ite' not in cond_key :
                    condition_map[cond_key]=argument[0]
                else:
                    get_conditions_all(argument[0],condition_map)
        	get_conditions_all(argument[1],condition_map)
                get_conditions_all(argument[2],condition_map)

def get_conditions_and_part(e):
        if e[:1]==['or']:
                argument=expr_args(e)
        	result = get_conditions_and_part(argument[0])
                if result is not None:
                    return result
                result = get_conditions_and_part(argument[1])
                if result is not None:
                    return result

        elif e[:1]==['and']:
            return e
        return None




def get_conditions_approximate(e,condition_map):
        
        if e[:1]==['ite']:
                argument=expr_args(e)
                cond_key=expr2string1(argument[0])
                if 'ite' not in cond_key :
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(argument[0],var_cstr_map)
                    isQuantified=qualifier_list(var_cstr_map.keys())
                    if isQuantified is not None:
                        condition_map[cond_key]=argument[0]
                else:
                    get_conditions_approximate(argument[0],condition_map)
        	get_conditions_approximate(argument[1],condition_map)
                get_conditions_approximate(argument[2],condition_map)
        elif e[:1]==['implies']:
                argument=expr_args(e)
                cond_key=expr2string1(argument[0])
                if 'ite' not in cond_key:
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(argument[0],var_cstr_map)
                    isQuantified=qualifier_list(var_cstr_map.keys())
                    if isQuantified is not None:
                        condition_map[cond_key]=argument[0]
                else:
                    get_conditions_approximate(argument[0],condition_map)
        	get_conditions_approximate(argument[1],condition_map)
        else:
        	for x in expr_args(e):
                    get_conditions_approximate(x,condition_map) 






def simplify_ind_equation_tactic8(e,con_e):
        if e[:1]==['ite']:
        	temp=[]
                argument=expr_args(e)
        	for x in argument:
        		parameter=simplify_ind_equation_tactic8(x,con_e)
        		temp.append(parameter)
        	if argument[0]==con_e:
        		return argument[1]
        	else:
        		return e[:1]+temp
        elif e[:1]==['implies']:
                temp=[]
                argument=expr_args(e)
        	for x in argument:
        		parameter=simplify_ind_equation_tactic8(x,con_e)
        		temp.append(parameter)
                if argument[0]==con_e:
        		return argument[1]
        	else:
        		return e[:1]+temp
        
        else:
        	return e[:1]+list(simplify_ind_equation_tactic8(x,con_e) for x in expr_args(e))


def simplify_ind_condition_tactic8(e,vfact):
        if e[:1]==['ite']:
        	temp=[]
                argument=expr_args(e)
        	for x in argument:
        		parameter=simplify_ind_condition_tactic8(x,vfact)
        		temp.append(parameter)
                temp_conl=[]
                temp_conl.append('c1')
                temp_conl.append(argument[0])
        	status=query2z3_cond([],wff2z3_update(temp_conl),vfact)
        	if 'Successfully Proved' in status:
        		return argument[1]
        	else:
        		return e[:1]+temp
        elif e[:1]==['implies']:
                temp=[]
                argument=expr_args(e)
        	for x in argument:
        		parameter=simplify_ind_condition_tactic8(x,vfact)
        		temp.append(parameter)
                temp_conl=[]
                temp_conl.append('c1')
                temp_conl.append(argument[0])
                status=query2z3_cond([],wff2z3_update(temp_conl),vfact)
                if 'Successfully Proved' in status:
        		return argument[1]
        	else:
        		return e[:1]+temp
        
        else:
        	return e[:1]+list(simplify_ind_condition_tactic8(x,vfact) for x in expr_args(e))





def simplify_ind_condition_tactic8(e,vfact):
        if e[:1]==['ite']:
        	temp=[]
                argument=expr_args(e)
        	for x in argument:
        		parameter=simplify_ind_condition_tactic8(x,vfact)
        		temp.append(parameter)
                temp_conl=[]
                temp_conl.append('c1')
                temp_conl.append(argument[0])
        	status=query2z3_cond([],wff2z3_update(temp_conl),vfact)
        	if 'Successfully Proved' in status:
        		return argument[1]
        	else:
        		return e[:1]+temp
        elif e[:1]==['implies']:
                temp=[]
                argument=expr_args(e)
        	for x in argument:
        		parameter=simplify_ind_condition_tactic8(x,vfact)
        		temp.append(parameter)
                temp_conl=[]
                temp_conl.append('c1')
                temp_conl.append(argument[0])
                status=query2z3_cond([],wff2z3_update(temp_conl),vfact)
                if 'Successfully Proved' in status:
        		return argument[1]
        	else:
        		return e[:1]+temp
        
        else:
        	return e[:1]+list(simplify_ind_condition_tactic8(x,vfact) for x in expr_args(e))


def simplify_ind_condition_else(e):
        if e[:1]==['ite']:
        	temp=[]
                argument=expr_args(e)
                if argument[-1][:1]==['ite']:
                    return simplify_ind_condition_else(argument[-1])
                else:
                    return argument[-1]
        return None



def isNonDeterFunPresent(e):
        if e[:1]==['ite']:
        	temp=[]
                argument=expr_args(e)
                if argument[0][:1]==['ite']:
                    if isNonDeterFunPresent(argument[0])==True:
                        return True
                    
                if argument[1][:1]==['ite']:
                    if isNonDeterFunPresent(argument[1])==True:
                        return True
                else:
                    exp=expr2string1(argument[1])
                    if '__VERIFIER_nondet' in exp:
                        return True
                    
                if argument[2][:1]==['ite']:
                    return isNonDeterFunPresent(argument[2])
                else:
                    exp=expr2string1(argument[2])
                    if '__VERIFIER_nondet' in exp:
                        return True
        else:
            exp=expr2string1(e)
            if '__VERIFIER_nondet' in exp:
                return True

        return False






def update_assertion(axiom,witnessXml):
        global fun_call_map
	pre_condition=[]
	post_condition=[]
        constraint_list=[]
        condition_map={}
        update_equation=[]
        
        small_macro_eq=[]
        
        
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
	
        if axiom.getAsserts() is not None:
            str_value,word=axiom.getAsserts()
        
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())

	subs_list=eqset2subs_list(axiom.getOutput_equations())
        for x in axiom.getOutput_equations():
            if axiom.getOutput_equations()[x][1][0]!='main':
                getAllCondtion_tactic8(axiom.getOutput_equations()[x],condition_map)
	for x in out_axioms:
		constraint_list.append(x)
        if len(condition_map)==1:
            for x in condition_map:
                temp_temp=[]
                temp_temp.append('s0')
                temp_temp.append(condition_map[x])
                constraint_list.append(wff2z3_update(temp_temp))

	for x in axiom.getOther_axioms(): 
        	equations=wff2z3_update(x)
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        if simplify(equations)!=False:
                            constraint_list.append(equations)
                    else:
                        constraint_list.append(equations)
                else:
                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in axiom.getConstraints():
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
	
        for x in axiom.getOther_axioms():
            if x[0]=='s0':
                if x[-1][0]=='>=' or x[-1][0]=='<=':
                    if isMacroPresent(expr2string1(x[-1][1]),axiom.getConst_var_map().values())==True:
                        #print constraint_list
                        x_new=copy.deepcopy(x)
                        x_new[-1][0]='=='
                        status=query2z3_cond(constraint_list,wff2z3_update1(x_new,axiom.getConst_var_map()),axiom.getVfact())
                        if 'Successfully' in status:
                                expression=expr2string1(x_new[-1][1])+"="+str(simplify(expr2string1(x_new[-1][2])))
				fun_call_map={}
				parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+expression+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                #assertion[-1]=expr_replace(assertion[-1],expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue))),expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue))))
                                result_list=[]
                                result_list.append(expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue))))
                                result_list.append(expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue))))
                                small_macro_eq.append(result_list)

        return small_macro_eq
    
    
    
    
def update_assertion1(axiom,witnessXml,inst_other_axioms,inst_output_equations):
        global fun_call_map
	pre_condition=[]
	post_condition=[]
        constraint_list=[]
        condition_map={}
        update_equation=[]
        
        small_macro_eq=[]
        
        
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
	

	str_value,word=axiom.getAsserts()
        
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(inst_output_equations)

	subs_list=eqset2subs_list(inst_output_equations)
        for x in axiom.getOutput_equations():
            if axiom.getOutput_equations()[x][1][0]!='main':
                getAllCondtion_tactic8(inst_output_equations[x],condition_map)
	for x in out_axioms:
		constraint_list.append(x)
        if len(condition_map)==1:
            for x in condition_map:
                temp_temp=[]
                temp_temp.append('s0')
                temp_temp.append(condition_map[x])
                constraint_list.append(wff2z3_update(temp_temp))

	for x in inst_other_axioms: 
        	equations=wff2z3_update(x)
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        if simplify(equations)!=False:
                            constraint_list.append(equations)
                    else:
                        constraint_list.append(equations)
                else:
                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in axiom.getConstraints():
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
	
        for x in inst_other_axioms:
            if x[0]=='s0':
                if x[-1][0]=='>=' or x[-1][0]=='<=':
                    if isMacroPresent(expr2string1(x[-1][1]),axiom.getConst_var_map().values())==True:
                        #print constraint_list
                        x_new=copy.deepcopy(x)
                        x_new[-1][0]='=='
                        status=query2z3_cond(constraint_list,wff2z3_update1(x_new,axiom.getConst_var_map()),axiom.getVfact())
                        if 'Successfully' in status:
                                expression=expr2string1(x_new[-1][1])+"="+str(simplify(expr2string1(x_new[-1][2])))
				fun_call_map={}
				parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+expression+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                #assertion[-1]=expr_replace(assertion[-1],expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue))),expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue))))
                                result_list=[]
                                result_list.append(expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue))))
                                result_list.append(expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue))))
                                small_macro_eq.append(result_list)

        return small_macro_eq
    

def isMacroPresent(value,Const_var_map):
    for x in Const_var_map:
        if simplify(x)==simplify(value):
            return True
    return False





def prove_assert_tactic9(axiom,witnessXml):
    
    small_macro_eq = update_assertion(axiom,witnessXml)
    
    #print '####################'
    
    #print small_macro_eq
    
    #print '####################'
    
    str_value,word=axiom.getAsserts() 
    
    size_before=-1
    size_after=0

    
    
    pre_condition=[]
    post_condition=[]
    
    if len(small_macro_eq)>0:
        inst_word=copy.deepcopy(word)
        inst_other_axioms=copy.deepcopy(axiom.getOther_axioms())
        inst_output_equations=copy.deepcopy(axiom.getOutput_equations())
        
        size_before=len(inst_other_axioms)
        
        for y in small_macro_eq:
            for x in inst_other_axioms:
                if x[0]=='i1':
                    x[-1]=expr_replace(x[-1],y[1],y[0])
        f,inst_output_equations,inst_other_axioms,cm,inst_word = rec_solver_tactic8(axiom.getFrame_axioms(),inst_output_equations,inst_other_axioms,inst_word)
        
        size_after=len(inst_other_axioms)
        
        post_condition.append(wff2z3_update1(inst_word,axiom.getConst_var_map()))
        
        
        for w in axiom.getAssumes():
            if w[0]=='i1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'i1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
            elif w[0]=='c1':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'c1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
            else:
                if w[0]!='i0':
                    var_cstr_map={}
                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                    list_var_str=qualifier_list(var_cstr_map.keys())
                    list_cstr_str=cstr_list(var_cstr_map.values())
                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    if list_var_str is not None and list_cstr_str is not None:
                        if w[0] == 'i1':
                            pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                        else:
                            pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                    else:
                        pre_condition.append(rhs)
                        
        if size_before!=size_after:
            for x in post_condition:
                #print('\nAssertion To Prove:'+x)
                temp_post_condition=[]
                temp_post_condition.append(x)
                if post_condition is not None:
                    start_time=current_milli_time()
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                    status=tactic1_update(f,inst_output_equations,inst_other_axioms,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
                    #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                    if "Successfully Proved" in status:
                        return "Successfully Proved"			
                    elif "Counter Example" in status:
                        return status
                    else:
                        return "Failed to Prove"
        else:
            return "Failed to Prove"
    else:

        return "Failed to Prove"


def prove_assert_tactic10(axiom,witnessXml):
    p_condition,word = axiom.getAsserts()
    new_word = copy.deepcopy(word)
    small_macro_eq = update_assertion(axiom,witnessXml)
    for y in small_macro_eq:
        new_word[-1]=expr_replace(new_word[-1],y[0],y[1])
    new_axiom = copy.deepcopy(axiom)
    if new_word!=word:
        new_axiom.setAsserts((p_condition,new_word))
        status=prove_assert_tactic2(new_axiom,witnessXml)
        if "Successfully Proved" in status:
            return "Successfully Proved"
        else:
            return "Failed to Prove"
    else:
        return "Failed to Prove"
    
def prove_assert_tactic11(axiom,witnessXml):
    small_macro_sub=[]
    new_axiom = copy.deepcopy(axiom)
    update_axioms=[]
    for x in new_axiom.getOther_axioms():
        if x[0]=='s1':
            if x[1][2][0]=='<' and str(simplify(expr2string1(x[1][2][1]))) in axiom.getConst_var_map().keys():
                list_info=[]
                list_info.append(eval("['"+str(simplify(expr2string1(x[1][2][1])))+"']"))
                list_info.append(x[1][2][2])
                small_macro_sub.append(list_info)
    for x in new_axiom.getOther_axioms():
        if x[0]=='s1':
            flag=False
            for y in small_macro_sub:
                if expr_find(x[1][1][2],y[0])==True:
                    x_new = copy.deepcopy(x)
                    x_new[1][2] = expr_replace(x_new[1][2],y[0],y[1])
                    flag=True
            if flag==True:
                update_axioms.append(x_new)
        update_axioms.append(x)
    if update_axioms==new_axiom.getOther_axioms():
        return "Failed to Prove"
    else:
        new_axiom.setOther_axioms(update_axioms)
        status=prove_assert_tactic1(new_axiom,witnessXml)
        if "Successfully Proved" in status:
            return "Successfully Proved"
        else:
            return "Failed to Prove"
        





def simplifyAxioms(e):
    if e[0]=='ite':
        arg_list=expr_args(e)
        e1=None
        e2=None
        if arg_list[1][0]=='ite':
            e1=simplifyAxioms(arg_list[1])
        else:
            e1=arg_list[1]
        if arg_list[2][0]=='ite':
            e2=simplifyAxioms(arg_list[2])
        else:
            e2=arg_list[1]
        if  e1 is not None  and e2 is not None and e1==e2:
            return e1
        else:
            return e
    else:
        return e[:1]+list(simplifyAxioms(x) for x in expr_args(e))







def updateAssumption(e,map_condtion):
    if e[0]=='ite':
        arg_list=expr_args(e)
        map_condtion[expr2string1(arg_list[0])]=arg_list[0]
        if arg_list[1][0]=='ite':
            updateAssumption(arg_list[1],map_condtion) 
        else:
            if expr2string1(arg_list[1]).strip()!='0':
                map_condtion[expr2string1(arg_list[1])]=arg_list[1]
        if arg_list[1][0]=='ite':
            updateAssumption(arg_list[2],map_condtion) 
        else:
            if expr2string1(arg_list[2]).strip()!='0':
                map_condtion[expr2string1(arg_list[2])]=arg_list[2]























#New array prove method 

def prove_assert_tactic4_update1(axiom,witnessXml):
        global fun_call_map

        condition_list=[]

	array_fun_map={}
        
        array_fun_map_query={}
        
        array_fun_map_parameter={}
	
	array_var_map={}
        
        #Array Variables Basecase Value Map
        
        array_var_base_map={}
        
	post_condition={}
	
        array_degree_map={}
	
	array_list=[]
	
	counter_var_list=[]
	
	instant_eq=[]
	
	t_instant_eq=[]
	
	addition_eq=[]
        
        more_addition_eq=[]
	
	o_instant_eq={}
	
	call_var_list=[]
	
	array_fun=None
	
	array_init_map={}
	
	#Base Cases Query List
	
	base_case_query=[]
	       
	#Conclusions Query List
	
	conl_case_query=[]
	 
	#List of Assumptions
	 
	assum_list=[]
	
	#Variable Constant Map
	       
        var_const_map={}
	
	#List of Constraints Derived from Axoims 
	
	constraint_list=[]
	
	#Elements Return by Recursive Function 
	
	assum_list_ret=None
	
	conl_case_query_ret=None
	
	var_const_map_ret=None
	
	pre_condition=[]
	
	#Additional Equation
	
	add_equation_d=[]
	
	#main free variable map
	
	main_free_var_map={}
	
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
		
	str_value,word=axiom.getAsserts()
	
	for variable in axiom.getVariables():
            variableclass=axiom.getVariables()[variable]
            if variableclass.getDimensions() is not None:
                array_degree_map[variable]=len(variableclass.getDimensions())
            else:
                array_degree_map[variable]=0
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
	#for x in out_axioms:
	#	constraint_list.append(x)
	
	
	for x in axiom.getOutput_equations():
		if isArrayFunction(x)==True:
			array_fun =  copy.deepcopy(axiom.getOutput_equations()[x][1])
			array_fun[0] = x
			array_init_map[x[1]]=array_fun
			

	
	for [x,k,l] in axiom.getVfact():
		if k==0 and l[0]=='array' and isArrayFinal(x)==False and not(x=='main'):
                        if x in array_degree_map.keys() and str(array_degree_map[x]) in array_init_map.keys():
                            array_list.append(x)
                            #array_fun_map[x]=array_init_map[str(array_degree_map[x])]
        var_list=axiom.getConst_var_map().keys()
         
        f_count=0
        for x in axiom.getOutput_equations():
        	if isArrayFunction(x):
        		var_e1=eval("['_x1']")
        		for e_array in array_list:
        			if axiom.getOutput_equations()[x][1][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_x1 = copy.deepcopy(axiom.getOutput_equations()[x])
        				var_array=eval("['"+e_array+"']")
        				f_count=f_count+1
        				new_x1[1]=expr_replace(new_x1[1],var_e1,var_array)
        				new_x1[2]=expr_replace(new_x1[2],var_e1,var_array)
        				o_instant_eq[x+'_'+str(f_count)]=new_x1
		else:
			o_instant_eq[x]=axiom.getOutput_equations()[x]
                        
        for e in axiom.getOther_axioms():
        	if e[0]=='i0' and isArrayFunction(e[2][0]):
        		for e_array in array_list:
                                if e[2][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_e1 = copy.deepcopy(e)
					var_e1=eval("['_x1']")
        				var_array=eval("['"+e_array+"']")
        				new_e1[2]=expr_replace(new_e1[2],var_e1,var_array)
        				new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                        new_e1[3]=simplify_ind_equation(new_e1[3],array_list)
                                        if e_array not in array_fun_map.keys() and '_n' not in expr2string1(new_e1[3]):
                                            array_fun_map[e_array]=new_e1[3]
                                        array_var_base_map[expr2string1(new_e1[2])]=new_e1[3]
        				instant_eq.append(new_e1)        	
        	elif e[0]=='i1' and isArrayFunction(e[3][0]):
          		for e_array in array_list:
                                if e[3][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
            		      		new_e1 = copy.deepcopy(e)
			        	status,array_value=findArrayInEq(new_e1[4],array_list)
                                        status=findArrayInEqSp(new_e1[4],e_array)
                                        if status==True:
                                            array_value=e_array
			        	if array_value is not None:
        					inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
        				var_e1=eval("['_x1']")
         				var_array=eval("['"+e_array+"']")
        				if e_array==array_value:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						free_var_map={}
                                                getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)
                                                if not free_var_map:
                                                    new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),var_e1,var_array)
                                                else:

                                                    new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),var_e1,var_array)
						new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
						for f_var in free_var_map.keys():
							new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
							new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
						instant_eq.append(new_e1)
					else:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
			        		instant_eq.append(new_e1)
        	else:
        		instant_eq.append(e)


        update_facts=copy.deepcopy(axiom.getVfact())
        
        array_fun_map_query = copy.deepcopy(array_fun_map)

        Super_Couter=0
        
        G_dgree=None
        

        for e in axiom.getOutput_equations():
            element=axiom.getOutput_equations()[e]
            if isArrayFunction(element[1][0]):
                getAllCondtionArray(element,condition_list)
        for e in condition_list:
            var_cstr_map={}
            pre_condition.append(expr2z3_update_postCond(e,var_cstr_map))
            
        for e in axiom.getOther_axioms():
        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list and (G_dgree is None or e[3][0][1]==G_dgree):
                                if G_dgree is None:
                                	G_dgree=e[3][0][1]
        			var=e[2]
        			const_var=e[2].replace('n','k')
        			update_facts.append(eval("['"+const_var+"',0,['int']]"))
        			constraint_list.append(const_var+">=0")
                                
                                fun_call_map={}
                                parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                constant=eval(expressionCreator_C(statement_temp))
                                
        			
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
        					
        			new_e = copy.deepcopy(e)
                                
                                ins_array_lsit=[]
                                
                                ins_array_lsit = findArrayInEqlist(new_e[4],array_list,ins_array_lsit)
                                
                                flag=False
                                
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
                                                
                                query_ret_list=None
                                
                                var_const_map_ret=None
                                
        			if flag:
                                        query_ret_list,var_const_map_ret = prove_assert_tactic4_update1_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map,array_degree_map)

                                #Add1
                                constraint_list1=copy.deepcopy(constraint_list)
        			if query_ret_list is not None:
                                    for query_ret in query_ret_list:
                                        for ret_e_array in query_ret:
                                            constraint_list1.append(wff2z3_update(query_ret[ret_e_array][1]))
                                    for l_variable in var_const_map_ret:
                                        update_facts.append(eval("['"+var_const_map_ret[l_variable]+"',0,['int']]"))
                                        constraint_list1.append(var_const_map_ret[l_variable]+">=0")
        			#	for query_ret in query_ret_list:
        			#		if query_ret is not None:
                                #        		for e_array in query_ret.keys():
                                #            			constraint_list1.append(wff2z3_update(query_ret[e_array][2]))

                                array_fun_map_temp={}
                                

                                for e_array in array_list:
                                    
                                        if e_array in array_fun_map.keys() and e[3][0][1]==str(array_degree_map[e_array]):
                                            
                                                new_e1 = copy.deepcopy(e)
                                                
                                                new_e2 = copy.deepcopy(new_e1)
                                                
                                                new_e3 = copy.deepcopy(new_e1)
                                                
                                                
                                                inst_str=eval("['=',['_x1'],['"+str(e_array)+"']]")
                                                
						new_e1[3]=expr_replace(new_e1[3],eval("['_x1']"),eval("['"+e_array+"']"))
                                                
						free_var_map={}
                                                
                                           
                                                
                                                getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)

                                                if not free_var_map:
                                                    
                                                    new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                else:

                                                    new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
						new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                                

                                                if e_array in ins_array_lsit:
                                                    for f_var in free_var_map.keys():
                                                            new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])

                                                array_fun_map_temp[e_array]=expr_update_iter(new_e1[4],array_fun_map)

                                                if e_array in ins_array_lsit:
                                                    parameter_list=[]
                                                    for x in range(2, int(e[3][0][1])+2):
                                                        parameter_list.append(new_e1[3][x])
                                                    array_fun_map_parameter[e_array]=parameter_list
                                                new_e_left=expr_replace(copy.deepcopy(new_e1[3]),eval("['+',['"+var+"'],['1']]"),constant)
                                                if e_array in array_fun_map_parameter.keys():
                                                    for x in range(2, int(e[3][0][1])+2):
                                                        new_e_left[x]=array_fun_map_parameter[e_array][x-2]
                                                new_e2[3]=new_e_left
                                                new_e2[4]=array_fun_map_temp[e_array]
                                                
                                                index_var_map={}
                                                
                                                
                                                getIndexVaribles(new_e2[4],index_var_map)
                                                
                                                #print '%%%%%%%%%%%%%%%%%%%%%%%%%'
                                                #print index_var_map
                                                #print '%%%%%%%%%%%%%%%%%%%%%%%%%'
                                                
                                                if not free_var_map:
                                                    new_e2[4] = expr_modify_array(new_e2[4],inst_str,free_var_map)
                                                
                                                var_e1=eval("['_x1']")
                                                #new_e3[3] = copy.deepcopy(new_e2[3])
                                                new_e3[4] = expr_prime(copy.deepcopy(new_e2[4]),expr_replace(copy.deepcopy(new_e3[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1)
                                                new_e3[3] = copy.deepcopy(new_e2[3])
                                                
                                                
                                                more_addition_eq.append(new_e2)
                                                instant_eq.append(new_e2)
                                                more_addition_eq.append(new_e3)
                                                add_equation_d.append(new_e2)
                                                
                                                
                                                #getAllFreeVariable(x,e1,free_var_map)
                                
                                
                                for x in array_fun_map_temp:
                                        array_fun_map[x]=array_fun_map_temp[x]
                                if query_ret_list is not None:
                                    for query_ret in query_ret_list:
                                        for ret_e_array in query_ret:

                                            ret_new_e1 = copy.deepcopy(query_ret[ret_e_array][0])
                                            ret_new_e2 = copy.deepcopy(query_ret[ret_e_array][0])
                                            ret_new_e3 = copy.deepcopy(query_ret[ret_e_array][0])
                                            
                                            #update_facts.append(eval("['"+query_ret[ret_e_array][3]+"',0,['int']]"))
                                            #constraint_list1.append(const_var+">=0")
                                            
                                            fun_call_map={}
                                            ast = parser.parse("void test(){"+axiom.getConst_var_map()[ret_new_e1[2]]+";}")
                                            statement_temp=ast.ext[0].body.block_items[0]
                                            constant=eval(expressionCreator_C(statement_temp))
                                            new_e_left=expr_replace(copy.deepcopy(ret_new_e1[3]),eval("['+',['"+ret_new_e1[2]+"'],['1']]"),constant)
                                            if ret_e_array in array_fun_map_parameter.keys():
                                                for x in range(2, int(e[3][0][1])+2):
                                                    new_e_left[x] = array_fun_map_parameter[ret_e_array][x-2]
                                            ret_new_e2[3]=new_e_left
                                            ret_new_e2[4]=expr_update_iter(ret_new_e1[4],array_fun_map)
                                            
                                            var_e1=eval("['_x1']")
                                            #new_e3[3] = copy.deepcopy(new_e2[3])
                                            ret_new_e3[4] = expr_prime(copy.deepcopy(ret_new_e2[4]),expr_replace(copy.deepcopy(ret_new_e3[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1)
                                            ret_new_e3[3] = copy.deepcopy(ret_new_e2[3])
                                            
                                            
                                            more_addition_eq.append(ret_new_e2)
                                            instant_eq.append(ret_new_e2)
                                            more_addition_eq.append(ret_new_e3)
                                            add_equation_d.append(ret_new_e2)
                                            
                                            
        #return "Failed to prove"
	post_condition[str_value]=word
	for postcondition in post_condition.keys():
                #print '=====================Main Proving Process====================='
                for x in axiom.getConstraints():
                    constraint_list.append(x)
                new_instant_eq = copy.deepcopy(instant_eq)
                for e in more_addition_eq:
                    new_instant_eq.append(e)
		#print '\nAxiomes Added\n'
                print_map={}
		for e in more_addition_eq:
                        print_map[wff2string1(e)]= wff2string1(e)
                #for e in print_map:
		#	print e
                        
		temp_post_condition=[]

		#print '\n'
		#temp_post_condition.append(wff2z3_update(post_condition[postcondition]))
                if post_condition[postcondition][0]=='s0':
                    post_condition[postcondition][0]='c1'
                
                
                
                #temp_post_condition.append(wff2z3_update_postCond(post_condition[postcondition]))
                
                
                temp_post_condition.append(wff2z3_update4(post_condition[postcondition],axiom.getVariables(),axiom.getConst_var_map()))
		
		writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
		writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(post_condition[postcondition])+'\n')
	
                status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,new_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)	
 
		#status=tactic4_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,axiom.getVariables(),axiom.getConst_var_map(),witnessXml)	
                
                #coment on 16/11/2017
                
                #status=tactic4_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,axiom.getVariables(),axiom.getConst_var_map(),witnessXml)	

                #print status
                
                return status
                
                #status="Failed To prove"
                writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                
                #print '=============================================================='
                if 'Successfully Proved' not in status:
                    status=prove_assert_tactic5(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)
                    print '----1'
                    print status
                    if status is None:
                        status=prove_assert_tactic12(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)
                        print '----2'
                        print status
                        if status is None or "Failed to prove" in status:
                            return "Failed to prove"
                        else:
                            return status
                    elif "Failed to prove" in status:
                        status=prove_assert_tactic12(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)
                        print '----3'
                        print status
                        if status is None or "Failed to prove" in status:
                            return "Failed to prove"
                        else:
                            return status
                    else:
                        return status
                else:
                    return status


                                                




def prove_assert_tactic4_update1_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map,array_degree_map):

       var_list=axiom.getConst_var_map().keys()
       
       query_map_list=[]
       
       query_map={}
       
       base_case_query=[]
       
       conl_case_query=[]
       
       assum_list=[]
       
       var_const_map={}
       
       constraint_list=[]
       frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
       for x in frame_axioms:
       		constraint_list.append(x)
       out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
       for x in out_axioms:
		constraint_list.append(x)
       pre_condition=[]
	
       for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in lhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
       
                 
       for e in axiom.getOther_axioms():
        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list:

        			var=e[2]
        			const_var=e[2].replace('n','k')
                                var_const_map[var]=const_var

                                
                                #p = getParser()
                                #tree = p.parse_expression(axiom.getConst_var_map()[var])
        			#constant=eval(expressionCreator(tree))
                                
                                parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                constant=eval(expressionCreator_C(statement_temp))
                                
                                
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True

        			if not flag:
                                	new_e = copy.deepcopy(e)
					status,array_value=findArrayInEq(e[4],array_list)	
					#instantiated the array value
					if array_value is not None:
						inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
					 
					
					for e_array in array_list:
                                            
                                            
                                                if e_array in array_fun_map.keys() and e[3][0][1]==str(array_degree_map[e_array]):
                                            
                                                    #get Initial Array values
                                                    array_fun=array_fun_map[e_array]
                                                    #List of queries
                                                    quary_list=[]
                                                    # Construct Variable Array
                                                    var_e1=eval("['_x1']")
                                                    # Construct Array
                                                    var_array=eval("['"+e_array+"']")
                                                    #Get the copy of the equation
                                                    new_e1 = copy.deepcopy(e)
                                                    
                                                    new_e2 = copy.deepcopy(new_e1)
                                                    
                                                    new_e3 = copy.deepcopy(new_e1)
                                                    
                                                    new_e3[4] = array_fun_map[e_array]
                                                    
                                                
                                                    inst_str=eval("['=',['_x1'],['"+str(e_array)+"']]")
                                                
                                                    new_e1[3]=expr_replace(new_e1[3],eval("['_x1']"),eval("['"+e_array+"']"))
                                                
                                                    free_var_map={}
                                                
                                                    getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)

                                                    if not free_var_map:
                                                    
                                                        new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                    else:

                                                        new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                    new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                                    
                                                    new_e3[3]=expr_replace(new_e3[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
                                                    
                                                    
                                                    new_e3[3]=expr_replace(new_e3[3],eval("['"+var+"']"),eval("['"+const_var+"']"))
                                                    

                                                    query_list=[]

                                                    query_list.append(new_e1)
                                                    
                                                    query_list.append(new_e3)
                                                    
                                                    query_list.append(var)
                                                    
                                                    query_list.append(const_var)
                                                    
                                                    query_list.append(constant)
                                                    
                                                    query_map[e_array]=query_list
                        
                                        query_map_list.append(query_map)
                                	return query_map_list,var_const_map
        			else:
        				#print 'XXXXX-XXXXX'
                                        #print main_free_var_map
        				query_map_list_temp,var_const_map_temp=prove_assert_tactic4_update1_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map,array_degree_map)
       			       				
        				#for query_ret in query_map_list_temp:
					#	if query_ret is not None:
					#        	for e_array in query_ret.keys():
                                        #    			constraint_list.append(wff2z3_update(query_ret[e_array][2]))
        				for var_const_temp in var_const_map_temp.keys():
        					var_const_map[var_const_temp]=var_const_map_temp[var_const_temp]
                                                
                                	update_facts=copy.deepcopy(axiom.getVfact())
                                        
                                        for e_array in array_list:
                                            if e_array in array_fun_map.keys() and e[3][0][1]==str(array_degree_map[e_array]):
                                                    #get Initial Array values
                                                    array_fun=array_fun_map[e_array]
                                                    #List of queries
                                                    quary_list=[]
                                                    # Construct Variable Array
                                                    var_e1=eval("['_x1']")
                                                    # Construct Array
                                                    var_array=eval("['"+e_array+"']")
                                                    #Get the copy of the equation
                                                    new_e1 = copy.deepcopy(e)
                                                    
                                                    new_e2 = copy.deepcopy(new_e1)
                                                    
                                                    new_e3 = copy.deepcopy(new_e1)
                                                    
                                                    new_e3[4] = array_fun_map[e_array]
                                                
                                                
                                                    inst_str=eval("['=',['_x1'],['"+str(e_array)+"']]")
                                                
                                                    new_e1[3]=expr_replace(new_e1[3],eval("['_x1']"),eval("['"+e_array+"']"))
                                                
                                                    free_var_map={}
                                                
                                                    getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)

                                                    if not free_var_map:
                                                    
                                                        new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                    else:

                                                        new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                    new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                                    
                                                    new_e3[3]=expr_replace(new_e1[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
                                                    
                                                    new_e3[3]=expr_replace(new_e1[3],eval("['"+var+"']"),eval("['"+const_var+"']"))
                                                    
                                                    query_list=[]
                                                    
                                                    query_list.append(new_e1)
                                                    
                                                    query_list.append(new_e3)
                                                    
                                                    query_list.append(var)
                                                    
                                                    query_list.append(const_var)
                                                    
                                                    query_list.append(constant)
                                                    
                                                    query_map[ e_array]=query_list
                                                    
                                        for x in query_map_list_temp:
                                            query_map_list.append(x)
                                                    
                                        query_map_list.append(query_map)

        				return query_map_list,var_const_map				
       return None,None			




def prove_assert_tactic4_update2(axiom,witnessXml):
        global fun_call_map

        condition_list=[]

	array_fun_map={}
        
        array_fun_map_query={}
        
        array_fun_map_parameter={}
	
	array_var_map={}
        
        #Array Variables Basecase Value Map
        
        array_var_base_map={}
        
	post_condition={}
	
        array_degree_map={}
	
	array_list=[]
	
	counter_var_list=[]
	
	instant_eq=[]
	
	t_instant_eq=[]
	
	addition_eq=[]
        
        more_addition_eq=[]
	
	o_instant_eq={}
	
	call_var_list=[]
	
	array_fun=None
	
	array_init_map={}
	
	#Base Cases Query List
	
	base_case_query=[]
	       
	#Conclusions Query List
	
	conl_case_query=[]
	 
	#List of Assumptions
	 
	assum_list=[]
	
	#Variable Constant Map
	       
        var_const_map={}
	
	#List of Constraints Derived from Axoims 
	
	constraint_list=[]
	
	#Elements Return by Recursive Function 
	
	assum_list_ret=None
	
	conl_case_query_ret=None
	
	var_const_map_ret=None
	
	pre_condition=[]
	
	#Additional Equation
	
	add_equation_d=[]
	
	#main free variable map
	
	main_free_var_map={}
	
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
		
	str_value,word=axiom.getAsserts()
	
	for variable in axiom.getVariables():
            variableclass=axiom.getVariables()[variable]
            if variableclass.getDimensions() is not None:
                array_degree_map[variable]=len(variableclass.getDimensions())
            else:
                array_degree_map[variable]=0
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
	#for x in out_axioms:
	#	constraint_list.append(x)
        sub_flag_div=False
            
        for x in axiom.getOther_axioms():
            if x[0]=='i1' and 'f2_' in x[3][0]:    
                if len(x[4])>=3 and len(x[4][1])>=3 and len(x[4][1][2])>=3 and x[4][1][2][0]=='/':
                    sub_flag_div=True
                    
        if sub_flag_div==True:
            return "Failed to prove" 

    
	
	
	for x in axiom.getOutput_equations():
		if isArrayFunction(x)==True:
			array_fun =  copy.deepcopy(axiom.getOutput_equations()[x][1])
			array_fun[0] = x
			array_init_map[x[1]]=array_fun
			

	
	for [x,k,l] in axiom.getVfact():
		if k==0 and l[0]=='array' and isArrayFinal(x)==False and not(x=='main'):
                        if x in array_degree_map.keys() and str(array_degree_map[x]) in array_init_map.keys():
                            array_list.append(x)
                            #array_fun_map[x]=array_init_map[str(array_degree_map[x])]
        var_list=axiom.getConst_var_map().keys()
         
        f_count=0
        for x in axiom.getOutput_equations():
        	if isArrayFunction(x):
        		var_e1=eval("['_x1']")
        		for e_array in array_list:
        			if axiom.getOutput_equations()[x][1][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_x1 = copy.deepcopy(axiom.getOutput_equations()[x])
        				var_array=eval("['"+e_array+"']")
        				f_count=f_count+1
        				new_x1[1]=expr_replace(new_x1[1],var_e1,var_array)
        				new_x1[2]=expr_replace(new_x1[2],var_e1,var_array)
        				o_instant_eq[x+'_'+str(f_count)]=new_x1
		else:
			o_instant_eq[x]=axiom.getOutput_equations()[x]
                        
        for e in axiom.getOther_axioms():
        	if e[0]=='i0' and isArrayFunction(e[2][0]):
        		for e_array in array_list:
                                if e[2][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_e1 = copy.deepcopy(e)
					var_e1=eval("['_x1']")
        				var_array=eval("['"+e_array+"']")
        				new_e1[2]=expr_replace(new_e1[2],var_e1,var_array)
        				new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                        new_e1[3]=simplify_ind_equation(new_e1[3],array_list)
                                        if e_array not in array_fun_map.keys() and '_n' not in expr2string1(new_e1[3]):
                                            array_fun_map[e_array]=new_e1[3]
                                        array_var_base_map[expr2string1(new_e1[2])]=new_e1[3]
        				instant_eq.append(new_e1)        	
        	elif e[0]=='i1' and isArrayFunction(e[3][0]):
          		for e_array in array_list:
                                if e[3][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
            		      		new_e1 = copy.deepcopy(e)
			        	status,array_value=findArrayInEq(new_e1[4],array_list)
                                        status=findArrayInEqSp(new_e1[4],e_array)
                                        if status==True:
                                            array_value=e_array
			        	if array_value is not None:
        					inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
        				var_e1=eval("['_x1']")
         				var_array=eval("['"+e_array+"']")
        				if e_array==array_value:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						free_var_map={}
                                                getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)
                                                if not free_var_map:
                                                    new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),var_e1,var_array)
                                                else:

                                                    new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),var_e1,var_array)
						new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
						for f_var in free_var_map.keys():
							new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
							new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
						instant_eq.append(new_e1)
					else:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
			        		instant_eq.append(new_e1)
        	else:
        		instant_eq.append(e)


        update_facts=copy.deepcopy(axiom.getVfact())
        
        array_fun_map_query = copy.deepcopy(array_fun_map)

        Super_Couter=0
        
        G_dgree=None
        

        for e in axiom.getOutput_equations():
            element=axiom.getOutput_equations()[e]
            if isArrayFunction(element[1][0]):
                getAllCondtionArray(element,condition_list)
        for e in condition_list:
            var_cstr_map={}
            pre_condition.append(expr2z3_update_postCond(e,var_cstr_map))
            
        for e in axiom.getOther_axioms():
        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list and (G_dgree is None or e[3][0][1]==G_dgree):
                                if G_dgree is None:
                                	G_dgree=e[3][0][1]
        			var=e[2]
        			const_var=e[2].replace('n','k')
        			update_facts.append(eval("['"+const_var+"',0,['int']]"))
        			constraint_list.append(const_var+">=0")
                                
                                fun_call_map={}
                                parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                constant=eval(expressionCreator_C(statement_temp))
                                
        			
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
        					
        			new_e = copy.deepcopy(e)
                                
                                ins_array_lsit=[]
                                
                                ins_array_lsit = findArrayInEqlist(new_e[4],array_list,ins_array_lsit)
                                
                                flag=False
                                
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
                                                
                                query_ret_list=None
                                
                                var_const_map_ret=None
                                
        			if flag:
                                        query_ret_list,var_const_map_ret = prove_assert_tactic4_update1_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map,array_degree_map)

                                #Add1
                                constraint_list1=copy.deepcopy(constraint_list)
        			if query_ret_list is not None:
                                    for query_ret in query_ret_list:
                                        for ret_e_array in query_ret:
                                            constraint_list1.append(wff2z3_update(query_ret[ret_e_array][1]))
                                    for l_variable in var_const_map_ret:
                                        update_facts.append(eval("['"+var_const_map_ret[l_variable]+"',0,['int']]"))
                                        constraint_list1.append(var_const_map_ret[l_variable]+">=0")
        			#	for query_ret in query_ret_list:
        			#		if query_ret is not None:
                                #        		for e_array in query_ret.keys():
                                #            			constraint_list1.append(wff2z3_update(query_ret[e_array][2]))

                                array_fun_map_temp={}
                                

                                for e_array in array_list:
                                    
                                        if e_array in array_fun_map.keys() and e[3][0][1]==str(array_degree_map[e_array]):
                                            
                                                new_e1 = copy.deepcopy(e)
                                                
                                                new_e2 = copy.deepcopy(new_e1)
                                                
                                                new_e3 = copy.deepcopy(new_e1)
                                                
                                                
                                                inst_str=eval("['=',['_x1'],['"+str(e_array)+"']]")
                                                
						new_e1[3]=expr_replace(new_e1[3],eval("['_x1']"),eval("['"+e_array+"']"))
                                                
						free_var_map={}
                                                
                                           
                                                
                                                getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)

                                                if not free_var_map:
                                                    
                                                    new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                else:

                                                    new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
						new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                                

                                                if e_array in ins_array_lsit:
                                                    for f_var in free_var_map.keys():
                                                            new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])

                                                array_fun_map_temp[e_array]=expr_update_iter(new_e1[4],array_fun_map)

                                                if e_array in ins_array_lsit:
                                                    parameter_list=[]
                                                    for x in range(2, int(e[3][0][1])+2):
                                                        parameter_list.append(new_e1[3][x])
                                                    array_fun_map_parameter[e_array]=parameter_list
                                                new_e_left=expr_replace(copy.deepcopy(new_e1[3]),eval("['+',['"+var+"'],['1']]"),constant)
                                                if e_array in array_fun_map_parameter.keys():
                                                    for x in range(2, int(e[3][0][1])+2):
                                                        new_e_left[x]=array_fun_map_parameter[e_array][x-2]
                                                new_e2[3]=new_e_left
                                                new_e2[4]=array_fun_map_temp[e_array]
                                                
                                                index_var_map={}
                                                
                                                
                                                getIndexVaribles(new_e2[4],index_var_map)
                                                
                                                #print '%%%%%%%%%%%%%%%%%%%%%%%%%'
                                                #print index_var_map
                                                #print '%%%%%%%%%%%%%%%%%%%%%%%%%'
                                                
                                                if not free_var_map:
                                                    new_e2[4] = expr_modify_array(new_e2[4],inst_str,free_var_map)
                                                
                                                var_e1=eval("['_x1']")
                                                #new_e3[3] = copy.deepcopy(new_e2[3])
                                                new_e3[4] = expr_prime(copy.deepcopy(new_e2[4]),expr_replace(copy.deepcopy(new_e3[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1)
                                                new_e3[3] = copy.deepcopy(new_e2[3])
                                                
                                                
                                                more_addition_eq.append(new_e2)
                                                instant_eq.append(new_e2)
                                                more_addition_eq.append(new_e3)
                                                add_equation_d.append(new_e2)
                                                
                                                
                                                #getAllFreeVariable(x,e1,free_var_map)
                                
                                
                                for x in array_fun_map_temp:
                                        array_fun_map[x]=array_fun_map_temp[x]
                                if query_ret_list is not None:
                                    for query_ret in query_ret_list:
                                        for ret_e_array in query_ret:

                                            ret_new_e1 = copy.deepcopy(query_ret[ret_e_array][0])
                                            ret_new_e2 = copy.deepcopy(query_ret[ret_e_array][0])
                                            
                                            #update_facts.append(eval("['"+query_ret[ret_e_array][3]+"',0,['int']]"))
                                            #constraint_list1.append(const_var+">=0")
                                            
                                            fun_call_map={}
                                            ast = parser.parse("void test(){"+axiom.getConst_var_map()[ret_new_e1[2]]+";}")
                                            statement_temp=ast.ext[0].body.block_items[0]
                                            constant=eval(expressionCreator_C(statement_temp))
                                            new_e_left=expr_replace(copy.deepcopy(ret_new_e1[3]),eval("['+',['"+ret_new_e1[2]+"'],['1']]"),constant)
                                            if ret_e_array in array_fun_map_parameter.keys():
                                                for x in range(2, int(e[3][0][1])+2):
                                                    new_e_left[x] = array_fun_map_parameter[ret_e_array][x-2]
                                            ret_new_e2[3]=new_e_left
                                            ret_new_e2[4]=expr_update_iter(ret_new_e1[4],array_fun_map)
                                            
                                            var_e1=eval("['_x1']")
                                            #new_e3[3] = copy.deepcopy(new_e2[3])
                                            ret_new_e3[4] = expr_prime(copy.deepcopy(ret_new_e2[4]),expr_replace(copy.deepcopy(ret_new_e3[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1)
                                            ret_new_e3[3] = copy.deepcopy(ret_new_e2[3])
                                            
                                            
                                            more_addition_eq.append(ret_new_e2)
                                            instant_eq.append(ret_new_e2)
                                            more_addition_eq.append(ret_new_e3)
                                            add_equation_d.append(ret_new_e2)
                                            
                                            
        #return "Failed to prove"
	post_condition[str_value]=word
	for postcondition in post_condition.keys():
                #print '=====================Main Proving Process====================='
                
                if len(more_addition_eq)==0:
                    return "Failed to prove"
                
                for x in axiom.getConstraints():
                    constraint_list.append(x)
                new_instant_eq = copy.deepcopy(instant_eq)
                for e in more_addition_eq:
                    new_instant_eq.append(e)
		#print '\nAxiomes Added\n'
		#for e in more_addition_eq:
		#	print wff2string1(e)
                        
		temp_post_condition=[]

		#print '\n'
		#temp_post_condition.append(wff2z3_update(post_condition[postcondition]))
                if post_condition[postcondition][0]=='s0':
                    post_condition[postcondition][0]='c1'
                
                
                
                #temp_post_condition.append(wff2z3_update_postCond(post_condition[postcondition]))
                
                
                temp_post_condition.append(wff2z3_update4(post_condition[postcondition],axiom.getVariables(),axiom.getConst_var_map()))
		
		writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
		writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(post_condition[postcondition])+'\n')
	
                status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,new_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)	
 
		#status=tactic4_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,axiom.getVariables(),axiom.getConst_var_map(),witnessXml)	
                
                #coment on 16/11/2017
                
                #status=tactic4_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,axiom.getVariables(),axiom.getConst_var_map(),witnessXml)	

                
                
                #status="Failed To prove"
                writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                
                #print '=============================================================='
                if 'Successfully Proved' not in status:
                    constraint_list = copy.deepcopy(axiom.getConstraints())
                    for x in more_addition_eq:
			constraint_list.append(wff2z3_update(x))
                    axiom.setConstraints(constraint_list)
                    status=prove_assert_tactic2(axiom,witnessXml)
                    if status is None:
                        return "Failed to prove"
                    else:
                        return status
                else:
                    return status










def prove_assert_tactic4_update3(axiom,witnessXml):
        global fun_call_map

        condition_list=[]

	array_fun_map={}
        
        array_fun_map_query={}
        
        array_fun_map_parameter={}
	
	array_var_map={}
        
        #Array Variables Basecase Value Map
        
        array_var_base_map={}
        
	post_condition={}
	
        array_degree_map={}
	
	array_list=[]
	
	counter_var_list=[]
	
	instant_eq=[]
	
	t_instant_eq=[]
	
	addition_eq=[]
        
        more_addition_eq=[]
	
	o_instant_eq={}
	
	call_var_list=[]
	
	array_fun=None
	
	array_init_map={}
	
	#Base Cases Query List
	
	base_case_query=[]
	       
	#Conclusions Query List
	
	conl_case_query=[]
	 
	#List of Assumptions
	 
	assum_list=[]
	
	#Variable Constant Map
	       
        var_const_map={}
	
	#List of Constraints Derived from Axoims 
	
	constraint_list=[]
	
	#Elements Return by Recursive Function 
	
	assum_list_ret=None
	
	conl_case_query_ret=None
	
	var_const_map_ret=None
	
	pre_condition=[]
	
	#Additional Equation
	
	add_equation_d=[]
	
	#main free variable map
	
	main_free_var_map={}
	
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
		
	str_value,word=axiom.getAsserts()
	
	for variable in axiom.getVariables():
            variableclass=axiom.getVariables()[variable]
            if variableclass.getDimensions() is not None:
                array_degree_map[variable]=len(variableclass.getDimensions())
            else:
                array_degree_map[variable]=0
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
	#for x in out_axioms:
	#	constraint_list.append(x)
	
	
	for x in axiom.getOutput_equations():
		if isArrayFunction(x)==True:
			array_fun =  copy.deepcopy(axiom.getOutput_equations()[x][1])
			array_fun[0] = x
			array_init_map[x[1]]=array_fun
			

	
	for [x,k,l] in axiom.getVfact():
		if k==0 and l[0]=='array' and isArrayFinal(x)==False and not(x=='main'):
                        if x in array_degree_map.keys() and str(array_degree_map[x]) in array_init_map.keys():
                            array_list.append(x)
                            #array_fun_map[x]=array_init_map[str(array_degree_map[x])]
        var_list=axiom.getConst_var_map().keys()
         
        f_count=0
        for x in axiom.getOutput_equations():
        	if isArrayFunction(x):
        		var_e1=eval("['_x1']")
        		for e_array in array_list:
        			if axiom.getOutput_equations()[x][1][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_x1 = copy.deepcopy(axiom.getOutput_equations()[x])
        				var_array=eval("['"+e_array+"']")
        				f_count=f_count+1
        				new_x1[1]=expr_replace(new_x1[1],var_e1,var_array)
        				new_x1[2]=expr_replace(new_x1[2],var_e1,var_array)
        				o_instant_eq[x+'_'+str(f_count)]=new_x1
		else:
			o_instant_eq[x]=axiom.getOutput_equations()[x]
                        
        for e in axiom.getOther_axioms():
        	if e[0]=='i0' and isArrayFunction(e[2][0]):
        		for e_array in array_list:
                                if e[2][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_e1 = copy.deepcopy(e)
					var_e1=eval("['_x1']")
        				var_array=eval("['"+e_array+"']")
        				new_e1[2]=expr_replace(new_e1[2],var_e1,var_array)
        				new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                        new_e1[3]=simplify_ind_equation(new_e1[3],array_list)
                                        if e_array not in array_fun_map.keys() and '_n' not in expr2string1(new_e1[3]):
                                            array_fun_map[e_array]=new_e1[3]
                                        array_var_base_map[expr2string1(new_e1[2])]=new_e1[3]
        				instant_eq.append(new_e1)        	
        	elif e[0]=='i1' and isArrayFunction(e[3][0]):
          		for e_array in array_list:
                                if e[3][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
            		      		new_e1 = copy.deepcopy(e)
			        	status,array_value=findArrayInEq(new_e1[4],array_list)
                                        status=findArrayInEqSp(new_e1[4],e_array)
                                        if status==True:
                                            array_value=e_array
			        	if array_value is not None:
        					inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
        				var_e1=eval("['_x1']")
         				var_array=eval("['"+e_array+"']")
        				if e_array==array_value:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						free_var_map={}
                                                getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)
                                                if not free_var_map:
                                                    new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),var_e1,var_array)
                                                else:

                                                    new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),var_e1,var_array)
						new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
						for f_var in free_var_map.keys():
							new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
							new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
						instant_eq.append(new_e1)
					else:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
			        		instant_eq.append(new_e1)
        	else:
        		instant_eq.append(e)


        update_facts=copy.deepcopy(axiom.getVfact())
        
        array_fun_map_query = copy.deepcopy(array_fun_map)

        Super_Couter=0
        
        G_dgree=None
        

        for e in axiom.getOutput_equations():
            element=axiom.getOutput_equations()[e]
            if isArrayFunction(element[1][0]):
                getAllCondtionArray(element,condition_list)
        for e in condition_list:
            var_cstr_map={}
            pre_condition.append(expr2z3_update_postCond(e,var_cstr_map))
            
        for e in axiom.getOther_axioms():
        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list and (G_dgree is None or e[3][0][1]==G_dgree):
                                if G_dgree is None:
                                	G_dgree=e[3][0][1]
        			var=e[2]
        			const_var=e[2].replace('n','k')
        			update_facts.append(eval("['"+const_var+"',0,['int']]"))
        			constraint_list.append(const_var+">=0")
                                
                                fun_call_map={}
                                parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                constant=eval(expressionCreator_C(statement_temp))
                                
        			
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
        					
        			new_e = copy.deepcopy(e)
                                
                                ins_array_lsit=[]
                                
                                ins_array_lsit = findArrayInEqlist(new_e[4],array_list,ins_array_lsit)
                                
                                flag=False
                                
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
                                                
                                query_ret_list=None
                                
                                var_const_map_ret=None
                                
        			if flag:
                                        query_ret_list,var_const_map_ret = prove_assert_tactic4_update1_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map,array_degree_map)

                                #Add1
                                constraint_list1=copy.deepcopy(constraint_list)
        			if query_ret_list is not None:
                                    for query_ret in query_ret_list:
                                        for ret_e_array in query_ret:
                                            constraint_list1.append(wff2z3_update(query_ret[ret_e_array][1]))
                                    for l_variable in var_const_map_ret:
                                        update_facts.append(eval("['"+var_const_map_ret[l_variable]+"',0,['int']]"))
                                        constraint_list1.append(var_const_map_ret[l_variable]+">=0")
        			#	for query_ret in query_ret_list:
        			#		if query_ret is not None:
                                #        		for e_array in query_ret.keys():
                                #            			constraint_list1.append(wff2z3_update(query_ret[e_array][2]))

                                array_fun_map_temp={}
                                

                                for e_array in array_list:
                                    
                                        if e_array in array_fun_map.keys() and e[3][0][1]==str(array_degree_map[e_array]):
                                            
                                                new_e1 = copy.deepcopy(e)
                                                
                                                new_e2 = copy.deepcopy(new_e1)
                                                
                                                new_e3 = copy.deepcopy(new_e1)
                                                
                                                print '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-------------1'
                                                
                                                print array_fun_map
                                                
                                                print expr2string1(new_e2[3])
                                                
                                                print expr2string1(new_e2[4])
                                                
                                                print '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-------------1'
                                                
                                                
                                                inst_str=eval("['=',['_x1'],['"+str(e_array)+"']]")
                                                
						new_e1[3]=expr_replace(new_e1[3],eval("['_x1']"),eval("['"+e_array+"']"))
                                                
						free_var_map={}
                                                
                                           
                                                
                                                getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)

                                                if not free_var_map:
                                                    
                                                    new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                else:

                                                    new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
						new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                                

                                                if e_array in ins_array_lsit:
                                                    for f_var in free_var_map.keys():
                                                            new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])

                                                array_fun_map_temp[e_array]=expr_update_iter(new_e1[4],array_fun_map)

                                                if e_array in ins_array_lsit:
                                                    parameter_list=[]
                                                    for x in range(2, int(e[3][0][1])+2):
                                                        parameter_list.append(new_e1[3][x])
                                                    array_fun_map_parameter[e_array]=parameter_list
                                                new_e_left=expr_replace(copy.deepcopy(new_e1[3]),eval("['+',['"+var+"'],['1']]"),constant)
                                                if e_array in array_fun_map_parameter.keys():
                                                    for x in range(2, int(e[3][0][1])+2):
                                                        new_e_left[x]=array_fun_map_parameter[e_array][x-2]
                                                new_e2[3]=new_e_left
                                                
                                                print '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-------------2'
                                                
                                                print expr2string1(new_e2[4])
                                                
                                                print '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-------------2'
                                                
                                                new_e2[4]=array_fun_map_temp[e_array]
                                                
                                                
                                                print '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-------------3'
                                                
                                                print expr2string1(new_e2[4])
                                                
                                                print '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-------------3'
                                                
                                                index_var_map={}
                                                
                                                
                                                getIndexVaribles(new_e2[4],index_var_map)
                                                
                                                #print '%%%%%%%%%%%%%%%%%%%%%%%%%'
                                                #print index_var_map
                                                #print '%%%%%%%%%%%%%%%%%%%%%%%%%'
                                                
                                                if not free_var_map:
                                                    new_e2[4] = expr_modify_array(new_e2[4],inst_str,free_var_map)
                                                
                                                var_e1=eval("['_x1']")
                                                #new_e3[3] = copy.deepcopy(new_e2[3])
                                                new_e3[4] = expr_prime(copy.deepcopy(new_e2[4]),expr_replace(copy.deepcopy(new_e3[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1)
                                                new_e3[3] = copy.deepcopy(new_e2[3])
                                                
                                                
                                                more_addition_eq.append(new_e2)
                                                instant_eq.append(new_e2)
                                                more_addition_eq.append(new_e3)
                                                add_equation_d.append(new_e2)
                                                
                                                
                                                #getAllFreeVariable(x,e1,free_var_map)
                                
                                
                                for x in array_fun_map_temp:
                                        array_fun_map[x]=array_fun_map_temp[x]
                                if query_ret_list is not None:
                                    for query_ret in query_ret_list:
                                        for ret_e_array in query_ret:

                                            ret_new_e1 = copy.deepcopy(query_ret[ret_e_array][0])
                                            ret_new_e2 = copy.deepcopy(query_ret[ret_e_array][0])
                                            
                                            #update_facts.append(eval("['"+query_ret[ret_e_array][3]+"',0,['int']]"))
                                            #constraint_list1.append(const_var+">=0")
                                            
                                            fun_call_map={}
                                            ast = parser.parse("void test(){"+axiom.getConst_var_map()[ret_new_e1[2]]+";}")
                                            statement_temp=ast.ext[0].body.block_items[0]
                                            constant=eval(expressionCreator_C(statement_temp))
                                            new_e_left=expr_replace(copy.deepcopy(ret_new_e1[3]),eval("['+',['"+ret_new_e1[2]+"'],['1']]"),constant)
                                            if ret_e_array in array_fun_map_parameter.keys():
                                                for x in range(2, int(e[3][0][1])+2):
                                                    new_e_left[x] = array_fun_map_parameter[ret_e_array][x-2]
                                            ret_new_e2[3]=new_e_left
                                            ret_new_e2[4]=expr_update_iter(ret_new_e1[4],array_fun_map)
                                            
                                            var_e1=eval("['_x1']")
                                            #new_e3[3] = copy.deepcopy(new_e2[3])
                                            ret_new_e3[4] = expr_prime(copy.deepcopy(ret_new_e2[4]),expr_replace(copy.deepcopy(ret_new_e3[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1)
                                            ret_new_e3[3] = copy.deepcopy(ret_new_e2[3])
                                            
                                            
                                            more_addition_eq.append(ret_new_e2)
                                            instant_eq.append(ret_new_e2)
                                            more_addition_eq.append(ret_new_e3)
                                            add_equation_d.append(ret_new_e2)
                                            
                                            
        #return "Failed to prove"
	post_condition[str_value]=word
	for postcondition in post_condition.keys():
                #print '=====================Main Proving Process====================='
                for x in axiom.getConstraints():
                    constraint_list.append(x)
                new_instant_eq = copy.deepcopy(instant_eq)
                for e in more_addition_eq:
                    new_instant_eq.append(e)
		#print '\nAxiomes Added\n'
		#for e in add_equation_d:
		#	print wff2string1(e)
                        
                return
                        
		temp_post_condition=[]

		#print '\n'
		#temp_post_condition.append(wff2z3_update(post_condition[postcondition]))
                if post_condition[postcondition][0]=='s0':
                    post_condition[postcondition][0]='c1'
                
                
                
                #temp_post_condition.append(wff2z3_update_postCond(post_condition[postcondition]))
                
                
                temp_post_condition.append(wff2z3_update4(post_condition[postcondition],axiom.getVariables(),axiom.getConst_var_map()))
		
		writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
		writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(post_condition[postcondition])+'\n')
	
                status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,new_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)	
 
 
                
		#status=tactic4_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,axiom.getVariables(),axiom.getConst_var_map(),witnessXml)	
                
                #coment on 16/11/2017
                
                #status=tactic4_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,axiom.getVariables(),axiom.getConst_var_map(),witnessXml)	

                
                
                #status="Failed To prove"
                writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                
                #print '=============================================================='
                if 'Successfully Proved' not in status:
                    status=prove_assert_tactic5(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)
                    if status is None:
                        return "Failed to prove"
                    else:
                        return status
                else:
                    return status




def getMaxLength(equations):
    max=0
    for equation in equations:
        if equation[0]=='i1':
            l=len(expr2string1(equation[4]))
            if l>max:
                max=l
    return max










def prove_assert_tactic4_update4(axiom,witnessXml):
        global fun_call_map

        condition_list=[]

	array_fun_map={}
        
        array_fun_map_query={}
        
        array_fun_map_parameter={}
	
	array_var_map={}
        
        fixedValue=None
        
        #Array Variables Basecase Value Map
        
        array_var_base_map={}
        
	post_condition={}
	
        array_degree_map={}
	
	array_list=[]
	
	counter_var_list=[]
	
	instant_eq=[]
	
	t_instant_eq=[]
	
	addition_eq=[]
        
        more_addition_eq=[]
	
	o_instant_eq={}
	
	call_var_list=[]
	
	array_fun=None
	
	array_init_map={}
	
	#Base Cases Query List
	
	base_case_query=[]
	       
	#Conclusions Query List
	
	conl_case_query=[]
	 
	#List of Assumptions
	 
	assum_list=[]
	
	#Variable Constant Map
	       
        var_const_map={}
	
	#List of Constraints Derived from Axoims 
	
	constraint_list=[]
	
	#Elements Return by Recursive Function 
	
	assum_list_ret=None
	
	conl_case_query_ret=None
	
	var_const_map_ret=None
	
	pre_condition=[]
	
	#Additional Equation
	
	add_equation_d=[]
	
	#main free variable map
	
	main_free_var_map={}
	
	for w in axiom.getAssumes():
                #if w[0]!='s0':
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
                
		
		elif w[0]=='s0':
                    condition_map_temp={}
                    updateAssumption(w[1],condition_map_temp)
                    for x in condition_map_temp.keys():
                        pre_condition.append(x)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
		
	
	
	str_value,word=axiom.getAsserts()
	
	for variable in axiom.getVariables():
            variableclass=axiom.getVariables()[variable]
            if variableclass.getDimensions() is not None:
                array_degree_map[variable]=len(variableclass.getDimensions())
            else:
                array_degree_map[variable]=0
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
	#for x in out_axioms:
	#	constraint_list.append(x)
	
	
	for x in axiom.getOutput_equations():
                if x=='FIXEDVAL':
                    if axiom.getOutput_equations()[x][2][0]=='ite' and is_number(axiom.getOutput_equations()[x][2][2][0])==True:
                        fixedValue=axiom.getOutput_equations()[x][2][2][0]
		if isArrayFunction(x)==True:
			array_fun =  copy.deepcopy(axiom.getOutput_equations()[x][1])
			array_fun[0] = x
			array_init_map[x[1]]=array_fun
			

	
	for [x,k,l] in axiom.getVfact():
		if k==0 and l[0]=='array' and isArrayFinal(x)==False and not(x=='main'):
                        if x in array_degree_map.keys() and str(array_degree_map[x]) in array_init_map.keys():
                            array_list.append(x)
                            #array_fun_map[x]=array_init_map[str(array_degree_map[x])]
        var_list=axiom.getConst_var_map().keys()
         
        f_count=0
        for x in axiom.getOutput_equations():
        	if isArrayFunction(x):
        		var_e1=eval("['_x1']")
        		for e_array in array_list:
        			if axiom.getOutput_equations()[x][1][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_x1 = copy.deepcopy(axiom.getOutput_equations()[x])
        				var_array=eval("['"+e_array+"']")
        				f_count=f_count+1
        				new_x1[1]=expr_replace(new_x1[1],var_e1,var_array)
        				new_x1[2]=expr_replace(new_x1[2],var_e1,var_array)
        				o_instant_eq[x+'_'+str(f_count)]=new_x1
		else:
			o_instant_eq[x]=axiom.getOutput_equations()[x]
                        
        for e in axiom.getOther_axioms():
        	if e[0]=='i0' and isArrayFunction(e[2][0]):
        		for e_array in array_list:
                                if e[2][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_e1 = copy.deepcopy(e)
					var_e1=eval("['_x1']")
        				var_array=eval("['"+e_array+"']")
        				new_e1[2]=expr_replace(new_e1[2],var_e1,var_array)
        				new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                        new_e1[3]=simplify_ind_equation(new_e1[3],array_list)
                                        if e_array not in array_fun_map.keys() and '_n' not in expr2string1(new_e1[3]):
                                            array_fun_map[e_array]=new_e1[3]
                                        array_var_base_map[expr2string1(new_e1[2])]=new_e1[3]
        				instant_eq.append(new_e1)        	
        	elif e[0]=='i1' and isArrayFunction(e[3][0]):
                        
          		for e_array in array_list:
                                if e[3][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
            		      		new_e1 = copy.deepcopy(e)
			        	status,array_value=findArrayInEq(new_e1[4],array_list)
                                        status=findArrayInEqSp(new_e1[4],e_array)
                                        if status==True:
                                            array_value=e_array
			        	if array_value is not None:
        					inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
        				var_e1=eval("['_x1']")
         				var_array=eval("['"+e_array+"']")
        				if e_array==array_value:
						
						free_var_map={}
                                                free_var_list=[]
                                                                                                        
                                                new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                                new_e1[4]=expr_replace(new_e1[4],var_e1,var_array)
                                            
                                                #getAllFreeVariable2(new_e1[4],free_var_list)
                                                
                                                getAllFreeVariable4(new_e1[4],free_var_map)

                                                if len(free_var_map)>0:
                                                    for var in free_var_map.keys():
                                                        inst_map = free_var_map[var]
                                                        for f_var in inst_map.keys():
                                                            new_e2 = copy.deepcopy(e)
                                                            new_e2[3]=expr_replace(new_e2[3],var_e1,var_array)
                                                            new_e2[4]=expr_replace(new_e2[4],var_e1,var_array)
                                                            new_e2[3]=expr_replace(new_e2[3],eval("['"+var+"']"),inst_map[f_var])
                                                            new_e2[4]=expr_replace(new_e2[4],eval("['"+var+"']"),inst_map[f_var])
                                                            new_e2[4]=simplify_ind_equation(new_e2[4],array_list)
                                                            new_e2[4] = simplifyAxioms(new_e2[4])
                                                            instant_eq.append(new_e2)

                                                            
                                                        
                                                    
                                                #if len(free_var_list)>0:
                                                #    for inst_map in free_var_list:
                                                #        for f_var in inst_map.keys():
                                                #            value=expr2string1(inst_map[f_var])
                                                #            if value not in free_var_map.keys():
                                                #                free_var_map[value]=value
                                                #                new_e2 = copy.deepcopy(e)
                                                #                new_e2[3]=expr_replace(new_e2[3],var_e1,var_array)
                                                #                new_e2[4]=expr_replace(new_e2[4],var_e1,var_array)
                                                #                new_e2[3]=expr_replace(new_e2[3],eval("['"+f_var+"']"),inst_map[f_var])
                                                #                new_e2[4]=expr_replace(new_e2[4],eval("['"+f_var+"']"),inst_map[f_var])
                                                #                new_e2[4]=simplify_ind_equation(new_e2[4],array_list)
                                                #                new_e2[4] = simplifyAxioms(new_e2[4])
                                                #                instant_eq.append(new_e2)
                                                                
                                                #if not free_var_map:
                                                #    new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),var_e1,var_array)
                                                #else:

                                                #    new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),var_e1,var_array)
						#new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
						#for f_var in free_var_map.keys():
						#	new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
						#	new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
						
					else:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
			        		instant_eq.append(new_e1)
        	else:
        		instant_eq.append(e)

        update_facts=copy.deepcopy(axiom.getVfact())
        
        array_fun_map_query = copy.deepcopy(array_fun_map)

        Super_Couter=0
        
        G_dgree=None
        

        for e in axiom.getOutput_equations():
            element=axiom.getOutput_equations()[e]
            if isArrayFunction(element[1][0]):
                getAllCondtionArray(element,condition_list)
        for e in condition_list:
            var_cstr_map={}
            pre_condition.append(expr2z3_update_postCond(e,var_cstr_map))
            

        for x in axiom.getOther_axioms():
            if x[0]=='s0':
                if x[-1][0]=='>=' or x[-1][0]=='<=':
                    if isMacroPresent(expr2string1(x[-1][1]),axiom.getConst_var_map().values())==True:
                        #print constraint_list
                        temp_constraint_list=[]
                        x_new=copy.deepcopy(x)
                        x_new[-1][0]='=='
                        frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
                        for y in frame_axioms:
                            temp_constraint_list.append(y)

                        for y in out_axioms:
                            temp_constraint_list.append(y)
                        for y in axiom.getOther_axioms(): 
                            equations=wff2z3_update(y)
                            equations_sp=None
                            if y[0]=='s0':
                                if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                                    status_value = query2z3_cond([],equations,axiom.getVfact())
                                    if 'Successfully Proved' not in status_value:
                                        temp_constraint_list.append(equations)
                                else:
                                    temp_constraint_list.append(equations)
                            else:
                                temp_constraint_list.append(equations)
                            if y[0]=='s1':
                                equations_sp=wff2z3SC_update(y)
                                if equations_sp is not None:
                                    temp_constraint_list.append(equations_sp)        		
                        for y in axiom.getConstraints():
                            temp_constraint_list.append(y)
                        for y in pre_condition:
                            temp_constraint_list.append(y)
                        status=query2z3_cond(temp_constraint_list,wff2z3_update1(x_new,axiom.getConst_var_map()),axiom.getVfact())
                        if 'Successfully Proved' in status:
                            constraint_list.append(wff2string1(x_new))

            
        
        for e in axiom.getOther_axioms():

        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list and (G_dgree is None or e[3][0][1]==G_dgree):

                                if G_dgree is None:
                                	G_dgree=e[3][0][1]
        			var=e[2]
        			const_var=e[2].replace('n','k')
        			update_facts.append(eval("['"+const_var+"',0,['int']]"))
        			constraint_list.append(const_var+">=0")
                                
                                fun_call_map={}
                                parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                constant=eval(expressionCreator_C(statement_temp))
                                
        			
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
        					
        			new_e = copy.deepcopy(e)
                                                    
                                ins_array_lsit=[]
                                
                                ins_array_lsit = findArrayInEqlist(new_e[4],array_list,ins_array_lsit)
                                
                                flag=False
                                
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
                                                
                                query_ret_list=None
                                
                                var_const_map_ret=None
                                
        			if flag:
                                        query_ret_list,var_const_map_ret = prove_assert_tactic4_update4_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map,array_degree_map)

                                #Add1
                                constraint_list1=copy.deepcopy(constraint_list)
        			if query_ret_list is not None:
                                    for query_ret in query_ret_list:
                                        for ret_e_array in query_ret:
                                            constraint_list1.append(wff2z3_update(query_ret[ret_e_array][1]))
                                    for l_variable in var_const_map_ret:
                                        update_facts.append(eval("['"+var_const_map_ret[l_variable]+"',0,['int']]"))
                                        constraint_list1.append(var_const_map_ret[l_variable]+">=0")
        			#	for query_ret in query_ret_list:
        			#		if query_ret is not None:
                                #        		for e_array in query_ret.keys():
                                #            			constraint_list1.append(wff2z3_update(query_ret[e_array][2]))

                                array_fun_map_temp={}
                                
                                
                                for e_array in array_list:
                                    
                                        if e_array in array_fun_map.keys() and e[3][0][1]==str(array_degree_map[e_array]):
                                            
                                                new_e1 = copy.deepcopy(e)
                                                
                                                inst_str=eval("['=',['_x1'],['"+str(e_array)+"']]")
                                                
						new_e1[3]=expr_replace(new_e1[3],eval("['_x1']"),eval("['"+e_array+"']"))
                                                new_e1[4]=expr_replace(new_e1[4],eval("['_x1']"),eval("['"+e_array+"']"))
                                                
						
                                                free_var_list=[]
                                                free_var_map={}
                                                

                                                getAllFreeVariable2(new_e1[4],free_var_list)
                                                
                                                if len(free_var_list)>0:
                                                                #free_var_map[value]=value
                                                                new_e1 = copy.deepcopy(e)
                                                                new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                                                new_e1[4]=expr_replace(new_e1[4],var_e1,var_array)
                                                                #new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),inst_map[f_var])
                                                                new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                                                new_e1[4] = simplifyAxioms(new_e1[4])
                                                                array_fun_map_temp[e_array]=expr_update_iter(new_e1[4],array_fun_map)
                                                                
                                                                if e_array in ins_array_lsit:
                                                                    parameter_list=[]
                                                                    for x in range(2, int(e[3][0][1])+2):
                                                                        parameter_list.append(new_e1[3][x])
                                                                    array_fun_map_parameter[e_array]=parameter_list
                                                                new_e_left=expr_replace(copy.deepcopy(new_e1[3]),eval("['+',['"+var+"'],['1']]"),constant)
                                                                #new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),inst_map[f_var])
                                                                #new_e_left=expr_replace(new_e_left,eval("['"+f_var+"']"),inst_map[f_var])
                                                                new_e2 = copy.deepcopy(new_e1)
                                                                new_e3 = copy.deepcopy(new_e1)
                                                                new_e2[3]=new_e_left
                                                            
                                                                new_e2[4]=array_fun_map_temp[e_array]
                                                
                                                                index_var_map={}
                                                                getIndexVaribles(new_e2[4],index_var_map)
                                                                
                                                                if not free_var_map:
                                                                    new_e2[4] = expr_modify_array(new_e2[4],inst_str,free_var_map)
                                                
                                                                var_e1=eval("['_x1']")
                                                                #new_e3[3] = copy.deepcopy(new_e2[3])
                                                                new_e3[4] = expr_prime(copy.deepcopy(new_e2[4]),expr_replace(copy.deepcopy(new_e3[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1)
                                                                new_e3[3] = copy.deepcopy(new_e2[3])
                                                
                                                                
                                                                #more_addition_eq.append(new_e2)
                                                                #instant_eq.append(new_e2)
                                                                more_addition_eq.append(new_e3)
                                                                #add_equation_d.append(new_e2)
                                                                
                                                else:
                                                    free_var_map={}
                                                    getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)
                                                    new_e1 = copy.deepcopy(e)
                                                    new_e2 = copy.deepcopy(new_e1)
                                                    new_e3 = copy.deepcopy(new_e1)
                                                    
                                                    new_e1[3]=expr_replace(new_e1[3],eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                    new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                                    array_fun_map_temp[e_array]=expr_update_iter(new_e1[4],array_fun_map)
                                                    
                                                    if e_array in ins_array_lsit:
                                                        for f_var in free_var_map.keys():
                                                                new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                                new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
                                                
                                                    if e_array in ins_array_lsit:
                                                        parameter_list=[]
                                                        for x in range(2, int(e[3][0][1])+2):
                                                            parameter_list.append(new_e1[3][x])
                                                        array_fun_map_parameter[e_array]=parameter_list
                                                    new_e_left=expr_replace(copy.deepcopy(new_e1[3]),eval("['+',['"+var+"'],['1']]"),constant)
                                                
                                                    if e_array in array_fun_map_parameter.keys():
                                                        for x in range(2, int(e[3][0][1])+2):
                                                            new_e_left[x]=array_fun_map_parameter[e_array][x-2]
                                                    new_e2[3]=new_e_left
                                                    new_e2[4]=array_fun_map_temp[e_array]
                                                
                                                    index_var_map={}
                                                    getIndexVaribles(new_e2[4],index_var_map)
                                                
                                                    if not free_var_map:
                                                        new_e2[4] = expr_modify_array(new_e2[4],inst_str,free_var_map)
                                                
                                                    var_e1=eval("['_x1']")
                                                    #new_e3[3] = copy.deepcopy(new_e2[3])
                                                    new_e3[4] = expr_prime(copy.deepcopy(new_e2[4]),expr_replace(copy.deepcopy(new_e3[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1)
                                                    new_e3[3] = copy.deepcopy(new_e2[3])
                                                
                                                
                                                    #more_addition_eq.append(new_e2)
                                                    #instant_eq.append(new_e2)
                                                    more_addition_eq.append(new_e3)
                                                    #add_equation_d.append(new_e2)
                                
                                
                                
                                
                                
                                for x in array_fun_map_temp:
                                        array_fun_map[x]=array_fun_map_temp[x]
                                if query_ret_list is not None:
                                    for query_ret in query_ret_list:
                                        for ret_e_array in query_ret:

                                            ret_new_e1 = copy.deepcopy(query_ret[ret_e_array][0])
                                            ret_new_e2 = copy.deepcopy(query_ret[ret_e_array][0])
                                            ret_new_e3 = copy.deepcopy(query_ret[ret_e_array][0])
                                            
                                            #update_facts.append(eval("['"+query_ret[ret_e_array][3]+"',0,['int']]"))
                                            #constraint_list1.append(const_var+">=0")
                                            
                                            fun_call_map={}
                                            ast = parser.parse("void test(){"+axiom.getConst_var_map()[ret_new_e1[2]]+";}")
                                            statement_temp=ast.ext[0].body.block_items[0]
                                            constant=eval(expressionCreator_C(statement_temp))
                                            new_e_left=expr_replace(copy.deepcopy(ret_new_e1[3]),eval("['+',['"+ret_new_e1[2]+"'],['1']]"),constant)
                                            if ret_e_array in array_fun_map_parameter.keys():
                                                for x in range(2, int(e[3][0][1])+2):
                                                    new_e_left[x] = array_fun_map_parameter[ret_e_array][x-2]
                                            ret_new_e2[3]=new_e_left
                                            ret_new_e2[4]=expr_update_iter(ret_new_e1[4],array_fun_map)
                                            
                                            var_e1=eval("['_x1']")
                                            #new_e3[3] = copy.deepcopy(new_e2[3])
                                            ret_new_e3[4] = expr_prime(copy.deepcopy(ret_new_e2[4]),expr_replace(copy.deepcopy(ret_new_e3[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1)
                                            ret_new_e3[3] = copy.deepcopy(ret_new_e2[3])
                                            
                                            
                                            more_addition_eq.append(ret_new_e2)
                                            instant_eq.append(ret_new_e2)
                                            more_addition_eq.append(ret_new_e3)
                                            add_equation_d.append(ret_new_e2)
                                            
                                            
        #return "Failed to prove"
	post_condition[str_value]=word
	for postcondition in post_condition.keys():
                #print '=====================Main Proving Process====================='
                for x in axiom.getConstraints():
                    constraint_list.append(x)
                new_instant_eq = copy.deepcopy(instant_eq)
                for e in more_addition_eq:
                    if e[4][0]=='ite' and e[4][1][0]=='!=' and 'ReadFromPort' in e[4][1][1][0] and e[4][1][2][0]=='0':
                        if fixedValue is not None:
                            e[4] = expr_replace(e[4],e[3],eval("['"+fixedValue+"']"))
                    if e[4][0]=='ite' and e[4][1][0]=='>=' and 'MINVAL' in e[4][1][2][0] and e[4][1][1][0]=='1':
                        e[4] = expr_replace(e[4],e[3],eval("['MINVAL']"))
                    new_instant_eq.append(e)
                
                        
		temp_post_condition=[]

		#print '\n'
		#temp_post_condition.append(wff2z3_update(post_condition[postcondition]))
                if post_condition[postcondition][0]=='s0':
                    post_condition[postcondition][0]='c1'
                
                
                
                #temp_post_condition.append(wff2z3_update_postCond(post_condition[postcondition]))
                
                
                temp_post_condition.append(wff2z3_update4(post_condition[postcondition],axiom.getVariables(),axiom.getConst_var_map()))
		
		writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
		writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(post_condition[postcondition])+'\n')
	
                #status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,new_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)	
 
		#status=tactic4_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,axiom.getVariables(),axiom.getConst_var_map(),witnessXml)	
                
                #coment on 16/11/2017
                
                status=tactic5_update(axiom.getFrame_axioms(),o_instant_eq,new_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,axiom.getVariables(),axiom.getConst_var_map(),witnessXml)	

                
                
                #status="Failed To prove"
                writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                
                #print '=============================================================='
                if 'Successfully Proved' not in status:
                    status=prove_assert_tactic5(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)
                    if status is None:
                        status=prove_assert_tactic12(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)
                        if status is None or "Failed to prove" in status:
                            return "Failed to prove"
                        else:
                            return status
                    elif "Failed to prove" in status:
                        status=prove_assert_tactic12(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)
                        if status is None or "Failed to prove" in status:
                            return "Failed to prove"
                        else:
                            return status
                    else:
                        return status
                    return status
                else:
                    return status


                                                




def prove_assert_tactic4_update4_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map,array_degree_map):

       var_list=axiom.getConst_var_map().keys()
       
       query_map_list=[]
       
       query_map={}
       
       base_case_query=[]
       
       conl_case_query=[]
       
       assum_list=[]
       
       var_const_map={}
       
       constraint_list=[]
       frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
       for x in frame_axioms:
       		constraint_list.append(x)
       out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
       for x in out_axioms:
		constraint_list.append(x)
       pre_condition=[]
	
       for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in lhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
       
                 
       for e in axiom.getOther_axioms():
        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list:

        			var=e[2]
        			const_var=e[2].replace('n','k')
                                var_const_map[var]=const_var

                                
                                #p = getParser()
                                #tree = p.parse_expression(axiom.getConst_var_map()[var])
        			#constant=eval(expressionCreator(tree))
                                
                                parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                constant=eval(expressionCreator_C(statement_temp))
                                
                                
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True

        			if not flag:
                                	new_e = copy.deepcopy(e)
					status,array_value=findArrayInEq(e[4],array_list)	
					#instantiated the array value
					if array_value is not None:
						inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
					 
					
					for e_array in array_list:
                                            
                                            
                                                if e_array in array_fun_map.keys() and e[3][0][1]==str(array_degree_map[e_array]):
                                            
                                                    #get Initial Array values
                                                    array_fun=array_fun_map[e_array]
                                                    #List of queries
                                                    quary_list=[]
                                                    # Construct Variable Array
                                                    var_e1=eval("['_x1']")
                                                    # Construct Array
                                                    var_array=eval("['"+e_array+"']")
                                                    #Get the copy of the equation
                                                    new_e1 = copy.deepcopy(e)
                                                    
                                                    new_e2 = copy.deepcopy(new_e1)
                                                    
                                                    new_e3 = copy.deepcopy(new_e1)
                                                    
                                                    new_e3[4] = array_fun_map[e_array]
                                                    
                                                
                                                    inst_str=eval("['=',['_x1'],['"+str(e_array)+"']]")
                                                
                                                    new_e1[3]=expr_replace(new_e1[3],eval("['_x1']"),eval("['"+e_array+"']"))
                                                
                                                    free_var_map={}
                                                
                                                    getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)

                                                    if not free_var_map:
                                                    
                                                        new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                    else:

                                                        new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                    new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                                    
                                                    new_e3[3]=expr_replace(new_e3[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
                                                    
                                                    
                                                    new_e3[3]=expr_replace(new_e3[3],eval("['"+var+"']"),eval("['"+const_var+"']"))
                                                    

                                                    query_list=[]

                                                    query_list.append(new_e1)
                                                    
                                                    query_list.append(new_e3)
                                                    
                                                    query_list.append(var)
                                                    
                                                    query_list.append(const_var)
                                                    
                                                    query_list.append(constant)
                                                    
                                                    query_map[e_array]=query_list
                        
                                        query_map_list.append(query_map)
                                	return query_map_list,var_const_map
        			else:
        				#print 'XXXXX-XXXXX'
                                        #print main_free_var_map
        				query_map_list_temp,var_const_map_temp=prove_assert_tactic4_update4_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map,array_degree_map)
       			       				
        				#for query_ret in query_map_list_temp:
					#	if query_ret is not None:
					#        	for e_array in query_ret.keys():
                                        #    			constraint_list.append(wff2z3_update(query_ret[e_array][2]))
        				for var_const_temp in var_const_map_temp.keys():
        					var_const_map[var_const_temp]=var_const_map_temp[var_const_temp]
                                                
                                	update_facts=copy.deepcopy(axiom.getVfact())
                                        
                                        for e_array in array_list:
                                            if e_array in array_fun_map.keys() and e[3][0][1]==str(array_degree_map[e_array]):
                                                    #get Initial Array values
                                                    array_fun=array_fun_map[e_array]
                                                    #List of queries
                                                    quary_list=[]
                                                    # Construct Variable Array
                                                    var_e1=eval("['_x1']")
                                                    # Construct Array
                                                    var_array=eval("['"+e_array+"']")
                                                    #Get the copy of the equation
                                                    new_e1 = copy.deepcopy(e)
                                                    
                                                    new_e2 = copy.deepcopy(new_e1)
                                                    
                                                    new_e3 = copy.deepcopy(new_e1)
                                                    
                                                    new_e3[4] = array_fun_map[e_array]
                                                
                                                
                                                    inst_str=eval("['=',['_x1'],['"+str(e_array)+"']]")
                                                
                                                    new_e1[3]=expr_replace(new_e1[3],eval("['_x1']"),eval("['"+e_array+"']"))
                                                
                                                    free_var_map={}
                                                
                                                    getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)

                                                    if not free_var_map:
                                                    
                                                        new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                    else:

                                                        new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),eval("['_x1']"),eval("['"+e_array+"']"))
                                                    
                                                    new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                                    
                                                    new_e3[3]=expr_replace(new_e1[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
                                                    
                                                    new_e3[3]=expr_replace(new_e1[3],eval("['"+var+"']"),eval("['"+const_var+"']"))
                                                    
                                                    query_list=[]
                                                    
                                                    query_list.append(new_e1)
                                                    
                                                    query_list.append(new_e3)
                                                    
                                                    query_list.append(var)
                                                    
                                                    query_list.append(const_var)
                                                    
                                                    query_list.append(constant)
                                                    
                                                    query_map[ e_array]=query_list
                                                    
                                        for x in query_map_list_temp:
                                            query_map_list.append(x)
                                                    
                                        query_map_list.append(query_map)

        				return query_map_list,var_const_map				
       return None,None			







def prove_assert_tactic4_update5(axiom,witnessXml):
    
        global fun_call_map

        condition_list=[]

	array_fun_map={}
        
        array_fun_map_query={}
        
        array_fun_map_parameter={}
	
	array_var_map={}
        
        fixedValue=None
        
        #Array Variables Basecase Value Map
        
        array_var_base_map={}
        
	post_condition={}
	
        array_degree_map={}
	
	array_list=[]
	
	counter_var_list=[]
	
	instant_eq=[]
	
	t_instant_eq=[]
	
	addition_eq=[]
        
        more_addition_eq=[]
	
	o_instant_eq={}
	
	call_var_list=[]
	
	array_fun=None
	
	array_init_map={}
	
	#Base Cases Query List
	
	base_case_query=[]
	       
	#Conclusions Query List
	
	conl_case_query=[]
	 
	#List of Assumptions
	 
	assum_list=[]
	
	#Variable Constant Map
	       
        var_const_map={}
	
	#List of Constraints Derived from Axoims 
	
	constraint_list=[]
	
	#Elements Return by Recursive Function 
	
	assum_list_ret=None
	
	conl_case_query_ret=None
	
	var_const_map_ret=None
	
	pre_condition=[]
	
	#Additional Equation
	
	add_equation_d=[]
	
	#main free variable map
	
	main_free_var_map={}
	
	for w in axiom.getAssumes():
                #if w[0]!='s0':
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
                
		
		elif w[0]=='s0':
                    condition_map_temp={}
                    updateAssumption(w[1],condition_map_temp)
                    for x in condition_map_temp.keys():
                        pre_condition.append(x)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
		
	
	
	str_value,word=axiom.getAsserts()
        
	
	for variable in axiom.getVariables():
            variableclass=axiom.getVariables()[variable]
            if variableclass.getDimensions() is not None:
                array_degree_map[variable]=len(variableclass.getDimensions())
            else:
                array_degree_map[variable]=0
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
	#for x in out_axioms:
	#	constraint_list.append(x)
	
	
	for x in axiom.getOutput_equations():
                if x=='FIXEDVAL':
                    if axiom.getOutput_equations()[x][2][0]=='ite' and is_number(axiom.getOutput_equations()[x][2][2][0])==True:
                        fixedValue=axiom.getOutput_equations()[x][2][2][0]
		if isArrayFunction(x)==True:
			array_fun =  copy.deepcopy(axiom.getOutput_equations()[x][1])
			array_fun[0] = x
			array_init_map[x[1]]=array_fun
			

	
	for [x,k,l] in axiom.getVfact():
		if k==0 and l[0]=='array' and isArrayFinal(x)==False and not(x=='main'):
                        if x in array_degree_map.keys() and str(array_degree_map[x]) in array_init_map.keys():
                            array_list.append(x)
                            #array_fun_map[x]=array_init_map[str(array_degree_map[x])]
        var_list=axiom.getConst_var_map().keys()
         
        f_count=0
        for x in axiom.getOutput_equations():
        	if isArrayFunction(x):
        		var_e1=eval("['_x1']")
        		for e_array in array_list:
        			if axiom.getOutput_equations()[x][1][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_x1 = copy.deepcopy(axiom.getOutput_equations()[x])
        				var_array=eval("['"+e_array+"']")
        				f_count=f_count+1
        				new_x1[1]=expr_replace(new_x1[1],var_e1,var_array)
        				new_x1[2]=expr_replace(new_x1[2],var_e1,var_array)
        				o_instant_eq[x+'_'+str(f_count)]=new_x1
		else:
			o_instant_eq[x]=axiom.getOutput_equations()[x]
                        
        

        
        
        
        for e in axiom.getOther_axioms():
        	if e[0]=='i0' and isArrayFunction(e[2][0]):
        		for e_array in array_list:
                                if e[2][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_e1 = copy.deepcopy(e)
					var_e1=eval("['_x1']")
        				var_array=eval("['"+e_array+"']")
        				new_e1[2]=expr_replace(new_e1[2],var_e1,var_array)
        				new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                        new_e1[3]=simplify_ind_equation(new_e1[3],array_list)
                                        if e_array not in array_fun_map.keys() and '_n' not in expr2string1(new_e1[3]):
                                            array_fun_map[e_array]=new_e1[3]
                                        array_var_base_map[expr2string1(new_e1[2])]=new_e1[3]
        				instant_eq.append(new_e1)        	
        	elif e[0]=='i1' and isArrayFunction(e[3][0]):
                        
          		for e_array in array_list:
                                if e[3][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
            		      		new_e1 = copy.deepcopy(e)
			        	status,array_value=findArrayInEq(new_e1[4],array_list)
                                        status=findArrayInEqSp(new_e1[4],e_array)
                                        if status==True:
                                            array_value=e_array
			        	if array_value is not None:
        					inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
        				var_e1=eval("['_x1']")
         				var_array=eval("['"+e_array+"']")
        				if e_array==array_value:
						
						free_var_map={}
                                                free_var_list=[]
                                                                                                        
                                                new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                                new_e1[4]=expr_replace(new_e1[4],var_e1,var_array)
                                            
                                                #getAllFreeVariable2(new_e1[4],free_var_list)
                                                
                                                getAllFreeVariable4(new_e1[4],free_var_map)

                                                if len(free_var_map)>0:
                                                    for var in free_var_map.keys():
                                                        inst_map = free_var_map[var]
                                                        for f_var in inst_map.keys():
                                                            new_e2 = copy.deepcopy(e)
                                                            new_e2[3]=expr_replace(new_e2[3],var_e1,var_array)
                                                            new_e2[4]=expr_replace(new_e2[4],var_e1,var_array)
                                                            new_e2[3]=expr_replace(new_e2[3],eval("['"+var+"']"),inst_map[f_var])
                                                            new_e2[4]=expr_replace(new_e2[4],eval("['"+var+"']"),inst_map[f_var])
                                                            new_e2[4]=simplify_ind_equation(new_e2[4],array_list)
                                                            #new_e2[4] = simplifyAxioms(new_e2[4])
                                                            instant_eq.append(new_e2)						
					else:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
			        		instant_eq.append(new_e1)
        	else:
        		instant_eq.append(e)
                        
        
	equation_map={}
        equation_base_map={}
        Const_var_map={}


        parser = c_parser.CParser()
        for var in axiom.getConst_var_map().keys():
            ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
            statement_temp=ast.ext[0].body.block_items[0]
            constant=eval(expressionCreator_C(statement_temp))
            Const_var_map[var]=constant
        
        for e in instant_eq:
            if (e[0]=='i0') and isArrayFunction(e[2][0]):
                equation_base_map[expr2string1(e[2])]=e
            elif (e[0]=='i1') and isArrayFunction(e[3][0]):
                equation_map[expr2string1(e[3])]=e
                
        for key in equation_map.keys():
            e=equation_map[key]
            rec_e1 = copy.deepcopy(e[3])
            rec_e2 = copy.deepcopy(e[3])
            soln_e1 = copy.deepcopy(e[3])
            rec_e1=expr_replace(rec_e1,eval("['+',['"+e[2]+"'],['1']]"),eval("['"+e[2]+"']"))
            rec_e2=expr_replace(rec_e2,eval("['+',['"+e[2]+"'],['1']]"),eval("['0']"))
            if rec_e1==e[4]:
                soln_e1 = expr_replace(soln_e1,eval("['+',['"+e[2]+"'],['1']]"),eval("['"+axiom.getConst_var_map()[e[2]]+"']"))
                e_base=equation_base_map[expr2string1(rec_e2)]
                instant_eq=solnsubstitution(instant_eq,soln_e1,e_base[3])
                instant_eq=solnsubstitution_Array(instant_eq,soln_e1,e_base[3])
                instant_eq.remove(e)
                instant_eq.remove(e_base)
                word = expr_array_replace(word,soln_e1,e_base[3])
            
        for e in instant_eq:
            if (e[0]=='i0') and isArrayFunction(e[2][0]):
                print wff2string1(e)
            elif (e[0]=='i1') and isArrayFunction(e[3][0]):
                print wff2string1(e)
            else:
                print wff2string1(e)
        fun_map={}
        para_map={}
        smallest_map={}
        condition_map={}
        getAllArrayFunctions(word,fun_map)
        for e in instant_eq:
            if (e[0]=='i1') and isArrayFunction(e[3][0]) and e[3][0] in fun_map:
                args=expr_args(e[3])
                count=0
                for arg in args:
                    count=count+1
                    getFunctionIndex(arg,para_map,count)
        for e in instant_eq:
            if (e[0]=='i1') and e[3][0] in para_map:
                condition_list=[]
                left_e=copy.deepcopy(e[3])
                left_e=expr_replace(left_e,eval("['+',['"+e[2]+"'],['1']]"),eval("['"+e[2]+"']"))
                getConditionsForInduction(e[4],condition_list,left_e)
                if e[2] in condition_map.keys():
                    condition_map[e[2]]=condition_map[e[2]]+condition_list
                else:
                    condition_map[e[2]]=condition_list
        
        
        for e in instant_eq:
            if e[0]=='i1':
                if e[3][0] in para_map:
                    left_e = copy.deepcopy(e[3])
                    left_e=expr_replace(left_e,eval("['+',['"+e[2]+"'],['1']]"),eval("['"+axiom.getConst_var_map()[e[2]]+"']"))
                    constraint_list.append(expr2string1(left_e)+'>=0')
                    constraint_list.append(expr2string1(left_e)+'<='+axiom.getConst_var_map()[e[2]])
    
        for e in instant_eq:
            if e[0]=='s0':
                if e[1][0]=='>=' or e[1][0]=='<=':
                    smallest_macro = copy.deepcopy(e)
                    smallest_macro[1][0]='=='
                    smallest_macro[0]='c1'
                    temp_post_condition=[]
                    temp_post_condition.append(wff2z3_update_postCond(smallest_macro))
                    status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),constraint_list,witnessXml)
                    if 'Successfully Proved' in status:
                        constraint_list.append(expr2string1(smallest_macro[1]))
                        if '_N' in expr2string1(smallest_macro[1][1]):
                            smallest_map[expr2string1(smallest_macro[1][1])]=smallest_macro
                        else:
                            smallest_map[expr2string1(smallest_macro[2][1])]=smallest_macro        
        
        if len(para_map)>=1:
            if len(para_map)==1:
                
                variable=None
                con_var=None
                variable_con_map={}
                update_facts=copy.deepcopy(axiom.getVfact())
                for var in Const_var_map.keys():
                    #if expr_find(word[1],Const_var_map[var])==True:
                    if expr_find(word[1],eval("['"+var+"']"))==True:
                        word[1] = expr_replace(word[1],Const_var_map[var],eval("['+',['"+var+"'],['1']]"))
                        variable = var 
                        con_var = var.replace('n','k')
                        variable_con_map[variable] = con_var
                        update_facts.append(eval("['"+con_var+"',0,['int']]"))
                        constraint_list.append(con_var+">=0")
                
                
                
                word[1] = replaceIndexWithFun(word[1],para_map,fun_map)
                
                        
                base_word = copy.deepcopy(word)
            
                assum_word = copy.deepcopy(word[1])
            
                ind_word = copy.deepcopy(word[1])
                
                
            
                for variable in variable_con_map:
                    #con_var=variable_con_map[variable]
                    base_word[1] = expr_replace(base_word[1],eval("['"+variable+"']"),eval("['0']"))
                    assum_word = expr_replace(assum_word,eval("['"+variable+"']"),eval("['-',['"+con_var+"'],['1']]"))
                    ind_word = expr_replace(ind_word,eval("['"+variable+"']"),eval("['"+con_var+"']"))
                
                for var in condition_map:
                    condition_list=condition_map[var]
                    update_cond = conditionCreator(condition_list)
                    base_word_cond= expr_replace(copy.deepcopy(update_cond),eval("['"+var+"']"),eval("['0']"))
                    assum_word_cond= expr_replace(copy.deepcopy(update_cond),eval("['"+var+"']"),eval("['"+con_var+"']"))

                base_word[1] = eval("['Implies',"+str(base_word_cond)+","+str(base_word[1])+"]")
                temp_post_condition=[]
                temp_post_condition.append(wff2z3_update(base_word))
                writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(base_word)+'\n')
                status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                #print status
                if 'Successfully Proved' in status:
                
                    assum_word = eval("['And',"+str(assum_word_cond)+","+str(assum_word)+"]")
                    
                                
                    update_word=[]
                    update_word.append('c1')
                    temp_update_word=[]
                    temp_update_word.append('Implies')
                    temp_update_word.append(assum_word)
                    temp_update_word.append(ind_word)
                    update_word.append(temp_update_word)
                    
                    temp_post_condition=[]
                    temp_post_condition.append(wff2z3_update(update_word))
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                    writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(update_word)+'\n')
                    status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                    writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                
                    if 'Successfully Proved' in status:
                        #print status
                        return status
                    else:
                        return "Failed to prove"
                else:
                    return "Failed to prove"
            else:
                temp_para_map=copy.deepcopy(para_map)
                temp_word=copy.deepcopy(word)
                for x in temp_para_map:
                
                    word=copy.deepcopy(temp_word)
                
                    para_map={}
                    para_map[x] = temp_para_map[x]
                    variable=None
                    con_var=None
                    variable_con_map={}
                    update_facts=copy.deepcopy(axiom.getVfact())
                    for var in Const_var_map.keys():
                        if expr_find(word[1],Const_var_map[var])==True:
                            word[1] = expr_replace(word[1],Const_var_map[var],eval("['+',['"+var+"'],['1']]"))
                            variable = var 
                            con_var = var.replace('n','k')
                            variable_con_map[variable] = con_var
                            update_facts.append(eval("['"+con_var+"',0,['int']]"))
                            constraint_list.append(con_var+">=0")
                
                    word[1] = replaceIndexWithFun(word[1],para_map,fun_map)

                    
                    for var in condition_map:
                    
                        condition_list=condition_map[var]

                        for update_cond in condition_list:
                        
                        
                                        
                            base_word = copy.deepcopy(word)
            
                            assum_word = copy.deepcopy(word[1])
            
                            ind_word = copy.deepcopy(word[1])
                                        
            
                            for variable in variable_con_map:
                                con_var=variable_con_map[variable]
                                base_word[1] = expr_replace(base_word[1],eval("['"+variable+"']"),eval("['0']"))
                                assum_word = expr_replace(assum_word,eval("['"+variable+"']"),eval("['-',['"+con_var+"'],['1']]"))
                                ind_word = expr_replace(ind_word,eval("['"+variable+"']"),eval("['"+con_var+"']"))



                            base_word_cond= expr_replace(copy.deepcopy(update_cond),eval("['"+var+"']"),eval("['0']"))
                            assum_word_cond= expr_replace(copy.deepcopy(update_cond),eval("['"+var+"']"),eval("['"+con_var+"']"))
                            



                            base_word[1] = eval("['Implies',"+str(base_word_cond)+","+str(base_word[1])+"]")
                            temp_post_condition=[]
                                                
                            temp_post_condition.append(wff2z3_update(base_word))
                            writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                            writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(base_word)+'\n')
                            status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                            writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                            #print status
                            if 'Successfully Proved' in status:
                                
                                assum_word = eval("['And',"+str(assum_word_cond)+","+str(assum_word)+"]")
                                

                                
                                update_word=[]
                                update_word.append('c1')
                                temp_update_word=[]
                                temp_update_word.append('Implies')
                                temp_update_word.append(assum_word)
                                temp_update_word.append(ind_word)
                                update_word.append(temp_update_word)
                                
                                temp_post_condition=[]
                                temp_post_condition.append(wff2z3_update(update_word))
                                writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                                writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(update_word)+'\n')
                                status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                                writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                
                                if 'Successfully Proved' in status:
                                    return status
                return "Failed to prove"
        else:
            var_const_ind_map={}
            
            getIndexParameter(word[1],var_const_ind_map,Const_var_map)
            
            base_word = copy.deepcopy(word)
            
            assum_word = copy.deepcopy(word[1])
            
            ind_word = copy.deepcopy(word[1])
            
            key_list=var_const_ind_map.keys()
            
            if len(key_list)>0:
                
                update_facts=copy.deepcopy(axiom.getVfact())
                
                con_var='_k'+str(key_list[0])
                
                update_facts.append(eval("['"+con_var+"',0,['int']]"))
                constraint_list.append(con_var+">=0")

                list_variables=var_const_ind_map[key_list[0]]
                for variable in list_variables:
                    base_word[1] = expr_replace(base_word[1],variable,eval("['0']"))
                    if '_N' in variable[0]:
                            assum_word = expr_replace(assum_word,variable,eval("['"+con_var+"']"))
                            ind_word = expr_replace(ind_word,variable,eval("['+',['"+con_var+"'],['1']]"))
                    else:
                            assum_word = expr_replace(assum_word,variable,eval("['-',['"+con_var+"'],['1']]"))
                            ind_word = expr_replace(ind_word,variable,eval("['"+con_var+"']"))

                temp_post_condition=[]
                temp_post_condition.append(wff2z3_update(base_word))
                writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(base_word)+'\n')
                status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                #print status
                if 'Successfully Proved' in status:
                    update_word=[]
                    update_word.append('c1')
                    temp_update_word=[]
                    temp_update_word.append('Implies')
                    temp_update_word.append(assum_word)
                    temp_update_word.append(ind_word)
                    update_word.append(temp_update_word)
                    
                    temp_post_condition=[]
                    temp_post_condition.append(wff2z3_update(update_word))
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                    writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(update_word)+'\n')
                    status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                    writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                    if 'Successfully Proved' in status:
                        #print status
                        return status
            return "Failed to prove"            




                    
                    

def getIndexParameter(e,var_const_ind_map,Const_var_map):
    if isArrayFunction(e[:1][0])==True:
        para_list=expr_args(e)
        for x in range(0,len(para_list)):
            #para_list[x] = getIndexParameter(para_list[x],var_const_ind_map,Const_var_map)
            list_para = getListOfPara(para_list[x],Const_var_map)
            if list_para is not None:
                if x in var_const_ind_map.keys():
                    temp_var_const_ind_map=var_const_ind_map[x]
                    var_const_ind_map[x]= temp_var_const_ind_map+list_para
                else:
                    var_const_ind_map[x]= list_para
        return e[:1]+para_list
    elif e[:1][0]!='and' and e[:1][0]!='or' and e[:1][0]!='not' and e[:1][0]!='implies' and e[:1][0] not in _infix_op and isArrayFunction(e[:1][0])!=True:        
        para_list=expr_args(e)
        for x in range(0,len(para_list)):
            #para_list[x] = getIndexParameter(para_list[x],var_const_ind_map,Const_var_map)
            list_para = getListOfPara(para_list[x],Const_var_map)
            if list_para is not None:
                if x+1 in var_const_ind_map.keys():
                    temp_var_const_ind_map=var_const_ind_map[x+1]
                    var_const_ind_map[x+1]= temp_var_const_ind_map+list_para
                else:
                    var_const_ind_map[x+1]= list_para
        return e[:1]+para_list

    else:
        return e[:1]+list(getIndexParameter(x,var_const_ind_map,Const_var_map) for x in expr_args(e))


def getListOfPara(e,Const_var_map):
    list_para=[]
    for var in Const_var_map:
        var_exp=eval("['"+var+"']")
        if expr_find(e,Const_var_map[var])==True:
            if Const_var_map[var] not in list_para:
                list_para.append(Const_var_map[var])
        if expr_find(e,var_exp)==True:
            if var_exp not in list_para:
                list_para.append(var_exp)
    if len(list_para)>0:
        return list_para
    else:
        return None





def conditionCreator(condition_list):
    if len(condition_list)>1:
        list=[]
        list.append('And')
        list.append(condition_list[0])
        list.append(conditionCreator(condition_list[1:]))
        return list
    else:
        return condition_list[0]
    
    
def replaceIndexWithFun(e,para_map,fun_map):
    if isArrayFunction(e[:1][0])==True and e[:1][0] in fun_map.keys():
        para_list=expr_args(e)
        for x in para_map:
            para_list[int(para_map[x])-1]=eval("['"+x+"',"+str(para_list[int(para_map[x])-1])+"]")
        return e[:1]+para_list
    else:
        return e[:1]+list(replaceIndexWithFun(x,para_map,fun_map) for x in expr_args(e))







def getConditionsForInduction(e,condition_list,left_e):
    if type(e) is list:
        if e[:1]==['ite']:
            args=expr_args(e)
            if args[1]==left_e and args[1][:1]!=['ite'] and args[2]!=left_e and args[2][:1]!=['ite']:
                if args[0][:1]!=['ite']:
                    condition_list.append(expr_complement(copy.deepcopy(args[0])))
                else:
                    getConditionsForInduction(args[0],condition_list,left_e)
            elif args[1]!=left_e and args[1][:1]!=['ite'] and args[2]==left_e and args[2][:1]!=['ite']:
                if args[0][:1]!=['ite']:
                    condition_list.append(args[0])
                else:
                    getConditionsForInduction(args[0],condition_list,left_e)
            elif args[1]==left_e and args[1][:1]!=['ite'] and args[2]!=left_e and args[2][:1]==['ite']:
                if args[0][:1]!=['ite']:
                    condition_list.append(expr_complement(copy.deepcopy(args[0])))
                else:
                    getConditionsForInduction(args[0],condition_list,left_e)
                getConditionsForInduction(args[1],condition_list,left_e)
            elif args[1]!=left_e and args[1][:1]==['ite'] and args[2]==left_e and args[2][:1]!=['ite']:
                if args[0][:1]!=['ite']:
                    condition_list.append(args[0])
                else:
                    getConditionsForInduction(args[0],condition_list,left_e)
                getConditionsForInduction(args[2],condition_list,left_e)
            else:
                if args[0][:1]!=['ite']:
                    condition_list.append(args[0])
                else:
                    getConditionsForInduction(args[0],condition_list,left_e)
                getConditionsForInduction(args[1],condition_list,left_e)
                getConditionsForInduction(args[2],condition_list,left_e)
        else:
            for x in expr_args(e):
                getConditionsForInduction(x,condition_list,left_e)



def getFunctionIndex(e,para_map,count):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)>0:
        if op!='and' and op!='or' and op!='not' and op!='implies' and op not in _infix_op and isArrayFunction(op)!=True:
            para_map[op]=count
            return e[:1]+list(getFunctionIndex(x,para_map,count) for x in expr_args(e))
        else:
            return e[:1]+list(getFunctionIndex(x,para_map,count) for x in expr_args(e))
    else:
        return e




def getAllArrayFunctions(e,fun_map):
    if isArrayFunction(e[:1][0])==True:
        para_list=[]
        for x in expr_args(e):
            para_list.append(x)
        fun_map[e[:1][0]]=para_list
        return e[:1]+list(getAllArrayFunctions(x,fun_map) for x in expr_args(e))
    else:
        return e[:1]+list(getAllArrayFunctions(x,fun_map) for x in expr_args(e))






def getIndexVaribles(e,index_var_map):
        if e[:1]==['and']:
        	for x in expr_args(e):
                    if x[0]=='=' and isvariable(x[1][0])==True:
                        if x[1][0] not in index_var_map.keys() :
                            index_var_map[x[1][0]]=x[2]

        elif e[:1]==['ite']:
        	for x in expr_args(e):
                    if x[0]=='=' and isvariable(x[1][0])==True:
                        if x[1][0] not in index_var_map.keys():
                            index_var_map[x[1][0]]=x[2]

        else:
            for x in expr_args(e):
                getIndexVaribles(x,index_var_map)







def getAllCondtionArray(w,condition_list):
	if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
	        if w[-1][0]=='ite':
                    if isArrayFunction(w[-1][2][0]) and '_N' in expr2string1(w[-1][2]):
                        condition_list.append(w[-1][1])
                        if  w[-1][2][3]=='ite':
                            getAllCondtionArray(w[-1][2],condition_list)










def expr_update_iter(e,array_fun_map): #e,e1,e2: expr
	if isArrayFunction(e[:1][0])==True:
		temp=[]
                parameter=[]
		count=0
                e1 = array_fun_map[e[1][0]]
                temp.append(e[1][0])
        	for x in expr_args(e):
                    if count>0 and count<len(expr_args(e))-1:
                        parameter.append(x)
                    count=count+1
		return expr_update_term(copy.deepcopy(e1),parameter)
	else:
		return e[:1]+list(expr_update_iter(x,array_fun_map) for x in expr_args(e))
                

def expr_update_term(e,parameter):
    if isArrayFunction(e[:1][0])==True:
            temp=[]
            count=0
            for x in expr_args(e):
                if count>0 and count<len(expr_args(e)):
                    if '_x' not in parameter[count-1][0]:
                        temp.append(parameter[count-1])
                    else:
                        temp.append(x)
                else:
                    temp.append(x)
                count=count+1
            return e[:1]+temp
    else:
		return e[:1]+list(expr_update_term(x,parameter) for x in expr_args(e))














def prove_assert_tactic4_test(axiom,witnessXml):
	array_fun_map={}
	
	array_var_map={}
	
	post_condition={}
	
        array_degree_map={}
	
	array_list=[]
	
	counter_var_list=[]
	
	instant_eq=[]
	
	t_instant_eq=[]
	
	addition_eq=[]
	
	o_instant_eq={}
	
	call_var_list=[]
	
	array_fun=None
	
	array_init_map={}
	
	#Base Cases Query List
	
	base_case_query=[]
	       
	#Conclusions Query List
	
	conl_case_query=[]
	 
	#List of Assumptions
	 
	assum_list=[]
	
	#Variable Constant Map
	       
        var_const_map={}
	
	#List of Constraints Derived from Axoims 
	
	constraint_list=[]
	
	#Elements Return by Recursive Function 
	
	assum_list_ret=None
	
	conl_case_query_ret=None
	
	var_const_map_ret=None
	
	pre_condition=[]
	
	#Additional Equation
	
	add_equation_d=[]
	
	#main free variable map
	
	main_free_var_map={}
	
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
		
	str_value,word=axiom.getAsserts()
	
	for variable in axiom.getVariables():
            variableclass=axiom.getVariables()[variable]
            array_degree_map[variable]=variableclass.getDimensions()
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())

	for x in axiom.getOutput_equations():
		if isArrayFunction(x)==True:
			array_fun =  copy.deepcopy(axiom.getOutput_equations()[x][1])
			array_fun[0] = x
			array_init_map[x[1]]=array_fun

	for [x,k,l] in axiom.getVfact():
		if k==0 and l[0]=='array' and isArrayFinal(x)==False and not(x=='main'):
			array_list.append(x)
                        array_init_list=[]
                        temp=[]
                        temp.append({})
                        temp.append(array_init_map[str(array_degree_map[x])])
                        array_init_list.append(temp)
			#array_fun_map[x]=array_init_map[str(array_degree_map[x])]
                        array_fun_map[x]=array_init_list
        var_list=axiom.getConst_var_map().keys()
        f_count=0
        for x in axiom.getOutput_equations():
        	if isArrayFunction(x):
        		var_e1=eval("['_x1']")
        		for e_array in array_list:
        			if axiom.getOutput_equations()[x][1][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_x1 = copy.deepcopy(axiom.getOutput_equations()[x])
        				var_array=eval("['"+e_array+"']")
        				f_count=f_count+1
        				new_x1[1]=expr_replace(new_x1[1],var_e1,var_array)
        				new_x1[2]=expr_replace(new_x1[2],var_e1,var_array)
        				o_instant_eq[x+'_'+str(f_count)]=new_x1
		else:
			o_instant_eq[x]=axiom.getOutput_equations()[x]
        
        temp_instant_eq_list=[]
        for e in axiom.getOther_axioms():
        	if e[0]=='i0' and isArrayFunction(e[2][0]):
        		for e_array in array_list:
                                if e[2][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_e1 = copy.deepcopy(e)
					var_e1=eval("['_x1']")
        				var_array=eval("['"+e_array+"']")
        				new_e1[2]=expr_replace(new_e1[2],var_e1,var_array)
        				new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
        				instant_eq.append(new_e1)        	
        	elif e[0]=='i1' and isArrayFunction(e[3][0]):
          		temp_instant_eq1=[]
                        temp_instant_eq2=[]
          		for e_array in array_list:
                                if e[3][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
            		      		new_e1 = copy.deepcopy(e)
                                        var_e1=eval("['_x1']")
         				var_array=eval("['"+e_array+"']")
                                        new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                        new_e1[4]=expr_replace(new_e1[4],var_e1,var_array)
                                        new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
                                        new_e1[4]=simplify_ind_equation_array(new_e1[4],array_list)
                                        temp_instant_eq1.append(new_e1)
                        for new_e2 in temp_instant_eq1:
                            #print '~~~~~~~~~~~~~~~~~3'
                            #print wff2string1(new_e2)
                            #print '~~~~~~~~~~~~~~~~~3'
                            free_var_list=[]
                            getAllFreeVariable2(copy.deepcopy(new_e2[4]),free_var_list)
                            if len(free_var_list)>0:
                                for free_var_map in free_var_list:
                                    new_e3 = copy.deepcopy(new_e2)
                                    for f_var in free_var_map.keys():
                                        new_e3[3]=expr_replace(new_e3[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                        new_e3[4]=expr_replace(new_e3[4],eval("['"+f_var+"']"),free_var_map[f_var])
                                    new_e3[4]=simplify_ind_equation(new_e3[4],array_list)
                                    temp_instant_eq2.append(new_e3)
                            else:
                                temp_instant_eq2.append(new_e2)
                        for new_e2 in temp_instant_eq2:    
                            instant_eq.append(new_e2) 
        	else:
        		instant_eq.append(e)
                        
        update_facts=copy.deepcopy(axiom.getVfact())

        Super_Couter=0
        
        G_dgree=None
        
        
        for e in axiom.getOther_axioms():
        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list and (G_dgree is None or e[3][0][1]==G_dgree):
                                if G_dgree is None:
                                	G_dgree=e[3][0][1]
        			var=e[2]
        			const_var=e[2].replace('n','k')
        			update_facts.append(eval("['"+const_var+"',0,['int']]"))
        			constraint_list.append(const_var+">=0")
        			#p = getParser()
                                #tree = p.parse_expression(axiom.getConst_var_map()[var])
        			#constant=axiom.getConst_var_map()[var]
        			#constant=eval(expressionCreator(tree))
                                
                                
                                parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                constant=construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
        			
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
                                query_ret_list=None
                                var_const_map_ret=None
                                if flag:
                                    query_ret_list,var_const_map_ret = prove_assert_tactic4_Rec_test(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map)
                                    
                                #Add1
                                
                                constraint_list1=copy.deepcopy(constraint_list)
        			if query_ret_list is not None:
        				for query_ret in query_ret_list:
        					if query_ret is not None:
                                        		for e_array in query_ret.keys():
                                            			constraint_list1.append(wff2z3_update(query_ret[e_array][2]))
                                for e_array in array_list:
                                    list = getRecEquation(instant_eq,var,e_array,array_degree_map[e_array])
                                    array_flag=False
                                                                    
                                    temp_map_values_array=[]
                                    
                                    array_init_list=array_fun_map[e_array]
                                    
                                    for ei in list:
                                        
                                        for array_init in array_init_list:
                                            #get Initial Array values
                                            #array_fun=array_fun_map[e_array]
                                            array_fun=array_init[1]
                                            free_var_map=array_init[0]
                                        
                                            #Deep Copy for Base Case Equation 
                                        
                                            new_e1 = copy.deepcopy(ei)
                                            query_e1 = copy.deepcopy(ei)
                                            query_e2 = copy.deepcopy(ei)
                                            query_e3 = copy.deepcopy(ei)
                                            query_e4 = copy.deepcopy(ei)
                                            query_e5 = copy.deepcopy(ei)
                                            query_e6 = copy.deepcopy(ei)
                                            query_e7 = copy.deepcopy(ei)
                                            var_e1=eval("['_x1']")
                                            var_array=eval("['"+e_array+"']")
                                        
                                            inst_str=eval("['=',['_x1'],['"+str(e_array)+"']]")
         				
                                            initialValue=array_fun
					
                                            array_value=findAllArrayInEq(e[4],array_list)
                                            
         				
                                            if e_array in array_value:
                                                    initialValue=copy.deepcopy(new_e1[4])
                                                    array_map_inital={}
                                                    get_expr_initial(initialValue,array_map_inital)
                                                #initialValue=expr_initial(initialValue,array_fun_map,array_map_inital,var)
                                                    update_facts.append(eval("['"+e[2].replace('n','L')+"',0,['int']]"))
                                                #if Super_Couter==1 :
                                                #    return
						
                                            #Base Case Equation 
    						
                                            if e_array in array_value:
                                                    free_var_map={}
                                                    free_var_map=getAllFreeVariable3(expr_else(new_e1[4]),array_degree_map[e_array])
                                                    main_free_var_map[e_array]=free_var_map
                                                    if not free_var_map:
                                                        query_e1[4]=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        query_e4[4]=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        query_e5[4]=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        query_e6[4]=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                    else:
                                                        query_e1[4]=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        query_e4[4]=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        query_e5[4]=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        query_e6[4]=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                    array_var_map[e_array]=free_var_map
                                                    for f_var in free_var_map.keys():
                                                            query_e1[3]=expr_replace(query_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            query_e1[4]=expr_replace(query_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            query_e4[3]=expr_replace(query_e4[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            query_e4[4]=expr_replace(query_e4[4],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            query_e6[3]=expr_replace(query_e6[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            query_e6[4]=expr_replace(query_e6[4],eval("['"+f_var+"']"),free_var_map[f_var])
       					
                                                    query_e1[4]=expr_replace(query_e1[4],eval("['"+var+"']"),eval("['0']"))
                                                    query_e1[3]=expr_replace(query_e1[3],eval("['"+var+"']"),eval("['0']"))
                                                    query_e5[3]=expr_replace(query_e5[3],eval("['+',['"+var+"'],['1']]"),constant)
                                                    query_e5[4]=expr_replace(query_e5[4],eval("['"+var+"']"),eval("['-',"+str(constant)+",['1']]"))
                                                    #const_avoid_map[var]=eval("['-',"+str(constant)+",['1']]")
                                            else:
                                                    #free_var_map={}
                                                    #if e_array in main_free_var_map.keys():
                                                    #    free_var_map=main_free_var_map[e_array]
                                                    array_var_map[e_array]=free_var_map
                                                    query_e1[4]=copy.deepcopy(initialValue)
                                                    query_e1[3]=expr_replace(query_e1[3],eval("['+',['"+var+"'],['1']]"),eval("['0']"))
                                                    query_e4[3]=expr_replace(query_e4[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
                                                    query_e4[4]=copy.deepcopy(initialValue)
                                                    query_e5[3]=expr_replace(query_e4[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
                                                    query_e5[4]=copy.deepcopy(initialValue)
                                                    query_e5[3]=expr_replace(query_e5[3],eval("['"+var+"']"),constant)
                                                    query_e5[4]=expr_replace(query_e5[4],eval("['"+var+"']"),constant)
                                                    query_e6[3]=expr_replace(query_e6[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
                                                    query_e6[4]=copy.deepcopy(initialValue)
                                                    for f_var in free_var_map.keys():
                                                            new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
							#Added 18/04/2017
                                                            query_e1[3]=expr_replace(query_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            query_e5[3]=expr_replace(query_e5[3],eval("['"+f_var+"']"),free_var_map[f_var])

        				
                                            #Substituting Constant 
                                            if var_const_map_ret is not None:
                                                    for var_ret in var_const_map_ret.keys():
        				
                                                            update_facts.append(eval("['"+var_const_map_ret[var_ret]+"',0,['int']]"))
        					
                                                            constraint_list1.append(var_const_map_ret[var_ret]+">=0")
        					
                                                            query_e1[3]=expr_replace(query_e1[3],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
                                                            query_e1[4]=expr_replace(query_e1[4],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
        				
                                            query_e1[3]=expr_replace(query_e1[3],var_e1,var_array)
        				
                                            query_e1[4]=expr_replace(query_e1[4],var_e1,var_array)
                                                                                    
                                            query_e1[4]=simplify_ind_equation(query_e1[4],array_list)
                                        
                                            query_e4[3]=expr_replace(query_e4[3],var_e1,var_array)
                                        
                                            query_e4[4]=expr_replace(query_e4[4],var_e1,var_array)
                                            query_e4[4]=simplify_ind_equation(query_e4[4],array_list)
                                        

 					
                                            query_e5[3]=expr_replace(query_e5[3],var_e1,var_array)
                                        
                                            query_e5[4]=expr_replace(query_e5[4],var_e1,var_array)
                                        

                                        
                                            query_e5[4]=simplify_ind_equation(query_e5[4],array_list)
                                        
 					
                                            query_e6[3]=expr_replace(query_e6[3],var_e1,var_array)
                                            query_e6[4]=expr_replace(query_e6[4],var_e1,var_array)
                                            query_e6[4]=simplify_ind_equation(query_e6[4],array_list)

                                            temp_post_condition=[]
                                            temp_post_condition.append(wff2z3_update(query_e1))
                                            t_instant_eq=getLoopAxiomes(instant_eq,axiom.getConst_var_map()[var],var,add_equation_d)
                                            writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                                            writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+ wff2z3_update(query_e1)+'\n')
                                            #status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                            #status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                            status=tactic1_update(axiom.getFrame_axioms(),[],t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                            writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                                            print wff2z3_update(query_e1)
                                            print status
                                            if 'Successfully Proved' in status:
					
                                                    #Assumption Equation
                                                
                                                    assum_e2=query_e2[3]
					
                                                    if e_array in array_value:
                                                            free_var_map=getAllFreeVariable3(expr_else(new_e1[4]),array_degree_map[e_array])
                                                            if not free_var_map:
                                                                assum_e1=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                            else:
                                                                assum_e1=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                            for f_var in free_var_map.keys():
                                                                assum_e1=expr_replace(assum_e1,eval("['"+f_var+"']"),free_var_map[f_var])
                                                                assum_e2=expr_replace(assum_e2,eval("['"+f_var+"']"),free_var_map[f_var])
                                                            #assum_e1=initialValue
                                                            assum_e1=expr_replace(assum_e1,eval("['"+var+"']"),eval("['"+const_var+"']"))
                                                            assum_e1=simplify_ind_equation(assum_e1,array_list)
                                                    else:
                                                            #assum_e1=array_fun
                                                            if e_array in main_free_var_map.keys():
                                                                free_var_map=main_free_var_map[e_array]
                                                            assum_e1=copy.deepcopy(initialValue)
                                                            for f_var in free_var_map.keys():
                                                                    assum_e1=expr_replace(assum_e1,eval("['"+f_var+"']"),free_var_map[f_var])
                                                                    assum_e2=expr_replace(assum_e2,eval("['"+f_var+"']"),free_var_map[f_var])
					
                                                    #assum_e2=expr_replace(query_e2[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
                                                    assum_e2=expr_replace(assum_e2,eval("['"+var+"']"),eval("['"+const_var+"']"))
                                                    assum=[]
                                                    assum.append('==')
                                                    assum.append(assum_e2)
                                                    assum.append(assum_e1)
                                                    assum=expr_replace(assum,var_e1,var_array)
                                                    conl_e2=query_e3[3]
                                                    if e_array in array_value:
                                                            free_var_map=getAllFreeVariable3(expr_else(new_e1[4]),array_degree_map[e_array])
                                                            if not free_var_map:
                                                                conl_e1=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                            else:
                                                                conl_e1=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                            for f_var in free_var_map.keys():
                                                                conl_e1=expr_replace(conl_e1,eval("['"+f_var+"']"),free_var_map[f_var])
                                                                conl_e2=expr_replace(conl_e2,eval("['"+f_var+"']"),free_var_map[f_var])
         						#conl_e1=initialValue
                                                            conl_e1=expr_replace(conl_e1,eval("['"+var+"']"),eval("['+',['"+const_var+"'],['1']]"))
                                                            conl_e1=simplify_ind_equation(conl_e1,array_list)
                                                    else:
                                                            #conl_e1=array_fun
                                                            if e_array in main_free_var_map.keys():
                                                                free_var_map=main_free_var_map[e_array]
                                                            conl_e1=copy.deepcopy(initialValue)
                                                            for f_var in free_var_map.keys():
                                                                    conl_e1=expr_replace(conl_e1,eval("['"+f_var+"']"),free_var_map[f_var])
                                                                    conl_e2=expr_replace(conl_e2,eval("['"+f_var+"']"),free_var_map[f_var])
         				                                                
                                                    conl_e2=expr_replace(conl_e2,eval("['"+var+"']"),eval("['+',['"+const_var+"'],['1']]"))            
                                                    conl=[]
                                                    conl.append('==')
                                                    conl.append(conl_e2)
                                                    conl.append(conl_e1)
        				
                                                    conl=expr_replace(conl,var_e1,var_array)
        				
                                                    if var_const_map_ret is not None:
                                                            for var_ret in var_const_map_ret.keys():
                                                                    assum=expr_replace(assum,eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
                                                                    conl=expr_replace(conl,eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
                                                    ind_case_query=['c1',['implies',assum,conl]]
                                                    conl_case_query.append(ind_case_query)
                                                    temp_post_condition=[]
                                                    temp_post_condition.append(wff2z3_update(ind_case_query))
                                                    #status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                                                    writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+ wff2z3_update(ind_case_query)+'\n')			
                                                    #status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                                    status=tactic1_update(axiom.getFrame_axioms(),[],t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                                    writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                                                    print wff2z3_update(ind_case_query)
                                                    print status
                                                    #if e_array in array_value:
                                                    #    return
                                                    if 'Successfully Proved' in status:
                                                	#instant_eq.append(query_e4)

                                                                if e_array in array_value:
                                                                    query_e6[0]='L1'
                                                                    query=wff2z3_update(query_e6)
                                                                    if var_const_map_ret is not None:
                                                                            for var_ret in var_const_map_ret.keys():
                                                    				query=query.replace(var_ret,var_const_map_ret[var_ret])
                                                                    temp_post_condition=[]
                                                                    temp_post_condition.append(query)
								
                                                                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                                                                    writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+ wff2z3_update(ind_case_query)+'\n')
								
                                                                    #status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                                                    status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                                                    writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
				        			
                                                                    print query
                                                                    print status
                                                                    if 'Successfully Proved' in status:
                                                                            #array_fun_map[e_array]=copy.deepcopy(query_e5[4])
                                                                            #array_fun_map[e_array]=copy.deepcopy(expr_prime(array_fun_map[e_array],expr_replace(copy.deepcopy(query_e7[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1))
                                                                            ##array_fun_map[e_array]=expr_replace(array_fun_map[e_array],eval("['-',"+str(constant)+",['1']]"),eval(str(constant)))
                                                                            #array_fun_map[e_array]=expr_replace(array_fun_map[e_array],eval("['-',"+str(constant)+",['1']]"),eval("['"+var+"']"))
                                                                        
                                                                            array_fun=copy.deepcopy(query_e5[4])
                                                                            array_fun=copy.deepcopy(expr_prime(array_fun,expr_replace(copy.deepcopy(query_e7[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1))
                                                                            #array_fun_map[e_array]=expr_replace(array_fun_map[e_array],eval("['-',"+str(constant)+",['1']]"),eval(str(constant)))
                                                                            array_fun=expr_replace(array_fun,eval("['-',"+str(constant)+",['1']]"),eval("['"+var+"']"))
                                                                    
                                                                    
                                                                            temp_map_values=[]
                                                                    
                                                                            temp_map_values.append(free_var_map)
                                                                    
                                                                            temp_map_values.append(rep_array_free_list(array_fun,constant))
                                                                    
                                                                            array_flag=True
                                                                    
                                                                            temp_map_values_array.append(temp_map_values)
                                                                            #array_init[1]=array_fun
                                                                            #array_init[0]=free_var_map
                                            
                                                                    
                                                                            query_e7[3]=expr_replace(query_e7[3],var_e1,var_array)
                                                                            query_e7[3]=expr_replace(copy.deepcopy(query_e7[3]),eval("['+',['"+var+"'],['1']]"),constant)
                                                                            for f_var in free_var_map.keys():
                                                                                query_e7[3]=expr_replace(query_e7[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                                            query_e7[4]=array_fun
                                                                            writeLogFile( "j2llogs.logs" ,'\nAxiomes Added--'+wff2z3_update(query_e7)+'\n')
                                                                            instant_eq.append(query_e7)
                                                                            add_equation_d.append(query_e7)
                                                                else:
                                                                        writeLogFile( "j2llogs.logs" ,'\nAxiomes Added--'+wff2z3_update(query_e5)+'\n')
                                                                        instant_eq.append(query_e5)
                                                                        add_equation_d.append(query_e5)
                                    if array_flag==True:
                                        array_fun_map[e_array]=temp_map_values_array
                                

                                if var_const_map_ret is not None:
                                	for var_const1 in var_const_map_ret.values():
                                    		constraint_list.append(var_const1+">=0")
                                if query_ret_list is not None:
                                	for query_ret in query_ret_list:
                                		for e_array in query_ret.keys():
                                    			print e_array
                                                        array_init_list=array_fun_map[e_array]
                                                        for array_init in array_init_list:
                                                            #get Initial Array values
                                                            #array_fun=array_fun_map[e_array]
                                                            array_fun=array_init[1]
                                                            free_var_map=array_init[0]
                                                            new_e1=copy.deepcopy(query_ret[e_array][1])
                                                            new_e5=copy.deepcopy(query_ret[e_array][5])
                                                            new_e2=copy.deepcopy(query_ret[e_array][2])
                                                            #free_var_map=array_var_map[e_array]
                                                            #if not free_var_map:
                                                            #    if e_array in main_free_var_map.keys():
                                                            #            free_var_map=main_free_var_map[e_array]
                                                            for f_var in free_var_map.keys():
                                                                new_e5[3]=expr_replace(new_e5[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                                new_e1[1]=expr_replace(new_e1[1],eval("['"+f_var+"']"),free_var_map[f_var])  
                                                            

                                                            if var_const_map_ret is not None:
                                                                for var_const in var_const_map_ret.keys():
                                                                    if query_ret[e_array][6]==var_const:
                                                                         new_e1[1][1][1]=expr_replace(new_e1[1][1][1],eval("['"+var_const+"']"),eval("['-',['"+var_const_map_ret[var_const]+"'],['1']]"))
                                                                         new_e1[1][1][2]=expr_replace(new_e1[1][1][2],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                                                    else:
                                                                        new_e1[1][1]=expr_replace( new_e1[1][1],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                                                			
                                                            constraint_list1=copy.deepcopy(constraint_list)
                                                            if query_ret is not None:
                                                                    for e_array1 in query_ret.keys():
                                                                            constraint_list1.append(wff2z3_update(new_e2))
                                                            #for var_ret in var_const_map_ret.keys():
                                                            temp_post_condition=[]
                                                            temp_post_condition.append(wff2z3_update(new_e1))
                                                            writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                                                            writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+ wff2z3_update(new_e1)+'\n')
                                                            #Big N--query_ret[e_array][8] Small N--query_ret[e_array][6]
                                                            #status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                                            #status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                                            writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                                                            print wff2z3_update(new_e1)
                                                            status="Failed to prove"
                                                            print status
                                                            if 'Successfully Proved' not in status:
                                                                    
                                                                    
                                                                    new_e3=copy.deepcopy(query_ret[e_array][3])
                                                                    #query_ret[e_array][2][4]=array_fun_map[e_array]
                                                                    new_e2[4]=array_fun
                                                                    #query_ret[e_array][3][4]=expr_replace(copy.deepcopy(array_fun_map[e_array]),eval("['"+query_ret[e_array][6]+"']"),eval("['"+'0'+"']"))
                                                                    new_e3[4]=expr_replace(copy.deepcopy(array_fun),eval("['"+query_ret[e_array][6]+"']"),eval("['"+'0'+"']"))
                                        			
                                                                    for f_var in free_var_map.keys():
                                                                            new_e3[3]=expr_replace(new_e3[3],eval("['"+f_var+"']"),free_var_map[f_var])

                                                                    new_e3[3]=expr_replace(new_e3[3],eval("['"+query_ret[e_array][6]+"']"),eval("['0']"))
                                                                    new_e3[4]=expr_replace(new_e3[4],eval("['"+query_ret[e_array][6]+"']"),eval("['0']"))
                                                            
                                                                    if var_const_map_ret is not None:
                                                                            for var_const in var_const_map_ret.keys():
                                                                                    if query_ret[e_array][6]==var_const:
                                                                                            new_e3[4]=expr_replace(new_e3[4],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                                                                            new_e3[3]=expr_replace(new_e3[3],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                        		
                                        		
                                                                    #query_ret[e_array][1][1][1][2]=array_fun_map[e_array]
                                                                    #query_ret[e_array][1][1][2][2]=array_fun_map[e_array]
                                                                    new_e1[1][1][2]=array_fun
                                                                    new_e1[1][2][2]=array_fun
                                                                    
                                                                    if var_const_map_ret is not None:
                                                                            for var_ret in var_const_map_ret.keys():
                                                                                    new_e3[4]=expr_replace(new_e3[4],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
                                                                                    new_e3[3]=expr_replace(new_e3[3],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))

                                                                    temp_post_condition=[]
                                                                    constraint_list2=copy.deepcopy(constraint_list)
                                                                    if query_ret is not None:
                                                                            for e_array1 in query_ret.keys():
                                                                                    constraint_list2.append(wff2z3_update(new_e2))
                                                                    temp_post_condition.append(wff2z3_update(new_e3))
                                        		
                                                                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                                                                    writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(new_e3)+'\n')
                                        		
                                                                    #status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list2,witnessXml)
                    
                                                                    status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list2,witnessXml)
                                        		
                                                                    writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                                        		
                                                                    print wff2z3_update(new_e3)
                                                                    print status
                                                                    if 'Successfully Proved' in status:      
                                                                            temp_post_condition=[]
                                                                            constraint_list2=copy.deepcopy(constraint_list)
                                                                            if query_ret is not None:
                                                                                    for e_array1 in query_ret.keys():
                                                                                            constraint_list2.append(wff2z3_update(new_e2))
                                                                            for f_var in free_var_map.keys():
                                                                                    new_e1[1][1][1]=expr_replace(new_e1[1][1][1],eval("['"+f_var+"']"),free_var_map[f_var])
                                                                                    new_e1[1][2][1]=expr_replace(new_e1[1][2][1],eval("['"+f_var+"']"),free_var_map[f_var])                                            				
                                                                            if var_const_map_ret is not None: 
                                                                                    for var_const in var_const_map_ret.keys():
                                                                                            if query_ret[e_array][6]==var_const:
                                                                                                    #query_ret[e_array][1][1][1][2]=expr_replace(query_ret[e_array][1][1][1][2],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                                                                                    new_e1[1][1][2]=expr_replace(new_e1[1][1][2],eval("['"+var_const+"']"),eval("['-',['"+var_const_map_ret[var_const]+"'],['1']]") )
                                                                                                    #query_ret[e_array][1][1][2][2]=expr_replace(query_ret[e_array][1][1][2][2],eval("['"+var_const+"']"),eval("['+',['"+var_const_map_ret[var_const]+"'],['1']]"))
                                                                                                    new_e1[1][2][2]=expr_replace(new_e1[1][2][2],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))	
                                            			
                                                                            if var_const_map_ret is not None:
                                                                                    for var_ret in var_const_map_ret.keys():
                                                                                            if var_ret==query_ret[e_array][6]:
                                                                                                    new_e1[1][1]=expr_replace(new_e1[1][1],eval("['"+var_ret+"']"),eval("['-',['"+var_const_map_ret[var_ret]+"'],['1']]"))
                                                                                            else:
                                                                                                    new_e1[1][1]=expr_replace(new_e1[1][1],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
                                                                                            new_e1[1][2]=expr_replace(new_e1[1][2],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
                                            			

                                                                            temp_post_condition.append(wff2z3_update(new_e1))
                                                                            status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list2,witnessXml)
                                            			
                                                                            writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                                                                            writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(new_e1)+'\n')                               
                                                                            status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list2,witnessXml)	
                                                                            writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                                            			
                                                                            print wff2z3_update(new_e1)
                                                                            print status
                                                                            #count=count+1
                                                                            #if count==2:
                                                                            #    return 
                                                                            if 'Successfully Proved' in status:
                                                                                    new_e4=copy.deepcopy(query_ret[e_array][4])
                                                                                    #array_fun_map[e_array]=copy.deepcopy(expr_prime(array_fun_map[e_array],query_ret[e_array][9],var_e1))
                                                                                    array_init[1]=copy.deepcopy(expr_prime(array_init[1],query_ret[e_array][9],var_e1))
                                                                                    array_init[0]=free_var_map
                                                                                    new_e4[4]=copy.deepcopy(expr_prime(copy.deepcopy(array_init[1]),query_ret[e_array][10],var_e1))
                                                                                    #instant_eq.append(query_ret[e_array][4])
                                                                                    new_e5[4]=copy.deepcopy(array_init[1])
                                                                                    for f_var in free_var_map.keys():
                                                                                            new_e5[3]=expr_replace(new_e5[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                                                    writeLogFile( "j2llogs.logs" ,'\nAxiomes Added--'+wff2z3_update(new_e5)+'\n')
                                                                                    add_equation_d.append(new_e5)
                                                                                    instant_eq.append(new_e5)
                                    			else:
                                        			writeLogFile( "j2llogs.logs" ,'\nAxiomes Added--'+wff2z3_update(new_e5)+'\n')
                                        			add_equation_d.append(new_e5)
                                        			instant_eq.append(new_e5)                                        

        #return
        print '=====================Main Proving Process====================='
	post_condition[str_value]=word
	for postcondition in post_condition.keys():
                for x in axiom.getConstraints():
                    constraint_list.append(x)
		#print '\nAxiomes Added\n'
		#for e in add_equation_d:
		#	print wff2string1(e)
		temp_post_condition=[]
		print '\n'
		temp_post_condition.append(wff2z3_update(post_condition[postcondition]))
		
		writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
		writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(post_condition[postcondition])+'\n')
                
                
		status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)	
                
                writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                
                print status
                
                #if 'Successfully Proved' not in status:
                #    print prove_assert_tactic5(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)
                
	print '=============================================================='
        
            


def prove_assert_tactic4_Rec_test(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map):

       var_list=axiom.getConst_var_map().keys()
       
       query_map_list=[]
       
       query_map={}
       
       base_case_query=[]
       
       conl_case_query=[]
       
       assum_list=[]
       
       var_const_map={}
       
       constraint_list=[]
       frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
       for x in frame_axioms:
       		constraint_list.append(x)
       out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
       for x in out_axioms:
		constraint_list.append(x)
       pre_condition=[]
	
       for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
       
                 
       for e in axiom.getOther_axioms():
        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list:

        			var=e[2]
        			const_var=e[2].replace('n','k')
                                var_const_map[var]=const_var
                                p = getParser()
                                tree = p.parse_expression(axiom.getConst_var_map()[var])
        			constant=eval(expressionCreator(tree))
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True

        			if not flag:
                                	new_e = copy.deepcopy(e)
					status,array_value=findArrayInEq(e[4],array_list)	
					#instantiated the array value
					if array_value is not None:
						inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
					 
					
					for e_array in array_list:
                                            
                                                array_init_list=array_fun_map[e_array]
                                                for array_init in array_init_list:

                                                    #get Initial Array values
                                                    #array_fun=array_fun_map[e_array]
                                                    array_fun=array_init[1]
                                                    free_var_map=array_init[0]
                                                    
                                                    new_e_main = copy.deepcopy(e)
                                                    
                                                    for f_var in free_var_map.keys():
                                                        new_e_main[3]=expr_replace(new_e_main[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                        new_e_main[4]=expr_replace(new_e_main[4],eval("['"+f_var+"']"),free_var_map[f_var])
                                                    
                                                    #List of queries
                                                    quary_list=[]
                                                    # Construct Variable Array
                                                    var_e1=eval("['_x1']")
                                                    # Construct Array
                                                    var_array=eval("['"+e_array+"']")
                                                    #Get the copy of the equation
                                                    new_e1 = copy.deepcopy(new_e_main)
                                                    query_e1 = copy.deepcopy(new_e_main)
                                                    query_e2 = copy.deepcopy(new_e_main)
                                                    query_e3 = copy.deepcopy(new_e_main)
                                                    query_e4 = copy.deepcopy(new_e_main)
                                                    query_e5 = copy.deepcopy(new_e_main)
                                                    query_e6 = copy.deepcopy(new_e_main)
                                                    #Construct Base Case Equations 
                                                    query_e1[4]=array_fun
                                                    query_e1[3]=expr_replace(query_e1[3],eval("['+',['"+var+"'],['1']]"),eval("['0']"))
                                                    if e_array in main_free_var_map.keys():
                                                        free_var_map=main_free_var_map[e_array]
                                                        for f_var in free_var_map.keys():
                                                            query_e1[4]=expr_replace(query_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])  
                                                            query_e1[3]=expr_replace(query_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])  
                                                    #Construct Base Case Equations 
                                                    query_e4[4]=array_fun
                                                    query_e4[3]=expr_replace(query_e4[3],eval("['+',['"+var+"'],['1']]"),eval("['1']"))
                                                    #Construct Assumption Equation for Variable
                                                    query_e5[4]=array_fun
                                                    query_e5[3]=expr_replace(query_e5[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
                                                    #Construct Assumption Equation for Construct 
                                                    query_e6[4]=array_fun
                                                    #query_e6[3]=expr_replace(query_e6[3],eval("['+',['"+var+"'],['1']]"),constant)
                                                    query_e6[3]=expr_replace(query_e6[3],eval("['+',['"+var+"'],['1']]"),constant)
                                                    #Construct Assumption Equations
                                                    assum_e1=array_fun
                                                    assum_e2=expr_replace(query_e2[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
                                                    #Construct Induction Step Equations 
                                                    query_e2[3]=assum_e2
                                                    query_e2[4]=array_fun
                                                    #Construct Main Assumption Equation
                                                    assum=[]
                                                    assum.append('==')
                                                    assum.append(assum_e2)
                                                    assum.append(assum_e1)
                                                    #Construct Conclusion Equations
                                                    conl_e1=array_fun
                                                    conl_e2=expr_replace(query_e3[3],eval("['+',['"+var+"'],['1']]"),eval("['+',['"+const_var+"'],['1']]"))
                                                    #Construct Main Conclusion Equation
                                                    conl=[]
                                                    conl.append('==')
                                                    conl.append(conl_e2)
                                                    conl.append(conl_e1)
                                                    #Construct Final Conclusion Equation
                                                    ind_case_query=['c1',['implies',assum,conl]]
                                                    #Instantiated for Array
                                                    if e_array==array_value:
                                                            free_var_map={}
                                                            new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                                            new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),var_e1,var_array)
                                                            instant_eq.append(new_e1)
                                                    else:
                                                            new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                                            new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
                                                            instant_eq.append(new_e1) 
					        					
                                                    query_e1[3]=expr_replace(query_e1[3],var_e1,var_array)
                                                    query_e1[4]=expr_replace(query_e1[4],var_e1,var_array)
                                                    query_e2[3]=expr_replace(query_e2[3],var_e1,var_array)
                                                    query_e2[4]=expr_replace(query_e2[4],var_e1,var_array)
                                                    query_e4[3]=expr_replace(query_e4[3],var_e1,var_array)
                                                    query_e4[4]=expr_replace(query_e4[4],var_e1,var_array)                                
                                                    query_e5[3]=expr_replace(query_e5[3],var_e1,var_array)
                                                    query_e5[4]=expr_replace(query_e5[4],var_e1,var_array)
                                                    query_e6[3]=expr_replace(query_e6[3],var_e1,var_array)
                                                    query_e6[4]=expr_replace(query_e6[4],var_e1,var_array)
                                                    ind_case_query[1]=expr_replace(ind_case_query[1],var_e1,var_array) 
                                                    quary_list.append(query_e1)#0
                                                    quary_list.append(ind_case_query)#1
                                                    quary_list.append(query_e2)#2
                                                    quary_list.append(query_e4)#3
                                                    quary_list.append(query_e5)#4
                                                    quary_list.append(query_e6)#5
                                                    pre_condition=[]
                                                    temp_post_condition=[]
                                                    temp_post_condition.append(wff2z3_update(query_e1))
					        
                                                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                                                    writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(query_e1)+'\n')
                     
					        
                                                    status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),constraint_list,witnessXml)
					   	
                                                    writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                                                    print wff2z3_update(query_e1)
                                                    print status
                                                    quary_list.append(var)#6
                                                    quary_list.append(const_var)#7
                                                    quary_list.append(constant)#8
                                                    quary_list.append(expr_replace(copy.deepcopy(e[3]),eval("['+',['"+var+"'],['1']]"),constant))
                                                    quary_list.append(expr_replace(copy.deepcopy(e[3]),eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']")))
                                                    if 'Successfully Proved' in status:
                                            		query_map[e_array]=quary_list
                                                query_map_list.append(query_map)
                                                print ''
                                	return query_map_list,var_const_map
        			else:
        				#print 'XXXXX-XXXXX'
                                        #print main_free_var_map
        				query_map_list_temp,var_const_map_temp=prove_assert_tactic4_Rec_test(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map)
       			       				
        				for query_ret in query_map_list_temp:
						if query_ret is not None:
					        	for e_array in query_ret.keys():
                                            			constraint_list.append(wff2z3_update(query_ret[e_array][2]))
        				for var_const_temp in var_const_map_temp.keys():
        					var_const_map[var_const_temp]=var_const_map_temp[var_const_temp]

        				
                                	update_facts=copy.deepcopy(axiom.getVfact())
                                	
                                	for var_ret in var_const_map_temp.keys():
						update_facts.append(eval("['"+var_const_map_temp[var_ret]+"',0,['int']]"))
					        constraint_list.append(var_const_map_temp[var_ret]+">=0")
                                	
                                	new_e = copy.deepcopy(e)
					status,array_value=findArrayInEq(e[4],array_list)	
					#instantiated the array value
					if array_value is not None:
						inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]") 
					for e_array in array_list:
						#get Initial Array values
                                                array_init_list=array_fun_map[e_array]
                                                for array_init in array_init_list:
                                                    
                                                    array_fun=array_init[1]
                                                    
                                                    free_var_map=array_init[0]
                                                    
                                                    for f_var in free_var_map.keys():
                                                        new_e_main[3]=expr_replace(new_e_main[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                        new_e_main[4]=expr_replace(new_e_main[4],eval("['"+f_var+"']"),free_var_map[f_var])
                                                    
                                                    
                                                    #List of queries
                                                    quary_list=[]
                                                    # Construct Variable Array
                                                    var_e1=eval("['_x1']")
                                                    # Construct Array
                                                    var_array=eval("['"+e_array+"']")
                                                    #Get the copy of the equation
                                                    new_e1 = copy.deepcopy(e)
                                                    query_e1 = copy.deepcopy(e)
                                                    query_e2 = copy.deepcopy(e)
                                                    query_e3 = copy.deepcopy(e)
                                                    query_e4 = copy.deepcopy(e)
                                                    query_e5 = copy.deepcopy(e)
                                                    query_e6 = copy.deepcopy(e)
                                                    #Construct Base Case Equations 
                                                    query_e1[4]=array_fun
                                                    query_e1[3]=expr_replace(query_e1[3],eval("['+',['"+var+"'],['1']]"),eval("['0']"))
                                                    if e_array in main_free_var_map.keys():
                                                        free_var_map=main_free_var_map[e_array]
                                                        for f_var in free_var_map.keys():
                                                            query_e1[4]=expr_replace(query_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])  
                                                            query_e1[3]=expr_replace(query_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])  

                                                    #Construct Base Case Equations 
                                                    query_e4[4]=array_fun
                                                    query_e4[3]=expr_replace(query_e4[3],eval("['+',['"+var+"'],['1']]"),eval("['1']"))
                                                    #Construct Assumption Equation for Variable
                                                    query_e5[4]=array_fun
                                                    query_e5[3]=expr_replace(query_e5[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
                                                    #Construct Assumption Equation for Construct 
                                                    query_e6[4]=array_fun
                                                    query_e6[3]=expr_replace(query_e6[3],eval("['+',['"+var+"'],['1']]"),constant)
                                                    #Construct Assumption Equations
                                                    assum_e1=array_fun
                                                    assum_e2=expr_replace(query_e2[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
                                                    #Construct Induction Step Equations 
                                                    query_e2[3]=assum_e2
                                                    query_e2[4]=array_fun
                                                    #Construct Main Assumption Equation
                                                    assum=[]
                                                    assum.append('==')
                                                    assum.append(assum_e2)
                                                    assum.append(assum_e1)
                                                    #Construct Conclusion Equations
                                                    conl_e1=array_fun
                                                    conl_e2=expr_replace(query_e3[3],eval("['+',['"+var+"'],['1']]"),eval("['+',['"+const_var+"'],['1']]"))
                                                    #Construct Main Conclusion Equation
                                                    conl=[]
                                                    conl.append('==')
                                                    conl.append(conl_e2)
                                                    conl.append(conl_e1)
					        
                                                    for var_ret in var_const_map_temp.keys():
                                                            query_e1[3]=expr_replace(query_e1[3],eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
                                                            query_e1[4]=expr_replace(query_e1[4],eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
                                                            query_e2[3]=expr_replace(query_e2[3],eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
                                                            query_e2[4]=expr_replace(query_e2[4],eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
                                                            assum=expr_replace(assum,eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
                                                            conl=expr_replace(conl,eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
					        
					        
                                                    #Construct Final Conclusion Equation
                                                    ind_case_query=['c1',['implies',assum,conl]]
                                                    #Instantiated for Array
                                                    if e_array==array_value:
                                                            new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                                            new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str),var_e1,var_array)
                                                            instant_eq.append(new_e1)
                                                    else:
                                                            new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                                            new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
                                                            instant_eq.append(new_e1) 
					        					
                                                    query_e1[3]=expr_replace(query_e1[3],var_e1,var_array)
                                                    query_e1[4]=expr_replace(query_e1[4],var_e1,var_array)
                                                    query_e2[3]=expr_replace(query_e2[3],var_e1,var_array)
                                                    query_e2[4]=expr_replace(query_e2[4],var_e1,var_array)
                                                    query_e4[3]=expr_replace(query_e4[3],var_e1,var_array)
                                                    query_e4[4]=expr_replace(query_e4[4],var_e1,var_array)                                
                                                    query_e5[3]=expr_replace(query_e5[3],var_e1,var_array)
                                                    query_e5[4]=expr_replace(query_e5[4],var_e1,var_array)
                                                    query_e6[3]=expr_replace(query_e6[3],var_e1,var_array)
                                                    query_e6[4]=expr_replace(query_e6[4],var_e1,var_array)
                                                    ind_case_query[1]=expr_replace(ind_case_query[1],var_e1,var_array) 
                                                    quary_list.append(query_e1)
                                                    quary_list.append(ind_case_query)
                                                    quary_list.append(query_e2)
                                                    #print '##################################'
                                                    #print wff2z3_update(query_e1)
                                                    #print wff2z3_update(ind_case_query)
                                                    #print wff2z3_update(query_e2)
                                                    #print '##################################'
                                                    quary_list.append(query_e4)
                                                    quary_list.append(query_e5)
                                                    quary_list.append(query_e6)
                                                    pre_condition=[]
                                                    temp_post_condition=[]
                                                    temp_post_condition.append(wff2z3_update(query_e1))
					        
                                                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                                                    writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(query_e1)+'\n')
                     
					        
                                                    status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
					   	
                                                    writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
					   	
                                                    print wff2z3_update(query_e1)
                                                    print status
                                                    quary_list.append(var)
                                                    quary_list.append(const_var)
                                                    quary_list.append(constant)
                                                    quary_list.append(expr_replace(copy.deepcopy(e[3]),eval("['+',['"+var+"'],['1']]"),constant))
                                                    quary_list.append(expr_replace(copy.deepcopy(e[3]),eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']")))
                                                    if 'Successfully Proved' in status:
                                                            query_map[e_array]=quary_list
                                                query_map_list.append(query_map)
                                                for q_m_l_t in query_map_list_temp:
                                                    query_map_list.append(q_m_l_t)
        				return query_map_list,var_const_map				
       return None,None			






		


def getRecEquation(instant_eq,var,arrayVar,order):
    list=[]
    for e in instant_eq:
        #if e[0]=='i1' and isArrayFunction(e[3][0]) and e[3][order+1]==eval("['+',['"+var+"'],['1']]"):
        if e[0]=='i1' and isArrayFunction(e[3][0]) and e[3][1][0]==arrayVar and e[3][order+2]==eval("['+',['"+var+"'],['1']]") :
            list.append(e)
    return list







        
        
def prove_assert_tactic4(axiom,witnessXml):
	array_fun_map={}
	
	array_var_map={}
	
	post_condition={}
	
        array_degree_map={}
	
	array_list=[]
	
	counter_var_list=[]
	
	instant_eq=[]
	
	t_instant_eq=[]
	
	addition_eq=[]
	
	o_instant_eq={}
	
	call_var_list=[]
	
	array_fun=None
	
	array_init_map={}
	
	#Base Cases Query List
	
	base_case_query=[]
	       
	#Conclusions Query List
	
	conl_case_query=[]
	 
	#List of Assumptions
	 
	assum_list=[]
	
	#Variable Constant Map
	       
        var_const_map={}
	
	#List of Constraints Derived from Axoims 
	
	constraint_list=[]
	
	#Elements Return by Recursive Function 
	
	assum_list_ret=None
	
	conl_case_query_ret=None
	
	var_const_map_ret=None
	
	pre_condition=[]
	
	#Additional Equation
	
	add_equation_d=[]
	
	#main free variable map
	
	main_free_var_map={}
	
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
		
	str_value,word=axiom.getAsserts()
	
	for variable in axiom.getVariables():
            variableclass=axiom.getVariables()[variable]
            array_degree_map[variable]=variableclass.getDimensions()
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
	#for x in out_axioms:
	#	constraint_list.append(x)
	
	
	for x in axiom.getOutput_equations():
		if isArrayFunction(x)==True:
			array_fun =  copy.deepcopy(axiom.getOutput_equations()[x][1])
			array_fun[0] = x
			array_init_map[x[1]]=array_fun
			
	#print '################'
        #print array_degree_map
        #print array_init_map
        #print '################'

	for [x,k,l] in axiom.getVfact():
		if k==0 and l[0]=='array' and isArrayFinal(x)==False and not(x=='main'):
                        if str(array_degree_map[x]) in array_init_map.keys():
                            array_list.append(x)
                            array_fun_map[x]=array_init_map[str(array_degree_map[x])]
        var_list=axiom.getConst_var_map().keys()
        f_count=0
        for x in axiom.getOutput_equations():
        	if isArrayFunction(x):
        		var_e1=eval("['_x1']")
        		for e_array in array_list:
        			if axiom.getOutput_equations()[x][1][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_x1 = copy.deepcopy(axiom.getOutput_equations()[x])
        				var_array=eval("['"+e_array+"']")
        				f_count=f_count+1
        				new_x1[1]=expr_replace(new_x1[1],var_e1,var_array)
        				new_x1[2]=expr_replace(new_x1[2],var_e1,var_array)
        				o_instant_eq[x+'_'+str(f_count)]=new_x1
		else:
			o_instant_eq[x]=axiom.getOutput_equations()[x]
                        
        for e in axiom.getOther_axioms():
        	if e[0]=='i0' and isArrayFunction(e[2][0]):
        		for e_array in array_list:
                                if e[2][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
        				new_e1 = copy.deepcopy(e)
					var_e1=eval("['_x1']")
        				var_array=eval("['"+e_array+"']")
        				new_e1[2]=expr_replace(new_e1[2],var_e1,var_array)
        				new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
        				instant_eq.append(new_e1)        	
        	elif e[0]=='i1' and isArrayFunction(e[3][0]):
          		for e_array in array_list:
                                if e[3][0][1]==str(array_degree_map[e_array]) and '_PROVE' not in e_array:
            		      		new_e1 = copy.deepcopy(e)
			        	status,array_value=findArrayInEq(new_e1[4],array_list)
			        	if array_value is not None:
        					inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
        				var_e1=eval("['_x1']")
         				var_array=eval("['"+e_array+"']")
        				if e_array==array_value:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						free_var_map={}
                                                getAllFreeVariable(copy.deepcopy(new_e1[4]),inst_str,free_var_map)
                                                if not free_var_map:
                                                    new_e1[4]=expr_replace(expr_modify_array(new_e1[4],inst_str,free_var_map),var_e1,var_array)
                                                else:
                                                    new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),var_e1,var_array)
						new_e1[4]=simplify_ind_equation(new_e1[4],array_list)
						for f_var in free_var_map.keys():
							new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
							new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
						instant_eq.append(new_e1)
					else:
						new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
						new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
			        		instant_eq.append(new_e1)
        	else:
        		instant_eq.append(e)

        update_facts=copy.deepcopy(axiom.getVfact())


        Super_Couter=0
        
        G_dgree=None
        

        
        for e in axiom.getOther_axioms():
        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list and (G_dgree is None or e[3][0][1]==G_dgree):
                                if G_dgree is None:
                                	G_dgree=e[3][0][1]
        			var=e[2]
        			const_var=e[2].replace('n','k')
        			update_facts.append(eval("['"+const_var+"',0,['int']]"))
        			constraint_list.append(const_var+">=0")
        			#p = getParser()
                                #tree = p.parse_expression(axiom.getConst_var_map()[var])
        			#constant=axiom.getConst_var_map()[var]
        			#constant=eval(expressionCreator(tree))
                                
                                
                                parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                constant=eval(expressionCreator_C(statement_temp))
                                
        			
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
        					
        			new_e = copy.deepcopy(e)
        			
        			status,array_value=findArrayInEq(new_e[4],array_list)
        			
        			#instantiated the array value
        			        			        			
        			if array_value is not None:
        				inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
                                        
                                        
                                flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True
                                query_ret_list=None
                                var_const_map_ret=None
        			if flag:
                                        query_ret_list,var_const_map_ret = prove_assert_tactic4_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map)
                                        
                                        
                                #Add1
                                constraint_list1=copy.deepcopy(constraint_list)
        			if query_ret_list is not None:
        				for query_ret in query_ret_list:
        					if query_ret is not None:
                                        		for e_array in query_ret.keys():
                                            			constraint_list1.append(wff2z3_update(query_ret[e_array][2]))
                                            
       				for e_array in array_list:

                                        #Deep Copy for Base Case Equation 
                                        
                                        
                                        new_e1 = copy.deepcopy(e)
         				query_e1 = copy.deepcopy(e)
         				query_e2 = copy.deepcopy(e)
         				query_e3 = copy.deepcopy(e)
                                        query_e4 = copy.deepcopy(e)
                                        query_e5 = copy.deepcopy(e)
                                        query_e6 = copy.deepcopy(e)
                                        query_e7 = copy.deepcopy(e)
         				var_e1=eval("['_x1']")
         				var_array=eval("['"+e_array+"']")
         				
					initialValue=array_fun_map[e_array]
					
					status,array_value=findArrayInEq(new_e1[4],array_list)
                                        

         				
         				if e_array==array_value:
						initialValue=copy.deepcopy(new_e1[4])
						array_map_inital={}
                                                get_expr_initial(initialValue,array_map_inital)
                                                #initialValue=expr_initial(initialValue,array_fun_map,array_map_inital,var)
						update_facts.append(eval("['"+e[2].replace('n','L')+"',0,['int']]"))
                                                #if Super_Couter==1 :
                                                #    return
						
         				#Base Case Equation 
    						
       					if e_array==array_value:
       						free_var_map={}
                                                getAllFreeVariable(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                main_free_var_map[e_array]=free_var_map
                                                if not free_var_map:
                                                    query_e1[4]=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                    query_e4[4]=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                    query_e5[4]=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                    query_e6[4]=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                else:
                                                    query_e1[4]=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                    query_e4[4]=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                    query_e5[4]=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                    query_e6[4]=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                array_var_map[e_array]=free_var_map
                                                for f_var in free_var_map.keys():
							query_e1[3]=expr_replace(query_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
							query_e1[4]=expr_replace(query_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
							query_e4[3]=expr_replace(query_e4[3],eval("['"+f_var+"']"),free_var_map[f_var])
							query_e4[4]=expr_replace(query_e4[4],eval("['"+f_var+"']"),free_var_map[f_var])
							query_e6[3]=expr_replace(query_e6[3],eval("['"+f_var+"']"),free_var_map[f_var])
							query_e6[4]=expr_replace(query_e6[4],eval("['"+f_var+"']"),free_var_map[f_var])
       					
       						query_e1[4]=expr_replace(query_e1[4],eval("['"+var+"']"),eval("['0']"))
        					query_e1[3]=expr_replace(query_e1[3],eval("['"+var+"']"),eval("['0']"))
                                                query_e5[3]=expr_replace(query_e5[3],eval("['+',['"+var+"'],['1']]"),constant)
                                                query_e5[4]=expr_replace(query_e5[4],eval("['"+var+"']"),eval("['-',"+str(constant)+",['1']]"))
                                                #const_avoid_map[var]=eval("['-',"+str(constant)+",['1']]")
       					else:
       						free_var_map={}
                                                if e_array in main_free_var_map.keys():
                                                    free_var_map=main_free_var_map[e_array]
       						array_var_map[e_array]=free_var_map
       						query_e1[4]=copy.deepcopy(initialValue)
        					query_e1[3]=expr_replace(query_e1[3],eval("['+',['"+var+"'],['1']]"),eval("['0']"))
                                                query_e4[3]=expr_replace(query_e4[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
                                                query_e4[4]=copy.deepcopy(initialValue)
                                                query_e5[3]=expr_replace(query_e4[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
                                                query_e5[4]=copy.deepcopy(initialValue)
                                                query_e5[3]=expr_replace(query_e5[3],eval("['"+var+"']"),constant)
                                                query_e5[4]=expr_replace(query_e5[4],eval("['"+var+"']"),constant)
                                                query_e6[3]=expr_replace(query_e6[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
                                                query_e6[4]=copy.deepcopy(initialValue)
                                                for f_var in free_var_map.keys():
							new_e1[3]=expr_replace(new_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
							new_e1[4]=expr_replace(new_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])
							#Added 18/04/2017
							query_e1[3]=expr_replace(query_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])
							query_e5[3]=expr_replace(query_e5[3],eval("['"+f_var+"']"),free_var_map[f_var])

        				
        				#Substituting Constant 
        				if var_const_map_ret is not None:
        					for var_ret in var_const_map_ret.keys():
        				
        						update_facts.append(eval("['"+var_const_map_ret[var_ret]+"',0,['int']]"))
        					
        						constraint_list1.append(var_const_map_ret[var_ret]+">=0")
        					
        						query_e1[3]=expr_replace(query_e1[3],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
        						query_e1[4]=expr_replace(query_e1[4],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
        				
        				query_e1[3]=expr_replace(query_e1[3],var_e1,var_array)
        				
 					query_e1[4]=expr_replace(query_e1[4],var_e1,var_array)
                                                                                    
 					query_e1[4]=simplify_ind_equation(query_e1[4],array_list)
                                        
                                        query_e4[3]=expr_replace(query_e4[3],var_e1,var_array)
                                        
 					query_e4[4]=expr_replace(query_e4[4],var_e1,var_array)
 					query_e4[4]=simplify_ind_equation(query_e4[4],array_list)
                                        

 					
                                        query_e5[3]=expr_replace(query_e5[3],var_e1,var_array)
                                        
 					query_e5[4]=expr_replace(query_e5[4],var_e1,var_array)
                                        

                                        
 					query_e5[4]=simplify_ind_equation(query_e5[4],array_list)
                                        
 					
 					query_e6[3]=expr_replace(query_e6[3],var_e1,var_array)
 					query_e6[4]=expr_replace(query_e6[4],var_e1,var_array)
 					query_e6[4]=simplify_ind_equation(query_e6[4],array_list)

					temp_post_condition=[]
					temp_post_condition.append(wff2z3_update(query_e1))
                                        #print '-######%%%%%%%%%%%%%'
                                        #print update_facts
                                        #print '-######%%%%%%%%%%%%%'
					t_instant_eq=getLoopAxiomes(instant_eq,axiom.getConst_var_map()[var],var,add_equation_d)
                                	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
					writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+ wff2z3_update(query_e1)+'\n')
					#status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
					#status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                        status=tactic1_update(axiom.getFrame_axioms(),[],t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
					writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
					print wff2z3_update(query_e1)
					print status
					if 'Successfully Proved' in status:
					
						#Assumption Equation
                                                
                                                assum_e2=query_e2[3]
					
						if e_array==array_value:
                                                        free_var_map={}
                                                        getAllFreeVariable(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        if not free_var_map:
                                                            assum_e1=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        else:
                                                            assum_e1=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        for f_var in free_var_map.keys():
                                                            assum_e1=expr_replace(assum_e1,eval("['"+f_var+"']"),free_var_map[f_var])
                                                            assum_e2=expr_replace(assum_e2,eval("['"+f_var+"']"),free_var_map[f_var])
							#assum_e1=initialValue
							assum_e1=expr_replace(assum_e1,eval("['"+var+"']"),eval("['"+const_var+"']"))
                                                        assum_e1=simplify_ind_equation(assum_e1,array_list)
						else:
							#assum_e1=array_fun
                                                        if e_array in main_free_var_map.keys():
                                                            free_var_map=main_free_var_map[e_array]
							assum_e1=copy.deepcopy(initialValue)
							for f_var in free_var_map.keys():
								assum_e1=expr_replace(assum_e1,eval("['"+f_var+"']"),free_var_map[f_var])
							        assum_e2=expr_replace(assum_e2,eval("['"+f_var+"']"),free_var_map[f_var])

							
					
        					#assum_e2=expr_replace(query_e2[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
        					assum_e2=expr_replace(assum_e2,eval("['"+var+"']"),eval("['"+const_var+"']"))
				       		assum=[]
				    		assum.append('==')
				        	assum.append(assum_e2)
        					assum.append(assum_e1)
        					assum=expr_replace(assum,var_e1,var_array)
                                                conl_e2=query_e3[3]
         					if e_array==array_value:
                                                        free_var_map={}
                                                        getAllFreeVariable(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        if not free_var_map:
                                                            conl_e1=expr_modify_array(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        else:
                                                            conl_e1=expr_modify(copy.deepcopy(initialValue),inst_str,free_var_map)
                                                        for f_var in free_var_map.keys():
                                                            conl_e1=expr_replace(conl_e1,eval("['"+f_var+"']"),free_var_map[f_var])
                                                            conl_e2=expr_replace(conl_e2,eval("['"+f_var+"']"),free_var_map[f_var])
         						#conl_e1=initialValue
         						conl_e1=expr_replace(conl_e1,eval("['"+var+"']"),eval("['+',['"+const_var+"'],['1']]"))
                                                        conl_e1=simplify_ind_equation(conl_e1,array_list)
         					else:
         						#conl_e1=array_fun
                                                        if e_array in main_free_var_map.keys():
                                                            free_var_map=main_free_var_map[e_array]
         						conl_e1=copy.deepcopy(initialValue)
         						for f_var in free_var_map.keys():
								conl_e1=expr_replace(conl_e1,eval("['"+f_var+"']"),free_var_map[f_var])
                                                        	conl_e2=expr_replace(conl_e2,eval("['"+f_var+"']"),free_var_map[f_var])
         				                                                
                                                conl_e2=expr_replace(conl_e2,eval("['"+var+"']"),eval("['+',['"+const_var+"'],['1']]"))            
        					conl=[]
						conl.append('==')
						conl.append(conl_e2)
        					conl.append(conl_e1)
        				
        					conl=expr_replace(conl,var_e1,var_array)
        				
        					if var_const_map_ret is not None:
        						for var_ret in var_const_map_ret.keys():
        							assum=expr_replace(assum,eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
        							conl=expr_replace(conl,eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
        					ind_case_query=['c1',['implies',assum,conl]]
        					conl_case_query.append(ind_case_query)
        					temp_post_condition=[]
						temp_post_condition.append(wff2z3_update(ind_case_query))
						#status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
				        	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
						writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+ wff2z3_update(ind_case_query)+'\n')			
				        	#status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
				        	status=tactic1_update(axiom.getFrame_axioms(),[],t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
				        	writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
				        	print wff2z3_update(ind_case_query)
				        	print status
                                                #if e_array==array_value:
                                                #    return
                                                if 'Successfully Proved' in status:
                                                	#instant_eq.append(query_e4)

                                                    	if e_array==array_value:
                                                    		query_e6[0]='L1'
                                                                #print '----------'
                                                                #var.
                                                                #print query_e6.
                                                                #print '----------'
                                                    		query=wff2z3_update(query_e6)
                                                    		if var_const_map_ret is not None:
                                                    			for var_ret in var_const_map_ret.keys():
                                                    				query=query.replace(var_ret,var_const_map_ret[var_ret])
                                                    		temp_post_condition=[]
								temp_post_condition.append(query)
								
								writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
								writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+ wff2z3_update(ind_case_query)+'\n')
								
                                                    		#status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
				        			status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,t_instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
				        			writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
				        			
				        			print query
				        			print status
                                                                if 'Successfully Proved' in status:
                                                                    array_fun_map[e_array]=copy.deepcopy(query_e5[4])
                                                                    array_fun_map[e_array]=copy.deepcopy(expr_prime(array_fun_map[e_array],expr_replace(copy.deepcopy(query_e7[3]),eval("['+',['"+var+"'],['1']]"),constant),var_e1))
                                                                    #array_fun_map[e_array]=expr_replace(array_fun_map[e_array],eval("['-',"+str(constant)+",['1']]"),eval(str(constant)))
                                                                    array_fun_map[e_array]=expr_replace(array_fun_map[e_array],eval("['-',"+str(constant)+",['1']]"),eval("['"+var+"']"))
                                                                    
                                                                    array_fun_map[e_array]=rep_array_free_list(array_fun_map[e_array],constant)
                                                                    
                                                                    query_e7[3]=expr_replace(query_e7[3],var_e1,var_array)
                                                                    query_e7[3]=expr_replace(copy.deepcopy(query_e7[3]),eval("['+',['"+var+"'],['1']]"),constant)
                                                                    for f_var in free_var_map.keys():
									query_e7[3]=expr_replace(query_e7[3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                                    query_e7[4]=array_fun_map[e_array]
                                                                    writeLogFile( "j2llogs.logs" ,'\nAxiomes Added--'+wff2z3_update(query_e7)+'\n')
                                                                    instant_eq.append(query_e7)
                                                                    add_equation_d.append(query_e7)
                                                                
				        		else:
				        			writeLogFile( "j2llogs.logs" ,'\nAxiomes Added--'+wff2z3_update(query_e5)+'\n')
				        			instant_eq.append(query_e5)
				        			add_equation_d.append(query_e5)
                                                                
                                                                
                                if var_const_map_ret is not None:
                                	for var_const1 in var_const_map_ret.values():
                                    		constraint_list.append(var_const1+">=0")
                                if query_ret_list is not None:
                                	for query_ret in query_ret_list:
                                		for e_array in query_ret.keys():
                                    			print e_array
                                    			free_var_map=array_var_map[e_array]
                                    			if not free_var_map:
                                    				if e_array in main_free_var_map.keys():
                                    					free_var_map=main_free_var_map[e_array]
                                                        for f_var in free_var_map.keys():
                                                            query_ret[e_array][5][3]=expr_replace(query_ret[e_array][5][3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                            query_ret[e_array][1][1]=expr_replace(query_ret[e_array][1][1],eval("['"+f_var+"']"),free_var_map[f_var])  
                                                        if var_const_map_ret is not None:
                                                            for var_const in var_const_map_ret.keys():
                                                                if query_ret[e_array][6]==var_const:
                                                                    query_ret[e_array][1][1][1]=expr_replace(query_ret[e_array][1][1][1],eval("['"+var_const+"']"),eval("['-',['"+var_const_map_ret[var_const]+"'],['1']]"))
                                                                    query_ret[e_array][1][1][2]=expr_replace(query_ret[e_array][1][1][2],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                                                else:
                                                                    query_ret[e_array][1][1]=expr_replace(query_ret[e_array][1][1],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                                                			
                                    			constraint_list1=copy.deepcopy(constraint_list)
                                    			if query_ret is not None:
                                        			for e_array1 in query_ret.keys():
                                            				constraint_list1.append(wff2z3_update(query_ret[e_array1][2]))
                                    			#for var_ret in var_const_map_ret.keys():
                                    			temp_post_condition=[]
                                    			temp_post_condition.append(wff2z3_update(query_ret[e_array][1]))
                                    			writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
							writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+ wff2z3_update(query_ret[e_array][1])+'\n')
                                    			#Big N--query_ret[e_array][8] Small N--query_ret[e_array][6]
                                    			#status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                    			status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list1,witnessXml)
                                    			writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                                    			print wff2z3_update(query_ret[e_array][1])
                                    			print status
                                    			if 'Successfully Proved' not in status:
                                    			
                                        			query_ret[e_array][2][4]=array_fun_map[e_array]
                                        			query_ret[e_array][3][4]=expr_replace(copy.deepcopy(array_fun_map[e_array]),eval("['"+query_ret[e_array][6]+"']"),eval("['"+'0'+"']"))
                                        			
                                        			for f_var in free_var_map.keys():
									query_ret[e_array][3][3]=expr_replace(query_ret[e_array][3][3],eval("['"+f_var+"']"),free_var_map[f_var])

                                        			query_ret[e_array][3][3]=expr_replace(query_ret[e_array][3][3],eval("['"+query_ret[e_array][6]+"']"),eval("['0']"))
                                        			query_ret[e_array][3][4]=expr_replace(query_ret[e_array][3][4],eval("['"+query_ret[e_array][6]+"']"),eval("['0']"))

                                        			if var_const_map_ret is not None:
                                        				for var_const in var_const_map_ret.keys():
                                        					if query_ret[e_array][6]==var_const:
                                        						query_ret[e_array][3][4]=expr_replace(query_ret[e_array][3][4],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                                                			query_ret[e_array][3][3]=expr_replace(query_ret[e_array][3][3],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                        		
                                        		
                                        			query_ret[e_array][1][1][1][2]=array_fun_map[e_array]
                                        			query_ret[e_array][1][1][2][2]=array_fun_map[e_array]
                                      				if var_const_map_ret is not None:
                                      					for var_ret in var_const_map_ret.keys():
                                      						query_ret[e_array][3][4]=expr_replace(query_ret[e_array][3][4],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
        									query_ret[e_array][3][3]=expr_replace(query_ret[e_array][3][3],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))

                                        			temp_post_condition=[]
                                        			constraint_list2=copy.deepcopy(constraint_list)
                                        			if query_ret is not None:
                                            				for e_array1 in query_ret.keys():
                                                				constraint_list2.append(wff2z3_update(query_ret[e_array1][2]))
                                        			temp_post_condition.append(wff2z3_update(query_ret[e_array][3]))
                                        		
                                        			writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
								writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(query_ret[e_array][3])+'\n')
                                        		
                                        			#status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list2,witnessXml)
                                        			status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list2,witnessXml)
                                        		
                                        			writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                                        		
                                        			print wff2z3_update(query_ret[e_array][3])
                                        			print status
                                        			if 'Successfully Proved' in status:      
                                            				temp_post_condition=[]
                                            				constraint_list2=copy.deepcopy(constraint_list)
                                            				if query_ret is not None:
                                                				for e_array1 in query_ret.keys():
                                                    					constraint_list2.append(wff2z3_update(query_ret[e_array1][2]))
                                            				for f_var in free_var_map.keys():
										query_ret[e_array][1][1][1][1]=expr_replace(query_ret[e_array][1][1][1][1],eval("['"+f_var+"']"),free_var_map[f_var])
										query_ret[e_array][1][1][2][1]=expr_replace(query_ret[e_array][1][1][2][1],eval("['"+f_var+"']"),free_var_map[f_var])                                            				
                                            				if var_const_map_ret is not None: 
                                            					for var_const in var_const_map_ret.keys():
                                        						if query_ret[e_array][6]==var_const:
                                        							#query_ret[e_array][1][1][1][2]=expr_replace(query_ret[e_array][1][1][1][2],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))
                                        							query_ret[e_array][1][1][1][2]=expr_replace(query_ret[e_array][1][1][1][2],eval("['"+var_const+"']"),eval("['-',['"+var_const_map_ret[var_const]+"'],['1']]") )
                                        							#query_ret[e_array][1][1][2][2]=expr_replace(query_ret[e_array][1][1][2][2],eval("['"+var_const+"']"),eval("['+',['"+var_const_map_ret[var_const]+"'],['1']]"))
                                        							query_ret[e_array][1][1][2][2]=expr_replace(query_ret[e_array][1][1][2][2],eval("['"+var_const+"']"),eval("['"+var_const_map_ret[var_const]+"']"))	
                                            			
                                      					if var_const_map_ret is not None:
                                      						for var_ret in var_const_map_ret.keys():
                                      							if var_ret==query_ret[e_array][6]:
                                      								query_ret[e_array][1][1][1]=expr_replace(query_ret[e_array][1][1][1],eval("['"+var_ret+"']"),eval("['-',['"+var_const_map_ret[var_ret]+"'],['1']]"))
        										else:
        											query_ret[e_array][1][1][1]=expr_replace(query_ret[e_array][1][1][1],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
        										query_ret[e_array][1][1][2]=expr_replace(query_ret[e_array][1][1][2],eval("['"+var_ret+"']"),eval("['"+var_const_map_ret[var_ret]+"']"))
                                            			
                                            				temp_post_condition.append(wff2z3_update(query_ret[e_array][1]))
                                            				#status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list2,witnessXml)
                                            			
                                            				writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
									writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(query_ret[e_array][1])+'\n')                               
                                            				status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list2,witnessXml)	
                                            				writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                                            			
                                            				print wff2z3_update(query_ret[e_array][1])
                                            				print status
                                            				if 'Successfully Proved' in status:
                                            					array_fun_map[e_array]=copy.deepcopy(expr_prime(array_fun_map[e_array],query_ret[e_array][9],var_e1))
                                                				query_ret[e_array][4][4]=copy.deepcopy(expr_prime(copy.deepcopy(array_fun_map[e_array]),query_ret[e_array][10],var_e1))
                                                				#instant_eq.append(query_ret[e_array][4])
                                                				query_ret[e_array][5][4]=copy.deepcopy(array_fun_map[e_array])
                                                				for f_var in free_var_map.keys():
											query_ret[e_array][5][3]=expr_replace(query_ret[e_array][5][3],eval("['"+f_var+"']"),free_var_map[f_var])
                                                				writeLogFile( "j2llogs.logs" ,'\nAxiomes Added--'+wff2z3_update(query_ret[e_array][5])+'\n')
                                                				add_equation_d.append(query_ret[e_array][5])
                                                				instant_eq.append(query_ret[e_array][5])
                                    			else:
                                                                #k_map={}
                                                                #getBigk(query_ret[e_array][1][1],k_map)
                                                                #print '----------------------------'
                                                                #print len(k_map.keys())
                                                                #print '----------------------------'
                                        			writeLogFile( "j2llogs.logs" ,'\nAxiomes Added--'+wff2z3_update(query_ret[e_array][5])+'\n')
                                        			add_equation_d.append(query_ret[e_array][5])
                                        			instant_eq.append(query_ret[e_array][5])
        #return "Failed to prove"
        
	post_condition[str_value]=word
	for postcondition in post_condition.keys():
                print '=====================Main Proving Process====================='
                for x in axiom.getConstraints():
                    constraint_list.append(x)
		print '\nAxiomes Added\n'
		for e in add_equation_d:
			print wff2string1(e)
		temp_post_condition=[]
		print '\n'
		#temp_post_condition.append(wff2z3_update(post_condition[postcondition]))
                if post_condition[postcondition][0]=='s0':
                    post_condition[postcondition][0]='c1'
                
                temp_post_condition.append(wff2z3_update_postCond(post_condition[postcondition]))
		
		writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
		writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(post_condition[postcondition])+'\n')
                
                
		status=tactic1_update(axiom.getFrame_axioms(),o_instant_eq,instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)	
                
                #status="Failed To prove"
                writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                
                print '=============================================================='
                if 'Successfully Proved' not in status:
                    status=prove_assert_tactic5(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)
                    if status is None:
                        return "Failed to prove"
                    else:
                        return status
                else:
                    return status


        					
			
			
def prove_assert_tactic4_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map):

       var_list=axiom.getConst_var_map().keys()
       
       query_map_list=[]
       
       query_map={}
       
       base_case_query=[]
       
       conl_case_query=[]
       
       assum_list=[]
       
       var_const_map={}
       
       constraint_list=[]
       frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
       for x in frame_axioms:
       		constraint_list.append(x)
       out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
       for x in out_axioms:
		constraint_list.append(x)
       pre_condition=[]
	
       for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in lhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
       
                 
       for e in axiom.getOther_axioms():
        	if e[0]=='i1' and isArrayFunction(e[3][0]):
        		if e[2] not in call_var_list:

        			var=e[2]
        			const_var=e[2].replace('n','k')
                                var_const_map[var]=const_var
                                
                                #p = getParser()
                                #tree = p.parse_expression(axiom.getConst_var_map()[var])
        			#constant=eval(expressionCreator(tree))
                                
                                parser = c_parser.CParser()
                                ast = parser.parse("void test(){"+axiom.getConst_var_map()[var]+";}")
                                statement_temp=ast.ext[0].body.block_items[0]
                                constant=eval(expressionCreator_C(statement_temp))
                                
                                
        			call_var_list.append(e[2])
        			flag=False
        			for variable in var_list:
					if variable in axiom.getConst_var_map()[var]:
        					flag=True

        			if not flag:
                                	new_e = copy.deepcopy(e)
					status,array_value=findArrayInEq(e[4],array_list)	
					#instantiated the array value
					if array_value is not None:
						inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]")
					 
					
					for e_array in array_list:
						#get Initial Array values
					        array_fun=array_fun_map[e_array]
					        #List of queries
					        quary_list=[]
					        # Construct Variable Array
					    	var_e1=eval("['_x1']")
					        # Construct Array
					   	var_array=eval("['"+e_array+"']")
					        #Get the copy of the equation
					       	new_e1 = copy.deepcopy(e)
					        query_e1 = copy.deepcopy(e)
					        query_e2 = copy.deepcopy(e)
					        query_e3 = copy.deepcopy(e)
					        query_e4 = copy.deepcopy(e)
					        query_e5 = copy.deepcopy(e)
					        query_e6 = copy.deepcopy(e)
					        #Construct Base Case Equations 
					      	query_e1[4]=array_fun
					        query_e1[3]=expr_replace(query_e1[3],eval("['+',['"+var+"'],['1']]"),eval("['0']"))
                                                if e_array in main_free_var_map.keys():
                                                    free_var_map=main_free_var_map[e_array]
                                                    for f_var in free_var_map.keys():
                                                        query_e1[4]=expr_replace(query_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])  
                                                        query_e1[3]=expr_replace(query_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])  
					        #Construct Base Case Equations 
					        query_e4[4]=array_fun
					      	query_e4[3]=expr_replace(query_e4[3],eval("['+',['"+var+"'],['1']]"),eval("['1']"))
					        #Construct Assumption Equation for Variable
					        query_e5[4]=array_fun
					 	query_e5[3]=expr_replace(query_e5[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
					        #Construct Assumption Equation for Construct 
					        query_e6[4]=array_fun
					      	#query_e6[3]=expr_replace(query_e6[3],eval("['+',['"+var+"'],['1']]"),constant)
					      	query_e6[3]=expr_replace(query_e6[3],eval("['+',['"+var+"'],['1']]"),constant)
					       	#Construct Assumption Equations
					      	assum_e1=array_fun
					        assum_e2=expr_replace(query_e2[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
					        #Construct Induction Step Equations 
					        query_e2[3]=assum_e2
					        query_e2[4]=array_fun
					  	#Construct Main Assumption Equation
					      	assum=[]
					     	assum.append('==')
					        assum.append(assum_e2)
					        assum.append(assum_e1)
					        #Construct Conclusion Equations
					       	conl_e1=array_fun
					        conl_e2=expr_replace(query_e3[3],eval("['+',['"+var+"'],['1']]"),eval("['+',['"+const_var+"'],['1']]"))
					       	#Construct Main Conclusion Equation
					        conl=[]
						conl.append('==')
						conl.append(conl_e2)
					        conl.append(conl_e1)
					        #Construct Final Conclusion Equation
					        ind_case_query=['c1',['implies',assum,conl]]
					        #Instantiated for Array
					        if e_array==array_value:
                                                        free_var_map={}
					        	new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
							new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str,free_var_map),var_e1,var_array)
							instant_eq.append(new_e1)
					        else:
					         	new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
					         	new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
					        	instant_eq.append(new_e1) 
					        					
						query_e1[3]=expr_replace(query_e1[3],var_e1,var_array)
					 	query_e1[4]=expr_replace(query_e1[4],var_e1,var_array)
					        query_e2[3]=expr_replace(query_e2[3],var_e1,var_array)
					        query_e2[4]=expr_replace(query_e2[4],var_e1,var_array)
					        query_e4[3]=expr_replace(query_e4[3],var_e1,var_array)
						query_e4[4]=expr_replace(query_e4[4],var_e1,var_array)                                
					       	query_e5[3]=expr_replace(query_e5[3],var_e1,var_array)
						query_e5[4]=expr_replace(query_e5[4],var_e1,var_array)
					        query_e6[3]=expr_replace(query_e6[3],var_e1,var_array)
					        query_e6[4]=expr_replace(query_e6[4],var_e1,var_array)
					 	ind_case_query[1]=expr_replace(ind_case_query[1],var_e1,var_array) 
					        quary_list.append(query_e1)#0
					        quary_list.append(ind_case_query)#1
					        quary_list.append(query_e2)#2
					        quary_list.append(query_e4)#3
					        quary_list.append(query_e5)#4
					      	quary_list.append(query_e6)#5
					        pre_condition=[]
					        temp_post_condition=[]
					        temp_post_condition.append(wff2z3_update(query_e1))
					        
					        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
						writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(query_e1)+'\n')
                     
					        
					        status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),constraint_list,witnessXml)
					   	writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
					   	print wff2z3_update(query_e1)
					        print status
					    	quary_list.append(var)#6
						quary_list.append(const_var)#7
					        quary_list.append(constant)#8
					        quary_list.append(expr_replace(copy.deepcopy(e[3]),eval("['+',['"+var+"'],['1']]"),constant))
					        quary_list.append(expr_replace(copy.deepcopy(e[3]),eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']")))
					        if 'Successfully Proved' in status:
                                            		query_map[e_array]=quary_list
                                	query_map_list.append(query_map)
                                	print ''
                                	return query_map_list,var_const_map
        			else:
        				#print 'XXXXX-XXXXX'
                                        #print main_free_var_map
        				query_map_list_temp,var_const_map_temp=prove_assert_tactic4_Rec(axiom,array_list,call_var_list,instant_eq,array_fun_map,witnessXml,main_free_var_map)
       			       				
        				for query_ret in query_map_list_temp:
						if query_ret is not None:
					        	for e_array in query_ret.keys():
                                            			constraint_list.append(wff2z3_update(query_ret[e_array][2]))
        				for var_const_temp in var_const_map_temp.keys():
        					var_const_map[var_const_temp]=var_const_map_temp[var_const_temp]

        				
                                	update_facts=copy.deepcopy(axiom.getVfact())
                                	
                                	for var_ret in var_const_map_temp.keys():
						update_facts.append(eval("['"+var_const_map_temp[var_ret]+"',0,['int']]"))
					        constraint_list.append(var_const_map_temp[var_ret]+">=0")
                                	
                                	new_e = copy.deepcopy(e)
					status,array_value=findArrayInEq(e[4],array_list)	
					#instantiated the array value
					if array_value is not None:
						inst_str=eval("['=',['_x1'],['"+str(array_value)+"']]") 
					for e_array in array_list:
						#get Initial Array values
					        array_fun=array_fun_map[e_array]
					        #List of queries
					        quary_list=[]
					        # Construct Variable Array
					    	var_e1=eval("['_x1']")
					        # Construct Array
					   	var_array=eval("['"+e_array+"']")
					        #Get the copy of the equation
					       	new_e1 = copy.deepcopy(e)
					        query_e1 = copy.deepcopy(e)
					        query_e2 = copy.deepcopy(e)
					        query_e3 = copy.deepcopy(e)
					        query_e4 = copy.deepcopy(e)
					        query_e5 = copy.deepcopy(e)
					        query_e6 = copy.deepcopy(e)
					        #Construct Base Case Equations 
                                                query_e1[4]=array_fun
					        query_e1[3]=expr_replace(query_e1[3],eval("['+',['"+var+"'],['1']]"),eval("['0']"))
                                                if e_array in main_free_var_map.keys():
                                                    free_var_map=main_free_var_map[e_array]
                                                    for f_var in free_var_map.keys():
                                                        query_e1[4]=expr_replace(query_e1[4],eval("['"+f_var+"']"),free_var_map[f_var])  
                                                        query_e1[3]=expr_replace(query_e1[3],eval("['"+f_var+"']"),free_var_map[f_var])  

					        #Construct Base Case Equations 
					        query_e4[4]=array_fun
					      	query_e4[3]=expr_replace(query_e4[3],eval("['+',['"+var+"'],['1']]"),eval("['1']"))
					        #Construct Assumption Equation for Variable
					        query_e5[4]=array_fun
					 	query_e5[3]=expr_replace(query_e5[3],eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']"))
					        #Construct Assumption Equation for Construct 
					        query_e6[4]=array_fun
					      	query_e6[3]=expr_replace(query_e6[3],eval("['+',['"+var+"'],['1']]"),constant)
					       	#Construct Assumption Equations
					      	assum_e1=array_fun
					        assum_e2=expr_replace(query_e2[3],eval("['+',['"+var+"'],['1']]"),eval("['"+const_var+"']"))
					        #Construct Induction Step Equations 
					        query_e2[3]=assum_e2
					        query_e2[4]=array_fun
					  	#Construct Main Assumption Equation
					      	assum=[]
					     	assum.append('==')
					        assum.append(assum_e2)
					        assum.append(assum_e1)
					        #Construct Conclusion Equations
					       	conl_e1=array_fun
					        conl_e2=expr_replace(query_e3[3],eval("['+',['"+var+"'],['1']]"),eval("['+',['"+const_var+"'],['1']]"))
					       	#Construct Main Conclusion Equation
					        conl=[]
						conl.append('==')
						conl.append(conl_e2)
					        conl.append(conl_e1)
					        
					        for var_ret in var_const_map_temp.keys():
					        	query_e1[3]=expr_replace(query_e1[3],eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
        						query_e1[4]=expr_replace(query_e1[4],eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
        						query_e2[3]=expr_replace(query_e2[3],eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
        						query_e2[4]=expr_replace(query_e2[4],eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
        						assum=expr_replace(assum,eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
							conl=expr_replace(conl,eval("['"+var_ret+"']"),eval("['"+var_const_map_temp[var_ret]+"']"))
					        
					        
					        #Construct Final Conclusion Equation
					        ind_case_query=['c1',['implies',assum,conl]]
					        #Instantiated for Array
					        if e_array==array_value:
					        	new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
							new_e1[4]=expr_replace(expr_modify(new_e1[4],inst_str),var_e1,var_array)
							instant_eq.append(new_e1)
					        else:
					         	new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
					         	new_e1[4]=expr_replace(expr_else(new_e1[4]),var_e1,var_array)
					        	instant_eq.append(new_e1) 
					        					
						query_e1[3]=expr_replace(query_e1[3],var_e1,var_array)
					 	query_e1[4]=expr_replace(query_e1[4],var_e1,var_array)
					        query_e2[3]=expr_replace(query_e2[3],var_e1,var_array)
					        query_e2[4]=expr_replace(query_e2[4],var_e1,var_array)
					        query_e4[3]=expr_replace(query_e4[3],var_e1,var_array)
						query_e4[4]=expr_replace(query_e4[4],var_e1,var_array)                                
					       	query_e5[3]=expr_replace(query_e5[3],var_e1,var_array)
						query_e5[4]=expr_replace(query_e5[4],var_e1,var_array)
					        query_e6[3]=expr_replace(query_e6[3],var_e1,var_array)
					        query_e6[4]=expr_replace(query_e6[4],var_e1,var_array)
					 	ind_case_query[1]=expr_replace(ind_case_query[1],var_e1,var_array) 
					        quary_list.append(query_e1)
					        quary_list.append(ind_case_query)
					        quary_list.append(query_e2)
					        #print '##################################'
					        #print wff2z3_update(query_e1)
					        #print wff2z3_update(ind_case_query)
					        #print wff2z3_update(query_e2)
					        #print '##################################'
					        quary_list.append(query_e4)
					        quary_list.append(query_e5)
					      	quary_list.append(query_e6)
					        pre_condition=[]
					        temp_post_condition=[]
					        temp_post_condition.append(wff2z3_update(query_e1))
					        
					        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
						writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(query_e1)+'\n')
                     
					        
					        status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
					   	
					   	writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
					   	
					   	print wff2z3_update(query_e1)
					        print status
					        quary_list.append(var)
					        quary_list.append(const_var)
					        quary_list.append(constant)
					        quary_list.append(expr_replace(copy.deepcopy(e[3]),eval("['+',['"+var+"'],['1']]"),constant))
					        quary_list.append(expr_replace(copy.deepcopy(e[3]),eval("['+',['"+var+"'],['1']]"),eval("['"+var+"']")))
					        if 'Successfully Proved' in status:
                                            		query_map[e_array]=quary_list
                                       	query_map_list.append(query_map)
                                       	for q_m_l_t in query_map_list_temp:
        					query_map_list.append(q_m_l_t)
        				return query_map_list,var_const_map				
       return None,None			


#Get the axiomes loop wise
def getLoopAxiomes(equations,key_N,var,add_equation):
	eq_list=None
        bool_flag=False
	for e in equations:
		if e[0]=='i1' and isArrayFunction(e[3][0]):
			if var==e[2]:
                                bool_flag=True
                                if eq_list is None:
                                    eq_list=[]
                                eq_list.append(e)
			#elif e[2] in key_N:
			#	if eq_list is not None:
			#		eq_list.append(e)
			else:
				if bool_flag:
                                    if eq_list is not None:
                                        eq_list=eq_list+add_equation
                                    else:
					eq_list=add_equation
                                    return eq_list
		else:
			if eq_list is not None:
				eq_list.append(e)
	if eq_list is not None:
		eq_list=eq_list+add_equation
	else:
		eq_list=add_equation
	return eq_list

# expr_find(e,e1): find subterm e1 in e 

def expr_find(e,e1): #e,e1,e2: expr
    if e==e1:
        return True
    else:
        if e[:1]==e1:
            return True
    	for x in expr_args(e):
    		flag=expr_find(x,e1)
    		if flag:
                    return flag
    	return False


# Find array in equation

def findArrayInEq(e,array_list):
	flag=False
	array_value=None
	for arr in array_list:
		flag = expr_find(e,eval("['=',['_x1'],['"+arr+"']]"))
		if flag:
			return flag,arr
	return flag,array_value
    
# Find array list  in equation

def findArrayInEqlist(e,array_list,ins_array_lsit):
	flag=False
	array_value=None
	for arr in array_list:
		flag = expr_find(e,eval("['=',['_x1'],['"+arr+"']]"))
		if flag:
                    ins_array_lsit.append(arr)
	return ins_array_lsit







# Find array in equation

def findArrayInEqSp(e,array):
	flag=False
	array_value=None
        flag = expr_find(e,eval("['=',['_x1'],['"+array+"']]"))
	return flag

# Find array in equation

def findAllArrayInEq(e,array_list):
	flag=False
	array_value=[]
	for arr in array_list:
		flag = expr_find(e,eval("['=',['_x1'],['"+arr+"']]"))
		if flag:
			array_value.append(arr)
	return array_value



#e=['+',['d2array3', ['A'], ['_x2'], ['_x3'], ['_N1(_n2, _n3)'], ['_n2'], ['_n3']],['d2array3', ['A'], ['_x2'], ['_x3'], ['_N1(_n2, _n3)'], ['_n2'], ['_n3']]]
#e1=['d2array2', ['_x1'], ['_x2'], ['_x3'], ['_N1(_n2, _n3)'], ['_n2'], ['_n3']]
#var=['_x1']

#e=['+',['d2array5', ['B'], ['_x2'], ['_x3'], ['_N2']],['d2array5', ['A'], ['_x2'], ['_x3'], ['_N2']]]
#e1=['d2array7', ['_x1'], ['_x2'], ['_x3'], ['_n3'], ['_n4'], ['_n5']]
#var=['_x1']
#expr_prime(e,e1,var)
def expr_prime(e,e1,var): #e,e1,e2: expr
	if isArrayFunction(e[:1][0])==True:
		temp=[]
		count=0
        	for x in expr_args(e1):
        		#x=expr_prime(x,e1,var)
        		if x==var:
                                #print '-----------@@@@@@'
                                #print expr_args(e)[count]
                                #print '-----------@@@@@@'
        			temp.append(expr_args(e)[count])
        			#temp.append(x)
			else:
				if len(expr_args(e))>count and isvariable(x[0])==True:
					temp.append(expr_args(e)[count])
				else:
					temp.append(x)				
        		count=count+1
		return e1[:1]+temp
	else:
		return e[:1]+list(expr_prime(x,e1,var) for x in expr_args(e))





def expr_array_replace(e,e1,e2): #e,e1,e2: expr
	if isArrayFunction(e[:1][0])==True:
                args=expr_args(e)
                if e[:1][0]==e1[0] and e1[1][0]==e2[1][0] and args[0][0]==e2[1][0]:
                    temp=[]
                    count=0
                    for x in args:
                        if count< len(expr_args(e2)):
                            temp.append(x)
                        count=count+1
                    return e2[:1]+temp
                else:
                    return e[:1]+list(expr_array_replace(x,e1,e2) for x in expr_args(e))
	else:
		return e[:1]+list(expr_array_replace(x,e1,e2) for x in expr_args(e))



def getAllFreeVariable(e,e1,free_var_map):
        if e[:1]==['and']:
        	temp=[]
        	for x in expr_args(e):
        		if x!=e1:
        			if x[0]=='=' and isvariable(x[1][0])==True:
                                        if x[1][0] not in free_var_map.keys() :
                                            free_var_map[x[1][0]]=x[2]
                                        else:
                                            if not(simplify(expr2string1(x[2]))==simplify(expr2string1(free_var_map[x[1][0]]))):
                                                del free_var_map[x[1][0]]
                                                parameter=getAllFreeVariable(x,e1,free_var_map)
                                                if parameter is not None:
                                                    temp.append(parameter)
        			else:
        				parameter=getAllFreeVariable(x,e1,free_var_map)
        				if parameter is not None:
        					temp.append(parameter)
        	if len(temp)==0:
        		return None
        	elif len(temp)==1:
        		return getAllFreeVariable(temp[0],e1,free_var_map)
        	else:
        		return e[:1]+temp
        elif e[:1]==['ite']:
        	temp=[]
        	for x in expr_args(e):
        		if x!=e1:
        			if x[0]=='=' and isvariable(x[1][0])==True:
                                        if x[1][0] not in free_var_map.keys():
                                            free_var_map[x[1][0]]=x[2]
                                        else:
                                            if not(simplify(expr2string1(x[2]))==simplify(expr2string1(free_var_map[x[1][0]]))):
                                                del free_var_map[x[1][0]]
                                                parameter=getAllFreeVariable(x,e1,free_var_map)
                                                if parameter is not None:
                                                    temp.append(parameter)
        			else:
        				parameter=getAllFreeVariable(x,e1,free_var_map)
        				if parameter is not None:
        					temp.append(parameter)
        	if len(temp)==2:
        		return getAllFreeVariable(temp[0],e1,free_var_map)
        	else:
        		return e[:1]+temp
        else:
        	return e[:1]+list(getAllFreeVariable(x,e1,free_var_map) for x in expr_args(e))
                
                

def getAllFreeVariable2(e,free_var_list):
        if e[:1]==['and']:
        	temp=[]
                free_var_map={}
        	for x in expr_args(e):
                    if x[0]=='=' and isvariable(x[1][0])==True:
                        free_var_map[x[1][0]]=x[2]
                    else:
                        parameter=getAllFreeVariable2(x,free_var_list)
                        if parameter is not None:
                            temp.append(parameter)
        	if len(free_var_map)>0:
                    free_var_list.append(free_var_map)
        	if len(temp)==0:
        		return None
        	elif len(temp)==1:
        		return getAllFreeVariable2(temp[0],free_var_list)
        	else:
        		return e[:1]+temp
        elif e[:1]==['ite']:
        	temp=[]
                free_var_map={}
        	for x in expr_args(e):
                    if x[0]=='=' and isvariable(x[1][0])==True:
                        free_var_map[x[1][0]]=x[2]
                    else:
                        parameter=getAllFreeVariable2(x,free_var_list)
                        if parameter is not None:
                            temp.append(parameter)
        	
        	if len(free_var_map)>0:
                    free_var_list.append(free_var_map)
        	if len(temp)==2:
        		return getAllFreeVariable2(temp[0],free_var_list)
        	else:
        		return e[:1]+temp
        else:
        	return e[:1]+list(getAllFreeVariable2(x,free_var_list) for x in expr_args(e))




def getAllFreeVariable3(e,order):
    free_map={}
    for x in range(1, order+1):
        free_map['_x'+str(x+1)]=e[x+1]
    return free_map






def getAllFreeVariable4(e,free_var_map):
        if e[:1]==['and']:
        	temp=[]
        	for x in expr_args(e):
                    if x[0]=='=' and isvariable(x[1][0])==True:
                        if x[1][0] in free_var_map.keys():
                            temp_var_map=free_var_map[x[1][0]]
                            temp_var_map[expr2string1(x[2])]=x[2]
                            free_var_map[x[1][0]]=temp_var_map
                        else:
                            temp_var_map={}
                            temp_var_map[expr2string1(x[2])]=x[2]
                            free_var_map[x[1][0]]=temp_var_map
                    else:
                        parameter=getAllFreeVariable4(x,free_var_map)
                        if parameter is not None:
                            temp.append(parameter)
        	if len(temp)==0:
        		return None
        	elif len(temp)==1:
        		return getAllFreeVariable4(temp[0],free_var_map)
        	else:
        		return e[:1]+temp
        elif e[:1]==['ite']:
        	temp=[]
        	for x in expr_args(e):
                    if x[0]=='=' and isvariable(x[1][0])==True:
                        if x[1][0] in free_var_map.keys():
                            temp_var_map=free_var_map[x[1][0]]
                            temp_var_map[expr2string1(x[2])]=x[2]
                            free_var_map[x[1][0]]=temp_var_map
                        else:
                            temp_var_map={}
                            temp_var_map[expr2string1(x[2])]=x[2]
                            free_var_map[x[1][0]]=temp_var_map
                    else:
                        parameter=getAllFreeVariable4(x,free_var_map)
                        if parameter is not None:
                            temp.append(parameter)
        	if len(temp)==2:
        		return getAllFreeVariable4(temp[0],free_var_map)
        	else:
        		return e[:1]+temp
        else:
        	return e[:1]+list(getAllFreeVariable4(x,free_var_map) for x in expr_args(e))




#def expr_modify(e,e1,free_var_map): #e,e1,e2: expr
#        if e[:1]==['and']:
#        	temp=[]
#        	for x in expr_args(e):
#        		if x!=e1:
#        			if x[0]=='=' and isvariable(x[1][0])==True :
#        				free_var_map[x[1][0]]=x[2]
#        			else:
#        				parameter=expr_modify(x,e1,free_var_map)
#        				if parameter is not None:
#        					temp.append(parameter)
#        	if len(temp)==0:
#        		return None
#        	elif len(temp)==1:
#        		return expr_modify(temp[0],e1,free_var_map)
#        	else:
#        		return e[:1]+temp
#        elif e[:1]==['ite']:
#        	temp=[]
#        	for x in expr_args(e):
#        		if x!=e1:
#        			if x[0]=='=' and isvariable(x[1][0])==True:
#        				free_var_map[x[1][0]]=x[2]
#        			else:
#        				parameter=expr_modify(x,e1,free_var_map)
#        				if parameter is not None:
#        					temp.append(parameter)
#        	if len(temp)==2:
#        		return expr_modify(temp[0],e1,free_var_map)
#        	else:
#        		return e[:1]+temp
#        else:
#        	return e[:1]+list(expr_modify(x,e1,free_var_map) for x in expr_args(e))
                
                
def expr_modify(e,e1,free_var_map): #e,e1,e2: expr
        if e[:1]==['and']:
        	temp=[]
        	for x in expr_args(e):
        		if x!=e1:
        			if x[0]=='=' and isvariable(x[1][0])==True and x[1][0]!='_x1':
        				free_var_map[x[1][0]]=x[2]
        			else:
        				parameter=expr_modify(x,e1,free_var_map)
        				if parameter is not None:
        					temp.append(parameter)
        	if len(temp)==0:
        		return None
        	elif len(temp)==1:
        		return expr_modify(temp[0],e1,free_var_map)
        	else:
        		return e[:1]+temp
        elif e[:1]==['ite']:
        	temp=[]
        	for x in expr_args(e):
        		if x!=e1:
        			if x[0]=='=' and isvariable(x[1][0])==True and x[1][0]!='_x1':
        				free_var_map[x[1][0]]=x[2]
        			else:
        				parameter=expr_modify(x,e1,free_var_map)
        				if parameter is not None:
        					temp.append(parameter)
        	if len(temp)==2:
        		return expr_modify(temp[0],e1,free_var_map)
        	else:
        		return e[:1]+temp
        else:
        	return e[:1]+list(expr_modify(x,e1,free_var_map) for x in expr_args(e))




def expr_modify_array(e,e1,free_var_map): #e,e1,e2: expr
        if e[:1]==['and']:
        	temp=[]
        	for x in expr_args(e):
        		if x!=e1:
                                parameter=expr_modify_array(x,e1,free_var_map)
                                if parameter is not None:
                                    temp.append(parameter)
        				
        	if len(temp)==0:
        		return None
        	elif len(temp)==1:
        		return expr_modify_array(temp[0],e1,free_var_map)
        	else:
        		return e[:1]+temp
        elif e[:1]==['ite']:
        	temp=[]
        	for x in expr_args(e):
        		if x!=e1:
                                parameter=expr_modify_array(x,e1,free_var_map)
                                if parameter is not None:
                                    temp.append(parameter)
        	if len(temp)==2:
        		return expr_modify_array(temp[0],e1,free_var_map)
        	else:
        		return e[:1]+temp
        else:
        	return e[:1]+list(expr_modify_array(x,e1,free_var_map) for x in expr_args(e))





def expr_else(e): #e,e1,e2: expr
	if e[:1]==['ite']:
        	temp=[]
        	for x in expr_args(e):
        		temp.append(expr_else(x))
        	return temp[len(temp)-1]
        else:
        	return e[:1]+list(expr_else(x) for x in expr_args(e))
        


#array_map={'A': ['d2array5', ['_x1'], ['_x2'], ['_x3'], ['_N2']], 'C': ['0'], 'B': ['d2array5', ['_x1'], ['_x2'], ['_x3'], ['_N2']]}
        	
#init_value=['ite', ['and', ['=', ['_x1'], ['C']], ['=', ['_x2'], ['+', ['_n5'], ['0']]], ['=', ['_x3'], ['+', ['_n3'], ['0']]]], ['+', ['d2array7', ['C'], ['+', ['_n5'], ['0']], ['+', ['_n3'], ['0']], ['_n3'], ['_n4'], ['_n5']], ['*', ['d2array7', ['A'], ['+', ['_n5'], ['0']], ['+', ['_n4'], ['0']], ['_n3'], ['_n4'], ['_n5']], ['d2array7', ['B'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']], ['_n3'], ['_n4'], ['_n5']]]], ['d2array7', ['_x1'], ['_x2'], ['_x3'], ['_n3'], ['_n4'], ['_n5']]]        	
#e=['ite', ['and', ['=', ['_x1'], ['C']], ['=', ['_x2'], ['+', ['_n5'], ['0']]], ['=', ['_x3'], ['+', ['_n3'], ['0']]]], ['+', ['d2array7', ['C'], ['+', ['_n5'], ['0']], ['+', ['_n3'], ['0']], ['_n3'], ['_n4'], ['_n5']], ['*', ['d2array7', ['A'], ['+', ['_n5'], ['0']], ['+', ['_n4'], ['0']], ['_n3'], ['_n4'], ['_n5']], ['d2array7', ['B'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']], ['_n3'], ['_n4'], ['_n5']]]], ['d2array7', ['_x1'], ['_x2'], ['_x3'], ['_n3'], ['_n4'], ['_n5']]]
#left_side=['d2array7', ['_x1'], ['_x2'], ['_x3'], ['+', ['_n3'], ['1']], ['_n4'], ['_n5']]
#left_side=['d2array7', ['_x1'], ['_x2'], ['_x3'], ['_n3'], ['_n4'], ['_n5']]


def get_expr_initial(e,array_map): 
	if isArrayFunction(e[:1][0])==True:
		temp=[]
		count=0
		key=None
        	for x in expr_args(e):
        		if count==0:
        			key=x[0]
        		count=count+1
        		temp.append(x)
        	if key is not None and isvariable(key)==False:
        		array_map[key]=e[:1]+temp
	else:
		for x in expr_args(e):
			get_expr_initial(x,array_map)





			
			
def expr_initial(e,array_map,array_map_inital,var): #e,e1,e2: expr
	if isArrayFunction(e[:1][0])==True:
		temp=[]
		count=0
        	for x in expr_args(e):
        		if count==0:
                                if x[0] in array_map.keys() and x[0] in array_map_inital.keys():
                                    e1=expr_replace(copy.deepcopy(array_map_inital[x[0]]),var,x)
                                    return  expr_prime(copy.deepcopy(array_map[x[0]]),e1,var)
                                else:
                                    temp.append(x)
        			#temp.append(x)
			else:
				temp.append(x)
        		count=count+1
		return e[:1]+temp
	else:
		return e[:1]+list(expr_initial(x,array_map,array_map_inital,var) for x in expr_args(e))



#instant_eq=[['i1', 0, '_n1', ['m3', ['+', ['_n1'], ['1']], ['_n2']], ['ite', ['>', ['d2array', ['A'], ['+', ['_n2'], ['0']], ['+', ['_n1'], ['0']]], ['m3', ['_n1'], ['_n2']]], ['d2array', ['A'], ['+', ['_n2'], ['0']], ['+', ['_n1'], ['0']]], ['m3', ['_n1'], ['_n2']]]], ['i0', 0, ['m3', ['0'], ['_n2']], ['m6', ['_n2']]], ['s0', ['>=', ['_N1', ['_n2']], ['+', ['-', ['0']], ['n']]]], ['s1', ['implies', ['<', ['_n1'], ['_N1', ['_n2']]], ['<', ['+', ['_n1'], ['0']], ['n']]]], ['i1', 0, '_n2', ['j6', ['+', ['_n2'], ['1']]], ['+', ['_N1', ['_n2']], ['0']]], ['i1', 0, '_n2', ['m6', ['+', ['_n2'], ['1']]], ['m3', ['_N1', ['_n2']], ['_n2']]], ['i0', 0,['j6', ['0']], ['0']], ['i0', 0, ['m6', ['0']], ['d2array', ['A'], ['0'], ['0']]], ['s0', ['>=', ['_N2'], ['+', ['-', ['0']], ['m6', ['_N2']]]]], ['s1', ['implies', ['<', ['_n2'], ['_N2']], ['<', ['+', ['_n2'], ['0']], ['m6', ['_n2']]]]], ['i1', 3, '_n3', ['d2array8', ['A'], ['_x2'], ['_x3'], ['+', ['_n3'], ['1']], ['_n4']], ['d2array8', ['A'], ['_x2'], ['_x3'], ['_n3'], ['_n4']]], ['i0', 3, ['d2array8', ['A'], ['_x2'], ['_x3'], ['0'], ['_n4']], ['d2array11', ['A'], ['_x2'],['_x3'], ['_n4']]], ['s0', ['>=', ['_N3', ['_n4']], ['+', ['-', ['0']], ['n']]]], ['s1', ['implies', ['<', ['_n3'], ['_N3', ['_n4']]], ['<', ['+', ['_n3'], ['0']], ['n']]]], ['i1', 0, '_n4', ['j11', ['+', ['_n4'], ['1']]], ['+', ['_N3', ['_n4']], ['0']]], ['i1', 3, '_n4', ['d2array11', ['A'], ['_x2'], ['_x3'], ['+', ['_n4'], ['1']]], ['d2array8', ['A'], ['_x2'], ['_x3'], ['_N3', ['_n4']], ['_n4']]], ['i0', 0, ['j11', ['0']], ['0']], ['i0', 3, ['d2array11', ['A'], ['_x2'], ['_x3'], ['0']], ['d2array', ['A'], ['_x2'], ['_x3']]], ['s0', ['>=', ['_N4'], ['+', ['-', ['0']], ['m6', ['_N2']]]]], ['s1', ['implies', ['<', ['_n4'], ['_N4']],['<', ['+', ['_n4'], ['0']], ['m6', ['_N2']]]]], ['i1', 3, '_n4', ['d2array11',['A'], ['_x2'], ['_x3'], ['+', ['_n4'], ['1']]], ['d2array8', ['A'], ['_x2'], ['_x3'], ['_N3', ['_n4']], ['_n4']]], ['i1', 3, '_n3', ['d2array8', ['A'], ['_x2'], ['_x3'], ['_N3', ['_n4']], ['_n4']], ['d2array', ['A'], ['_x2'], ['_x3']]], ['i1', 3, '_n4', ['d2array11', ['A'], ['_x2'], ['_x3'], ['_N4']], ['d2array', ['A'], ['_x2'], ['_x3']]]]


#post_condition=['s0', ['<=', ['d2array11', ['A'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']],['_N4']], ['m6', ['_N2']]]]

#post_condition=['s0', ['<=', ['d2array11', ['A'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']],['_N4']], ['m6', ['_N1',['0']]]]]

#cons_var_map={'_n2': '_N2', '_n3': '_N3(_n4)', '_n1': '_N1(_n2)', '_n4': '_N4'}

#prove_assert_tactic5(axiom,instant_eq,post_condition[postcondition],axiom.getConst_var_map(),witnessXml)


def prove_assert_tactic5(axiom,instant_eq,post_condition,cons_var_map,witnessXml):

	array_map={}
	
        fun_map={}
        
	for e in instant_eq:
		if e[0]=='i1' and isArrayFunction(e[3][0])==True:
			parameter_list=[]
			value_list=[]
			for i in range(1,len(e[3])-1):
				parameter_list.append(e[3][i])
			value_list.append(e)
			value_list.append(parameter_list)
			array_map[e[3][0]]=value_list
		elif e[0]=='i1':
			parameter_list=[]
			value_list=[]
			for i in range(1,len(e[3])):
				parameter_list.append(e[3][i])
			value_list.append(e)
			value_list.append(parameter_list)
			fun_map[e[3][0]]=value_list				
	new_post_condition=update_postCondition(post_condition,array_map)
        

        
	return recInductionOnN(instant_eq,new_post_condition,cons_var_map,fun_map,axiom,witnessXml,axiom.getVfact())

	
	
def recInductionOnN(instant_eq,post_condition,cons_var_map,fun_map,axiom,witnessXml,Vfact):
    
    
        
	global fun_call_map
	
        constraint_list=[]
        frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
        for x in frame_axioms:
       		constraint_list.append(x)
        out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
        for x in out_axioms:
		constraint_list.append(x)
        pre_condition=[]
	
        for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
	
	
	
	N_map={}
	n_map={}
	
	new_post_condition=copy.deepcopy(post_condition)
        
        getBigNCheck(new_post_condition,N_map)
        
        
        if len(N_map.keys())==0:
            return "Failed to prove"
	
	N_map={}
        
	getBigN(new_post_condition,N_map,n_map)
        
        
        update_facts=copy.deepcopy(Vfact)

	if len(N_map.keys())==1:
		#p = getParser()
		system_N=N_map.keys()[0]
                
                fun_call_map={}
                parser = c_parser.CParser()
                ast = parser.parse("void test(){"+str(system_N)+";}")
                statement_temp=ast.ext[0].body.block_items[0]
                constant1=eval(expressionCreator_C(statement_temp))
		
		#tree = p.parse_expression(system_N)
		#constant1=eval(expressionCreator(tree))
		system_n=None
		system_N=constant1
		for var in cons_var_map.keys():
			#tree = p.parse_expression(cons_var_map[var])
	        	#constant2=eval(expressionCreator(tree))
                        ast = parser.parse("void test(){"+str(cons_var_map[var])+";}")
                        statement_temp=ast.ext[0].body.block_items[0]
                        constant2=eval(expressionCreator_C(statement_temp))
			if constant1!=constant2 and getOrder(constant1)==getOrder(constant2):
				if var in n_map.keys():
					system_n=var

		if system_n is not None:
			constant_var=system_n.replace('_n','_L')
                        
                        #print 'System Try To Prove'
                        #print wff2z3_update(post_condition)
                        #print wff2string1(post_condition)
                        #print "Induction Over--"+expr2string1(system_N)
			
			#Base Case Construct
			
                        
			query_base=copy.deepcopy(post_condition)
			query_base=expr_replace(query_base,system_N,eval("['1']"))
			query_base=expr_replace(query_base,eval("['"+system_n+"']"),eval("['0']"))
                        
			#print 'Base Case -'
			#print expr2string1(system_N)+'=1'
                        #print 'System tried to prove--'
                        #print wff2z3_update(query_base)
                        #print expr2string1(query_base[1])
                        
                        temp_post_condition=[]
                        temp_post_condition.append(wff2z3_update(query_base))
                        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                        writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(query_base)+'\n')
                        status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                        writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
			
			if 'Successfully Proved' not in status:
                            expand_query_base=expand_postCondition(query_base,fun_map)
                            if query_base==expand_query_base:
                                return "Failed to prove"
                            else:
                                result=recInductionOnN(instant_eq,expand_query_base,cons_var_map,fun_map,axiom,witnessXml,update_facts)
                                if 'Successfully Proved' not in result:
                                    return "Failed to prove"
                                else:
                                    print 'Successfully Proved Base Case'
                                
			#Assumption
			assume_stmt=copy.deepcopy(post_condition[1])
			assume_stmt=expr_replace(assume_stmt,system_N,eval("['"+constant_var+"']"))
                        
                        			
			#print "Inductive Assumption"
                        #print "when "+expr2string1(system_N)+'='+constant_var
			#print expr2string1(assume_stmt)
			
			#Induction Step
			ind_stmt=copy.deepcopy(post_condition[1])
			ind_stmt=expr_replace(ind_stmt,system_N,eval("['+',['"+constant_var+"'],['1']]"))

			
                        #print "Inductive Step"
                        #print "when "+expr2string1(system_N)+'='+constant_var+"+1"
			#print expr2string1(ind_stmt)
			
			#Final Query
			final_query=[]
			final_query.append('L2')
                        final_query.append(system_n)
			final_query.append(assume_stmt)
                        final_query.append(ind_stmt)
                        
                        update_facts=copy.deepcopy(Vfact)
                        update_facts.append(eval("['"+constant_var+"',0,['int']]"))
                        
                        update_instant_eq=copy.deepcopy(instant_eq)
                        
                        assumption1=[]
                        assumption1.append('c1')
                        assumption1.append(assume_stmt)
                        assumption2=[]
                        assumption2.append('c1')
                        assumption2.append(eval("['>=',['"+constant_var+"'],['0']]"))
                        update_instant_eq.append(assumption1)
                        update_instant_eq.append(assumption2)
                        
						
                        
                        temp_post_condition=[]
                        temp_post_condition.append(wff2z3_update(final_query))
                        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                        writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(final_query)+'\n')
                        status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                        writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
			
			if 'Successfully Proved' in status:
                            return 'Successfully Proved'
                        else:
                            expand_query=expand_postCondition(ind_stmt,fun_map)
                            expand_query_final=['c1']
                            expand_query_final.append(expand_query)
                            if ind_stmt==expand_query:
                                return 'Failed to prove'
                            else:
                                #print 'Result'
                                #print "Failed to prove"
                                return recInductionOnN(update_instant_eq,expand_query_final,cons_var_map,fun_map,axiom,witnessXml,update_facts)
        return "Failed to prove"






def prove_assert_tactic12(axiom,instant_eq,post_condition,cons_var_map,witnessXml):

	array_map={}
	
        fun_map={}
        
	for e in instant_eq:
		if e[0]=='i1' and isArrayFunction(e[3][0])==True:
			parameter_list=[]
			value_list=[]
			for i in range(1,len(e[3])-1):
				parameter_list.append(e[3][i])
			value_list.append(e)
			value_list.append(parameter_list)
			array_map[e[3][0]]=value_list
		elif e[0]=='i1':
			parameter_list=[]
			value_list=[]
			for i in range(1,len(e[3])):
				parameter_list.append(e[3][i])
			value_list.append(e)
			value_list.append(parameter_list)
			fun_map[e[3][0]]=value_list				
	new_post_condition=update_postCondition(post_condition,array_map)
        
        
	return recInductionOnn(instant_eq,new_post_condition,cons_var_map,fun_map,axiom,witnessXml,axiom.getVfact())









def recInductionOnn(instant_eq,post_condition,cons_var_map,fun_map,axiom,witnessXml,Vfact):
    
    
        
	global fun_call_map
	
        constraint_list=[]
        frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
        for x in frame_axioms:
       		constraint_list.append(x)
        out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())
        for x in out_axioms:
		constraint_list.append(x)
        pre_condition=[]
	
        for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
	                	pre_condition.append(rhs)
		
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
						pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
	
	
	
	N_map={}
	n_map={}
	
	new_post_condition=copy.deepcopy(post_condition)
        
        getBigNCheck(new_post_condition,N_map)
        
        
        if len(N_map.keys())==0:
            return "Failed to prove"
	
	N_map={}
        
	getBigN(new_post_condition,N_map,n_map)
        
        
        update_facts=copy.deepcopy(Vfact)
        
	if len(N_map.keys())==1:
		#p = getParser()
		system_N=N_map.keys()[0]
                system_n=n_map.keys()[0]
                

		if system_n is not None:
			constant_var=system_n.replace('_n','_k')
                        
                        #print 'System Try To Prove'
                        #print wff2z3_update(post_condition)
                        #print wff2string1(post_condition)
                        #print "Induction Over--"+expr2string1(system_N)
			
			#Base Case Construct
			
                        
			query_base=copy.deepcopy(post_condition)
			query_base=expr_replace(query_base,eval("['"+system_N+"']"),eval("['1']"))
			query_base=expr_replace(query_base,eval("['"+system_n+"']"),eval("['0']"))
                        
			#print 'Base Case -'
			#print expr2string1(system_N)+'=1'
                        #print 'System tried to prove--'
                        #print wff2z3_update(query_base)
                        #print expr2string1(query_base[1])
                    
                        
                        temp_post_condition=[]
                        temp_post_condition.append(wff2z3_update(query_base))
                        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                        writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(query_base)+'\n')
                        status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                        writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                    
			if 'Successfully Proved' in status:
                                
                            #Assumption
                            assume_stmt=copy.deepcopy(post_condition[1])
                            assume_stmt=expr_replace(assume_stmt,eval("['"+system_N+"']"),eval("['+',['"+constant_var+"'],['1']]"))
                            assume_stmt=expr_replace(assume_stmt,eval("['"+system_n+"']"),eval("['"+constant_var+"']"))
                        
                        			
                            #print "Inductive Assumption"
                            #print "when "+expr2string1(eval("['"+system_N+"']"))+'='+constant_var
                            #print expr2string1(assume_stmt)
			
                            #Induction Step
                            ind_stmt=copy.deepcopy(post_condition[1])
                            ind_stmt=expr_replace(ind_stmt,eval("['"+system_N+"']"),eval("['+',['"+constant_var+"'],['2']]"))
                            ind_stmt=expr_replace(ind_stmt,eval("['"+system_n+"']"),eval("['+',['"+constant_var+"'],['1']]"))
                    
            
                            #print "Inductive Step"
                            #print "when "+expr2string1(system_N)+'='+constant_var+"+1"
                            #print expr2string1(ind_stmt)
			
                            #Final Query
                            final_query=[]
                            final_query.append('c1')
                            final_query_temp=[]
                            final_query_temp.append('Implies')
                            final_query_temp.append(assume_stmt)
                            final_query_temp.append(ind_stmt)
                            final_query.append(final_query_temp)
                        
                            update_facts=copy.deepcopy(Vfact)
                            update_facts.append(eval("['"+constant_var+"',0,['int']]"))
                        
                        
                            assumption2=[]
                            assumption2.append('c1')
                            assumption2.append(eval("['>=',['"+constant_var+"'],['0']]"))
                            instant_eq.append(assumption2)
                            
                        
                            temp_post_condition=[]
                            temp_post_condition.append(wff2z3_update(final_query))
                            writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(temp_post_condition)+"\n Strategy--Automatically Deriving Addition Axoimes\n")
                            writeLogFile( "j2llogs.logs" ,'\nQuery --\n\n'+wff2z3_update(final_query)+'\n')
                            status = tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),instant_eq,pre_condition,temp_post_condition,update_facts,axiom.getInputvariable(),constraint_list,witnessXml)
                            writeLogFile( "j2llogs.logs" ,'\nResult --'+status+'\n')
                            if 'Successfully Proved' in status:
                                return 'Successfully Proved'
                            else:
                                return "Failed to prove"
        return "Failed to prove"




#temp_exp=['L1', ['implies', ['implies', ['<', ['_n4'], ['_L4']], ['<=', ['d2array', ['A'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']]], ['m6', ['_L4']]]], ['implies', ['<', ['_n4'], ['+', ['_L4'], ['1']]], ['<=', ['d2array', ['A'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']]], ['m6', ['+', ['_L4'], ['1']]]]]],'_n4']
#wff2z3_update(temp_exp)
#temp_exp=['L1',['implies', ['<', ['_n4'], ['_L4']], ['<=', ['d2array', ['A'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']]], ['m6', ['_L4']]]],'_n4' ]

#temp_exp=['L1','_n4',['<=', ['d2array', ['A'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']]], ['m6', ['_L4']]],['<=', ['d2array', ['A'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']]], ['m6', ['+',['_L4'],['1']]]]
	
#tem_exp=['L2', '_n4', ['<=', ['d2array', ['A'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']]], ['m6', ['_L4']]], ['<=', ['d2array', ['A'], ['+', ['_n4'], ['0']], ['+', ['_n3'], ['0']]], ['m6', ['+', ['_L4'], ['1']]]]]
	
def update_postCondition(e,array_map): 
	if isArrayFunction(e[:1][0])==True:
                if len(array_map.keys())==0:
                    return e
                parameter_list=None
                new_e=None
		if e[:1][0] in array_map.keys():
                    value_list=array_map[e[:1][0]]
                    parameter_list=value_list[1]
                    new_e=copy.deepcopy(value_list[0][4])
		if parameter_list is not None and new_e is not None:
			count=0
			for x in expr_args(e):
				if count>0 and count <len(parameter_list):
					new_e=expr_replace(new_e,parameter_list[count],x)
				count=count+1
			return new_e
		else:
			return e
	else:
		return e[:1]+list(update_postCondition(x,array_map) for x in expr_args(e))
		
		

def expand_postCondition(e,fun_map):
	if e[:1][0] in fun_map.keys():
		value_list=fun_map[e[:1][0]]
		parameter_list=value_list[1]
		new_e=copy.deepcopy(value_list[0][4])
		if parameter_list is not None and new_e is not None:
			count=0
			for x in expr_args(e):
                            if eval("['+',['"+value_list[0][2]+"'],['1']]")==parameter_list[count]:
                                if len(x)==1:
                                    new_e=expr_replace(new_e,eval("['"+value_list[0][2]+"']"),eval("['0']"))
                                else:
                                    new_e=expr_replace(new_e,eval("['"+value_list[0][2]+"']"),eval("['"+x[1][0]+"']"))
                            count=count+1
			return new_e
		else:
			return e
	else:
		return e[:1]+list(expand_postCondition(x,fun_map) for x in expr_args(e))




def getBigk(e,k_map):
	args=expr_args(e)
    	op=expr_op(e)
    	if len(args)==0:
    		if op.startswith('_k'):
        		k_map[op]=op
    	else:
                if op.startswith('_k'):
                    k_map[expr2string1(e)]=e
                for x in expr_args(e):
                    getBigk(x,k_map)


def getBigN(e,N_map,n_map):
	args=expr_args(e)
    	op=expr_op(e)
    	if len(args)==0:
    		if op.startswith('_N'):
        		N_map[op]=op
        	elif op.startswith('_n'):
        		n_map[op]=op
    	else:

                if op.startswith('_N'):
                    N_map[expr2string1(e)]=e
                for x in expr_args(e):
                    getBigN(x,N_map,n_map)
        


def getBigNCheck(e,N_map):
	args=expr_args(e)
    	op=expr_op(e)
    	if len(args)==0:
    		if op.startswith('_N'):
        		N_map[op]=op
    	else:
                if isArrayFunction(op)==False: 
                    if op.startswith('_N'):
                        N_map[expr2string1(e)]=e
                    for x in expr_args(e):
                        getBigNCheck(x,N_map)

      
      
def getOrder(e):
	args=expr_args(e)
	return len(args)
      
def prove_Ext(program,function_name,pre_condition,post_condition):
	if len(post_condition)==0:
		print "Nothing To Prove"
		return
		
	axiomeMap=program.getAxiomeMap()
	
	if axiomeMap is None:
		print "Something Wrong in Translation"
		return
	
	axiom=axiomeMap[function_name]
	
	if axiomeMap is None:
		print "Something Wrong in Translation"
		return	
	
	if axiom is not None and post_condition is not None:
		start_time=current_milli_time()
		writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(post_condition)+"\n Strategy--Direct")
		status=tactic1(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints())
		
		if "Successfully Proved" in status:
			print "Successfully Proved"			
		elif "Counter Example" in status:
			print status		
		else:
			status=tactic2(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
		
			if "Successfully Proved" in status:
				print "Successfully Proved"			
			elif "Counter Example" in status:
				print status		
			else:
				print "Failed to Prove"
		end_time=current_milli_time()
		print end_time-start_time


def rep_array_free_list(e,constant):
	if isArrayFunction(e[:1][0])==True:
		temp=[]
		count=0
        	for x in expr_args(e):
                    #and isLoopvariable( x[-1][0] )==True
                    if isArrayFunction(x[0])==True :
                        x[-1]=copy.deepcopy(constant)
                    temp.append(x)				
                    count=count+1
		return e[:1]+temp
	else:
		return e[:1]+list(rep_array_free_list(x,constant) for x in expr_args(e))



#e=['e', ['_1_FAILED1'], ['ite', ['and', ['>=', ['__VERIFIER_nondet_int2'], ['0']], ['<=', ['__VERIFIER_nondet_int2'], ['3']]], ['ite', ['and', ['>=', ['__VERIFIER_nondet_int_12'], ['0']], ['<=', ['__VERIFIER_nondet_int_12'], ['23']]], ['ite', ['or', ['or', ['<', ['__VERIFIER_nondet_int2'], ['0']], ['<', ['__VERIFIER_nondet_int_12'], ['0']]], ['>=', ['ackermann_3', ['__VERIFIER_nondet_int2'], ['__VERIFIER_nondet_int_12']], ['0']]], ['0'], ['1']], ['0']], ['0']]]

#equations = [['R', ['m', 'n'], ['ackermann', ['m'], ['n']], ['ite', ['!=', ['m'], ['0']], ['ite', ['!=', ['n'], ['0']], ['ackermann', ['-', ['m'], ['1']], ['ackermann', ['m'], ['-', ['n'], ['1']]]], ['ite', ['==', ['n'], ['0']], ['ackermann', ['-', ['m'], ['1']], ['1']], ['ite', ['==', ['m'], ['0']], ['+', ['n'], ['1']], ['0']]]], ['ite', ['==', ['m'], ['0']], ['+', ['n'], ['1']], ['0']]]]]

#cond_list=[['and',['>=',['__VERIFIER_nondet_int2'],['0']],['<=',['__VERIFIER_nondet_int2'],['3']]],['and',['>=',['__VERIFIER_nondet_int3'],['0']],['<=',['__VERIFIER_nondet_int3'],['23']]]]

#post_cond=['>=',['ackermann',['__VERIFIER_nondet_int2'],['__VERIFIER_nondet_int3']],['0']]

#f_cycle=['ackermann']

#vfact=[['ackermann', 2, ['int', 'int', 'int']], ['ackermann_2', 2, ['int', 'int', 'int']], ['m', 0, ['int']], ['ackermann_1', 2, ['int', 'int', 'int']], ['m1', 1, ['int', 'int']], ['n1', 1, ['int', 'int']], ['n', 0, ['int']], ['main', 0, ['int']],['__VERIFIER_nondet_int2', 0, ['int']],['__VERIFIER_nondet_int_12', 0, ['int']]]


#witnessXml=['<?xml version="1.0" encoding="UTF-8" standalone="no"?><graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><key attr.name="isEntryNode" attr.type="boolean" for="node" id="entry"><default>false</default></key><key attr.name="isViolationNode" attr.type="boolean" for="node" id="violation"><default>false</default></key><key attr.name="witness-type" attr.type="string" for="graph" id="witness-type"/><key attr.name="sourcecodelang" attr.type="string" for="graph" id="sourcecodelang"/><key attr.name="producer" attr.type="string" for="graph" id="producer"/><key attr.name="specification" attr.type="string" for="graph" id="specification"/><key attr.name="programFile" attr.type="string" for="graph" id="programfile"/><key attr.name="programHash" attr.type="string" for="graph" id="programhash"/><key attr.name="memoryModel" attr.type="string" for="graph" id="memorymodel"/><key attr.name="architecture" attr.type="string" for="graph" id="architecture"/><key attr.name="startline" attr.type="int" for="edge" id="startline"/><key attr.name="assumption" attr.type="string" for="edge" id="assumption"/><key attr.name="assumption.scope" attr.type="string" for="edge" id="assumption.scope"/><key attr.name="assumption.resultfunction" attr.type="string" for="edge" id="assumption.resultfunction"/><graph edgedefault="directed"><data key="witness-type">violation_witness</data><data key="sourcecodelang">C</data><data key="producer">CPAchecker 1.6.1-svn</data><data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )</data><data key="programfile">Ackermann01_true-unreach-call.c</data><data key="programhash">1776ed2413d170f227b69d8c79ba700d31db6f75</data><data key="memorymodel">precise</data><data key="architecture">32bit</data><node id="entry"><data key="entry">true</data></node><node id="error"><data key="violation">true</data></node><edge source="entry" target="error">', '<data key="assumption.scope">main</data><data key="assumption.resultfunction">__VERIFIER_nondet_int</data></edge></graph></graphml>', 'main', 'Ackermann01_true-unreach-call.c']

#e=['e', ['_1_FAILED1'], ['ite', ['and', ['>=', ['__VERIFIER_nondet_int2'], ['0']], ['<=', ['__VERIFIER_nondet_int2'], ['3']]], ['ite', ['and', ['>=', ['__VERIFIER_nondet_int_12'], ['0']], ['<=', ['__VERIFIER_nondet_int_12'], ['23']]], ['ite', ['or', ['or', ['<', ['__VERIFIER_nondet_int2'], ['2']], ['<', ['__VERIFIER_nondet_int_12'], ['2']]], ['>=', ['ackermann', ['__VERIFIER_nondet_int2'], ['__VERIFIER_nondet_int_12']], ['7']]], ['0'], ['1']], ['0']], ['0']]]

#e=['ite', ['and', ['>=', ['__VERIFIER_nondet_int2'], ['0']], ['<=', ['__VERIFIER_nondet_int2'], ['3']]], ['ite', ['and', ['>=', ['__VERIFIER_nondet_int_12'], ['0']], ['<=', ['__VERIFIER_nondet_int_12'], ['23']]], ['ite', ['or', ['or', ['<', ['__VERIFIER_nondet_int2'], ['2']], ['<', ['__VERIFIER_nondet_int_12'], ['2']]], ['>=', ['ackermann', ['__VERIFIER_nondet_int2'], ['__VERIFIER_nondet_int_12']], ['7']]], ['0'], ['1']], ['0']], ['0']]


#e=['ite', ['and', ['>=', ['__VERIFIER_nondet_int2'], ['0']], ['<=', ['__VERIFIER_nondet_int2'], ['3']]], ['ite', ['and', ['>=', ['__VERIFIER_nondet_int_12'], ['0']], ['<=', ['__VERIFIER_nondet_int_12'], ['23']]], ['ite', ['or', ['or', ['!=', ['__VERIFIER_nondet_int2'], ['2']], ['!=', ['__VERIFIER_nondet_int_12'], ['2']]], ['==', ['ackermann', ['__VERIFIER_nondet_int2'], ['__VERIFIER_nondet_int_12']], ['7']]], ['0'], ['1']], ['0']], ['0']]


#e=['ite', ['and', ['>=', ['__VERIFIER_nondet_int2'], ['0']], ['<=', ['__VERIFIER_nondet_int2'], ['3']]], ['ite', ['and', ['>=', ['__VERIFIER_nondet_int_12'], ['0']], ['<=', ['__VERIFIER_nondet_int_12'], ['23']]], ['ite', ['or', ['or', ['<', ['__VERIFIER_nondet_int2'], ['0']], ['<', ['__VERIFIER_nondet_int_12'], ['0']]], ['>=', ['ackermann', ['__VERIFIER_nondet_int2'], ['__VERIFIER_nondet_int_12']], ['0']]], ['0'], ['1']], ['0']], ['0']]


#f_cycle=['ackermann']

#range_list={}

#not_range_list={}


                    
        







def prove_assert_tactic7(e,equations,f_cycle,vfact,witnessXml):
    
    list_exps={}
    
    addition_equs=[]

    getRecuresiveFunDef(e,f_cycle,list_exps)
    
    range_value_map,range_equal_map = extractRangeValuesMain(e,f_cycle)
    
    for  exp in list_exps:
        para_list=[]
        post_cond = list_exps[exp]
        
        equation_list=[]
        
        getParameters(post_cond,para_list,f_cycle)

        for term in range_equal_map.keys():
            equation_list.append(eval("['a',['==',['"+term+"'],['"+str(range_equal_map[term])+"']]]"))
        if len(equation_list)==len(range_value_map.keys()):
            constraints=[]

            for x in equations:
                constraints.append(wff2z3_update(copy.deepcopy(x)))
            for x in equation_list:
                constraints.append(wff2z3_update(copy.deepcopy(x)))
                
            query_exp=[]
            query_exp.append('a')
            query_exp.append(post_cond)
            
            conclusion=wff2z3_update(query_exp)
        
            #print "Tried to prove "+conclusion
        
            status=query2z3_update(constraints,conclusion,vfact,witnessXml)
            
            if 'Successfully Proved' in status:
                #print '~~~~~~~~~~~~~~~'
                #print para_list
                #print '~~~~~~~~~~~~~~~'
                addition_equ=[]
                addition_equ.append('RE')
                addition_equ.append(para_list)
                term = constructConstraints_update1(range_equal_map,para_list)
                if term is not None:
                    addition_equ.append(eval(term))
                else:
                    addition_equ.append([])
                addition_equ.append(post_cond)
                addition_equs.append(addition_equ)
            
        else:
            
            #print '$$$$$$$$$$$$$$$$'
            #print range_value_map
            #print '$$$$$$$$$$$$$$$$'
            
            status = recurrsiveInduction1(equations,post_cond,range_value_map,para_list,vfact,witnessXml)
            

            
            if 'Successfully Proved' in status:
                addition_equ=[]
                addition_equ.append('RE')
                addition_equ.append(para_list)
                add_temp=[]
                add_temp.append('and')
                add_temp.append(eval(constructConstraints_update(range_value_map,para_list)))
                add_temp.append(post_cond)
                addition_equ.append([])
                addition_equ.append(add_temp)
                #addition_equ.append(eval(constructConstraints_update(range_value_map,para_list)))
                #addition_equ.append(post_cond)
                addition_equs.append(addition_equ)
    return addition_equs



equations = [['R', ['m', 'n'], ['ackermann', ['m'], ['n']], ['ite', ['!=', ['m'], ['0']], ['ite', ['!=', ['n'], ['0']], ['ackermann', ['-', ['m'], ['1']], ['ackermann', ['m'], ['-', ['n'], ['1']]]], ['ite', ['==', ['n'], ['0']], ['ackermann', ['-', ['m'], ['1']], ['1']], ['ite', ['==', ['m'], ['0']], ['+', ['n'], ['1']], ['0']]]], ['ite', ['==', ['m'], ['0']], ['+', ['n'], ['1']], ['0']]]]]


#e=['ite', ['!=', ['m'], ['0']], ['ite', ['!=', ['n'], ['0']], ['ackermann', ['-', ['m'], ['1']], ['ackermann', ['m'], ['-', ['n'], ['1']]]], ['ite', ['==', ['n'], ['0']], ['ackermann', ['-', ['m'], ['1']], ['1']], ['ite', ['==', ['m'], ['0']], ['+', ['n'], ['1']], ['0']]]], ['ite', ['==', ['m'], ['0']], ['+', ['n'], ['1']], ['0']]]
#tab='\t'
#e_fun=['ackermann', ['m'], ['n']]

G_Rec_count=0

G_Rec_program=''

def constructRecProgramMain(e,e_fun):
    global G_Rec_count
    global G_Rec_program
    G_Rec_count=0
    G_Rec_program=''
    fun_body=constructRecProgram(e,e_fun)
    G_Rec_program+='\ndef '+expr2string1(e_fun)+":\n"+fun_body+'\n'
    print G_Rec_program



def constructRecProgram(e,e_fun):
        global G_Rec_count
        global G_Rec_program
        if e[:1]==['ite']:
                statement=''
        	temp=[]
        	for x in expr_args(e):
                        temp.append(constructRecProgram(x,e_fun))
                cond=temp[0]
                ifstr=temp[1]
                elsestr=temp[2]
                if 'if' in cond:
                    G_Rec_count+=1
                    f_name=copy.deepcopy(e_fun)
                    f_name[0]=f_name[0]+str(G_Rec_count)
                    G_Rec_program+='\ndef '+expr2string1(f_name)+":\n"+cond
                    statement+="\tif "+expr2string1(f_name)+":\n"
                else:
                    statement+="\tif "+cond+":\n"
                if 'if' in ifstr:
                    G_Rec_count+=1
                    f_name=copy.deepcopy(e_fun)
                    f_name[0]=f_name[0]+str(G_Rec_count)
                    G_Rec_program+='\ndef '+expr2string1(f_name)+":\n"+ifstr
                    statement+="\t\treturn "+expr2string1(f_name)+"\n"
                else:
                    statement+='\t\treturn '+ifstr+"\n"
                    
                statement+="\telse "+":\n"
                
                if 'if' in elsestr:
                    G_Rec_count+=1
                    f_name=copy.deepcopy(e_fun)
                    f_name[0]=f_name[0]+str(G_Rec_count)
                    G_Rec_program+='\ndef '+expr2string1(f_name)+":\n"+elsestr
                    statement+="\t\treturn "+expr2string1(f_name)+"\n"
                else:
                    statement+='\t\treturn '+elsestr+"\n"

                return statement+'\n'
                
        else:
            return expr2string1(e)





def constructConstraints_update(range_value_map,para_list):
        stmt=""
        stmt1=None
        stmt2=None
        list = range_value_map[para_list[0]]
        if list[0]!=-1:
            stmt1="['>=',['"+para_list[0]+"'],['"+str(list[0])+"']]"
        if list[1]!=-1:
            stmt2="['<=',['"+para_list[0]+"'],['"+str(list[1])+"']]"
        if stmt1 is not None and stmt2 is not None :
            stmt="['and',"+stmt1+","+stmt2+"]"
        elif stmt1 is not None:
            stmt=stmt1
        elif stmt2 is not None:
            stmt=stmt2
        if len(para_list)>1:
            stmt3=constructConstraints_update(range_value_map,para_list[1:])
            if stmt3!='' and stmt3 is not None:
                stmt="['and',"+stmt+","+stmt3+"]"
        else:
            return stmt
        
def constructConstraints_update1(range_equal_map,para_list):
    stmt=''
    stmt1=None
    if len(para_list)>0 and para_list[0] in range_equal_map.keys():
        stmt1="['==',['"+para_list[0]+"'],['"+str(range_equal_map[para_list[0]])+"']]"
    if len(para_list)>1:
        stmt2=constructConstraints_update1(range_equal_map,para_list[1:])
        stmt="['and',"+stmt1+","+stmt2+"]"
        return stmt
    else:
        return stmt1
    
    
    
    


def recurrsiveInduction1(equations,post_cond,range_value_map,para_list,vfact,witnessXml):
    
    if len(para_list)==0:
        return "Failed to prove"
    
    ind_var=para_list[0]
    
    
    
    #print "Induction on "+str(ind_var)
    if ind_var not in range_value_map.keys():
        return "Failed to prove"
        
        
    lits_rang=range_value_map[ind_var]
    
        
    base_equation=[]
    base_equation.append('RE')
    if len(para_list)>1:
        base_equation.append(para_list[1:])
        ret_v = constructConstraints_update(range_value_map,para_list[1:])
        if ret_v is not None:
            base_equation.append(eval(ret_v))
        else:
            base_equation.append([])
    else:
        base_equation.append([])
        base_equation.append([])
    base_equation.append(expr_replace(copy.deepcopy(post_cond),eval("['"+ind_var+"']"),eval("['"+str(lits_rang[0])+"']")))
    
    constraints=[]
    for x in equations:
        constraints.append(wff2z3_update(copy.deepcopy(x)))

    conclusion=wff2z3_update(base_equation)
    
    #print "Base Case "+str(ind_var)+"= "+str(lits_rang[0])
    #print "Tried to prove"
    #print conclusion

    status=query2z3_update(constraints,conclusion,vfact,witnessXml)
    
    #print status
    
    #if len(para_list)==0:
    #    return
    
    #if len(base_equation[2])>0:
    #    status='Failed'
    #print '~~~~~~~~~~~~~~~~'
    #print status
    #print '~~~~~~~~~~~~~~~~'
    if 'Successfully Proved' in status:
    
        #print 'Successfully Proved Base Case --'+conclusion 
        
        term_list = cond_analysis(equations,witnessXml,vfact)
        
        
        query_equation=[]
        query_equation.append('RE')
        if len(para_list)>1:
            query_equation.append(para_list[1:])
            query_equation.append(eval(constructConstraints_update(range_value_map,para_list[1:])))
        else:
            if len(para_list)==1:
                query_equation.append([])
                query_equation.append(eval(constructConstraints_update(range_value_map,para_list)))
            else:
                query_equation.append([])
                query_equation.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
                
        query_temp=[]
        query_temp.append('implies')
        query_temp.append(copy.deepcopy(post_cond))
        query_temp.append(expr_replace(copy.deepcopy(post_cond),eval("['"+ind_var+"']"),eval("['+',['"+ind_var+"'],['1']]")))
        query_equation.append(query_temp)
        query_equation1=copy.deepcopy(query_equation)
        
    
        constraints=[]
        
        for x in equations:
            constraints.append(wff2z3_update(copy.deepcopy(x)))
        
        conclusion=wff2z3_update(query_equation)
        
        print "Tried to prove "+conclusion
        
        status=query2z3_update(constraints,conclusion,vfact,witnessXml)
        
        
        if 'Successfully Proved' not in status and len(para_list)==1:
            query_equation1[3][2]=simplification_rec_fun(query_equation1[3][2],term_list)
            conclusion=wff2z3_update(query_equation1)
            status=query2z3_update(constraints,conclusion,vfact,witnessXml)
        
        print status
    
        if 'Successfully Proved' in status:
            
            #print "Successfully Proved ---"+conclusion
            
            return status
        else:
            new_post_cond=copy.deepcopy(query_equation[3][2])
            inductive_assumption=[]
            inductive_assumption.append('RE')
            if len(para_list)>1:
                inductive_assumption.append(para_list[1:])
                inductive_assumption.append(eval(constructConstraints_update(range_value_map,para_list[1:])))
            else:
                if len(para_list)==1:
                    inductive_assumption.append([])
                    inductive_assumption.append(eval(constructConstraints_update(range_value_map,para_list)))
                else:
                    inductive_assumption.append([])
                    inductive_assumption.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
            inductive_assumption.append(copy.deepcopy(post_cond))
            new_equations=copy.deepcopy(equations)
            new_equations.append(inductive_assumption)
            if len(para_list)>1:
                new_equation=[]
                new_equation.append('a')
                new_equation.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
                new_equations.append(new_equation)
                status=recurrsiveInduction1(new_equations,new_post_cond,range_value_map,para_list[1:],vfact,witnessXml)
                return status
            else:
                return "Failed to Prove"
        
    else:
        new_post_cond=copy.deepcopy(base_equation[3])
        
        status=recurrsiveInduction1(equations,new_post_cond,range_value_map,para_list[1:],vfact,witnessXml)
        
        if 'Successfully Proved' in status:
            
            #print 'Successfully Proved Base Case ----'+conclusion
            
            term_list = cond_analysis(equations,witnessXml,vfact)
        
            
            query_equation=[]
            query_equation.append('RE')
            if len(para_list)>1:
                query_equation.append(para_list[1:])
                query_equation.append(eval(eval(constructConstraints_update(range_value_map,para_list[1:]))))
            else:
                if len(para_list)>1:
                    query_equation.append([])
                    query_equation.append(eval(eval(constructConstraints_update(range_value_map,para_list))))
                else:
                    query_equation.append([])
                    query_equation.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
            query_temp=[]
            query_temp.append('implies')
            query_temp.append(copy.deepcopy(post_cond))
            query_temp.append(expr_replace(copy.deepcopy(post_cond),eval("['"+ind_var+"']"),eval("['+',['"+ind_var+"'],['1']]")))
            query_equation.append(query_temp) 
            query_equation1=copy.deepcopy(query_equation)
            constraints=[]
            for x in equations:
                constraints.append(wff2z3_update(copy.deepcopy(x)))
                
            
            
            conclusion=wff2z3_update(query_equation)
            print "Tried to prove" +conclusion

            status=query2z3_update(constraints,conclusion,vfact,witnessXml)
            
            if 'Successfully Proved' not in status and len(para_list)==1:
                query_equation1[3][2]=simplification_rec_fun(query_equation1[3][2],term_list)
                conclusion=wff2z3_update(query_equation1)
                status=query2z3_update(constraints,conclusion,vfact,witnessXml)
                
            if 'Successfully Proved' in status:
                
                #print "Successfully Proved ---"+conclusion
                
                return status
            else:
                new_post_cond=copy.deepcopy(query_equation[3][2])
                inductive_assumption=[]
                inductive_assumption.append('RE')
                if len(para_list)>1:
                    inductive_assumption.append(para_list[1:])
                    inductive_assumption.append(eval(constructConstraints(para_list[1:])))
                else:
                    if len(para_list)>1:
                        inductive_assumption.append([])
                        inductive_assumption.append(eval(constructConstraints_update(range_value_map,para_list)))
                    else:
                        inductive_assumption.append([])
                        inductive_assumption.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
                inductive_assumption.append(copy.deepcopy(post_cond))
                new_equations=copy.deepcopy(equations)
                new_equations.append(inductive_assumption)
                if len(para_list)>1:
                    new_equation=[]
                    new_equation.append('a')
                    new_equation.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
                    new_equations.append(new_equation)
                    status=recurrsiveInduction1(new_equations,new_post_cond,range_value_map,para_list[1:],vfact,witnessXml)
                    return status
                else:
                    return "Failed to Prove"
        else:
            return "Failed to Prove"










                    

def extractRangeValuesMain(e,f_cycle):
    range_list={}
    not_range_list={}
    range_value_map={}
    range_equal_map={}
    cond_analysis_statement(e,f_cycle,range_list,not_range_list)
    for t in not_range_list:
        x=not_range_list[t]
        if x[0]=='>=':
            x[0]='<'
            range_list[expr2string1(x)]=x
        elif x[0]=='<=':
            x[0]='>'
            range_list[expr2string1(x)]=x
        elif x[0]=='<':
            x[0]='>='
            range_list[expr2string1(x)]=x
        elif x[0]=='>':
            x[0]='<='
            range_list[expr2string1(x)]=x
        elif x[0]=='!=':
            x[0]='=='
            range_list[expr2string1(x)]=x
        elif x[0]=='==':
            x[0]='!='
            range_list[expr2string1(x)]=x
    for t in range_list:
        x=range_list[t]
        
        
        
        if x[0]=='>=':
            key1=None
            value1=None
            key2=None
            value2=None
            if is_number(x[1][0])==True:
                value1=x[1][0]
                key1=x[2][0]
            if is_number(x[2][0])==True:
                key2=x[1][0]
                value2=x[2][0]
            if key1 is not None and value1 is not None and key2 is None and value2 is None:
                if key1 in range_value_map.keys():
                    list=range_value_map[key1]
                    max=int(value1)
                    if list[1]<max:
                        list[1]=max
                    range_value_map[key1]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    max=int(value1)
                    if list[1]<max:
                        list[1]=max
                    range_value_map[key1]=list
            if key2 is not None and value2 is not None and key1 is None and value1 is None:
                if key2 in range_value_map.keys():
                    list=range_value_map[key2]
                    min=int(value2)
                    if list[0]<min:
                        list[0]=min
                    range_value_map[key2]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    min=int(value2)
                    list[0]=min
                    range_value_map[key2]=list
        elif x[0]=='<=':
            key1=None
            value1=None
            key2=None
            value2=None
            if is_number(x[1][0])==True:
                value1=x[1][0]
                key1=x[2][0]
            if is_number(x[2][0])==True:
                key2=x[1][0]
                value2=x[2][0]
            if key1 is not None and value1 is not None and key2 is None and value2 is None:
                if key1 in range_value_map.keys():
                    list=range_value_map[key1]
                    min=int(value1)
                    if list[0]<min:
                        list[0]=min
                    range_value_map[key1]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    min=int(value1)
                    if list[0]<min:
                        list[0]=min
                    range_value_map[key1]=list
            if key2 is not None and value2 is not None and key1 is None and value1 is None:
                if key2 in range_value_map.keys():
                    list=range_value_map[key2]
                    min=int(value2)
                    if list[1]<min:
                        list[1]=min
                    range_value_map[key2]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    min=int(value2)
                    list[1]=min
                    range_value_map[key2]=list
        elif x[0]=='>':
            key1=None
            value1=None
            key2=None
            value2=None
            if is_number(x[1][0])==True:
                value1=x[1][0]
                key1=x[2][0]
            if is_number(x[2][0])==True:
                key2=x[1][0]
                value2=x[2][0]
            if key1 is not None and value1 is not None and key2 is None and value2 is None:
                if key1 in range_value_map.keys():
                    list=range_value_map[key1]
                    max=int(value1)-1
                    if list[1]<max:
                        list[1]=max
                    range_value_map[key1]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    max=int(value1)-1
                    if list[1]<max:
                        list[1]=max
                    range_value_map[key1]=list
            if key2 is not None and value2 is not None and key1 is None and value1 is None:
                if key2 in range_value_map.keys():
                    list=range_value_map[key2]
                    min=int(value2)+1
                    if list[0]<min:
                        list[0]=min
                    range_value_map[key2]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    min=int(value2)+1
                    list[0]=min
                    range_value_map[key2]=list
        elif x[0]=='<=':
            key1=None
            value1=None
            key2=None
            value2=None
            if is_number(x[1][0])==True:
                value1=x[1][0]
                key1=x[2][0]
            if is_number(x[2][0])==True:
                key2=x[1][0]
                value2=x[2][0]
            if key1 is not None and value1 is not None and key2 is None and value2 is None:
                if key1 in range_value_map.keys():
                    list=range_value_map[key1]
                    min=int(value1)+1
                    if list[0]<min:
                        list[0]=min
                    range_value_map[key1]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    min=int(value1)+1
                    if list[0]<min:
                        list[0]=min
                    range_value_map[key1]=list
            if key2 is not None and value2 is not None and key1 is None and value1 is None:
                if key2 in range_value_map.keys():
                    list=range_value_map[key2]
                    max=int(value2)
                    if list[1]<max:
                        list[1]=max
                    range_value_map[key2]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    max=int(value2)
                    list[1]=max-1
                    range_value_map[key2]=list
        elif x[0]=='==':
            key1=None
            value1=None
            key2=None
            value2=None
            if is_number(x[1][0])==True:
                value1=x[1][0]
                key1=x[2][0]
            if is_number(x[2][0])==True:
                key2=x[1][0]
                value2=x[2][0]
            if key1 is not None and value1 is not None and key2 is None and value2 is None:
                if key1 in range_value_map.keys():
                    list=range_value_map[key1]
                    min=int(value1)
                    list[0]=min
                    list[1]=min
                    range_equal_map[key1]=min
                    range_value_map[key1]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    min=int(value1)
                    list[0]=min
                    list[1]=min
                    range_equal_map[key1]=min
                    range_value_map[key1]=list
            if key2 is not None and value2 is not None and key1 is None and value1 is None:
                if key2 in range_value_map.keys():
                    list=range_value_map[key2]
                    max=int(value2)
                    list[1]=max
                    list[0]=max
                    range_equal_map[key2]=max
                    range_value_map[key2]=list
                else:
                    list=[]
                    list.append(-1)
                    list.append(-1)
                    max=int(value2)
                    list[1]=max
                    list[0]=max
                    range_equal_map[key2]=max
                    range_value_map[key2]=list
            
    return range_value_map,range_equal_map
    #status = recurrsiveInduction(equations,post_cond,para_list,vfact,witnessXml)
    #if 'Successfully Proved' in status:
    #    equation=[]
    #    equation.append('RE')
    #    equation.append(para_list)
    #    equation.append(eval(constructConstraints(para_list)))
    #    equation.append(post_cond)
    #    return equation
    #else:
    #    return None
    
    #for term in range_value_map:
    #    list = range_value_map[term]
    #    if list[0]!=-1:
    #        print "['a',['>=',['"+term+"'],['"+str(list[0])+"']]]"
    #    if list[1]!=-1:
    #        print "['a',['<=',['"+term+"'],['"+str(list[1])+"']]]"




def cond_analysis_statement(e,f_cycle,range_list,not_range_list):
	if e[:1]==['ite']:
        	temp=[]
                status=False
        	for x in expr_args(e):
                        temp.append(cond_analysis_statement(x,f_cycle,range_list,not_range_list))
                        x=extractRangeValues(x,f_cycle,range_list,not_range_list)
                return e[:1]+temp
        else:
                temp=[]
                for x in expr_args(e):
                    temp.append(cond_analysis_statement(x,f_cycle,range_list,not_range_list))
                return e[:1]+temp
    



def extractRangeValues(e,f_cycle,range_list,not_range_list):
    if e[:1]==['and']:
        temp=[]
        t_temp=None
        status=False
        for x in expr_args(e):
            if x[:1]==['ite']:
                temp.append(cond_analysis_statement(x,f_cycle,range_list,not_range_list))
            elif x[:1]==['and'] or x[:1]==['or']:
                temp.append(extractRangeValues(x,f_cycle,range_list,not_range_list))
            else:
                if isRecuresiveFunDef(x,f_cycle)==True:
                    status=True
                    t_temp=x
                temp.append(x)
            for t in temp:
                if t!=t_temp and t[:1]!=['ite'] and t[:1]!=['and'] and t[:1]!=['or']:
                    range_list[expr2string1(t)]=t
        return e[:1]+temp
    elif e[:1]==['or']:
        temp=[]
        t_temp=None
        status=False
        for x in expr_args(e):
            if x[:1]==['ite']:
                temp.append(cond_analysis_statement(x,f_cycle,range_list,not_range_list))
            elif x[:1]==['and'] or x[:1]==['or']:
                temp.append(extractRangeValues(x,f_cycle,range_list,not_range_list))
            else:
                if isRecuresiveFunDef(x,f_cycle)==True:
                    status=True
                    t_temp=x
                temp.append(x)
            for t in temp:
                if t!=t_temp and t[:1]!=['ite'] and t[:1]!=['and'] and t[:1]!=['or']:
                    not_range_list[expr2string1(t)]=t
        return e[:1]+temp
    else:
        temp=[]
        for x in expr_args(e):
            temp.append(cond_analysis_statement(x,f_cycle,range_list,not_range_list))
        return e[:1]+temp






def prove_assert_tactic6(equations,post_cond,f_cycle,vfact,witnessXml):
    para_list=[]
    getParameters(post_cond,para_list,f_cycle)
    status = recurrsiveInduction(equations,post_cond,para_list,vfact,witnessXml)
    if 'Successfully Proved' in status:
        equation=[]
        equation.append('RE')
        equation.append(para_list)
        #print '~~~~~~~~~~~~~1'
        #print equation[1]
        #print '~~~~~~~~~~~~~1'
        equation.append(eval(constructConstraints(para_list)))
        #print '~~~~~~~~~~~~~2'
        #print equation[2]
        #print '~~~~~~~~~~~~~2'
        equation.append(post_cond)
        #print '~~~~~~~~~~~~~3'
        #print equation[3]
        #print '~~~~~~~~~~~~~3'
        return equation
    else:
        return None
    #print '~~~~~~~~~~~~~~~~~~~~~@@@@~~~~~~~~~~~~~'


def recurrsiveInduction(equations,post_cond,para_list,vfact,witnessXml):
    
    #print '~~~~~~~~~~~~~~~~~~~~~@@@@~~~~~~~~~~~~~'
    
    #print post_cond
    
    #print para_list
    
    #print '~~~~~~~~~~~~~~~~~~~~~@@@@@~~~~~~~~~~~~'
    
    if len(para_list)==0:
        return "Failed to prove"
    
    ind_var=para_list[0]
    if is_number(ind_var)==True:
        return "Failed to prove"
        
    #print "Induction on "+str(ind_var)
        
    base_equation=[]
    base_equation.append('RE')
    if len(para_list)>1:
        base_equation.append(para_list[1:])
        base_equation.append(eval(constructConstraints(para_list[1:])))
    else:
        base_equation.append([])
        base_equation.append([])
    base_equation.append(expr_replace(copy.deepcopy(post_cond),eval("['"+ind_var+"']"),eval("['0']")))
    
    
    
    constraints=[]
    for x in equations:
        constraints.append(wff2z3_update(copy.deepcopy(x)))

    conclusion=wff2z3_update(base_equation)
    
    #print "Base Case "+str(ind_var)+"= 0"
    #print "Tried to prove"
    #print conclusion

    status=query2z3_update(constraints,conclusion,vfact,witnessXml)
    
    #print status
    #print '@@@@@@@@@@@@'
    #if len(base_equation[2])>0:
    #    status='Failed'
    
    if 'Successfully Proved' in status:
    
        #print 'Successfully Proved Base Case --'+conclusion 
        
        term_list = cond_analysis(equations,witnessXml,vfact)
        
        
        query_equation=[]
        query_equation.append('RE')
        if len(para_list)>1:
            query_equation.append(para_list[1:])
            query_equation.append(eval(constructConstraints(para_list[1:])))
        else:
            query_equation.append([])
            query_equation.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
        query_temp=[]
        query_temp.append('implies')
        query_temp.append(copy.deepcopy(post_cond))
        query_temp.append(expr_replace(copy.deepcopy(post_cond),eval("['"+ind_var+"']"),eval("['+',['"+ind_var+"'],['1']]")))
        query_equation.append(query_temp)
        query_equation1=copy.deepcopy(query_equation)
    
        constraints=[]
        
        for x in equations:
            constraints.append(wff2z3_update(copy.deepcopy(x)))
        
        conclusion=wff2z3_update(query_equation)
        
        #print "Tried to prove "+conclusion
        
        status=query2z3_update(constraints,conclusion,vfact,witnessXml)
        
        
        if 'Successfully Proved' not in status and len(para_list)==1:
            query_equation1[3][2]=simplification_rec_fun(query_equation1[3][2],term_list)
            conclusion=wff2z3_update(query_equation1)
            status=query2z3_update(constraints,conclusion,vfact,witnessXml)
        
        #print status
    
        if 'Successfully Proved' in status:
            
            #print "Successfully Proved ---"+conclusion
            
            return status
        else:
            new_post_cond=copy.deepcopy(query_equation[3][2])
            inductive_assumption=[]
            inductive_assumption.append('RE')
            if len(para_list)>1:
                inductive_assumption.append(para_list[1:])
                inductive_assumption.append(eval(constructConstraints(para_list[1:])))
            else:
                inductive_assumption.append([])
                inductive_assumption.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
            inductive_assumption.append(copy.deepcopy(post_cond))
            new_equations=copy.deepcopy(equations)
            new_equations.append(inductive_assumption)
            if len(para_list)>1:
                new_equation=[]
                new_equation.append('a')
                new_equation.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
                new_equations.append(new_equation)
                status=recurrsiveInduction(new_equations,new_post_cond,para_list[1:],vfact,witnessXml)
                return status
            else:
                return "Failed to Prove"
        
    else:
        new_post_cond=copy.deepcopy(base_equation[3])
        
        status=recurrsiveInduction(equations,new_post_cond,para_list[1:],vfact,witnessXml)
        
        
        if 'Successfully Proved' in status:
            
            #print 'Successfully Proved Base Case ----'+conclusion
            
            term_list = cond_analysis(equations,witnessXml,vfact)
        
            
            query_equation=[]
            query_equation.append('RE')
            if len(para_list)>1:
                query_equation.append(para_list[1:])
                query_equation.append(eval(constructConstraints(para_list[1:])))
            else:
                query_equation.append([])
                query_equation.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
            query_temp=[]
            query_temp.append('implies')
            query_temp.append(copy.deepcopy(post_cond))
            query_temp.append(expr_replace(copy.deepcopy(post_cond),eval("['"+ind_var+"']"),eval("['+',['"+ind_var+"'],['1']]")))
            query_equation.append(query_temp) 
            query_equation1=copy.deepcopy(query_equation)
            constraints=[]
            for x in equations:
                constraints.append(wff2z3_update(copy.deepcopy(x)))
                
            
            
            conclusion=wff2z3_update(query_equation)
            #print "Tried to prove" +conclusion

            status=query2z3_update(constraints,conclusion,vfact,witnessXml)
            
            if 'Successfully Proved' not in status and len(para_list)==1:
                query_equation1[3][2]=simplification_rec_fun(query_equation1[3][2],term_list)
                conclusion=wff2z3_update(query_equation1)
                status=query2z3_update(constraints,conclusion,vfact,witnessXml)
                
            if 'Successfully Proved' in status:
                
                #print "Successfully Proved ---"+conclusion
                
                return status
            else:
                new_post_cond=copy.deepcopy(query_equation[3][2])
                inductive_assumption=[]
                inductive_assumption.append('RE')
                if len(para_list)>1:
                    inductive_assumption.append(para_list[1:])
                    inductive_assumption.append(eval(constructConstraints(para_list[1:])))
                else:
                    inductive_assumption.append([])
                    inductive_assumption.append([])
                inductive_assumption.append(copy.deepcopy(post_cond))
                new_equations=copy.deepcopy(equations)
                new_equations.append(inductive_assumption)
                if len(para_list)>1:
                    new_equation=[]
                    new_equation.append('a')
                    new_equation.append(eval("['>='"+",['"+str(ind_var)+"'],['0']]"))
                    new_equations.append(new_equation)
                    status=recurrsiveInduction(new_equations,new_post_cond,para_list[1:],vfact,witnessXml)
                    return status
                else:
                    return "Failed to Prove"
        else:
            return "Failed to Prove"











#f_map={'ackermann':'ackermann'}

#e=['>=',['ackermann',['__VERIFIER_nondet_int2'],['+',['__VERIFIER_nondet_int3'],['1']]],['0']]
#term_map={'ackermann':[ ['m','n'],['ackermann', ['-', ['m'], ['1']], ['ackermann', ['m'], ['-', ['n'], ['1']]]]]}

def simplification_rec_fun(e,term_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return e
    else:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            temp=[]
            for x in expr_args(e):
                parameter=simplification_rec_fun(x,term_map)
                temp.append(parameter)
            return e[:1]+temp
         elif op in term_map.keys():
                temp=[]
                for x in expr_args(e):
                    parameter=simplification_rec_fun(x,term_map)
                    temp.append(parameter)
                simpl_term_list=term_map[op]
                temp2=simpl_term_list[0]
                new_stmt=copy.deepcopy(simpl_term_list[1])
                for x in range(0,len(temp2)):
                    new_stmt=expr_replace(new_stmt,eval("['"+temp2[x]+"']"),temp[x])
                return new_stmt
         else:
            return e[:1]+list(simplification_rec_fun(x,term_map) for x in expr_args(e))







def cond_analysis(equations,witnessXml,vfact):
    assum_list=[]
    terms_map={}
    for x in equations:
        if x[0]=='R':
            for a in x[1]:
                assume_eq=[]
                assume_eq.append('a')
                assume_eq.append(eval("['>',['"+a+"'],['0']]"))
                assum_list.append(assume_eq)
            terms_list=[]
            terms_list.append(x[1])
            terms_list.append(expr_conditions_analysis(x[3],vfact,assum_list,witnessXml))
            terms_map[x[2][0]]=terms_list
    return terms_map
            

#e = ['e', ['_1_FAILED1'], ['ite', ['and', ['>=', ['__VERIFIER_nondet_int2'], ['0']], ['<=', ['__VERIFIER_nondet_int2'], ['3']]], ['ite', ['and', ['>=', ['__VERIFIER_nondet_int_12'], ['0']], ['<=', ['__VERIFIER_nondet_int_12'], ['23']]], ['ite', ['or', ['or', ['<', ['__VERIFIER_nondet_int2'], ['0']], ['<', ['__VERIFIER_nondet_int_12'], ['0']]], ['>=', ['ackermann', ['__VERIFIER_nondet_int2'], ['__VERIFIER_nondet_int_12']], ['0']]], ['0'], ['1']], ['0']], ['0']]]
#f_cycle=['ackermann']

def getRecuresiveFunDef(e,f_cycle,list_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)>0:
         if  op in _infix_op:
            for x in args:
                #print x
                if isRecursiveTerm(x,f_cycle)==True:
                    list_map[expr2string1(e)]=e
                else:
                    getRecuresiveFunDef(x,f_cycle,list_map)
         else:
                for x in args:
                    getRecuresiveFunDef(x,f_cycle,list_map)


def isRecuresiveFunDef(e,f_cycle):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)>0:
         if  op in _infix_op:
            for x in args:
                #print x
                if isRecursiveTerm(x,f_cycle)==True:
                    return True
                else:
                    if isRecuresiveFunDef(x,f_cycle)==True:
                        return True
         else:
                for x in args:
                    if isRecuresiveFunDef(x,f_cycle)==True:
                        return True
    return False





def isRecursiveTerm(e,f_cycle):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)>0:
        if op in f_cycle:
            return True
        else:
            return False
    else:
        return False



#assume=[['a',[">",['m'],['0']]],['a',[">",['n'],['0']]]]


#vfact=[['ackermann', 2, ['int', 'int', 'int']], ['ackermann_2', 2, ['int', 'int', 'int']], ['m', 0, ['int']], ['ackermann_1', 2, ['int', 'int', 'int']], ['m1', 1, ['int', 'int']], ['n1', 1, ['int', 'int']], ['n', 0, ['int']], ['main', 0, ['int']],['__VERIFIER_nondet_int2', 0, ['int']],['__VERIFIER_nondet_int3', 0, ['int']]]


#witnessXml=['<?xml version="1.0" encoding="UTF-8" standalone="no"?><graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><key attr.name="isEntryNode" attr.type="boolean" for="node" id="entry"><default>false</default></key><key attr.name="isViolationNode" attr.type="boolean" for="node" id="violation"><default>false</default></key><key attr.name="witness-type" attr.type="string" for="graph" id="witness-type"/><key attr.name="sourcecodelang" attr.type="string" for="graph" id="sourcecodelang"/><key attr.name="producer" attr.type="string" for="graph" id="producer"/><key attr.name="specification" attr.type="string" for="graph" id="specification"/><key attr.name="programFile" attr.type="string" for="graph" id="programfile"/><key attr.name="programHash" attr.type="string" for="graph" id="programhash"/><key attr.name="memoryModel" attr.type="string" for="graph" id="memorymodel"/><key attr.name="architecture" attr.type="string" for="graph" id="architecture"/><key attr.name="startline" attr.type="int" for="edge" id="startline"/><key attr.name="assumption" attr.type="string" for="edge" id="assumption"/><key attr.name="assumption.scope" attr.type="string" for="edge" id="assumption.scope"/><key attr.name="assumption.resultfunction" attr.type="string" for="edge" id="assumption.resultfunction"/><graph edgedefault="directed"><data key="witness-type">violation_witness</data><data key="sourcecodelang">C</data><data key="producer">CPAchecker 1.6.1-svn</data><data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )</data><data key="programfile">Ackermann01_true-unreach-call.c</data><data key="programhash">1776ed2413d170f227b69d8c79ba700d31db6f75</data><data key="memorymodel">precise</data><data key="architecture">32bit</data><node id="entry"><data key="entry">true</data></node><node id="error"><data key="violation">true</data></node><edge source="entry" target="error">', '<data key="assumption.scope">main</data><data key="assumption.resultfunction">__VERIFIER_nondet_int</data></edge></graph></graphml>', 'main', 'Ackermann01_true-unreach-call.c']


def expr_conditions_analysis(e,vfact,assume,witnessXml): #e,e1,e2: expr
	if e[:1]==['ite']:
        	temp=[]
        	for x in expr_args(e):
        		temp.append(expr_conditions_analysis(x,vfact,assume,witnessXml))
        	constraints=[]
        	for x in assume:
                    constraints.append(wff2z3_update(x))
                query=[]
                query.append('a')
                query.append(temp[0])
                conclusion=wff2z3_update(query)
                status=query2z3_update(constraints,conclusion,vfact,witnessXml)
                if 'Successfully Proved' in status:
                    return temp[1]
                else:
                    return temp[2]
        else:
        	return e[:1]+list(expr_conditions_analysis(x,vfact,assume,witnessXml) for x in expr_args(e))




def getBigN(e,N_map,n_map):
	args=expr_args(e)
    	op=expr_op(e)
    	if len(args)==0:
    		if op.startswith('_N'):
        		N_map[op]=op
        	elif op.startswith('_n'):
        		n_map[op]=op
    	else:

                if op.startswith('_N'):
                    N_map[expr2string1(e)]=e
                for x in expr_args(e):
                    getBigN(x,N_map,n_map)
    
    
def constructConstraints(list_var):
    if len(list_var)==1:
        return "['>=',['"+list_var[0]+"'],['0']]"
    elif len(list_var)==2:
        return "['and',['>=',['"+list_var[0]+"'],['0']],"+"['>=',['"+list_var[1]+"'],['0']]]"
    else:
        return "['+and+',['>=',['"+list_var[0]+"'],['0']],"+constructConstraints(list_var[1:])+"]"
    
    





def getParameters(e,para_list,f_cycle):
    args=expr_args(e)
    op=expr_op(e)
    fun_name=fun_matching(op)
    if len(args)>0:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            for x in args:
                getParameters(x,para_list,f_cycle)
         elif fun_name in f_cycle:
                for x in args:
                    key=expr2string1(x)
                    if is_number(key)!=True:
                        para_list.append(key)
         else:
                for x in args:
                    getParameters(x,para_list,f_cycle)






"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def query2z3(constraint_list,conclusion,vfact,inputmap,witnessXml):
	pythonProgram="import sys\n"
        pythonProgram+="import os\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
	pythonProgram+="from z3 import *\n"
        pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
	pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
	pythonProgram+="\t_p1=Int('_p1')\n"
	pythonProgram+="\t_p2=Int('_p2')\n"
	pythonProgram+="\t_n=Int('_n')\n"
        pythonProgram+="\t_bool=Int('_bool')\n"
	pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
	pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    

        duplicate_map={}
        
	status=""
	for [x,k,l] in vfact:
		if k==0:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
				if l[0]=="int":
					if '_N' in x:
						pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
					else:				
						pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="double":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
				elif l[0]=="float":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        	elif l[0]=="Bool":
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="constant":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
				elif l[0]=="array":
					if 'array(' not in x:
                                            pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
				else:
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                                duplicate_map[x]=x
                                        
		else:
			if x not in duplicate_map.keys():
                            if ('_PROVE' not in x or '_ASSUME' not in x):
                                    pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                    duplicate_map[x]=x
                                    for e in l:
                                            if e=="int":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="unsigned":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="long":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="array":
                                                    pythonProgram+=",arraySort"
                                            else:
                                                    pythonProgram+=",RealSort()"
                                    pythonProgram+=")\n"
	power_flag=False
	for equation in constraint_list:
		if '**' in equation or 'power' in equation:
			power_flag=True
	if '**' in conclusion or 'power' in conclusion:
		power_flag=True
	if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
                pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
		pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

	pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
	pythonProgram+="\t_s.set(\"timeout\","+str(TIMEOUT)+")\n"
	for equation in constraint_list:
                if 'main(argc, argv)' not in equation and 'argv1(argv)' not in equation and 'argc1(argc)' not in equation:
                    pythonProgram+="\t_s.add("+str(equation)+")\n"
	finalProgram=pythonProgram
	#finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
        #if conclusion is not None:
        finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#print finalProgram
	writtingFile( "z3query.py" , finalProgram )
	writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
	try :
		proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
		output = proc.stdout.read()
		status=output
	except OSError  as err:
		print 'dharilo1'
	return status




"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def query2z3_bitwise(constraint_list,conclusion,vfact,inputmap, map_fun_bitwise,witnessXml):
	pythonProgram="import sys\n"
        pythonProgram+="import os\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
	pythonProgram+="from z3 import *\n"
        pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
	pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
	pythonProgram+="\t_p1=Int('_p1')\n"
	pythonProgram+="\t_p2=Int('_p2')\n"
	pythonProgram+="\t_n=Int('_n')\n"
        pythonProgram+="\t_bool=Int('_bool')\n"
	pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
	pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    

        duplicate_map={}
        
	status=""
	for [x,k,l] in vfact:
            
                para_count=0
                
		if k==0:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
                                if x in map_fun_bitwise:
                                    pythonProgram+='\t'+x+"=BitVec(\'"+x+"\',32)\n"
				elif l[0]=="int":
					if '_N' in x:
						pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
					else:				
						pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="double":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
				elif l[0]=="float":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        	elif l[0]=="Bool":
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="constant":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
				elif l[0]=="array":
					if 'array(' not in x:
                                            pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
				else:
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                                duplicate_map[x]=x
                                        
		else:
			if x not in duplicate_map.keys():
                            if ('_PROVE' not in x or '_ASSUME' not in x):
                                    pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                    duplicate_map[x]=x
                                    for e in l:
                                            if x in map_fun_bitwise and len(l)-1==para_count:
                                                    pythonProgram+=",BitVecSort(32)"
                                            elif e=="int":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="unsigned":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="long":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="array":
                                                    pythonProgram+=",arraySort"
                                            else:
                                                    pythonProgram+=",RealSort()"
                                                    
                                            para_count=para_count+1
                                            
                                    pythonProgram+=")\n"
	power_flag=False
	for equation in constraint_list:
		if '**' in equation or 'power' in equation:
			power_flag=True
	if '**' in conclusion or 'power' in conclusion:
		power_flag=True
	if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
                pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
		pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

	pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
	pythonProgram+="\t_s.set(\"timeout\","+str(200000)+")\n"
	for equation in constraint_list:
                if 'main(argc, argv)' not in equation and 'argv1(argv)' not in equation and 'argc1(argc)' not in equation:
                    pythonProgram+="\t_s.add("+str(equation)+")\n"
	finalProgram=pythonProgram
	#finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
	finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#print finalProgram
	writtingFile( "z3query.py" , finalProgram )
	writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
	try :
		proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
		output = proc.stdout.read()
		status=output
	except OSError  as err:
		print 'dharilo1'
	return status



"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def query2z3_bitwise_assert(constraint_list,conclusion,vfact,inputmap, map_fun_bitwise,witnessXml):
	pythonProgram="import sys\n"
        pythonProgram+="import os\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
	pythonProgram+="from z3 import *\n"
        pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
	pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
	pythonProgram+="\t_p1=Int('_p1')\n"
	pythonProgram+="\t_p2=Int('_p2')\n"
	pythonProgram+="\t_n=BitVec('_n',32)\n"
        pythonProgram+="\t_bool=Int('_bool')\n"
	pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
	pythonProgram+="\t_f=Function('_f',BitVecSort(32),BitVecSort(32))\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    

        duplicate_map={}
        
	status=""
	for [x,k,l] in vfact:
            
                para_count=0
                
		if k==0:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
                                if x in map_fun_bitwise:
                                    pythonProgram+='\t'+x+"=BitVec(\'"+x+"\',32)\n"
				elif l[0]=="int":
					if '_N' in x:
						pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
					else:				
						pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="double":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
				elif l[0]=="float":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        	elif l[0]=="Bool":
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="constant":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
				elif l[0]=="array":
					if 'array(' not in x:
                                            pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
				else:
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                                duplicate_map[x]=x
                                        
		else:
			if x not in duplicate_map.keys():
                            if ('_PROVE' not in x or '_ASSUME' not in x):
                                    pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                    duplicate_map[x]=x
                                    for e in l:
                                            if x in map_fun_bitwise and len(l)-1==para_count:
                                                    pythonProgram+=",BitVecSort(32)"
                                            elif e=="int":
                                                    pythonProgram+=",BitVecSort(32)"
                                            elif e=="unsigned":
                                                    pythonProgram+=",BitVecSort(32)"
                                            elif e=="long":
                                                    pythonProgram+=",BitVecSort(32)"
                                            elif e=="array":
                                                    pythonProgram+=",arraySort"
                                            else:
                                                    pythonProgram+=",RealSort()"
                                                    
                                            para_count=para_count+1
                                            
                                    pythonProgram+=")\n"
	power_flag=False
	for equation in constraint_list:
		if '**' in equation or 'power' in equation:
			power_flag=True
	if '**' in conclusion or 'power' in conclusion:
		power_flag=True
	if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
                pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
		pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

	pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
	pythonProgram+="\t_s.set(\"timeout\","+str(200000)+")\n"
	for equation in constraint_list:
                if 'main(argc, argv)' not in equation and 'argv1(argv)' not in equation and 'argc1(argc)' not in equation:
                    pythonProgram+="\t_s.add("+str(equation)+")\n"
	finalProgram=pythonProgram
	#finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
	finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#print finalProgram
	writtingFile( "z3query.py" , finalProgram )
	writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
	try :
		proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
		output = proc.stdout.read()
		status=output
	except OSError  as err:
		print 'dharilo1'
	return status








def query2z3_array_abstract(constraint_list,conclusion,vfact,inputmap,witnessXml):
	pythonProgram="import sys\n"
        pythonProgram+="import os\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
	pythonProgram+="from z3 import *\n"
        pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
	pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
	pythonProgram+="\t_p1=Int('_p1')\n"
	pythonProgram+="\t_p2=Int('_p2')\n"
	pythonProgram+="\t_n=Int('_n')\n"
        pythonProgram+="\t_bool=Int('_bool')\n"
	pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
	pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    

        duplicate_map={}
        
	status=""
	for [x,k,l] in vfact:
		if k==0:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
				if l[0]=="int":
					if '_N' in x:
						pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
					else:				
						pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="double":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
				elif l[0]=="float":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        	elif l[0]=="Bool":
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="constant":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
				elif l[0]=="array":
					if 'array(' not in x:
                                            pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
				else:
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                                duplicate_map[x]=x
                                        
		else:
			if x not in duplicate_map.keys():
                            if ('_PROVE' not in x or '_ASSUME' not in x):
                                    pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                    duplicate_map[x]=x
                                    for e in l:
                                            if e=="int":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="unsigned":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="long":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="array":
                                                    pythonProgram+=",arraySort"
                                            else:
                                                    pythonProgram+=",RealSort()"
                                    pythonProgram+=")\n"
	power_flag=False
	for equation in constraint_list:
		if '**' in equation or 'power' in equation:
			power_flag=True
	if '**' in conclusion or 'power' in conclusion:
		power_flag=True
	if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
                pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
		pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

	pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
	pythonProgram+="\t_s.set(\"timeout\","+str(100000)+")\n"
	for equation in constraint_list:
                if 'main(argc, argv)' not in equation and 'argv1(argv)' not in equation and 'argc1(argc)' not in equation:
                    pythonProgram+="\t_s.add("+str(equation)+")\n"
	finalProgram=pythonProgram
	#finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
	finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#print finalProgram
	writtingFile( "z3query.py" , finalProgram )
	writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
	try :
		proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
		output = proc.stdout.read()
		status=output
	except OSError  as err:
		print 'dharilo1'
	return status





def query2z3_termination(constraint_list,vfact,inputmap,witnessXml):
	pythonProgram="import sys\n"
        pythonProgram+="import os\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
	pythonProgram+="from z3 import *\n"
        pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
	pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
	pythonProgram+="\t_p1=Int('_p1')\n"
	pythonProgram+="\t_p2=Int('_p2')\n"
	pythonProgram+="\t_n=Int('_n')\n"
        pythonProgram+="\t_bool=Int('_bool')\n"
	pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
	pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    

        duplicate_map={}
        
	status=""
	for [x,k,l] in vfact:
		if k==0:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
				if l[0]=="int":
					if '_N' in x:
						pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
					else:				
						pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="double":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
				elif l[0]=="float":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        	elif l[0]=="Bool":
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="constant":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
				elif l[0]=="array":
					if 'array(' not in x:
                                            pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
				else:
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                                duplicate_map[x]=x
                                        
		else:
			if x not in duplicate_map.keys():
                            if ('_PROVE' not in x or '_ASSUME' not in x):
                                    pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                    duplicate_map[x]=x
                                    for e in l:
                                            if e=="int":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="unsigned":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="long":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="array":
                                                    pythonProgram+=",arraySort"
                                            else:
                                                    pythonProgram+=",RealSort()"
                                    pythonProgram+=")\n"
	power_flag=False
	for equation in constraint_list:
		if '**' in equation or 'power' in equation:
			power_flag=True
	if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
                pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
		pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

	pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
	pythonProgram+="\t_s.set(\"timeout\","+str(500)+")\n"
	for equation in constraint_list:
                if 'main(argc, argv)' not in equation and 'argv1(argv)' not in equation and 'argc1(argc)' not in equation:
                    pythonProgram+="\t_s.add("+str(equation)+")\n"
	finalProgram=pythonProgram
	#finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
	#finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#print finalProgram
	writtingFile( "z3query.py" , finalProgram )
	writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
	try :
		proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
		output = proc.stdout.read()
		status=output
	except OSError  as err:
		print 'dharilo1'
	return status




























"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def query2z3_update(constraint_list,conclusion,vfact,witnessXml):
	pythonProgram="import sys\n"
        pythonProgram+="import os\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
	pythonProgram+="from z3 import *\n"
        pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
	pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
	pythonProgram+="\t_p1=Int('_p1')\n"
	pythonProgram+="\t_p2=Int('_p2')\n"
	pythonProgram+="\t_n=Int('_n')\n"
        pythonProgram+="\t_bool=Int('_bool')\n"
	pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
	pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    
        duplicate_map={}

	status=""
	for [x,k,l] in vfact:
		if k==0:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
				if l[0]=="int":
					if '_N' in x:
						pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
					else:				
						pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="double":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
				elif l[0]=="float":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        	elif l[0]=="Bool":
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="constant":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
				elif l[0]=="array":
					if 'array(' not in x:
                                            pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
				else:
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                                duplicate_map[x]=x
		else:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
				pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                duplicate_map[x]=x
				for e in l:
					if e=="int":
						pythonProgram+=",IntSort()"
					elif e=="unsigned":
						pythonProgram+=",IntSort()"
					elif e=="long":
						pythonProgram+=",IntSort()"
					elif e=="Bool":
						pythonProgram+=",IntSort()"
					elif e=="array":
						pythonProgram+=",arraySort"
					else:
						pythonProgram+=",RealSort()"
                                pythonProgram+=")\n"
	power_flag=False
	for equation in constraint_list:
		if '**' in equation or 'power' in equation:
			power_flag=True
	if conclusion is not None and ('**' in conclusion or 'power' in conclusion):
		power_flag=True
	if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
                pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
		pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

	pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
	pythonProgram+="\t_s.set(\"timeout\","+str(500)+")\n"
	for equation in constraint_list:
		pythonProgram+="\t_s.add("+str(equation)+")\n"
	finalProgram=pythonProgram
	#finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
	if conclusion is not None:
            finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
        #finalProgram+="\tif sat==_s.check():\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\t\twitnessXmlStr="+str(witnessXml)+"\n"+"\t\tmiddle=''\n"+"\t\tfor element in _s.model():\n"+"\t\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\t\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\t\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\t\tfile.close()\n"+"\telif unsat==_s.check():\n"+"\t\t_s.check()\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#print finalProgram
	writtingFile( "z3query.py" , finalProgram )
	writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
	try :
		proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
		output = proc.stdout.read()
		status=output
	except OSError  as err:
		print 'dharilo1'
	return status




"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def query2z3_cond(constraint_list,conclusion,vfact):
	pythonProgram="import sys\n"
        pythonProgram+="import os\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
	pythonProgram+="from z3 import *\n"
        pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
	pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
	pythonProgram+="\t_p1=Int('_p1')\n"
	pythonProgram+="\t_p2=Int('_p2')\n"
	pythonProgram+="\t_n=Int('_n')\n"
        pythonProgram+="\t_bool=Int('_bool')\n"
	pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
	pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    
        duplicate_map={}

	status=""
	for [x,k,l] in vfact:
		if k==0:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
				if l[0]=="int":
					if '_N' in x:
						pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
					else:				
						pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="double":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
				elif l[0]=="float":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        	elif l[0]=="Bool":
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="constant":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
				elif l[0]=="array":
					if 'array(' not in x:
                                            pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
				else:
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                                duplicate_map[x]=x
		else:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
				pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                duplicate_map[x]=x
				for e in l:
					if e=="int":
						pythonProgram+=",IntSort()"
					elif e=="unsigned":
						pythonProgram+=",IntSort()"
					elif e=="long":
						pythonProgram+=",IntSort()"
					elif e=="Bool":
						pythonProgram+=",IntSort()"
					elif e=="array":
						pythonProgram+=",arraySort"
					else:
						pythonProgram+=",RealSort()"
                                pythonProgram+=")\n"
	power_flag=False
	for equation in constraint_list:
		if '**' in equation or 'power' in equation:
			power_flag=True
	if '**' in conclusion or 'power' in conclusion:
		power_flag=True
	if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
                pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
		pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

	pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
	pythonProgram+="\t_s.set(\"timeout\","+str(500)+")\n"
	for equation in constraint_list:
		pythonProgram+="\t_s.add("+str(equation)+")\n"
	finalProgram=pythonProgram
	finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        #finalProgram+="\tif sat==_s.check():\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==_s.check():\n"+"\t\t_s.check()\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	writtingFile( "z3query.py" , finalProgram )
	writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
	try :
		proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
		output = proc.stdout.read()
		status=output
	except OSError  as err:
		print 'dharilo1'
	return status



"""

Tactic 1  ----> 1.Directly translate axoimes to z3 constraint 2.try to prove conclusion 3.waited for 6000

"""
def tactic1(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints):
	constraint_list=[]
	frame_axioms=eqset2constraintlist(f)
	for x in frame_axioms:
		constraint_list.append(x)
	
	
	out_axioms=eqset2constraintlist(o)
	subs_list=eqset2subs_list(o)
	
	
	for x in out_axioms:
		constraint_list.append(x)
	for x in a: 
        	#equations=wff2z3(x)
        	equations=wff2z3_update(x)
        	
        	equations_sp=None
                constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        	       
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		if "factorial" in conclusion:
			cfact=eval("['factorial',1,['int','int']]")
			vfact.append(cfact)
		status=query2z3(constraint_list,conclusion,vfact,inputmap)
		writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
		if "Successfully Proved" in status:
			return "Successfully Proved"			
		elif "Counter Example" in status:
			return 	status		
		else:
			return "Failed to Prove"







def tactic1_update(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
	frame_axioms=eqset2constraintlist_update(f)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(o)
    
	subs_list=eqset2subs_list(o)
	
	for x in out_axioms:
		constraint_list.append(x)

	for x in a: 
        	equations=wff2z3_update(x)                
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        status_value = query2z3_cond([],equations,vfact)
                        if 'Successfully Proved' not in status_value:
                            constraint_list.append(equations)
                    else:

                        constraint_list.append(equations)
                else:

                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		if "factorial" in conclusion:
			cfact=eval("['factorial',1,['int','int']]")
			vfact.append(cfact)
		status=query2z3(constraint_list,conclusion,vfact,inputmap,witnessXml)
		writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
		if "Successfully Proved" in status:
			return "Successfully Proved"			
		elif "Counter Example" in status:
			return 	status		
		else:
			return "Failed to Prove"



def tactic1_update_power(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
	frame_axioms=eqset2constraintlist_update(f)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(o)
    
	subs_list=eqset2subs_list(o)
	
	for x in out_axioms:
		constraint_list.append(x)

	for x in a: 
        	equations=wff2z3_update_power(x)                
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        status_value = query2z3_cond([],equations,vfact)
                        if 'Successfully Proved' not in status_value:
                            constraint_list.append(equations)
                    else:

                        constraint_list.append(equations)
                else:

                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		if "factorial" in conclusion:
			cfact=eval("['factorial',1,['int','int']]")
			vfact.append(cfact)
		status=query2z3(constraint_list,conclusion,vfact,inputmap,witnessXml)
		writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
		if "Successfully Proved" in status:
			return "Successfully Proved"			
		elif "Counter Example" in status:
			return 	status		
		else:
			return "Failed to Prove"





def tactic1_update_array_abstract(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
	frame_axioms=eqset2constraintlist_update(f)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(o)
    
	subs_list=eqset2subs_list(o)
	
	for x in out_axioms:
		constraint_list.append(x)
	for x in a: 
        	equations=wff2z3_update(x)                
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        status_value = query2z3_cond([],equations,vfact)
                        if 'Successfully Proved' not in status_value:
                            constraint_list.append(equations)
                    else:

                        constraint_list.append(equations)
                else:

                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		if "factorial" in conclusion:
			cfact=eval("['factorial',1,['int','int']]")
			vfact.append(cfact)
		status=query2z3_array_abstract(constraint_list,conclusion,vfact,inputmap,witnessXml)
		writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
		if "Successfully Proved" in status:
			return "Successfully Proved"			
		elif "Counter Example" in status:
			return 	status		
		else:
			return "Failed to Prove"






def tactic1_update_bitwise(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints, map_fun_bitwise,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
	frame_axioms=eqset2constraintlist_update(f)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(o)
    
	subs_list=eqset2subs_list(o)
	
	for x in out_axioms:
		constraint_list.append(x)
	for x in a: 
        	equations=wff2z3_update(x)                
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        status_value = query2z3_cond([],equations,vfact)
                        if 'Successfully Proved' not in status_value:
                            constraint_list.append(equations)
                    else:

                        constraint_list.append(equations)
                else:

                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		if "factorial" in conclusion:
			cfact=eval("['factorial',1,['int','int']]")
			vfact.append(cfact)
		status=query2z3_bitwise(constraint_list,conclusion,vfact,inputmap, map_fun_bitwise,witnessXml)
		writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
		if "Successfully Proved" in status:
			return "Successfully Proved"			
		elif "Counter Example" in status:
			return 	status		
		else:
			return "Failed to Prove"





def tactic1_update_bitwise_assert(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints, map_fun_bitwise,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
	frame_axioms=eqset2constraintlist_update(f)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(o)
    
	subs_list=eqset2subs_list(o)
	
	for x in out_axioms:
		constraint_list.append(x)
	for x in a: 
        	equations=wff2z3_update(x)                
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        status_value = query2z3_cond([],equations,vfact)
                        if 'Successfully Proved' not in status_value:
                            constraint_list.append(equations)
                    else:

                        constraint_list.append(equations)
                else:

                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		if "factorial" in conclusion:
			cfact=eval("['factorial',1,['int','int']]")
			vfact.append(cfact)
		status=query2z3_bitwise_assert(constraint_list,conclusion,vfact,inputmap, map_fun_bitwise,witnessXml)
		writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
		if "Successfully Proved" in status:
			return "Successfully Proved"			
		elif "Counter Example" in status:
			return 	status		
		else:
			return "Failed to Prove"






def tactic1_update_termination(f,o,a,pre_condition,vfact,inputmap,constaints,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
	frame_axioms=eqset2constraintlist_update(f)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(o)

	subs_list=eqset2subs_list(o)
	
	
	for x in out_axioms:
		constraint_list.append(x)
	for x in a: 
        	equations=wff2z3_update(x)
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        constraint_list.append(equations)
                    else:
                        constraint_list.append(equations)
                else:

                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
        #writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
        status=query2z3_termination(constraint_list,vfact,inputmap,witnessXml)
        writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
        if "Successfully Proved" in status:
            return "Successfully Proved"					
        else:
            return "Failed to Prove"













#For Array 
def tactic4_update(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,allvariables,const_var_map,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
        array_dimesion_map={}
        for array in allvariables.keys():
            dimesnsion= allvariables[array].getDimensions()
            if dimesnsion is not None:
                array_dimesion_map[array]=dimesnsion
                
	frame_axioms=eqset2constraintlist4_update(f,allvariables,const_var_map)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist4_update(o,allvariables,const_var_map)

	subs_list=eqset2subs_list(o)
	
	
	for x in out_axioms:
		constraint_list.append(x)
	for x in a: 
        	equations=wff2z3_update4(x,allvariables,const_var_map)
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        if simplify(equations)!=False:
                            constraint_list.append(equations)
                    else:
                        constraint_list.append(equations)
                else:
                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		if "factorial" in conclusion:
			cfact=eval("['factorial',1,['int','int']]")
			vfact.append(cfact)
		status=query2z3(constraint_list,conclusion,vfact,inputmap,witnessXml)
		writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
		if "Successfully Proved" in status:
			return "Successfully Proved"			
		elif "Counter Example" in status:
			return 	status		
		else:
			return "Failed to Prove"








#For Array Tilling
def tactic5_update(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,allvariables,const_var_map,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
        array_dimesion_map={}
        for array in allvariables.keys():
            dimesnsion= allvariables[array].getDimensions()
            if dimesnsion is not None:
                array_dimesion_map[array]=dimesnsion
                
	frame_axioms=eqset2constraintlist4_update(f,allvariables,const_var_map)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist4_update(o,allvariables,const_var_map)

	subs_list=eqset2subs_list(o)
	
	
	for x in out_axioms:
		constraint_list.append(x)
	for x in a: 
        	equations=wff2z3_update5(x,allvariables,const_var_map)
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        if simplify(equations)!=False:
                            constraint_list.append(equations)
                    else:
                        constraint_list.append(equations)
                else:
                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		if "factorial" in conclusion:
			cfact=eval("['factorial',1,['int','int']]")
			vfact.append(cfact)
		status=query2z3(constraint_list,conclusion,vfact,inputmap,witnessXml)
		writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
		if "Successfully Proved" in status:
			return "Successfully Proved"			
		elif "Counter Example" in status:
			return 	status		
		else:
			return "Failed to Prove"






















"""

Tactic 2  ----> 1.Directly translate axoimes to z3 constraint 2.try to prove using induction on loop variable 

"""
def tactic2(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,const_var_map,witnessXml):
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		subs_list=eqset2subs_list(o)
		conclusion=simplify_conclusion(conclusion,subs_list)
		if conclusion is None:
			return "Failed to Prove"
		variable=None
		constant=None
		const_map={}
		var_const_map={}
		count=0
		for cm in const_var_map:
			if const_var_map[cm] in conclusion:
				count=count+1
				const_map[const_var_map[cm]]=cm
				var_const_map[cm]="_k"+str(count)
		constraint_list=[]
		condition_map={}
		frame_axioms=eqset2constraintlist(f)
		for x in frame_axioms:
			constraint_list.append(x)
		out_axioms=eqset2constraintlist(o)
		
		for x in out_axioms:
			constraint_list.append(x)
		for x in a: 
        		equations=wff2z3(x)
        		getAllCondtion(x,condition_map)
        		equations_sp=None	
                	constraint_list.append(equations)
                	if x[0]=='s1':
        			equations_sp=wff2z3SC(x)
        			if equations_sp is not None:
        				constraint_list.append(equations_sp)
		for x in constaints:
			constraint_list.append(x)
		for x in pre_condition:
        		constraint_list.append(x)
		update_vfact=[]
		for [x,k,l] in vfact:
			if x in const_map.values():
				if k==0:
					ul=['constant']
					update_vfact.append([var_const_map[x],k,ul])
					update_vfact.append([x,k,l])
				else:
					update_vfact.append([var_const_map[x],k,l])
					update_vfact.append([x,k,l])
			else:
				update_vfact.append([x,k,l])

		if 'ForAll(' in conclusion or 'Exits' in conclusion:
			return "Failed to Prove"
		
		for x in const_map:
			variable=var_const_map[const_map[x]]			
			constant=x
			loop_var=const_map[x]
			if 'Not(' in conclusion:
				arg_list=extract_args(conclusion)
				conclusion=arg_list[0]
				#conclusion=conclusion.replace('==','!=')

			
			if '==' in str(conclusion) and '<' not in  str(conclusion) and '>' not in str(conclusion) and '!' not in str(conclusion) and 'ite' not in str(conclusion) and 'And(' not in str(conclusion) and 'Or(' not in str(conclusion):
				exp=str(conclusion).split('==')
				invariantstmtdisplay_left=None
				invariantstmtdisplay_right=None
				if '/' in str(exp[0]):
					invariantstmtdisplay_left=exp[0].replace(constant,const_map[x])
					exp[0]=exp[0].replace(constant,variable)
				else:
					invariantstmtdisplay_left=str(simplify(exp[0]).subs(simplify(constant),simplify(const_map[x])))
					exp[0]=simplify(exp[0]).subs(simplify(constant),simplify(variable))
				if '/' in str(exp[1]):
					invariantstmtdisplay_right=exp[1].replace(constant,const_map[x])
					exp[1]=exp[1].replace(constant,variable)
				else:
					invariantstmtdisplay_right=str(simplify(exp[1]).subs(simplify(constant),simplify(const_map[x])))
					exp[1]=simplify(exp[1]).subs(simplify(constant),simplify(variable))
				
			
				invariantstmtdisplay=invariantstmtdisplay_left+"=="+invariantstmtdisplay_right				
				invariantstmt=str(exp[0])+"=="+str(exp[1])
				if '/' in str(exp[0]):
					exp[0]=exp[0].replace(variable,'0')
				else:
					exp[0]=simplify(exp[0]).subs(simplify(variable),0)
					
				if '/' in str(exp[1]):
					exp[1]=exp[1].replace(variable,'0')
				else:
					exp[1]=simplify(exp[1]).subs(simplify(variable),0)
					
				basecasestmt=str(exp[0])+"=="+str(exp[1])
			elif '!=' in str(conclusion) and '<' not in  str(conclusion) and '>' not in str(conclusion) and 'ite' not in str(conclusion) and 'And(' not in str(conclusion) and 'Or(' not in str(conclusion):
				exp=str(conclusion).split('!=')
				invariantstmtdisplay_left=None
				invariantstmtdisplay_right=None
				if '/' in str(exp[0]):
					invariantstmtdisplay_left=exp[0].replace(constant,const_map[x])
					exp[0]=exp[0].replace(constant,variable)
				else:
					invariantstmtdisplay_left=str(simplify(exp[0]).subs(simplify(constant),simplify(const_map[x])))
					exp[0]=simplify(exp[0]).subs(simplify(constant),simplify(variable))
				if '/' in str(exp[1]):
					invariantstmtdisplay_right=exp[1].replace(constant,const_map[x])
					exp[1]=exp[1].replace(constant,variable)
				else:
					invariantstmtdisplay_right=str(simplify(exp[1]).subs(simplify(constant),simplify(const_map[x])))
					exp[1]=simplify(exp[1]).subs(simplify(constant),simplify(variable))
							
				invariantstmtdisplay=invariantstmtdisplay_left+"!="+invariantstmtdisplay_right			
				invariantstmt=str(exp[0])+"!="+str(exp[1])
				if '/' in str(exp[0]):
					exp[0]=exp[0].replace(variable,'0')
				else:
					exp[0]=simplify(exp[0]).subs(simplify(variable),0)
				if '/' in str(exp[1]):
					exp[1]=exp[1].replace(variable,'0')
				else:
					exp[1]=simplify(exp[1]).subs(simplify(variable),0)
								
				basecasestmt=str(exp[0])+"!="+str(exp[1])
			elif 'And(' in str(conclusion) or 'Or(' in str(conclusion):
				sub_list={}
				sub_list[constant]=variable
				invariantstmt=simplify_conclusion(conclusion,sub_list)
				sub_list={}
				sub_list[constant]=const_map[x]	
				invariantstmt=simplify_conclusion(invariantstmt,sub_list)
				invariantstmtdisplay=simplify_conclusion(conclusion,sub_list)
				sub_list={}
				sub_list[variable]='0'
				basecasestmt=simplify_conclusion(conclusion,sub_list)
			
			else:
				
				if '/' in str(conclusion):
					invariantstmt=conclusion.replace(constant,variable)
					invariantstmtdisplay=conclusion.replace(constant,const_map[x])
					basecasestmt=invariantstmt.replace(variable,'0')
				else:
					invariantstmt=simplify(conclusion).subs(simplify(constant),simplify(variable))
					invariantstmtdisplay=simplify(conclusion).subs(simplify(constant),simplify(const_map[x]))
					basecasestmt=simplify(invariantstmt).subs(simplify(variable),0)
					
			print " Try to prove following using induction on "+const_map[x]
			print "ForAll("+const_map[x]+","+str(invariantstmtdisplay)+")"
			print "Base Case"
			if '==' in str(invariantstmt) and '<' not in  str(invariantstmt) and '>' not in str(invariantstmt) and '!' not in str(invariantstmt) and 'ite' not in str(invariantstmt) and 'And(' not in str(invariantstmt) and 'Or(' not in str(invariantstmt):
				exp=str(invariantstmt).split('==')
				if '/' in str(exp[0]):
					exp[0]=exp[0].replace(variable,'0')
				else:
					exp[0]=simplify(exp[0]).subs(simplify(variable),0)
					
				if '/' in str(exp[1]):
					exp[1]=exp[1].replace(variable,'0')
				else:
					exp[1]=simplify(exp[1]).subs(simplify(variable),0)
				basecasestmt=str(exp[0])+"=="+str(exp[1])
			
			elif '!=' in str(invariantstmt) and '<' not in  str(invariantstmt) and '>' not in str(invariantstmt) and 'ite' not in str(invariantstmt) and 'And(' not in str(invariantstmt) and 'Or(' not in str(invariantstmt):
				exp=str(invariantstmt).split('!=')
				if '/' in str(exp[0]):
					exp[0]=exp[0].replace(variable,'0')
				else:
					exp[0]=simplify(exp[0]).subs(simplify(variable),0)
								
				if '/' in str(exp[1]):
					exp[1]=exp[1].replace(variable,'0')
				else:
					exp[1]=simplify(exp[1]).subs(simplify(variable),0)
				basecasestmt=str(exp[0])+"!="+str(exp[1])
			elif 'And(' in str(invariantstmt) or 'Or(' in str(invariantstmt):
				sub_list={}
				sub_list[variable]='0'
				basecasestmt=simplify_conclusion(invariantstmt,sub_list)			
			else:
				if '/' in str(basecasestmt):
					basecasestmt=invariantstmt.replace(variable,'0')
				else:
					basecasestmt=simplify(invariantstmt).subs(simplify(variable),0)
			print basecasestmt
			writeLogFile( "j2llogs.logs" , "\nBase Case \n"+str(basecasestmt)+"\n" )
			status=query2z3(constraint_list,str(basecasestmt),update_vfact,inputmap)
			#status=query2z3(constraint_list,str(basecasestmt),vfact,inputmap)
			writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
			if "Successfully Proved" in status:
				case_list=[]
				case_temp_inductivestep=None
				if len(condition_map)==1:
					for key in condition_map.keys():
						case_list.append(key.replace(loop_var,variable))
						case_list.append('Not('+key.replace(loop_var,variable)+')')
				print "Successfully Proved"
				print "Inductive Step"
				print "Inductive Assumption"
				print invariantstmt
				updated_equation=[]
				updated_vfact=[]
				if '==' in str(invariantstmt) and '<' not in  str(invariantstmt) and '>' not in str(invariantstmt) and '!' not in str(invariantstmt) and 'ite' not in str(invariantstmt) and 'And(' not in str(invariantstmt) and 'Or(' not in str(invariantstmt):
					exp=str(invariantstmt).split('==')
					
					lexp=None
					rexp=None
					if '/' not in str(exp[0]):
						lexp=simplify(exp[0])
					else:
						lexp=exp[0]
					if '/' not in str(exp[1]):
						rexp=simplify(exp[1])
					else:
						rexp=exp[1]
					inductiveassum=str(lexp)+"=="+str(rexp)
					
					
					if '/' not in str(exp[0]):
						lexp=simplify(exp[0]).subs(simplify(variable),simplify(variable+"+1"))
					else:
						lexp=exp[0].replace(variable,variable+"+1")
						
					if '/' not in str(exp[1]):
						rexp=simplify(exp[1]).subs(simplify(variable),simplify(variable+"+1"))
					else:
						rexp=exp[1].replace(variable,variable+"+1")				
					
					ind_def_map=eqset2subs_list_ind(a)
					for i_e in ind_def_map:
                                            lexp=sub_ind_def(str(lexp),sub_ind_def(str(i_e),loop_var,variable),'('+sub_ind_def(str(ind_def_map[i_e]),loop_var,variable)+')')
                                            rexp=sub_ind_def(str(rexp),sub_ind_def(str(i_e),loop_var,variable),'('+sub_ind_def(str(ind_def_map[i_e]),loop_var,variable)+')')
					case_temp_inductivestep=str(lexp)+"=="+str(rexp)
					inductivestep='Implies('+str(inductiveassum)+','+str(lexp)+"=="+str(rexp)+')'
				
				elif '!=' in str(invariantstmt) and '<' not in  str(invariantstmt) and '>' not in str(invariantstmt)  and 'ite' not in str(invariantstmt) and 'And(' not in str(invariantstmt) and 'Or(' not in str(invariantstmt):
					exp=str(invariantstmt).split('==')
					
					lexp=None
					rexp=None
					if '/' not in str(exp[0]):
						lexp=simplify(exp[0])
					else:
						lexp=exp[0]
					if '/' not in str(exp[1]):
						rexp=simplify(exp[1])
					else:
						rexp=exp[1]
					inductiveassum=str(lexp)+"!="+str(rexp)
					
					
					if '/' not in str(exp[0]):
						lexp=simplify(exp[0]).subs(simplify(variable),simplify(variable+"+1"))
					else:
						lexp=exp[0].replace(variable,variable+"+1")
						
					if '/' not in str(exp[1]):
						rexp=simplify(exp[1]).subs(simplify(variable),simplify(variable+"+1"))
					else:
						rexp=exp[1].replace(variable,variable+"+1")				
					
					ind_def_map=eqset2subs_list_ind(a)
					for i_e in ind_def_map:
                                            lexp=sub_ind_def(str(lexp),sub_ind_def(str(i_e),loop_var,variable),'('+sub_ind_def(str(ind_def_map[i_e]),loop_var,variable)+')')
                                            rexp=sub_ind_def(str(rexp),sub_ind_def(str(i_e),loop_var,variable),'('+sub_ind_def(str(ind_def_map[i_e]),loop_var,variable)+')')
					case_temp_inductivestep=str(lexp)+"!="+str(rexp)
					inductivestep='Implies('+str(inductiveassum)+','+str(lexp)+"=="+str(rexp)+')'
				
				elif 'And(' in str(invariantstmt) or 'Or(' in str(invariantstmt):					
					inductiveassum=invariantstmt
					sub_list={}
					for i_e in ind_def_map:
						sub_list[sub_ind_def(str(i_e),loop_var,variable)]='('+sub_ind_def(str(ind_def_map[i_e]),loop_var,variable)+')'
					inductivestep=simplify_conclusion(invariantstmt,sub_list)
				
				else:
					if '/' in str(invariantstmt):
						inductiveassum=simplify_sympy(invariantstmt)
						inductivestep=simplify_sympy(invariantstmt).replace(variable,variable+"+1")
						ind_def_map=eqset2subs_list_ind(a)
						temp_inductivestep=str(inductivestep)
						for i_e in ind_def_map:
							temp_inductivestep=sub_ind_def(temp_inductivestep,sub_ind_def(str(i_e),loop_var,variable),sub_ind_def(str(ind_def_map[i_e]),loop_var,variable))
						case_temp_inductivestep=temp_inductivestep
						inductivestep='Implies('+str(inductiveassum)+','+temp_inductivestep+')'
					else:
						inductiveassum=simplify(invariantstmt)
						inductivestep=simplify(invariantstmt).subs(simplify(variable),simplify(variable+"+1"))
						ind_def_map=eqset2subs_list_ind(a)
						temp_inductivestep=str(inductivestep)
						for i_e in ind_def_map:
							temp_inductivestep=sub_ind_def(temp_inductivestep,sub_ind_def(str(i_e),loop_var,variable),sub_ind_def(str(ind_def_map[i_e]),loop_var,variable))
						case_temp_inductivestep=temp_inductivestep
						inductivestep='Implies('+str(inductiveassum)+','+temp_inductivestep+')'

					
					
				for equation in constraint_list:
					updated_equation.append(equation)
				updated_equation.append(variable+">=0")
				#updated_equation.append(inductiveassum)
				writeLogFile( "j2llogs.logs" ,"\nInductive Step \n"+str(inductivestep)+"\n" )
				status=query2z3(updated_equation,str(inductivestep),update_vfact,inputmap)
				###status=query2z3(updated_equation,str(inductivestep),vfact,inputmap)
				writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
				if "Successfully Proved" in status:
					#print "Successfully Proved"
					return "Successfully Proved"
				elif "Counter Example" in status:
					return status
				else:
					if len(case_list)>0:
						case_status=False
						for case in case_list:

							inductivestep='Implies(And('+str(inductiveassum)+','+case+'),'+case_temp_inductivestep+')'
							status=query2z3(updated_equation,str(inductivestep),update_vfact,inputmap)
							if "Successfully Proved" in status:
								case_status=True
							else:
								case_status=False
								break
						
					
						if case_status==True:
                                                        writeLogFile( "j2llogs.logs" , "\nResult \n"+str(status)+"\n" )
							return "Successfully Proved"
						else:

							return "Failed to Prove"
					else:
						return "Failed to Prove"
			elif "Counter Example" in status:
				return status
			else:
				return "Failed to Prove"
		return "Failed to Prove"



def tactic2_update(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,const_var_map,witnessXml):
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		variable=None
		constant=None
		const_map={}
		var_const_map={}
		count=0
		for cm in const_var_map:
			if const_var_map[cm] in conclusion:
				count=count+1
				const_map[const_var_map[cm]]=cm
				var_const_map[cm]="_k"+str(count)
		constraint_list=[]
		condition_map={}
		frame_axioms=eqset2constraintlist_update(f)
		for x in frame_axioms:
			constraint_list.append(x)
		out_axioms=eqset2constraintlist_update(o)
		
		for x in out_axioms:
			constraint_list.append(x)
		for x in a: 
        		equations=wff2z3_update(x)
        		getAllCondtion(x,condition_map)
        		equations_sp=None	
                	constraint_list.append(equations)
                	if x[0]=='s1':
        			equations_sp=wff2z3SC_update(x)
        			if equations_sp is not None:
        				constraint_list.append(equations_sp)
		for x in constaints:
			constraint_list.append(x)
		for x in pre_condition:
        		constraint_list.append(x)
		
		filter_map={}
		for element in defineDetaillist:
			if element[0] not in filter_map.keys():
		        	filter_map[element[0]]=element[0]
		        	vfact.append(element)
		defineDetaillist=[]
		
		update_vfact=[]
		for [x,k,l] in vfact:
			if x in const_map.values():
				if k==0:
					ul=['constant']
					update_vfact.append([var_const_map[x],k,ul])
					update_vfact.append([x,k,l])
				else:
					update_vfact.append([var_const_map[x],k,l])
					update_vfact.append([x,k,l])
			else:
				update_vfact.append([x,k,l])

		for x in const_map:
			variable=var_const_map[const_map[x]]			
			constant=x
			#print x
			#print variable
	return None








"""

Tactic 3  ----> 1.Directly translate axoimes to z3 constraint 
2.try to Find the value of Big _N and evaluate the post condition using Recursive defination 

"""
def tactic3(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,const_var_map,witnessXml):
	for conclusion in conclusions:
		print conclusion




#Recursive Function to ** to power Function

def transferToFunctionRec(expression):

	term=isFunction(expression)
	
	if term is None:
		return None

	if 'ForAll' in expression and term=='ForAll':
		arg_list=extract_args(expression)
		result=transferToFunctionRec(arg_list[1])
		if result is not None:
			return 'ForAll('+arg_list[0]+','+result+')'
		else:
			return None
	elif 'Or' in expression and term=='Or':
		arg_list=extract_args(expression)
		result1=transferToFunctionRec(arg_list[0])
		result2=transferToFunctionRec(arg_list[1])
		if result1 is not None and result2 is not None:
			return 'Or('+result1+','+result2+')'
		else:
			return None
	elif 'And' in expression and term=='And':
		arg_list=extract_args(expression)

		result1=transferToFunctionRec(arg_list[0])
		result2=transferToFunctionRec(arg_list[1])
		if result1 is not None and result2 is not None:
			return 'And('+result1+','+result2+')'
		else:
			return None
	elif 'Implies' in expression and term=='Implies':
		arg_list=extract_args(expression)
		result1=transferToFunctionRec(arg_list[0])
		result2=transferToFunctionRec(arg_list[1])
		if result1 is not None and result2 is not None:
			return 'Implies('+result1+','+result2+')'
		else:
			return None
	elif 'Exists' in expression and term=='Exists':
		arg_list=extract_args(expression)
		result=transferToFunctionRec(arg_list[1])
		if result is not None:
			return 'Exists('+arg_list[0]+','+result+')'
		else:
			return None
	elif 'Not' in expression and term=='Not':
		arg_list=extract_args(expression)
		result=transferToFunctionRec(arg_list[0])
		if result is not None:
			return 'Not('+transferToFunctionRec(arg_list[0])+')'
		else:
			return None
	else:
		return translatepowerToFun(expression)
		
		
#Stack Implementaion 

class Stack:
     def __init__(self):
         self.items = []

     def isEmpty(self):
         return self.items == []

     def push(self, item):
         self.items.append(item)

     def pop(self):
         return self.items.pop()

     def peek(self):
         return self.items[len(self.items)-1]

     def size(self):
         return len(self.items)


def translatepowerToFunCheck(expression):
    if "**" in expression:
    	expression=transferToFunctionSyntax(str(expression))
    	xform = expr.transformString(expression)[1:-1]
    	xform=xform.replace('[','(')
    	expression=xform.replace(']',')')
   	#print expression
    return expression

#expression="(A+B+((Z**(K)-1)/(Z-1))*(Z-1))"
expression="((Z**(K)-1)/(Z-1))*(Z-1)"
expression="(Z/2)*6<=Z"
expression="r6(_n2)>=(((2**-(_n2))*((2**_N1)*B))/2)"
#expressionChecking(expression)
def expressionChecking(expression):
	if '(((((((' not in str(expression):
		if "**" in str(expression):
			expression=translatepowerToFunCheck(str(expression))
		#p = getParser()
                parser = c_parser.CParser()
		#tree = p.parse_expression(expression)
                ast = parser.parse("void test(){"+str(expression)+";}")
		statement_temp=ast.ext[0].body.block_items[0]
		#expr_wff=eval(expressionCreator(tree)) 
                expr_wff = eval(expressionCreator_C(statement_temp))
		flag=False
		return expr2simplified(expr_wff,flag)
	else:
		return str(expression),False



#wff to Simplified Expression
def expr2simplified(e,flag):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op,flag
    else:
	if op in _infix_op and len(args)==2:
	    expr1,flag=expr2simplified(args[0],flag)
	    if flag==True:
	    	expr2,flag=expr2simplified(args[1],flag)
	    	flag=True
	    else:
	    	expr2,flag=expr2simplified(args[1],flag)
	    if op=='*' and expr_op(args[0])=='/':
	    	n,d=fraction(expr1)
	    	if gcd(d,expr2)!=1:
	    		flag=True
	    elif op=='/' and expr_op(args[0])=='*':
	    	n,d=fraction(expr2)
	    	if gcd(expr1,d)!=1:
	    		flag=True
            if flag==True:
            	expression= '(' + expr1+ op + expr2 +')' 
            else:
            	expression= '((' + str(pow_to_mul(powsimp(expr1)))+ ')'+ op + '('+ str(pow_to_mul(powsimp(expr2)))+'))' 
            return expression,flag
        else:
            return op +'('+ ','.join(list(trim_p(expr2string1(x)) for x in args))+ ')',flag
        	

#Is Function and Return the name

#expression="(A+B+((Z**(K)-1)/(Z-1))*(Z-1))"
#expression="((((Z**(K)-1)/(Z-1))*(Z-1)))"

#expression="ForAll(Y+1,Exits(X==Y))"

#expression="(X<(Y+y))"
#expression="Rest(Z,Exists(K,((((Z**(K)-1)/(Z-1))*(Z-1)))))"
#expression="m1==((((Z**(K)-1)/(Z-1))*(Z-1)))"

def isFunction(expression):
	function=['ForAll','Or','And','Exists','Implies','Not']

	operators=['==','<=','>=','>','<','!=']
	if 'ForAll' in expression or 'Or' in expression or 'And' in expression or 'Exists' in  expression or 'Implies' in expression or 'Not' in expression:
		arg_list=extract_args(expression)
		arglist=""
		for arg in arg_list:
			if arglist=="":
				arglist='('+arg
			else:
				arglist+=','+arg
		arglist+=")"
		
		
		tem_expression=expression.replace(arglist,'')
		tem_expression=tem_expression.strip()
		
		if tem_expression in function:
			return tem_expression
		else:
			return None
	else:
		arg_list=extract_args(expression)
		arglist=""
		for arg in arg_list:
			if arglist=="":
				arglist='('+arg
			else:
				arglist+=','+arg
		arglist+=")"
		tem_expression=expression.replace(arglist,'')
		tem_expression=tem_expression.strip()
		if tem_expression=='':
			return expression
		else:
			status=False
			for operator in operators:
				if operator in tem_expression:
					status=True
			if status==True:
				return expression
			else:
				return None


#C parsing Function


"""

#C Function Class
#Plain Python object to store Information about Function
"""
class cFunctionclass(object):
 	def __init__(self, functionname, returnType , inputvar, localvar):
        	self.functionname = functionname
        	self.inputvar = inputvar
        	self.returnType = returnType
        	self.localvar = localvar
        def getFunctionname(self):
        	return self.methodname
        def getreturnType(self):
        	return self.returnType
        def getInputvar(self):
        	return self.inputvar
        def getLocalvar(self):
        	return self.localvar



def programTransformation(function_body,functionMap,medthodname):

    generator = c_generator.CGenerator()   
   
    global break_count
    global continue_count
    global new_variable
    global dummyCount
    global count__VERIFIER_nondet
    
    new_variable={}
        
    #Handling Pointer
    
    #print '#######'
    #print(generator.visit(function_body))
    #print '#######'
    
    
    #statements= handlingPointer(function_body.block_items)
    
    #function_body.show()
    
    statements=function_body.block_items
        
    #Syntax translation of the function body
    
#print '#######1'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######1'
        
    statements=syntaxTranslate(statements)

    #print '#######1'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######1'

    statements=arrangeEmptyStatement(statements)
    #print '#######11'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######11'
   
    #Convert Initiation to assignments   
    
    statements=construct_program(statements)
    
    
    #print '#######2'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######2'

    #print(generator.visit(c_ast.Compound(block_items=statements)))
    
    #Reconstruct Program by Removing assert,assume,error
    
    statements=reconstructPreDefinedFun(statements)
    
    pa_update_statements=copy.deepcopy(statements)
    
    pa_update_statements=removeEmptyIfLoop(pa_update_statements)
    
    pa_update_statements=change_var_name(pa_update_statements)
    
    #print '#######2'
    #print(generator.visit(c_ast.Compound(block_items=pa_update_statements)))
    #print '#######2' 
    
    
    #pa_update_statements = organizeDeclaration(pa_update_statements)
    
    #pa_update_statements = getVariablesInit(pa_update_statements)
    
    
    
    
    
    #print '#######3'
    #print(generator.visit(c_ast.Compound(block_items=pa_update_statements)))
    #print '#######3'
    
    #print '#######3'
    #print(generator.visit(c_ast.Compound(block_items=pa_update_statements)))
    #print '#######3'
        
    #Replace return by goto statement
        
    statements=remove_return(statements,functionMap[medthodname])
    
    #print '#######4'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######4'
    
        
    #Replace goto structured statement
        
    statements=gotoremoval(statements)
    
    #print '#######5'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######5'
        
    update_statements=[]
        
    #Add new variable
        
    for var in new_variable.keys():
    	if isBoolVariable( var )==True:
    	    	#temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
                temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
    		update_statements.append(temp)
    	else:
    		temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
    		update_statements.append(temp)
        	
    for statement in statements:
    	update_statements.append(statement)
        	
    #print '#######5'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######5' 
      
      
    #Remove Empty If Loops  
    
    update_statements=removeEmptyIfLoop(update_statements)
        
    #Remove Dead Code
    
    #print '#######6'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######6'
    
    
    update_statements=removeDeadCode(update_statements)
    
    
    #print '#######7'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######7'
        
    #Simplify Conditions
        
    statements=simplifyProgram(update_statements)
    
    
    #print '#######8'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######8'
    
    #Add Break Removal Modules
    
    
    break_map={}
    break_count=0
    continue_count=0
    
    statements=getBreakStmt(statements,break_map)
    
    #print '#######9'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######9'
    
    
    statements=changeConditionProgram(statements)
    
    
    #print '#######10'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######10'
    
        
    update_statements=[]
    
    for var in new_variable.keys():
    	if isBoolVariable( var )==True:
    	    	#temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
                temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
       		update_statements.append(temp)
    	else:
    		temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
       		update_statements.append(temp)
        	
    for statement in statements:
    	update_statements.append(statement)
    
    dummyCount=0
    
    #print '#######10'
    #print(generator.visit(c_ast.Compound(block_items=update_statements)))
    #print '#######10'
    
    
    statements=functionToAssignment(update_statements,functionMap)
    
    
    
    
    #print '#######11'
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print '#######11'
       
    update_statements=[]
    
    if dummyCount>0:
    	for x in range(0, dummyCount):
    		temp=c_ast.Decl(name='_'+str(x+1)+'DUMMY', quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname='_'+str(x+1)+'DUMMY', quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
       		update_statements.append(temp)
    for statement in statements:
    	update_statements.append(statement)
        
    #count__VERIFIER_nondet=0
    
    #print 'xxxxx1'
    
    update_statements=getVariablesInit(update_statements)
    
    #print 'xxxxx2'
    
    update_statements=change_var_name(update_statements)
    
    #print 'xxxxx3'

    return update_statements,pa_update_statements





def organizeMallocFunctionBlock(statements):
    global external_pointer_map
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            if type(statement.lvalue) is c_ast.ArrayRef:
                if type(statement.lvalue.name) is c_ast.ID:
                    if statement.lvalue.name.name in external_pointer_map and type(statement.lvalue.subscript) is c_ast.ID and type(statement.rvalue) is c_ast.FuncCall and statement.rvalue.name.name=='malloc':
                        index_value=statement.lvalue.subscript
                        if len(statement.rvalue.args.exprs)==1:
                            statement.rvalue.args.exprs[0]=index_value
                            statement.rvalue.name.name='_malloc'
                            update_statements.append(statement)
                        else:
                            update_statements.append(statement)
                    else:
                        update_statements.append(statement)
                else:
                    update_statements.append(statement)
            else:                
                update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(organizeMallocFunctionIf(statement))
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=organizeMallocFunctionBlock(statement.stmt.block_items))))
        else:
            update_statements.append(statement)  
    return update_statements



def organizeMallocFunctionIf(statement):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=organizeMallocFunctionBlock(statement.iftrue.block_items)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=organizeMallocFunctionBlock(statement.iffalse.block_items)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=organizeMallocFunctionIf(statement.iffalse)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)







def isFunctionInExpression(statement):
    if type(statement) is c_ast.FuncCall:
        return True
    elif type(statement) is c_ast.BinaryOp:
        if isFunctionInExpression(statement.left) == True:
            return True
        elif isFunctionInExpression(statement.right) == True:
            return True
        else:
            return False
    return False






def organizeDeclaration(update_statements):
    statements=[]
    del_statements=[]
    other_statements=[]
    array_del_statements=[]
    other_del_statements=[]
    duplicate_map={}
    
    for statement in update_statements:
        if type(statement) is c_ast.Decl:
            if isFunctionInExpression(statement.init)==False:
                if type(statement.type) is not c_ast.ArrayDecl:
                    if statement.name not in duplicate_map.keys():
                        duplicate_map[statement.name]=statement.name
                        del_statements.append(statement)
                    else:
                        if statement.init is not None:
                            other_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=statement.name), rvalue=statement.init))
                else:
                    
                    del_statements.append(statement)
            else:
                if statement.name=='MAX' and type(statement.init) is c_ast.FuncCall and statement.init.name.name=='__VERIFIER_nondet_uint':
                    other_del_statements.append(statement)
                else:
                    other_statements.append(statement)
        else:
            other_statements.append(statement)
    for statement in del_statements:
        if type(statement.type) is c_ast.ArrayDecl:
            array_del_statements.append(statement)
        else:
            other_del_statements.append(statement)
    for statement in other_del_statements:
        statements.append(statement)
    for statement in array_del_statements:
        statements.append(statement)
    for statement in other_statements:
        statements.append(statement)
    return statements
    

def organizeInnerDeclartionMain(statements):
    update_statements=[]
    update_statements1=[]
    dec_statements=[]
    for statement in statements:
        if type(statement) is c_ast.If:
            update_statements.append(organizeInnerDeclartionIf(statement,dec_statements))
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=organizeInnerDeclartion(statement.stmt.block_items,dec_statements))))
        else:
            update_statements.append(statement)
    for statement in dec_statements:
        update_statements1.append(statement)
    for statement in update_statements:
        update_statements1.append(statement)
    return update_statements1
 
    
def organizeInnerDeclartion(statements,dec_statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            dec_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(organizeInnerDeclartionIf(statement,dec_statements))
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=organizeInnerDeclartion(statement.stmt.block_items,dec_statements))))
        else:
            update_statements.append(statement)  
    return update_statements
            
            
def organizeInnerDeclartionIf(statement,dec_statements):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=organizeInnerDeclartion(statement.iftrue.block_items,dec_statements)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=organizeInnerDeclartion(statement.iffalse.block_items,dec_statements)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=organizeInnerDeclartionIf(statement.iffalse,dec_statements)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)



def blockConstructExtract(statements,list,seq_list):
    #print statements
    for statement in statements:
        if type(statement) is c_ast.UnaryOp:
            line_no,list = findInList(statement,list,seq_list)
            if line_no is not None:
                seq=[]
                seq.append(line_no)
                seq.append(programPrint(syntaxTranslateStmt(statement)))
                seq_list.append(seq)
        elif type(statement) is c_ast.For:
            if type(statement.init) is c_ast.DeclList:
                for stmt in statement.init.decls:
                    line_no,list = findInList(stmt,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(stmt))
                        seq_list.append(seq)
            else:
                line_no,list = findInList(statement.init,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(statement.init))
                    seq_list.append(seq)
            if type(statement.stmt) is c_ast.Compound:
                new_block_items=statement.stmt.block_items
                if new_block_items is None:
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(statement.cond))
                        seq_list.append(seq)
                    new_block_items=[]
                    new_block_items.append(statement.next)
                    blockConstructExtract(new_block_items,list,seq_list)
                else:
                    line_no,list = findInList(statement.cond,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                        seq_list.append(seq)
                    new_block_items=[]
                    new_block_items.append(statement.stmt)
                    new_block_items.append(statement.next)
                    blockConstructExtract(new_block_items,list,seq_list)
            else:
                
                if type(statement.stmt) is not c_ast.EmptyStatement:
                    line_no,list = findInList(statement.cond,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                        seq_list.append(seq)
                    new_block_items=[]
                    new_block_items.append(statement.stmt)
                    new_block_items.append(statement.next)
                    blockConstructExtract(new_block_items,list,seq_list)
        
        elif type(statement) is c_ast.If:

            blockConstructExtractIf(statement,list,seq_list)
        
        elif type(statement) is c_ast.DoWhile:
            if type(statement.stmt) is c_ast.Compound:
                new_block_items=statement.stmt.block_items
                if new_block_items is None:
                    new_block_items=[]
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                    seq_list.append(seq)
                blockConstructExtract(new_block_items,list,seq_list)
    
            else:
                new_block_items=[]
                new_block_items.append(statement.stmt)
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(statement.cond))
                    seq_list.append(seq)
                blockConstructExtract(new_block_items,list,seq_list)
        elif type(statement) is c_ast.While:
            if type(statement.stmt) is c_ast.Compound:
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                    seq_list.append(seq)
                blockConstructExtract(statement.stmt.block_items,list,seq_list)
            else:
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                    seq_list.append(seq)
                new_block_items=[]
                new_block_items.append(statement.stmt)
                blockConstructExtract(new_block_items,list,seq_list)
        elif type(statement) is c_ast.Assignment:
            if statement.op=='+=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='+', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))) 
                        seq_list.append(seq)            
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='+', left=statement.lvalue, right=statement.rvalue))))
                        seq_list.append(seq)
            elif statement.op=='-=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='-', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue))))
                        seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='-', left=statement.lvalue.name, right=statement.rvalue))))
                        seq_list.append(seq)
            elif statement.op=='/=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='/', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue))))
                        seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='/', left=statement.lvalue, right=statement.rvalue))))
                        seq_list.append(seq)
            elif statement.op=='%=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='%', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue))))
                        seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='%', left=statement.lvalue, right=statement.rvalue))))
                        seq_list.append(seq)
            elif statement.op=='*=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='*', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue))))
                        seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='*', left=statement.lvalue, right=statement.rvalue))))
                        seq_list.append(seq)
                	
            else:
                if type(statement.rvalue) is c_ast.Assignment:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        stmts=[]
                        separateAllAssignment(statement,stmts)
                        for stmt in stmts:
                            seq=[]
                            seq.append(line_no)
                            seq.append(programPrint(syntaxTranslateStmt(stmt)))
                            seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op=statement.op, lvalue=statement.lvalue, rvalue=statement.rvalue)))
                        seq_list.append(seq)
                
        elif type(statement) is c_ast.ExprList:
                blockConstructExtract(statement.exprs,list,seq_list)
        elif type(statement) is c_ast.Label:
            if type(statement.stmt) is c_ast.Compound:
                blockConstructExtract(statement.block_items,list,seq_list)
            else:
                if statement.stmt is not None:
                    line_no,list = findInList(statement.stmt,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(syntaxTranslateStmt(statement.stmt)))
                        seq_list.append(seq)
        elif type(statement) is c_ast.Compound:
            blockConstructExtract(statement.block_items,list,seq_list)
        else:
            line_no,list = findInList(statement,list,seq_list)
            if line_no is not None:
                seq=[]
                seq.append(line_no)
                seq.append(programPrint(syntaxTranslateStmt(statement)))
                seq_list.append(seq)
                




def blockConstructExtractIf(statement,list,seq_list):
	if type(statement) is c_ast.If:
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                    seq_list.append(seq)
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
                                blockConstructExtract(statement.iftrue.block_items,list,seq_list)
		else:
			if type(statement.iftrue) is c_ast.UnaryOp:
                                line_no,list = findInList(statement.iftrue,list,seq_list)
                                if line_no is not None:
                                    seq=[]
                                    seq.append(line_no)
                                    seq.append(programPrint(syntaxTranslateStmt(syntaxTranslateStmt(statement.iftrue))))
                                    seq_list.append(seq)
			elif type(statement.iftrue) is c_ast.BinaryOp:
                                line_no,list = findInList(statement.iftrue,list,seq_list)
                                if line_no is not None:
                                    seq=[]
                                    seq.append(line_no)
                                    seq.append(programPrint(syntaxTranslateStmt(syntaxTranslateStmt(statement.iftrue))))
                                    seq_list.append(seq)
			else:
				new_blocks=[]
				new_blocks.append(statement.iftrue)
                                blockConstructExtract(new_blocks,list,seq_list)
				
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				blockConstructExtract(statement.iffalse.block_items,list,seq_list)
		else:
			if type(statement.iffalse) is c_ast.If:
                                blockConstructExtractIf(statement.iffalse,list,seq_list)
			else:
				if type(statement.iffalse) is c_ast.UnaryOp:
                                        line_no,list = findInList(statement.iffalse,list,seq_list)
                                        if line_no is not None:
                                            seq=[]
                                            seq.append(line_no)
                                            seq.append(programPrint(syntaxTranslateStmt(statement.iffalse)))
                                            seq_list.append(seq)
				elif type(statement.iffalse) is c_ast.BinaryOp:
                                        line_no,list = findInList(statement.iffalse,list,seq_list)
                                        if line_no is not None:
                                            seq=[]
                                            seq.append(line_no)
                                            seq.append(programPrint(syntaxTranslateStmt(statement.iffalse)))
                                            seq_list.append(seq)
				else:
					new_blocks=[]
					new_blocks.append(statement.iffalse)
					new_iffalse=c_ast.Compound(block_items=syntaxTranslate(new_blocks))
	


def findInList(x,list,seq_list):
    z=None
    line_no=None
    for y in list:
        if getSpaceRemoveStr(programPrint(x)) in getSpaceRemoveStr(y[1]) and 'extern void __VERIFIER_error()' not in y[1] :
            z=y
            break;
    if z is not None:
        z[1]=getSpaceRemoveStr(z[1]).replace(getSpaceRemoveStr(programPrint(x)),'',1)
        line_no = z[0]
    return line_no,list


def findInList1(x,list,seq_list):
    z=None
    line_no=None
    for y in list:
        if getSpaceRemoveStr(x) in getSpaceRemoveStr(y[1]):
            z=y
            break;
    if z is not None:
        z[1]=getSpaceRemoveStr(z[1]).replace(getSpaceRemoveStr(x),'',1)
        line_no = z[0]
    return line_no,list
    
            


			    


def constructLineStmtmap(original_program,program):
    lines_map={}
    lines_list=[]
    count=0
    parser = GnuCParser()
    ast = parser.parse(program)
    lines_stmt=original_program.split('\n')
    for x in lines_stmt:
        count=count+1
        each_line=[]
        each_line.append(count)
        each_line.append(x)
        lines_list.append(each_line)
    for e in ast.ext:
        if type(e) is c_ast.Decl:
            if type(e.type) is c_ast.TypeDecl:
                line_no,lines_list=findInList(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=e.type.declname), rvalue=e.init),lines_list,'_GLOBAL')
                if line_no is not None:
                   lines_map[programPrint(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=e.type.declname), rvalue=e.init))]=int(line_no)
            elif type(e.type) is c_ast.ArrayDecl:
                line_no,lines_list=findInList(e,lines_list,'_GLOBAL')
                if line_no is not None:
                   lines_map[programPrint(e)]=int(line_no)
            else:
                line_no,lines_list=findInList(e,lines_list,'_GLOBAL')
                if line_no is not None:
                    lines_map[programPrint(e)]=int(line_no)
        else:
            if type(e) is c_ast.FuncDef:
                function_body = e.body
                seq_list=[]
                if function_body.block_items is not None:
                     blockConstructExtract(function_body.block_items,lines_list,seq_list)
                     lines_map[e.decl.name]= seq_list

    line_no,lines_list = findInList1('__VERIFIER_error();',lines_list,seq_list)
    if line_no is not None:
        lines_map['__VERIFIER_error();']=int(line_no)

    line_no,lines_list = findInList1('if (!(cond)) {',lines_list,seq_list)
    if line_no is not None:
        lines_map['if (!(cond)) {']=int(line_no)
    return lines_map


def getLineErrorAssert(file_name):
    fd = open(file_name)
    count=1
    for x in fd.readlines():
        if '__VERIFIER_error();' in x:
            return count
        count=count+1
    return None





def getVersion():
    return "1.1.12(Date 27/11/2018)"



def prove_auto(file_name,property=None):
        
	if not(os.path.exists(file_name)): 
        	print "File not exits"
		return
        if os.path.exists(currentdirectory+'/errorWitness.graphml'):
            os.remove(currentdirectory+'/errorWitness.graphml')
        if os.path.exists(currentdirectory+'/correctnessWitness.graphml'):
            os.remove(currentdirectory+'/correctnessWitness.graphml')
            
            
	start_time=current_milli_time()
	content=None
        witness_path=None
        global line_error_assert
	global new_variable
	global fail_count
	global error_count
	global assume_count
        global assert_count
        global defineMap
        global defineDetaillist
        global map___VERIFIER_nondet
        global new_variable_array
        global counter_variableMap
        global counter_variableMap_Conf
        global sub_vfact
        global external_var_map
        global external_pointer_map
        global fun_call_map
        global current_fun_call
        global fun_substitution_map
        global line_no_stmt_map
        global count_ast_line_no
        global main_count_ast_line_no
        global main_line_no_stmt_ast_map
        
        line_error_assert=None
        getLineErrorAssert(file_name)
        struct_map={}
        fail_count=0
        error_count=0
        assume_count=0
        assert_count=0
        count_ast_line_no=0
        main_count_ast_line_no=0
        map___VERIFIER_nondet={}
        new_variable_array={}
        counter_variableMap={}
        counter_variableMap_Conf={}
        fun_call_map={}
        fun_substitution_map={}
        line_no_stmt_map={}
        function_vfacts=[]
        program_analysis=''
        program_analysis2=''
        program_analysis3=''
        program_analysis_decl=''
        program_analysis_var_decl=''
        current_fun_call=None
        struct_list=None
        type_struct_list=None
        line_no_stmt_map=None
        original_program=None
        new_program=None
        flag_terminate=False
        main_line_no_stmt_ast_map={}
        
	try:
		fd = open(file_name)
		text = "".join(fd.readlines())
                original_program=text
                
                line_error_assert = getLineErrorAssert(file_name)
                
                defineMap={}
                content,defineMap=preProcessorHandling(text)
		text=replaceAddOperator(text)
    		filtered_program = SyntaxFilter.SLexer(text)
		filtered_program.build()
                
		content,struct_list,type_struct_list=filtered_program.filterSyntax()
                #print '--------------'
                #print content
                #print '--------------'
                #print struct_list
                #print '--------------'
                #print type_struct_list
                #print '--------------'
	except SyntaxFilter.SLexerError as e:
                print 'Error(Find Error in Input File)'
		#print(e)
		return
	text = r""" """+content
	parser = GnuCParser()
	#ast = parse_file(file_name, use_cpp=True)
        try:
            
            #print '##############'
            #print struct_list
            #print text
            #print '##############'
            try:
                new_program = text
                line_no_stmt_map = constructLineStmtmap(original_program,text)
            except Exception as e:
                line_no_stmt_map=None
            
            ast = parser.parse(text)
            for struct_str in struct_list:
                
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    struct_name=ast_struct.ext[0].type.name
                
                    isPointer=False
                
                    isTypedef=False
                
                    defName=None
                
                    variable_map=getVariablesC(ast_struct.ext[0].type.decls)
                
                    structobject = structclass(struct_name, isTypedef,  variable_map , defName, isPointer)
                
                    struct_map[struct_name]=structobject
                
            for struct_str in type_struct_list:
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    isPointer=False
                
                    isTypedef=False
                
                    struct_name = ast_struct.ext[0].name
                
                    if type(ast_struct.ext[0]) is c_ast.Typedef:
                        isTypedef=True
                    
                    if type(ast_struct.ext[0].type) is c_ast.PtrDecl:
                        isPointer=True
                    if isPointer==True:
                        struct_name = ast_struct.ext[0].type.type.type.name
                        defName = ast_struct.ext[0].type.type.declname
                        if struct_name is None and defName is not None:
                            struct_name=defName
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                    else:
                        struct_name = ast_struct.ext[0].type.declname
                        defName = ast_struct.ext[0].type.type.name
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                
        except Exception as e:
            #print 'Error(Find Error in Input File)'
            print 'Unknown'
            writeLogFile( "j2llogs.logs" ,str(e))
            return
        #ast.show()
	generator = c_generator.CGenerator()
	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Translate \n"+"\nParameters--\n File Name--"+file_name+"\n")
	if ast is None:
		print "Error present in code. Please verify you input file"
	       	return
	if len(ast.ext)==0:
		print "Error present in code. Please verify you input file"
	        return
    	externalvarmap={}
        externalarraymap={}
	functionvarmap={}
	memberfunctionmap={}
	axiomeMap={}
	addition_array_map={}
	function_vfact_map={}
	witnessXml_map={}
	
    	counter=0 
        
        try:
            for e in ast.ext:
                    if type(e) is c_ast.Decl:
                            if type(e.type) is c_ast.FuncDecl:
                                    parametermap={}
                                    structType=None
                                    new_e,pointer_list,array_list=pointerHandlingParameter(e)
                                    if new_e is None:
                                            function_decl=e
                                    else:
                                            function_decl=new_e
                                    if function_decl.type.args is not None:
                                            for param_decl in function_decl.type.args.params:
                                                    if param_decl.name is not None:
                                                            structType=None
                                                            if type(param_decl.type) is c_ast.ArrayDecl:
                                                                    degree=0
                                                                    dimensionmap={}
                                                                    data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                    variable=variableclass(param_decl.name, data_type,None,dimensionmap,None,structType)
                                                            else:
                                                                    try:
                                                                        #variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                        variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                    except Exception as e:
                                                                        #print 'Error(Translation to Intermate Intermediate)'
                                                                        print 'Unknown'
                                                                        writeLogFile( "j2llogs.logs" ,str(e))
                                                                        #print str(e)
                                                                        return
                                                            parametermap[param_decl.name]=variable

                                    membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,None,None,0,0,None,None,None)
                                    functionvarmap[membermethod.getMethodname()]=membermethod

                            elif type(e.type) is c_ast.TypeDecl:
                                    
                                    var_type=None
                                    initial_value=None
                                    structType=None
                                    e=change_var_name_decl(e)
                                    for child in e.children():
                                            if type(child[1].type) is c_ast.IdentifierType:
                                                    var_type=child[1].type.names[0]
                                            else:
                    				
                                                    initial_value=child[1].value
                                    #variable=variableclass(e.name, var_type,None,None,initial_value,structType)
                                    variable=variableclass(e.name, var_type,None,None,initial_value,structType)
                                    program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
                                    externalvarmap[e.name]=variable
                                    external_var_map[e.name]=e.name
                            elif type(e.type) is c_ast.ArrayDecl:
                                program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
                                
                                if type(e.type.type) is c_ast.PtrDecl:
                                    array_name=getArrayNameDecl(e.type.type.type)
                                    externalarraymap[array_name]=change_var_name_decl(e)
                                    external_var_map[array_name]=e.name
                                    external_pointer_map[array_name]=array_name
                                else:
                                    array_name=getArrayNameDecl(e.type)
                                    externalarraymap[array_name]=change_var_name_decl(e)
                                    external_var_map[array_name]=e.name
                    else:
                            if type(e) is c_ast.FuncDef:                          
                                    parametermap={}
                                    new_e,pointer_list,array_list=pointerHandlingParameter(e)
                                    if new_e is None:
                                            function_decl=e
                                    else:
                                            function_decl=new_e
    				
                                    function_decl=e.decl
                                
                                
                                    function_body = e.body
                                
                                    if function_body.block_items is not None:
                                        #function_body=pointerHandlingDecl(function_body,pointer_list,array_list)
                                        statements=function_body.block_items
                                        statements=change_var_name(statements)
                                        function_body= c_ast.Compound(block_items=statements)
                                        localvarmap=getVariables(function_body)
                                        counter=counter+1
                                        if function_decl.type.args is not None:
                                                for param_decl in function_decl.type.args.params:
                                                        new_param_decl=declarationModifying(param_decl)
                                                        if new_param_decl is not None:
                                                            param_decl=new_param_decl
                                                        param_decl=change_var_name_decl(param_decl)
                                                        if param_decl.name is not None:
                                                                structType=None
                                                                if type(param_decl.type) is c_ast.ArrayDecl:
                                                                        #print param_decl.show()
                                                                        degree=0
                                                                        dimensionmap={}
                                                                        data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                        variable=variableclass(param_decl.name, data_type,None,dimensionmap,None,structType)
                                                                elif type(param_decl.type) is c_ast.PtrDecl:
                                                                        stmt=pointerToArray(param_decl)
                                                                        #print stmt.show()
                                                                        if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
                                                                                degree=0
                                                                                dimensionmap={}
                                                                                data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                                variable=variableclass(stmt.name, data_type,None,dimensionmap,None,structType)
                                                                else:				
                                                                        try:
                                                                            variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                        except Exception as e:
                                                                            print 'Error(Translation to Intermate Intermediate)'
                                                                            writeLogFile( "j2llogs.logs" ,str(e))
                                                                            #print str(e)
                                                                            return
                                                                parametermap[param_decl.name]=variable
                                    if function_decl.name in functionvarmap.keys():
                                            if function_decl.name!='__VERIFIER_assert':
                                                membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,None,function_decl)
                                                functionvarmap[function_decl.name]=membermethod
                                    else:
                                            if function_decl.type.args is not None:
                                                    for param_decl in function_decl.type.args.params:
                                                            new_param_decl=declarationModifying(param_decl)
                                                            if new_param_decl is not None:
                                                                param_decl=new_param_decl
                                                                param_decl=change_var_name_decl(param_decl)
                                                            if param_decl.name is not None:
                                                                    structType=None
                                                                    if type(param_decl.type) is c_ast.ArrayDecl:
                                                                            degree=0
                                                                            dimensionmap={}
                                                                            data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                            variable=variableclass(param_decl.name, data_type,None,dimensionmap,None,structType)
                                                                    elif type(param_decl.type) is c_ast.PtrDecl:
                                                                            stmt=pointerToArray(param_decl)
                                                                            if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
                                                                                    degree=0
                                                                                    dimensionmap={}
                                                                                    data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap={})
                                                                                    variable=variableclass(stmt.name, data_type,None,dimensionmap,None,structType)
								
                                                                    else:	
                                                                            try:
                                                                                variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                            except Exception as e:
                                                                                print 'Error(Translation to Intermate Intermediate)'
                                                                                writeLogFile( "j2llogs.logs" ,str(e))
                                                                                #print str(e)
                                                                                return
                                                                    parametermap[param_decl.name]=variable
                                            if function_decl.name!='__VERIFIER_assert' and function_decl.name!='exit':
                                                membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,copy.deepcopy(function_body),function_decl)
                                                functionvarmap[membermethod.getMethodname()]=membermethod
        except Exception as e:
            print 'Unknown1'
            writeLogFile( "j2llogs.logs" ,str(e))
            print str(e)
            return
        
    	for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
    		body=membermethod.getBody()
    		if body is not None:
                    if body.block_items is not None: 
                        
                        try:
                            
                            

                            statements,pa_statements=programTransformation(body,functionvarmap,medthod)
                            
                            
                        
                            statements = updatePointerStruct(statements,struct_map)
                            
                        
                        
                            pa_statements = updatePointerStruct(pa_statements,struct_map)
                            
                            
                            statements = organizeMallocFunctionBlock(statements)
                            
                            
                            #pa_statements = organizeInnerDeclartionMain(pa_statements)
                            
                        
                        except Exception as e:
                            #print 'Error(Translation to Intermate Intermediate)'
                            print 'Unknown1'
                            writeLogFile( "j2llogs.logs" ,str(e))
                            print str(e)
                            return
                        
                        for temp_method in externalarraymap.keys():
                            if isVarPresnt(statements,temp_method)==True:
                                new_statements=[]
                                new_statements.append(externalarraymap[temp_method])
                                statements=construct_program(new_statements+statements)
                        body_comp = c_ast.Compound(block_items=statements)
                        localvarmap=getVariables(body_comp)
                        statements,localvarmap=addAllExtVariables(statements,externalvarmap,localvarmap)
                        statements = translateStruct(statements,localvarmap,struct_map)
                        
                        
                        
                        duplicate_dec_map={}
                        generator = c_generator.CGenerator()
                        update_pa_statements=[]
                        for s in pa_statements:
                            if type(s) is c_ast.Decl:
                                key = generator.visit(s)
                                if key not in duplicate_dec_map:
                                    duplicate_dec_map[key]=key
                                    update_pa_statements.append(s)
                                else:
                                    if s.init is not None:
                                        update_pa_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=s.name),rvalue=s.init))
                            else:
                                update_pa_statements.append(s)

                        pa_statements=update_pa_statements
                        
                        line_count_ast_Block(pa_statements)
                        #statements=pointerHandling(statements,pointer_list,array_list)
                        
                        #print pa_statements
                        
                        pa_statements = updateDeclartionFromWhile(pa_statements)
                        
                        #print pa_statements
                        
                        if medthod=='main':
                            
                            pa_statements = updateAddInitArray(pa_statements)
                            
                            #print pa_statements
                        
                        #print '$$$$$$$$$$$$$$$$$$$$$$$$$$$'
                        #generator = c_generator.CGenerator()
                        #print(generator.visit(c_ast.Compound(block_items=pa_statements)))
                        #print '$$$$$$$$$$$$$$$$$$$$$$$$$$$'

                        
                        body_comp = c_ast.Compound(block_items=statements)
                        membermethod.setBody(body_comp)
                        membermethod.setLocalvar(localvarmap)
                        membermethod.setAnalysis_module(c_ast.Compound(block_items=pa_statements))
                    else:
                        membermethod.setBody(None)
                        membermethod.setLocalvar(None)
    		else:
		    membermethod.setBody(None)
    		    membermethod.setLocalvar(None)
    
    	temp_functionvarmap={}
        
        
    	
    	for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
                in_var_map=membermethod.getInputvar()
                if len(in_var_map)>0:
                    for x in in_var_map:
                        variable=in_var_map[x]
                        if variable.getDimensions() is not None and len(variable.getDimensions())>0:
                            temp_functionvarmap[medthod]=functionvarmap[medthod]
                elif medthod=='main':
                        temp_functionvarmap[medthod]=functionvarmap[medthod]
                
    	
    	for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
    		body=membermethod.getBody()
    		if body is not None:
                    if medthod=='main':
                        
                        statements=body.block_items
                        
                        statements = substituteFunBlock(statements,temp_functionvarmap,medthod,externalvarmap)
            
                        duplicate_dec_map={}
                        
                        generator = c_generator.CGenerator()
                        
                        update_statements=[]

                        for s in statements:
                            if type(s) is c_ast.Decl:
                                key = generator.visit(s)
                                if key not in duplicate_dec_map:
                                    duplicate_dec_map[key]=key
                                    update_statements.append(s)
                            else:
                                update_statements.append(s)
                                                            
                        body_comp = c_ast.Compound(block_items=update_statements)
                        
                        membermethod.setBody(body_comp)
    
                        #print '!!!!!!!!!!!!!!!!!!!!!'
                        #body_comp = c_ast.Compound(block_items=update_statements)
                        #generator = c_generator.CGenerator()
                        #print(generator.visit(body_comp))
                        #print '!!!!!!!!!!!!!!!!!!!!!'
                        #if len(temp_functionvarmap)>0:
                        #    ret_body_comp,temp_status1,temp_status2 = reduceArraySize1("int main()"+generator.visit(body_comp))
                        #
                        #    if ret_body_comp is not None and temp_status1==True and temp_status2:
                        #        body_comp = ret_body_comp.body
                        #        membermethod.setBody(body_comp)
                        

    
    	
    	
    
    	#program in intermediate form
    	programeIF=[]

    	programeIF.append('-1')
    			
    	programeIF.append('prog')

    	programe_array=[]

    	variables_list_map={}
        
    	for medthod in functionvarmap.keys():
                f_vfact=[]
                f_vfact_para=[]
    		membermethod=functionvarmap[medthod]
                if membermethod.getreturnType() is not 'void':
                    f_vfact.append(medthod)
                    f_vfact_para.append(membermethod.getreturnType())
                    for iv in membermethod.getInputvar():
                        i_var=membermethod.getInputvar()[iv]
                        f_vfact_para.append(i_var.getVariableType())
                    f_vfact.append(len(f_vfact_para)-1)
                    f_vfact.append(f_vfact_para)
                    function_vfacts.append(f_vfact)

                
    		body=membermethod.getBody()
                
    		if body is not None:
    			new_variable={}
    			update_statements=[]
    			   		
	    		body_comp=body
	    		
	    		membermethod.setTempoary(body_comp)
	    		
	    		statements=body.block_items
	    		
	    		new_variable.clear()

	    		update_statements=[]
			
			for var in new_variable.keys():
				if isBoolVariable( var )==True:
			    	    	#temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
                                        temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
			    		update_statements.append(temp)
			    	else:
			    		if type(new_variable[var]) is tuple:
                                            type_stmt,t_degree=new_variable[var]
                                            program_temp=type_stmt+' '+var
                                            for x in range(0,t_degree):
                                                program_temp+='[]'
                                            program_temp+=';'
                                            temp_ast = parser.parse(program_temp)
                                            update_statements.append(temp_ast.ext[0])
                                        else:
                                            if var in new_variable_array.keys():
                                                type_stmt='int'
                                                t_degree=new_variable_array[var]
                                                program_temp=type_stmt+' '+var
                                                for x in range(0,t_degree):
                                                    program_temp+='[]'
                                                program_temp+=';'
                                                temp_ast = parser.parse(program_temp)
                                                update_statements.append(temp_ast.ext[0])
                                            else:
                                                temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                                                update_statements.append(temp)
			        	
			for statement in statements:
    				update_statements.append(statement)
                        
                        body_comp=c_ast.Compound(block_items=update_statements)
	    		
    			membermethod.setBody(body_comp)
   
    			
    			localvarmap=getVariables(body_comp)
    			
    			for var in externalvarmap.keys():
				variable=externalvarmap[var]
				localvarmap[var]=variable
    			
    			membermethod.setLocalvar(localvarmap)
    			membermethod=functionvarmap[medthod]
    			    			
    			function=[]
    			
    			function.append('-1')
    			
    			function.append('fun')    			
    			
    			functionName=[]
    			
    			allvariable={}
    			
    			for x in membermethod.getInputvar():
				allvariable[x]=membermethod.getInputvar()[x]
			for x in membermethod.getLocalvar():
        			allvariable[x]=membermethod.getLocalvar()[x]
    			if validationOfInput(allvariable)==True:
				print 'Unknown'
				#print "Please Rename variable Name {S,Q,N,in,is} to other Name"
          			return
    			

    			try:
                            
                             
                            
                            program,variablesarray,fname,iputmap,opvariablesarray,module_analysis,module_analysis2=translate2IntForm(membermethod.getMethodname(),membermethod.getreturnType(),membermethod.getBody(),membermethod.getInputvar(),membermethod.getTempoary(),membermethod.getAnalysis_module(),struct_map)

                            
                        except Exception as e:
                            #print 'Error(error occurred during translation intermediate format)'
                            print 'Unknown'
                            writeLogFile( "j2llogs.logs" ,str(e))
                        #    print str(e)
                            return
		

			functionName.append(fname)

                        
                        if len(iputmap.keys())>0:
                            for x_i in range(0,len(iputmap.keys())):
                                    functionName.append(iputmap.keys()[len(iputmap.keys())-1-x_i])
                                    #functionName.append(iputmap.keys()[x_i])


			function.append(functionName)
                                                
			
			function.append(program)
                        

			programe_array.append(function)
		
			variables_list_map[fname]=variablesarray
			
			addition_array=[]
			
			addition_array.append(iputmap)
			
			addition_array.append(allvariable)
			
			addition_array.append(opvariablesarray)
			
			addition_array_map[fname]=addition_array
			
			memberfunctionmap[fname]=membermethod
                        
                        
			
			function_vfact_list=[]
			function_vfact=[]
			function_vfact.append(fname)
			function_vfact.append(len(iputmap))
			parameters_type=[]
			parameters_type.append(membermethod.getreturnType())
			for x in defineDetaillist:
				function_vfact_list.append(x)
					
			
			defineDetaillist=[]
			for element in iputmap.keys():
				variable=iputmap[element]
				if variable is not None:
					parameters_type.append(variable.getVariableType())
			function_vfact.append(parameters_type)
			function_vfact_list.append(function_vfact)
			function_vfact_map[fname]=function_vfact_list	
                        
                        resultfunction='__VERIFIER_nondet_int'
                        
                        filename=file_name
                        functionname=functionName
                        
                        witnessXml=getWitness(filename,fname,resultfunction)
                        witnessXml_map[fname]= witnessXml
                        if program_analysis is not None:
                            #print '###########################3'
                            #print membermethod.getFun_decl().show()
                            #print '###########################3'
                            program_decl=programPrint(membermethod.getFun_decl())
                            #print '^^^^^^^^^^^^^^^^^^^'
                            #print membermethod.getMethodname()
                            #print membermethod.getreturnType()
                            #print program_decl
                            #print '^^^^^^^^^^^^^^^^^^^'
                            #print module_analysis2
                            #print '^^^^^^^^^^^^^^^^^^^'
                            if 'main' not in program_decl:
                                program_analysis_decl+=programPrint(membermethod.getFun_decl())+';\n'
                            module_analysis_t1,module_analysis_t2=module_analysis2
                            program_analysis2=program_decl+programPrint(module_analysis_t1)+program_analysis2
                            program_analysis3=program_decl+programPrint(module_analysis_t2)+program_analysis3
                            program_analysis=program_decl+programPrint(module_analysis)+program_analysis
                            
                            #print '%%%%%%%%%%%%%%%%%%!'
                            #print program_analysis
                            #print programPrint(module_analysis_t1)
                            #print '%%%%%%%%%%%%%%%%%%@'
                            #print program_analysis2
                            #print '%%%%%%%%%%%%%%%%%%@'
                            #print program_analysis3
                            #print '%%%%%%%%%%%%%%%%%%#'
                            
        
        
        #program_analysis=program_analysis_var_decl+program_analysis
        #program_analysis2=program_analysis_var_decl+program_analysis2
        #program_analysis3=program_analysis_var_decl+program_analysis3
        program_analysis_decl=program_analysis_var_decl+program_analysis_decl
        
        programeIF.append(programe_array)
        #print '$$$$$$$$$$$$$$$$$$$'
        #print program_analysis
        #print program_analysis_var_decl
        #print program_analysis_decl
        #print '$$$$$$$$$$$$$$$$$$$'
        #print '--------------------------------'
        #print programeIF
        #print '--------------------------------'
        #print variables_list_map
        #print '--------------------------------'
        #return
        
        try:
            f_map,o_map,a_map,cm_map,assert_map,assume_map,assert_key_map=translate1(programeIF,variables_list_map,1)
            
        except Exception as e:
            print 'Error(Translation Failed)'
            writeLogFile( "j2llogs.logs" ,str(e))
            #print str(e)
            return

        #Comment me to use Z3
        #return
        f_list=f_map.keys()
        cycle_list=[]
        programgraph_map=construct_graph(f_map,o_map,a_map,f_list)
        programgraph = graphclass.Graph(programgraph_map)
        

        
        if programgraph.cyclic():
            cycle_list=list(itertools.chain.from_iterable(programgraph.getAllNodesInCycle()))
            

        f_list=removeCycles(f_list,cycle_list)
        

        
        for f_x in cycle_list:
            for x in o_map[f_x]:
                if o_map[f_x][x][0]=='e':
                    o_map[f_x][x][2] = reconstructRecurences(o_map[f_x][x][2],cycle_list)

                    
        for f_x in cycle_list:
            if f_x in fun_call_map.keys() and fun_call_map[f_x]==1:
                for x in o_map['main']:
                    if o_map['main'][x][0]=='e':
                        o_map['main'][x][2] = reconstructRecurences(o_map['main'][x][2],cycle_list)
        


        function_substitution_test('main',programgraph_map,f_map,o_map,a_map,assert_map,assume_map,cycle_list)
        
        
           
        #print '$$$$$$$$$$$$$$$$$$$$'
        
        #print cycle_list
        
        #print '$$$$$$$$$$$$$$$$$$$$'
        
        
        
        
        #for x in f_map.keys():
        #    f=f_map[x]
        #    o=o_map[x]
        #    a=a_map[x]
        #    f,o,a=updateAxoimsRecurrences(f,o,a,cycle_list)
        #    f_map[x]=f
        #    o_map[x]=o
        #    a_map[x]=a
        
        if type(f_map) is dict and type(o_map) is dict and type(a_map) is dict and type(cm_map) is dict and type(assert_key_map) is dict:
                for key in f_map.keys():
                        membermethod=functionvarmap[key]                        
                        #print membermethod.getreturnType()
        		f=f_map[key]
        		o=o_map[key]
        		a=a_map[key]
        		cm=cm_map[key]
                        
        		assert_list=assert_map[key]
        		assume_list=assume_map[key]
                        
                        assert_list=function_substitution_main_Assert(assert_list,f_map,o_map,a_map,cycle_list)
                        
                        
        		addition_array=addition_array_map[key]
        		
        		vfacts,constraints=getVariFunDetails(f,o,a,addition_array[1],addition_array[2])
                        
                        #for x in vfacts:
                        #    print x

        		
        		vfacts2=getVariFunDetails2(f,o,a,addition_array[1],constraints,assert_list,assume_list)
                    
                        for x in a:
                            equ=getConstraints_Eq(x,addition_array[1],constraints)
                            if equ is not None:
                                constraints.append(equ)
        		vfacts=[]
        		for vfact in vfacts2:
        			vfacts.append(vfacts2[vfact])
                        
                        for x in function_vfacts:
                             vfacts.append(x)
                    
                        #print '--------------'
                        #for x in vfacts2:
                        #    print vfacts2[x]
                            
        		#for element in function_vfact_map.keys():
        		#	function_vfact_list=function_vfact_map[element]
        		#	for x in function_vfact_list:
                        #                if x[0] not in vfacts2.keys():
                        #                    vfacts.append(x)
                        f,o,a,cm,assert_list = rec_solver_tactic8(f,o,a,assert_list)
        		f,o,a,vfacts=organizeAxioms(f,o,a,vfacts)
                                                
                        
                        #output_axioms_fn(f,o,a)
        		axiom=axiomclass(f,o,a,membermethod.getInputvar(), vfacts, constraints,cm,assert_list,assume_list,addition_array[1])
        		axiomeMap[key]=axiom

                #print '#######'
                #print external_var_map
                #print program_analysis
                #print '#######'
                end_time=current_milli_time()
                #print "Translation Time--"
		#print end_time-start_time
                #AssetionAnalysis2(program_analysis2,program_analysis_decl)
                #
                #return
                #print '!!!!!!!!!!!!!'
                #print program_analysis
                #print program_analysis_decl
                #print '!!!!!!!!!!!!!'
                if programgraph.cyclic():
                    
                    axiommain=axiomeMap['main']
                    
                    program_analysis_list,concret_value_map_list = getRangeValues(axiommain.getOutput_equations(),program_analysis)
                    
                    #print '%%%%%%%%%%%%%%'
                    #print concret_value_map_list
                    #print '%%%%%%%%%%%%%%'
                    #print program_analysis
                    #print '%%%%%%%%%%%%%%'
                                        
                    isRunAgain=False
                    conrt_count=0
                    for program_analysis in program_analysis_list:
                        
                        if isRunAgain==False:
                            
                            results=AssetionAnalysis8(program_analysis,program_analysis_decl)
                            
                            #print '-----------'
                            #print program_analysis
                            #print main_count_ast_line_no

                            #print '-----------------'
                            #print main_line_no_stmt_ast_map
                            #if len(concret_value_map_list)>0:
                            #    print concret_value_map_list[conrt_count]
                            #print '-----------'
                            
                            if results is None and type(results) is not str:
                                
                                isRunAgain=True
                            else:
                                if len(concret_value_map_list)>0:
                                    program_analysis3 = AssetionAnalysis3_8(program_analysis3,concret_value_map_list[conrt_count])
                                
                            conrt_count=conrt_count+1
                        
                        
                    #print '%%%%%%%%%-------------'
                    #print results
                    #print '%%%%%%%%%-------------'
                    if type(results) is str and  'Termination Failed' in results:
                        print 'Termination Failed'
                        flag_terminate=True
                        #return
                    
                else:
                    
                    results=AssetionAnalysis(program_analysis,program_analysis_decl)
                    
                    #results={}
                    #print '%%%%%%%%%-------------'
                    #print program_analysis
                    #print '#####################'
                    #return
                    #parser = GnuCParser()
                    #generator = c_generator.CGenerator()
                    #ast = parser.parse(program_analysis)
                    #for e in ast.ext:
                    #    if type(e) is c_ast.FuncDef and e.decl.name=='main':
                    #        function_body = e.body
                    #        if function_body.block_items is not None:
                    #            statements=function_body.block_items
                    #            function_body= c_ast.Compound(block_items=updateAddInitArray(statements)) 
                    #            print(generator.visit(function_body))
                    if type(results) is str and  'Termination Failed' in results:
                        print 'Termination Failed'
                        return
                    elif type(results) is str and 'Segmentation fault (core dumped)' in results:
                        update_program,is_runable=reduceArraySize(program_analysis)
                        if is_runable==True:
                            results=AssetionAnalysis7(update_program,program_analysis_decl)
                        else:
                            update_program,is_runable=reduceArraySizeNonDet(program_analysis)
                            if is_runable==True:
                                results=AssetionAnalysis7(update_program,program_analysis_decl)
                    else:
                        if (type(results) is not dict and len(results)==0) or (type(results) is dict and len(results)==0):
                            new_program_analysis = AssetionAnalysis9(program_analysis)
                            if new_program_analysis is not None:
                                results=AssetionAnalysis(new_program_analysis,program_analysis_decl)
                                if results is not None and type(results) is not str and len(results) :
                                    program_analysis=new_program_analysis
                                
                                
                                

                #print '$$$$$$$$$$$$$$$$$'
                #print results
                #print '$$$$$$$$$$$$$$$$$'
                results={}
                #include <stdlib.h>
                
                if results is None:
                    #print 'Result--'
                    #print 'Program Terminates Failed'
                    #return
                    results={}
                for fun in assert_key_map.keys():
                    assert_key_list = assert_key_map[fun]
                    assert_list=axiomeMap[fun].getAsserts()
                    new_assert_key_list=[]
                    for result in results:
                        new_assert_list=[]
                        for key in assert_key_list:
                            if key in result:
                                assertion=assert_key_list[key]
                                if '_FAILED' not in key:
                                    #print 'Assertion :'+wff2z3_update_postCond(assertion)
                                    #print 'False'
                                    #violation_status=violationWitness(filename)
                                    #if violation_status is not None and 'False' in violation_status:
                                    print 'VIAP_STANDARD_OUTPUT_False'
                                    
                                    #print '!!!!!!!!!!!!!@@@@@@@@ram'
                                    #print program_analysis3
                                    #print program_analysis_decl
                                    #print '!!!!!!!!!!!!!@@@@@@@@ram'
                                    
                                    program_analysis3_new = reduceLoopSize(program_analysis3)
                                    
                                    if program_analysis3_new is not None:
                                        
                                        #print assert_key_list
                                        
                                        #print '-------------------@@@@@@@@@@@@@@@@'
                                        
                                        program_analysis3 = program_analysis3_new

                                    
                                    result=AssetionAnalysis3(program_analysis3,program_analysis_decl,file_name,property)
                                    
                                    print '~~~~~~~~~~~~~~~~~~~~~~~~~~'
                                    print property
                                    print '~~~~~~~~~~~~~~~~~~~~~~~~~~'
                                    
                                    if result is not None:
                                            writtingFile( "errorWitness.graphml" , result )
                                            writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(result)+"\n" )
                                    else:
                                            
                                            line_no,stmt2 = getLineNumber_terminate('__VERIFIER_error()','__VERIFIER_assert')
                                            if property is None:
                                                    property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
                                            else:
                                                    if '=' in property:
                                                        value_names=property.split('=')
                                                        fd = open(value_names[1])
                                                        property = "".join(fd.readlines())
                                                    else:
                                                        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
                                            hashcode=sha1(file_name)
                                            
                                            violation_witness2=''
                                            violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                            violation_witness2+="<node id=\"N"+str(1)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no)+"</data>\n"+"</node>\n"
                                            violation_witness2+="<edge source=\"N"+str(0)+"\" target=\"N"+str(1)+"\">\n"
                                            violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                                            violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                                            violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                                            violation_witness2+="</edge>\n"
                                            
                                            violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+filename+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">violation_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+filename+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"
                                            writtingFile( "errorWitness.graphml" , str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n"))
                                            writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n")+"\n" )
                                    
                                    test_int_mid=None
                                    test_uint_mid=None
                                    test_char_mid=None
                                    int_mid_count=0
                                    uint_mid_count=0
                                    char_mid_count=0
                                    #print results[result]
                                    return
                                            
                                    if assertion in assert_list:
                                        assert_list.remove(assertion)
                                else:
                                    for x in assert_list:
                                        if x[0]=='c1':
                                            if key in x[1][1][0]:
                                                #print 'Assertion :'+wff2z3_update_postCond(x)
                                                assert_list.remove(x)
                                    #print 'False'
                                    #violation_status=violationWitness(filename)
                                    #if violation_status is not None and 'False' in violation_status:
                                    print 'VIAP_STANDARD_OUTPUT_False'
                                    test_int_mid=None
                                    test_uint_mid=None
                                    test_char_mid=None
                                    int_mid_count=0
                                    uint_mid_count=0
                                    char_mid_count=0
                                    
                                    #print '!!!!!!!!!!!!!@@@@@@@@ram'
                                    #print result
                                    #print program_analysis3
                                    #AssetionAnalysis10(program_analysis3)
                                    #print program_analysis_decl
                                    
                                    #stmt,line_no = AssetionAnalysis11(program_analysis3)
                                    
                                    #print stmt
                                    
                                    #result,new_result = AssetionAnalysis10(program_analysis3,program_analysis_decl,file_name,property)
                                    
                                    #print new_result
                                    
                                    #print '!!!!!!!!!!!!!@@@@@@@@ram'
                                    
                                    result=AssetionAnalysis3(program_analysis3,program_analysis_decl,file_name,property)
                                    
                                    if result is not None:
                                            #print "Error Witness Generated"
                                            writtingFile( "errorWitness.graphml" , result )
                                            writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(result)+"\n" )
                                    else:
                                            
                                            line_no,stmt2 = getLineNumber_terminate('__VERIFIER_error();','main')
                                            
                                            if property is None:
                                                    property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
                                            else:
                                                    if '=' in property:
                                                        value_names=property.split('=')
                                                        fd = open(value_names[1])
                                                        property = "".join(fd.readlines())
                                                    else:
                                                        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
                                            
                                            violation_witness2=''
                                            violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                            violation_witness2+="<node id=\"N"+str(1)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no)+"</data>\n"+"</node>\n"
                                            violation_witness2+="<edge source=\"N"+str(0)+"\" target=\"N"+str(1)+"\">\n"
                                            violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                                            violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                                            violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                                            violation_witness2+="</edge>\n"
                                            
                                            hashcode=sha1(file_name)
                                            violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+filename+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">violation_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+filename+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"
                                            writtingFile( "errorWitness.graphml" , str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n"))
                                            writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n")+"\n" )                                    #print results[result]
                                    return
                
                if len(f_list)==1 and 'main' in f_list:
                    axiommain=axiomeMap['main']
                    vfactsmain=axiommain.getVfact()
                    
                    a=axiommain.getOther_axioms()
                    assert_list_main=axiommain.getAsserts()
                    re_equations=[]
                    for fun in cycle_list:
                        axiom=axiomeMap[fun]
                        if axiom is not None:
                            equations=[]
                            list_exps={}
                            f=axiom.getFrame_axioms()
                            o=axiom.getOutput_equations()
                            witnessXml= witnessXml_map[fun]
                            assert_list=axiom.getAsserts()
                            vfacts=axiom.getVfact()
                            inputvar=axiom.getInputvariable()
                            
                            for x in o:
                                equation=[]
                                equation.append('R')
                                equation.append(inputvar.keys())
                                equation.append(o[x][1])
                                equation.append(o[x][2])
                                a.append(equation)
                                equations.append(copy.deepcopy(equation))
                                re_equations.append(copy.deepcopy(equation))
                            #print '========================='
                            #print axiommain.getOutput_equations()
                            #print '========================='
                            for x in axiommain.getOutput_equations():
                                e=axiommain.getOutput_equations()[x]
                                if '_FAILED' in x and e[0]=='e':
                                    getRecuresiveFunDef(e[2],cycle_list,list_exps)
                                    temp_condition_map={}
                                    getAllCondtion_tactic8(e,temp_condition_map)
                                    list_ConcreteValue = getConcreteValue(temp_condition_map)
                                    #program_analysis,concret_value_map = getRangeValues(axiommain.getOutput_equations(),program_analysis)
                                    
                                    program_analysis_list,concret_value_map_list = getRangeValues(axiommain.getOutput_equations(),program_analysis)
                                    
                                    
                                    if len(list_ConcreteValue)==1:
                                        results=AssetionAnalysis5(program_analysis,program_analysis_decl,list_ConcreteValue[0])
                                        if type(results) is str and  'Termination Failed' in results:
                                            print 'Termination Failed'
                                            return
                                        if results is not None and len(results.keys())>0:
                                            print 'VIAP_STANDARD_OUTPUT_False'
                                            #print 'XXXXX-YYYYY'
                                            #result=AssetionAnalysis3(program_analysis3,program_analysis_decl,file_name,property)
                                            result= AssetionAnalysis3_5(program_analysis3,program_analysis_decl,file_name,property,list_ConcreteValue[0])
                                            if result is not None:
                                                #print "Error Witness Generated"
                                                writtingFile( "errorWitness.graphml" , result )
                                                writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(result)+"\n" )
                                                return
                                            else:
                                                line_no,stmt2 = getLineNumber_terminate('__VERIFIER_error()','main')
                                            
                                                if property is None:
                                                    property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
                                                else:
                                                    if '=' in property:
                                                        value_names=property.split('=')
                                                        fd = open(value_names[1])
                                                        property = "".join(fd.readlines())
                                                    else:
                                                        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
                                            
                                                violation_witness2=''
                                                violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                                violation_witness2+="<node id=\"N"+str(1)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no)+"</data>\n"+"</node>\n"
                                                violation_witness2+="<edge source=\"N"+str(0)+"\" target=\"N"+str(1)+"\">\n"
                                                violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                                                violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                                                violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                                                violation_witness2+="</edge>\n"
                                            
                                                hashcode=sha1(file_name)
                                                violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+filename+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">violation_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+filename+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"
                                                writtingFile( "errorWitness.graphml" , str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n"))
                                                writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n")+"\n" )                     
                                                return
                    
                                    elif len(concret_value_map_list)>0 and flag_terminate==False:
                                        list_ConcreteValue.append('0')
                                        
                                        isRunAgain=False
                                        
                                        results=None
                                        
                                        
                                        for program_analysis in program_analysis_list:
                                            
                                            if isRunAgain==False:
                                                
                                                #print '~~~~~~~~~~~~~~~~'
                                                #print program_analysis
                                                #print '~~~~~~~~~~~~~~~~'
                                        
                                                results=AssetionAnalysis5(program_analysis,program_analysis_decl,list_ConcreteValue[0])
                                                
                                                if results is None and type(results) is not str:
                                                    
                                                    isRunAgain=True
                                            
                                            
                                        if type(results) is str and  'Termination Failed' in results:
                                            print 'Termination Failed'
                                            #return
                                        if results is not None and type(results) is not str and len(results.keys())>0:
                                            print 'VIAP_STANDARD_OUTPUT_False'
                                            
                                            #print '~~~~~~~~~~~~~~~~'
                                            #print program_analysis3
                                            #print '~~~~~~~~~~~~~~~~'
            
                                            result=AssetionAnalysis3(program_analysis3,program_analysis_decl,file_name,property)
                                            if result is not None:
                                                #print "Error Witness Generated"
                                                writtingFile( "errorWitness.graphml" , result )
                                                writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(result)+"\n" )
                                                return
                                            else:
                                                line_no,stmt2 = getLineNumber_terminate('__VERIFIER_error()','main')
                                            
                                                if property is None:
                                                    property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
                                                else:
                                                    if '=' in property:
                                                        value_names=property.split('=')
                                                        fd = open(value_names[1])
                                                        property = "".join(fd.readlines())
                                                    else:
                                                        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
                                            
                                                violation_witness2=''
                                                violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                                violation_witness2+="<node id=\"N"+str(1)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no)+"</data>\n"+"</node>\n"
                                                violation_witness2+="<edge source=\"N"+str(0)+"\" target=\"N"+str(1)+"\">\n"
                                                violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                                                violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                                                violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                                                violation_witness2+="</edge>\n"
                                            
                                                hashcode=sha1(file_name)
                                                violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+filename+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">violation_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+filename+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"
                                                writtingFile( "errorWitness.graphml" , str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n"))
                                                writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n")+"\n" )                     
                                                return


                                        
                                        
                                        
                            for vfact in vfacts:
                                #if vfact[0][-1]!='1' and vfact[0]!=fun:
                                if vfact[0][0:len(vfact[0])-1] not in inputvar and vfact[0]!=fun:
                                    vfactsmain.append(vfact)
                                if vfact[0][-1]=='1' and '_FAILED1' in vfact[0]:
                                    vfactsmain.append(vfact)
                            for list_exp in list_exps:
                                status=prove_assert_tactic6(equations,list_exps[list_exp],cycle_list,vfactsmain,witnessXml)
                                if status is not None:
                                    a.append(status)
                            for tassert in assert_list:
                                assert_list_main.append(tassert)
                    
                    #print '--------------------'
                    #print re_equations
                    vfactsmain=axiommain.getVfact()
                    a=axiommain.getOther_axioms()
                    for x in axiommain.getOutput_equations():
                        if '_FAILED' in x:
                            #e=axiommain.getOutput_equations()[x][2]
                            #print e
                            #print wff2string1(axiommain.getOutput_equations()[x])
                            e=copy.deepcopy(axiommain.getOutput_equations()[x][2])
                            addition_equs = prove_assert_tactic7(e,re_equations,cycle_list,vfactsmain,witnessXml)
                            for addition_equ in addition_equs:
                                a.append(addition_equ)
                            #print wff2string1(axiommain.getOutput_equations()[x])
                    axiommain.setOther_axioms(a)
                    axiomeMap['main']=axiommain
                    #print '--------------------'
                program=programclass(file_name, memberfunctionmap , externalvarmap, axiomeMap, witnessXml_map) 
                #print '@@@@@@------'
                prove_auto_process(program,property,program_analysis3,program_analysis_decl)
                #return program
        else:
        	print 'Error in  Translation'



def getTheFileName(filename):
    if filename is not None:
        if '/' in filename:
            filenames=filename.strip()
            names=filename.split('/')
            return names[-1]
        else:
            return filename





#Get All Struct Variables

def updatePointerStruct(statements,struct_map):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            if type(statement.type.type) is c_ast.Struct:
                if statement.type.type.name in struct_map.keys():
                    structobject=struct_map[statement.type.type.name]
                    if structobject.getIsPointer()==True:
                        statement=c_ast.Decl(name=statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.PtrDecl(quals=[], type=statement.type), init=statement.init, bitsize=statement.bitsize)
                        update_statements.append(statement)
                    else:
                        update_statements.append(statement)
                else:
                    update_statements.append(statement)
            else:
                if type(statement.type) is c_ast.PtrDecl:
                                        
                    if isArrayNamePresent(statements,statement.name)==True:
                        
                        if type(statement.init) is c_ast.FuncCall and type(statement.init.name) is c_ast.ID and statement.init.name.name=='malloc' and len(statement.init.args.exprs)>0 and type(statement.init.args.exprs[0]) is c_ast.BinaryOp and type(statement.init.args.exprs[0].left) is c_ast.ID:
                            
                            new_statement = declarationModifyingUpdate(statement,statement.init.args.exprs[0].left.name)
                        
                            if new_statement is not None:
                                
                                update_statements.append(new_statement)
                                
                            else:
                                update_statements.append(statement)
    
                        else:
                            
                            update_statements.append(statement)
                        
                    else:
                        update_statements.append(statement)
                    
                else:
                    update_statements.append(statement)
        elif type(statement) is c_ast.Assignment:
            if type(statement.rvalue) is c_ast.Cast:
                if type(statement.rvalue.to_type.type.type) is c_ast.Struct:
                    if statement.rvalue.to_type.type.type.name in struct_map.keys():
                        structobject=struct_map[statement.rvalue.to_type.type.type.name]
                        if structobject.getIsPointer()==True:
                            stmt=c_ast.Typename(name = statement.rvalue.to_type.name, quals = statement.rvalue.to_type.quals, type=c_ast.PtrDecl(quals=[], type=statement.rvalue.to_type.type))
                            update_statements.append(c_ast.Assignment(op=statement.op,lvalue=statement.lvalue,rvalue=c_ast.Cast(to_type=stmt, expr=statement.rvalue.expr)))
                        else:
                            update_statements.append(statement)
                    else:
                        update_statements.append(statement)
                else:
                    update_statements.append(statement)
            else:
                update_statements.append(statement)
        elif type(statement) is c_ast.While:
            stmts = updatePointerStruct(statement.stmt.block_items,struct_map)
            statement=c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=stmts))
            update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(updatePointerStructIf(statement,struct_map))
        else:
            update_statements.append(statement)
    return update_statements
            
            

def declarationModifying(statement):
    if type(statement.type) is c_ast.PtrDecl:
        degree=0
        dimensionmap={}
        parser = c_parser.CParser()
        type_stmt,degree,structType=getArrayDetails(statement,degree,dimensionmap)
        program_temp=type_stmt+' '+ statement.name
        for x in range(0,degree):
            program_temp+='[]'
        pointer=statement.name
        program_temp+=';'
        temp_ast = parser.parse(program_temp)
        return temp_ast.ext[0]
    else:
        return None
    
    
def declarationModifyingUpdate(statement,size):
    if type(statement.type) is c_ast.PtrDecl:
        degree=0
        dimensionmap={}
        parser = c_parser.CParser()
        type_stmt,degree,structType=getArrayDetails(statement,degree,dimensionmap)
        if degree==1:
            program_temp=type_stmt+' '+ statement.name
            for x in range(0,degree):
                program_temp+='['+size+']'
            pointer=statement.name
            program_temp+=';'
            temp_ast = parser.parse(program_temp)
            return temp_ast.ext[0]
        else:
            return None
    else:
        return None



def isArrayNamePresent(statements,ptr_name):
    
    for statement in statements:
        
        if type(statement) is c_ast.Assignment:
            
            ret = isArrayNamePresentstatement(statement.rvalue,ptr_name)
            
            if ret==True:
                
                return True

            ret = isArrayNamePresentstatement(statement.lvalue,ptr_name)
            
            if ret==True:
                
                return True

        elif type(statement) is c_ast.While:
            
            
            ret = isArrayNamePresentstatement(statement.cond,ptr_name)
            
            if ret==True:
                
                return True

            ret = isArrayNamePresent(statement.stmt.block_items,ptr_name)
            
            if ret==True:
                
                return True

        elif type(statement) is c_ast.If:
            
            ret = isArrayNamePresentIf(statement,ptr_name)
            
            if ret==True:
                
                return True
    return False



def isArrayNamePresentIf(statement,ptr_name):
    
    if type(statement) is c_ast.If:
        
        ret = isArrayNamePresentstatement(statement.cond,ptr_name)
            
        if ret==True:
                
            return True

        
        if type(statement.iftrue) is c_ast.Compound:
            
            ret = isArrayNamePresent(statement.iftrue.block_items,ptr_name)
            
            if ret==True:
                
                return True

        else:

            ret = isArrayNamePresentstatement(statement.iftrue,ptr_name)
            
            if ret==True:
                
                return True

            
    if type(statement.iffalse) is c_ast.Compound:
        
        if statement.iffalse.block_items is not None:
            
            ret = isArrayNamePresent(statement.iffalse.block_items,ptr_name)
            
            if ret==True:
                
                return True

        else:
            
            ret = isArrayNamePresentstatement(statement.iffalse,ptr_name)
            
            if ret==True:
                
                return True

        
    else:
        
        if type(statement.iffalse) is c_ast.If:
            
            ret = isArrayNamePresentIf(statement.iffalse,ptr_name)
            
            if ret==True:
                
                return True
    return False

            
            



def isArrayNamePresentstatement(statement,ptr_name):
    
    if type(statement) is c_ast.BinaryOp:
        
        if type(statement.left) is c_ast.ArrayRef:
            
            if statement.left.name==ptr_name:
                
                return True
        else:
            ret = isArrayNamePresentstatement(statement.left,ptr_name)
            
            if ret==True:
                
                return True
            
        if type(statement.right) is c_ast.ArrayRef:
            
            if statement.right.name==ptr_name:
                
                return True
        else:
            ret = isArrayNamePresentstatement(statement.left,ptr_name)
            
            if ret==True:
                
                return True
    elif type(statement) is c_ast.Return:
        
        ret = isArrayNamePresentstatement(statement.expr,ptr_name)
        
        if ret==True:
                
            return True


    return True






def updatePointerStructIf(statement,struct_map):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=updatePointerStruct(statement.iftrue.block_items,struct_map)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=updatePointerStruct(statement.iffalse.block_items,struct_map)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=updatePointerStructIf(statement.iffalse,struct_map)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)






def translateStruct(statements,variable_map,struct_map):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            statement=c_ast.Assignment(op=statement.op,lvalue=translateStructStmt(statement.lvalue,variable_map,struct_map), rvalue=translateStructStmt(statement.rvalue,variable_map,struct_map))
            update_statements.append(statement)
        elif type(statement) is c_ast.While:
            cond=translateStructStmt(statement.cond,variable_map,struct_map)
            stmts=translateStruct(statement.stmt.block_items,variable_map,struct_map)
            statement=c_ast.While(cond=cond, stmt=c_ast.Compound(block_items=stmts))
            update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(translateStructIf(statement,variable_map,struct_map))
        else:
             update_statements.append(statement)
    return update_statements
            

def translateStructIf(statement,variable_map,struct_map):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=translateStruct(statement.iftrue.block_items,variable_map,struct_map)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=translateStruct(statement.iffalse.block_items,variable_map,struct_map)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=translateStructIf(statement.iffalse,variable_map,struct_map)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=translateStructStmt(statement.cond,variable_map,struct_map), iftrue=If_stmt, iffalse=Else_stmt)





def translateStructStmt(statement,variable_map,struct_map):
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op, left=translateStructStmt(statement.left,variable_map,struct_map), right=translateStructStmt(statement.right,variable_map,struct_map))
    elif type(statement) is c_ast.FuncCall:
        para_list=[]
        if statement.args is not None:
            for para_meter in statement.args.exprs:
                para_list.append(translateStructStmt(para_meter,variable_map,struct_map))
            return c_ast.FuncCall(name=statement.name, args=c_ast.ExprList(exprs=para_list))
        else:
            return statement
    elif type(statement) is c_ast.StructRef:
        if type(statement.name) is c_ast.ID and type(statement.field) is c_ast.ID:
            if statement.name.name in variable_map.keys():
                variable=variable_map[statement.name.name]
                struct_name=variable.getStructType()
                if struct_name is not None:
                    para_list=[]
                    para_list.append(statement.name)
                    return c_ast.FuncCall(name=c_ast.ID(name=struct_name+"_"+statement.field.name), args=c_ast.ExprList(exprs=para_list))
                    #return c_ast.FuncCall(name=c_ast.ID(name=struct_name+"_"+statement.field.name), args=c_ast.ParamList(params=ExprList(exprs=para_list)))
        elif type(statement.name) is c_ast.ArrayRef and type(statement.field) is c_ast.ID:
            s_array_name=getArrayName(statement.name)
            if s_array_name in variable_map.keys():
                variable=variable_map[s_array_name]
                struct_name=variable.getStructType()
                if struct_name is not None:
                    para_list=[]
                    para_list.append(statement.name)
                    return c_ast.FuncCall(name=c_ast.ID(name=struct_name+"_"+statement.field.name), args=c_ast.ExprList(exprs=para_list))
        else:
            return statement
    elif type(statement) is c_ast.Cast:
        if type(statement.to_type.type) is c_ast.PtrDecl:
            if type(statement.to_type.type.type.type) is c_ast.Struct:
                if type(statement.expr) is c_ast.FuncCall and statement.expr.name.name =='malloc':
                    if type(statement.expr.args.exprs[0]) is c_ast.UnaryOp and statement.expr.args.exprs[0].op == 'sizeof':
                        if statement.expr.args.exprs[0].expr.type.type.name in struct_map.keys():
                            structobject=struct_map[statement.expr.args.exprs[0].expr.type.type.name]
                            return c_ast.ID(name='_Address_Block_Type_'+statement.expr.args.exprs[0].expr.type.type.name)
                        else:
                            return c_ast.ID(name='_Address_Block_Type_'+statement.expr.args.exprs[0].expr.type.type.name)
                    else:
                        return statement
                else:
                    return statement
            else:
                return statement

        else:
            if type(statement.to_type.type.type) is c_ast.Struct:
                if type(statement.expr) is c_ast.FuncCall and statement.expr.name.name =='malloc':
                    if type(statement.expr.args.exprs[0]) is c_ast.UnaryOp and statement.expr.args.exprs[0].op == 'sizeof':
                        if statement.expr.args.exprs[0].expr.type.name in struct_map.keys():
                            if statement.expr.args.exprs[0].expr.type.name in struct_map.keys():
                                if statement.expr.args.exprs[0].expr.type.type.name in struct_map.keys():
                                    structobject=struct_map[statement.expr.args.exprs[0].expr.type.name]
                                    return c_ast.ID(name='_Address_Block_Type_'+statement.expr.args.exprs[0].expr.type.name)
                                else:
                                    return c_ast.ID(name='_Address_Block_Type_'+statement.expr.args.exprs[0].expr.type.name)
                            else:
                                return statement
                        else:
                            return statement
                    else:
                            return statement
                else:
                     return statement
            else:
                if type(statement.to_type.type.type) is c_ast.IdentifierType:
                    if 'char' in statement.to_type.type.type.names:
                        if type(statement.expr) is c_ast.Constant and statement.expr.type=='int':
                            return statement.expr
                        else:
                            #return statement
                            return statement.expr
                    elif 'int' in statement.to_type.type.type.names:
                        if type(statement.expr) is c_ast.Constant and statement.expr.type=='int':
                            return statement.expr
                        else:
                            #return statement
                            return statement.expr
                    elif 'short' in statement.to_type.type.type.names:
                        if type(statement.expr) is c_ast.Constant and statement.expr.type=='int':
                            return statement.expr
                        else:
                            #return statement
                            return statement.expr
                    elif 'long' in statement.to_type.type.type.names:
                        if type(statement.expr) is c_ast.Constant and statement.expr.type=='int':
                            return statement.expr
                        else:
                            #return statement
                            return statement.expr
                    else:
                        return statement
                else:
                    return statement
    else:
        return statement


#def substitution_process(programgraph_map):
    
def removeCycles(f_list,cycle_list):
    new_f_list=[]
    for vertex in f_list:
        if vertex not in cycle_list:
            new_f_list.append(vertex)
    return new_f_list

def getSinks(programgraph_map):
    sink_list=[]
    for vertex in programgraph_map:
        if len(programgraph_map[vertex])==0:
            sink_list.append(vertex)
    return sink_list


def function_substitution_test(methodname,programgraph_map,f_map,o_map,a_map,assert_map,assume_map,cycle_list):
    if methodname in programgraph_map.keys():
        list_of_dests=programgraph_map[methodname]
        if len(list_of_dests)>0:
            for dests in list_of_dests:
                if dests not in cycle_list:
                    #print '$$$$$$$$$$$$$$$$$@@@@@@@@@@@@@@'
                    #print dests
                    #print '$$$$$$$$$$$$$$$$$@@@@@@@@@@@@@@'
                    function_substitution_test(dests,programgraph_map,f_map,o_map,a_map,assert_map,assume_map,cycle_list)
            f,o,a,assert_list,assume_list=function_substitution_main(f_map[methodname],o_map[methodname],a_map[methodname],assert_map[methodname],assume_map[methodname],f_map,o_map,a_map,assert_map,assume_map,cycle_list)
            f_map[methodname]=f
            o_map[methodname]=o
            a_map[methodname]=a
            assert_map[methodname]=assert_list
            assume_map[methodname]=assume_list
            #print '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
            #print assert_map
            #print '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
            del programgraph_map[methodname]
            

        


fun_count=0

sub_vfact=[]

external_var_map={}

external_pointer_map={}

fun_substitution_map={}

def function_substitution_main(f,o,a,assert_list,assume_list,f_map,o_map,a_map,assert_map,assume_map,cycle_list):
    new_a=[]
    new_o={}
    for x in o:
        if o[x][0]=='e':
            new_stmts=[]
            ret_term=function_substitution(o[x][2],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            if len(new_stmts)>0:
                for y in new_stmts:
                    new_a.append(y)
            if ret_term is not None:
                o[x][2]=ret_term
        new_o[x]=o[x]
    for x in a:
        new_stmts=[]
        if x[0]=='i1':
            ret_term=function_substitution(x[4],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            if 'DUMMY' in x[3][0]:
                function_substitution_dummy_assert(x[4],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            else:
                if len(new_stmts)>0:
                    for y in new_stmts:
                        new_a.append(y)
                if ret_term is not None:
                    x[4]=function_substitution(x[4],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                    new_a.append(x)
        elif x[0]=='i0':
            ret_term=function_substitution(x[3],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            if len(new_stmts)>0:
                for y in new_stmts:
                    new_a.append(y)
            if ret_term is not None:
                x[3]=ret_term
                new_a.append(x)
        elif x[0]=='s0' or x[0]=='s1' :
            ret_term=function_substitution(x[1],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            if len(new_stmts)>0:
                for y in new_stmts:
                    new_a.append(y)
            if ret_term is not None:
                x[1]=ret_term
                new_a.append(x)
        else:
            new_a.append(x)
    return f,new_o,new_a,assert_list,assume_list



def function_substitution_main_Assert(assert_list,f_map,o_map,a_map,cycle_list):
    new_assert_list=[]
    for x in assert_list:
        if x[0]=='c1' or x[0]=='s0' or x[0]=='s1':
            ret_term=function_substitution_Assert(x[1],f_map,o_map,a_map,cycle_list)
            if ret_term is not None:
                x[1]=ret_term
                new_assert_list.append(x)
            else:
                new_assert_list.append(x)
        else:
            new_assert_list.append(x)
    return new_assert_list


def function_substitution(e,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list):
    global fun_substitution_map
    global LC
    args=expr_args(e)
    op=expr_op(e)
    fun_name=fun_matching(op)
    if len(args)==0:
        #if op in f_map.keys():
        if fun_name in f_map.keys() and fun_name not in cycle_list:
            for x in  assert_map[fun_name]:
                assert_list.append(x)
            for x in  assume_map[fun_name]:
                assume_list.append(x)
            if 'RET' in o_map[fun_name].keys():
                ret_stmt = o_map[fun_name]['RET']
                if len(a_map[fun_name])>0 and op not in fun_substitution_map.keys():
                    new_a=copy.deepcopy(a_map[fun_name])
                    if op not in fun_substitution_map.keys():
                        LC+=1
                        fun_substitution_map[op]=op
                    for x in new_a:
                        x = replace_fun_substitute(x,op,fun_count,temp)
                        new_stmts.append(x)
                return ret_stmt[2]
            else:
                return e
        else:
            return e
    else:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            temp=[]
            for x in expr_args(e):
                parameter=function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                if parameter is None:
                    temp.append(x)
                else:
                    temp.append(parameter)
            return e[:1]+temp
         #elif op in f_map.keys():
         elif fun_name in f_map.keys() and fun_name not in cycle_list:
            temp_assert_list=[]
            temp_assume_list=[]
            for x in  assert_map[fun_name]:
                temp_assert_list.append(x)
            for x in  assume_map[fun_name]:
                temp_assume_list.append(x) 
            temp=[]
            temp2=[]
            sub_map={}
            if 'RET' in o_map[fun_name].keys():
                #print '----------######----------'
                #print o_map[fun_name]
                #print '---------------------'
                #print fun_name
                #print '----------######----------'
                ret_stmt = o_map[fun_name]['RET']
                for x in expr_args(e):
                    parameter=function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                    temp.append(parameter)
                for x in expr_args(ret_stmt[1]):
                    parameter=function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                    temp2.append(parameter)
                if len(a_map[fun_name])>0 and op not in fun_substitution_map.keys():
                    new_a=copy.deepcopy(a_map[fun_name])
                    if op not in fun_substitution_map.keys():
                        LC+=1
                        fun_substitution_map[op]=op
                    for x in range(0,len(temp2)):
                        new_a=construct_a(temp2[x],temp[x],new_a,temp,op)
                    for x in new_a:
                        new_stmts.append(x)
                new_stmt=copy.deepcopy(ret_stmt[2])
                for x in range(0,len(temp2)):
                    new_stmt=expr_replace(new_stmt,temp2[x],temp[x])
                    for y in  temp_assert_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                    for y in  temp_assume_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                new_stmt = replace_fun_substitute(new_stmt,op,fun_count,temp)
                for x in  temp_assert_list:
                    assert_list.append(x)
                for x in  temp_assume_list:
                    assume_list.append(x)
                return new_stmt
            else:
                
                for x in expr_args(e):
                    parameter=function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                    temp.append(parameter)
                #for x in expr_args(ret_stmt[1]):
                #    parameter=function_substitution(x,f_map,o_map,a_map,new_stmts)
                #    temp2.append(parameter)
                if len(a_map[fun_name])>0 and op not in fun_substitution_map.keys():
                    new_a=copy.deepcopy(a_map[fun_name])
                    if op not in fun_substitution_map.keys():
                        LC+=1
                        fun_substitution_map[op]=op
                    for x in range(0,len(temp2)):
                        new_a=construct_a(temp2[x],temp[x],new_a,temp,op)
                        for y in  temp_assert_list:
                            y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                        for y in  temp_assume_list:
                            y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                    for x in new_a:
                        new_stmts.append(x)
                    for x in  temp_assert_list:
                        assert_list.append(x)
                    for x in  temp_assume_list:
                        assume_list.append(x)
                return None
                
         else:
            return e[:1]+list(function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list) for x in expr_args(e))




def function_substitution_dummy_assert(e,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list):
    global fun_substitution_map
    global LC
    args=expr_args(e)
    op=expr_op(e)
    fun_name=fun_matching(op)
    if op is 'ite':
            if args[1][0] in f_map.keys() and args[1][0] not in cycle_list:
                temp=[]
                temp2=[]
                parameters=expr_args(args[1])
                for parameter in parameters:
                    temp.append(parameter)
                for parameter in f_map[args[1][0]]:
                    temp2.append(eval("['"+parameter+"']"))
                temp_assert_list=[]
                temp_assume_list=[]
                for x in  assert_map[args[1][0]]:
                    temp_assert_list.append(x)
                for x in  assume_map[args[1][0]]:
                    temp_assume_list.append(x)
                    
                for x in range(0,len(temp2)):
                    for y in  temp_assert_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                    for y in  temp_assume_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                        
                for x in temp_assert_list:
                    assert_temp=[]
                    assert_temp.append('implies')
                    assert_temp.append(args[0])
                    assert_temp.append(x[-1])
                    x[-1]=assert_temp
                    assert_list.append(x)
                for x in temp_assume_list:
                    assume_temp=[]
                    assume_temp.append('implies')
                    assume_temp.append(args[0])
                    assume_temp.append(x[-1])
                    x[-1]=assert_temp
                    assert_list.append(x)
                    
            elif args[2][0] in f_map.keys() and args[2][0] not in cycle_list:
                temp=[]
                temp2=[]
                parameters=expr_args(args[2])
                for parameter in parameters:
                    temp.append(parameter)
                for parameter in f_map[args[2][0]]:
                    temp2.append(eval("['"+parameter+"']"))
                temp_assert_list=[]
                temp_assume_list=[]
                for x in  assert_map[args[2][0]]:
                    temp_assert_list.append(x)
                for x in  assume_map[args[2][0]]:
                    temp_assume_list.append(x)
                    
                for x in range(0,len(temp2)):
                    for y in  temp_assert_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                    for y in  temp_assume_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                        
                for x in temp_assert_list:
                    assert_temp=[]
                    assert_temp.append('Implies')
                    assert_temp.append(expr_complement(args[0]))
                    assert_temp.append(x[-1])
                    x[-1]=assert_temp
                    assert_list.append(x)
                for x in temp_assume_list:
                    assume_temp=[]
                    assume_temp.append('Implies')
                    assume_temp.append(expr_complement(args[0]))
                    assume_temp.append(x[-1])
                    x[-1]=assert_temp
                    assert_list.append(x)

#fun_name='avg_1'

def fun_matching(fun_name):
    fun_term=fun_name.split("_")
    if len(fun_term)==2:
        if is_number(fun_term[1])==True:
            return fun_term[0]
        else:
            return fun_name
    else:
        return fun_name




def function_substitution_Assert(e,f_map,o_map,a_map,cycle_list):
    global fun_count
    args=expr_args(e)
    op=expr_op(e)
    fun_name=fun_matching(op)
    if len(args)==0:
        #if op in f_map.keys():
        if fun_name in f_map.keys() and fun_name not in cycle_list:
            if 'RET' in o_map[fun_name].keys():
                ret_stmt = o_map[fun_name]['RET']
                return ret_stmt[2]
            else:
                return e
        else:
            return e
    else:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            temp=[]
            for x in expr_args(e):
                parameter=function_substitution_Assert(x,f_map,o_map,a_map,cycle_list)
                temp.append(parameter)
            return e[:1]+temp
         #elif op in f_map.keys():
         elif fun_name in f_map.keys() and fun_name not in cycle_list:
            temp=[]
            temp2=[]
            sub_map={}
            if 'RET' in o_map[fun_name].keys():
                ret_stmt = o_map[fun_name]['RET']
                for x in expr_args(e):
                    parameter=function_substitution_Assert(x,f_map,o_map,a_map,cycle_list)
                    temp.append(parameter)
                for x in expr_args(ret_stmt[1]):
                    parameter=function_substitution_Assert(x,f_map,o_map,a_map,cycle_list)
                    temp2.append(parameter)
                new_stmt=copy.deepcopy(ret_stmt[2])
                for x in range(0,len(temp2)):
                    new_stmt=expr_replace(new_stmt,temp2[x],temp[x])
                new_stmt = replace_fun_substitute(new_stmt,op,fun_count,temp)
                return new_stmt
            else:
                return e
                
         else:
            return e[:1]+list(function_substitution_Assert(x,f_map,o_map,a_map,cycle_list) for x in expr_args(e))





def construct_a(e1,e2,a,input_list,f_name):
    global fun_count
    fun_count=fun_count+1
    new_a=[]
    for x in a:
        if x[0]=='i1':
            x[3]=expr_replace(x[3],e1,e2)
            x[3] = replace_fun_substitute(x[3],f_name,fun_count,input_list)
            x[4]=expr_replace(x[4],e1,e2)
            x[4] = replace_fun_substitute(x[4],f_name,fun_count,input_list)
        elif x[0]=='i0':
            x[2]=expr_replace(x[2],e1,e2)
            x[2] = replace_fun_substitute(x[2],f_name,fun_count,input_list)
            x[3]=expr_replace(x[3],e1,e2)
            x[3] = replace_fun_substitute(x[3],f_name,fun_count,input_list)
        elif x[0]=='s0' or x[0]=='s1':
            x[1]=expr_replace(x[1],e1,e2)
            x[1] = replace_fun_substitute(x[1],f_name,fun_count,input_list)
        new_a.append(x)
    return new_a




def replace_fun_substitute(e,f_name,count,input_list):
    global sub_vfact
    global external_var_map
    global LC
    args=expr_args(e)
    op=expr_op(e)
    if e in input_list:
        return e
    elif len(args)==0:
        if isvariable(op)==False and is_number(op)==False and op.startswith('_N') == False and op not in external_var_map.keys():
            #sub_vfact.append(f_name+str(count)+'_'+op)
            sub_vfact.append(f_name+'_'+op)
            #return eval("['"+f_name+str(count)+'_'+op+"']")
            if f_name+'_' in op:
                return eval("['"+op+"']")
            else:
                return eval("['"+f_name+'_'+op+"']")
        else:
            if isConstant(op):
                return eval("['"+'_N'+str(LC)+"']")
            elif isLoopvariable(op):
                return eval("['"+'_n'+str(LC)+"']")
            return e
    else:
        if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True or e[:1]==['implies']:
            temp=[]
            for x in expr_args(e):
                temp.append(replace_fun_substitute(x,f_name,count,input_list))
            return e[:1]+list(temp)
        else:
            if isvariable(op)==False and op.startswith('_N') == False and op not in external_var_map.keys():
                #e[0]=f_name+str(count)+'_'+op
                if f_name+'_' in op:
                    e[0]=op
                else:
                    e[0]=f_name+'_'+op
                #sub_vfact.append(f_name+str(count)+'_'+op)
                sub_vfact.append(f_name+'_'+op)
            else:
                if isConstant(op):
                    #e[:1]='_N'+str(LC)
                    return eval("['"+'_N'+str(LC)+"']")+list(replace_fun_substitute(x,f_name,count,input_list) for x in expr_args(e))
            return e[:1]+list(replace_fun_substitute(x,f_name,count,input_list) for x in expr_args(e))





    

def updateAxoimsRecurrences(f,o,a,f_list):    
    for x in o:
        if o[x][0]=='e':
            o[x][2] = updateAxoimsNameRec(o[x][2],f_list)
    for x in a:
        if x[0]=='e':
            x[2] = updateAxoimsNameRec(x[2],f_list)
    return f,o,a
        
        
def updateAxoimsNameRec(e,f_list):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return e
    else:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            temp=[]
            for x in expr_args(e):
                parameter=updateAxoimsNameRec(x,f_list)
                temp.append(parameter)
            return e[:1]+temp
         elif isRecurrenceFun( op, f_list ) is not None:
            temp=[]
            for x in expr_args(e):
                parameter=updateAxoimsNameRec(x,f_list)
                temp.append(parameter)
            return eval("['"+isRecurrenceFun( op, f_list )+"']")+temp
         else:
            return e[:1]+list(updateAxoimsNameRec(x,f_list) for x in expr_args(e))






def organizeAxioms(f,o,a,vfacts):
    new_vfacts=[]
    array_list=[]
    new_f={}
    duplicate_map={}
    new_f={}
    new_o={}
    new_a=[]
    for [x,k,l] in vfacts:
        if k==0 and l[0]=='array' and isArrayFinal(x)==False and not(x=='main') and '_PROVE' not in x and '_ASSUME' not in x :
            array_list.append(x)
    for vfact in vfacts:
        if vfact[0] not in duplicate_map.keys():
            if '_ASSUME' not in vfact[0] and '_PROVE' not in vfact[0] and '__VERIFIER_assert' not in vfact[0]  : #and '_FAILED' not in vfact[0]
                duplicate_map[vfact[0]]=vfact[0]
                if isArrayFunction(vfact[0])==True:
                    if len(array_list)>0:
                        new_vfacts.append(vfact)
                else:
                    new_vfacts.append(vfact)
    #for e in f:
    #    if isArrayFunction(e)==True:
    #        if len(array_list)>0:
    #            new_f[e]=f[e]
    #    else:
    #        new_f[e]=f[e]
    #for e in o:
    #    if isArrayFunction(e)==True:
    #        if len(array_list)>0:
    #            new_o[e]=o[e]
    #    else:
    #        new_o[e]=o[e]
    #for e in a:
    #    if e[0]=='i1':
    #        if isArrayFunction(e[3][0])==True:
    #            if len(array_list)>0:
    #                new_a.append(e)
    #        else:
    #            new_a.append(e)
    #    elif e[0]=='i0':
    #        if isArrayFunction(e[2][0])==True:
    #            if len(array_list)>0:
    #                new_a.append(e)
    #        else:
    #            new_a.append(e)

    return f,o,a,new_vfacts


#Construct Graph To detect Recurences

def construct_graph(f_map,o_map,a_map,f_list):
    graph_map={}
    for fname in f_list:
        fnode_list=[]
        for x in f_map[fname]:
            getFunctionNameGraph(f_map[fname][x][2],f_list,fnode_list)
        for x in o_map[fname]:
            getFunctionNameGraph(o_map[fname][x][2],f_list,fnode_list)
        for x in a_map[fname]:
            if x[0]=='i1':
                getFunctionNameGraph(x[4],f_list,fnode_list)
            elif x[0]=='i0':
                getFunctionNameGraph(x[3],f_list,fnode_list)
            elif x[0]=='s0' or x[0]=='s1':
                getFunctionNameGraph(x[1],f_list,fnode_list)
        graph_map[fname]=fnode_list
    return graph_map

def getFunctionNameGraph(e,f_list,fnode_list):
    args=expr_args(e)
    op=expr_op(e)
    fun_name=fun_matching(op)
    if len(args)>0:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            for x in expr_args(e):
                getFunctionNameGraph(x,f_list,fnode_list)
         elif fun_name in f_list:
            if fun_name not in fnode_list:
                fnode_list.append(fun_name)
            for x in expr_args(e):
                getFunctionNameGraph(x,f_list,fnode_list)


def reconstructRecurences(e,f_list):
    op=expr_op(e)
    args=expr_args(e)
    fun_name=None
    if len(args)>0:
        if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            fun_name=None
        else:
            fun_name=fun_matching(op)
        if fun_name is not None and fun_name in f_list:
            return eval("['"+fun_name+"']")+list(reconstructRecurences(x,f_list) for x in expr_args(e))
        else:
            return e[:1]+list(reconstructRecurences(x,f_list) for x in expr_args(e))
    else:
        return e
    
    
def reconstructRecurences2(e,f_list,f_name):
    op=expr_op(e)
    args=expr_args(e)
    fun_name=None
    if len(args)>0:
        if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            fun_name=None
        else:
            fun_name=fun_matching(op)
        if fun_name is not None and fun_name in f_list and f_name==fun_name:
            return eval("['"+fun_name+"']")+list(reconstructRecurences2(x,f_list) for x in expr_args(e))
        else:
            return e[:1]+list(reconstructRecurences2(x,f_list) for x in expr_args(e))
    else:
        return e



#"char __VERIFIER_nondet_char()\n{\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nreturn rand()%1000;\n}"

#Module to Analysis Assertion
def AssetionAnalysis(program_analysis,program_analysis_decl):
    map_asserts={}
    #print '$$$$$$$$$$$$$--------------'
    #print program_analysis
    #print '$$$$$$$$$$$$$--------------'
    #print program_analysis_decl
    #print '$$$$$$$$$$$$$--------------'
     

 
 
    #""
    program_analysis = program_analysis.replace('_Bool','int')
     
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nint _count_long=0;\nint _count_short=0;\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nshort __VERIFIER_nondet_short()\n{\nint value;\n_count_short++;\nsrand(_count_short+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nlong __VERIFIER_nondet_long()\n{\nint value;\n_count_long++;\nsrand(_count_long+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis

    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nif(value<0) value=-value;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+program_analysis_decl+program_analysis
    
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nif(value<0) value=-value;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=int(str(rand())[:3]);\nif(value<0) value=-value;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+program_analysis_decl+program_analysis

    
    writtingFile( "input_program.c" , "int main(){}")
    try:
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program",currentdirectory+"/input_program.c"])
    except OSError  as err:
        print 'Error Occured'
    
    writtingFile( "input_program.c" , program_analysis )
    
    try :
        #proc = subprocess.Popen('gcc -o input_program input_program.c', stdout=subprocess.PIPE,shell=True)
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program",currentdirectory+"/input_program.c"])
        x=0
        for x in range(0,50):
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
            start_time=current_milli_time()
            command = commandclass.Command(currentdirectory+"/input_program")
            output = command.run(timeout=60)
            end_time=current_milli_time()
            #print end_time-start_time
            #if end_time-start_time >2000:
            #    return None
            #print '@@@@@@@@@@--------~~~~~~~~'
            status=output
            if status is not None and 'Segmentation fault (core dumped)' in status:
                return 'Segmentation fault (core dumped)'
            if status is not None and 'Termination Failed' not in status:
                outputs_list = status.split('--------\n')
                assume_output = processOutputAssume(outputs_list)
                if assume_output is None:
                    result=processOutput(outputs_list)
                    if len(result.keys())>0:
                        for key in result.keys():
                            map_asserts[key]=result[key]
                            return map_asserts
            elif status is not None and 'Termination Failed' in status:
                return 'Termination Failed'
        return map_asserts        
    except OSError  as err:
        print 'Error Occured'
        
        
def AssetionAnalysis2(program_analysis,program_analysis_decl):
    map_asserts={}

    program_analysis = program_analysis.replace('_Bool','int')
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool(int callcount)\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nprintf(\"__VERIFIER_nondet_bool:%d:%d\\n\",callcount,value);\nreturn value;\n}\nchar __VERIFIER_nondet_char(int callcount)\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nprintf(\"__VERIFIER_nondet_char:%d:%c\\n\",callcount,value);\nreturn value;\n}\nint __VERIFIER_nondet_int(int callcount)\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nprintf(\"__VERIFIER_nondet_int:%d:%d\\n\",callcount,value);\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint(int callcount)\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nprintf(\"__VERIFIER_nondet_uint:%d:%d\\n\",callcount,value);\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double(int callcount)\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nprintf(\"%d:%lf\\n\",callcount,value);\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float(int callcount)\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nprintf(\"__VERIFIER_nondet_float:%d:%f\\n\",callcount,value);\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis
    writtingFile( "input_program1.c" , program_analysis )
  
    
    try :
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program1",currentdirectory+"/input_program1.c"])
        x=0
        for x in range(0,1):
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
            start_time=current_milli_time()
            command = commandclass.Command(currentdirectory+"/input_program1")
            output = command.run(timeout=60)
            end_time=current_milli_time()
            #if end_time-start_time >300:
            #    return None
            status=output 
            if status is not None and 'Termination Failed' not in status:
                outputs_list = status.split('\n')
                out_results=processOutput1(outputs_list)
                if out_results is not None and len(out_results)>0:
                    print out_results
                      
    except OSError  as err:
        print 'Error Occured'



def AssetionAnalysis3(program_analysis,program_analysis_decl,file_name,property):
    map_asserts={}

    program_analysis = program_analysis.replace('_Bool','int')
    
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nint _count_long=0;\nint _count_short=0;\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nshort __VERIFIER_nondet_short()\n{\nint value;\n_count_short++;\nsrand(_count_short+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nlong __VERIFIER_nondet_long()\n{\nint value;\n_count_long++;\nsrand(_count_long+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis

    
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nint _count_short=0;\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_short()\n{\nint value;\n_count_short++;\nsrand(_count_short+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nvalue=2;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+program_analysis_decl+program_analysis
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+program_analysis_decl+program_analysis
    
    writtingFile( "input_program2.c" , "int main(){}")
    try:
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
    except OSError  as err:
        print 'Error Occured'
    
    writtingFile( "input_program2.c" , program_analysis )
    try :
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
        x=0
        for x in range(0,1):
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
            start_time=current_milli_time()
            command = commandclass.Command(currentdirectory+"/input_program2")
            output = command.run(timeout=60)
            end_time=current_milli_time()
            #if end_time-start_time >300:
            #    return None
            status=output
            #print '-----------------'
            #print status
            #print '-----------------'
            if status is not None and 'Termination Failed' not in status:
                outputs_list = status.split('\n')
                results=processOutput2(outputs_list,file_name,property)
                if results is not None:
                    return results
    except OSError  as err:
        print 'Error Occured'
        return status



def AssetionAnalysis3_5(program_analysis,program_analysis_decl,file_name,property,concerte_value):
    map_asserts={}

    program_analysis = program_analysis.replace('_Bool','int')
    
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nif(value<0) value=-value;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\n"+"\nreturn "+concerte_value+";\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\n return "+concerte_value+";\n}"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis

    
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nint _count_long=0;\nint _count_short=0;\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nshort __VERIFIER_nondet_short()\n{\nint value;\n_count_short++;\nsrand(_count_short+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nlong __VERIFIER_nondet_long()\n{\nint value;\n_count_long++;\nsrand(_count_long+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis

    
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nint _count_short=0;\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_short()\n{\nint value;\n_count_short++;\nsrand(_count_short+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nvalue=2;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+program_analysis_decl+program_analysis
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+program_analysis_decl+program_analysis
    
    writtingFile( "input_program2.c" , "int main(){}")
    try:
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
    except OSError  as err:
        print 'Error Occured'
    
    writtingFile( "input_program2.c" , program_analysis )
    try :
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
        x=0
        for x in range(0,1):
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
            start_time=current_milli_time()
            command = commandclass.Command(currentdirectory+"/input_program2")
            output = command.run(timeout=60)
            end_time=current_milli_time()
            #if end_time-start_time >300:
            #    return None
            status=output
            #print '-----------------'
            #print status
            #print '-----------------'
            if status is not None and 'Termination Failed' not in status:
                outputs_list = status.split('\n')
                results=processOutput2(outputs_list,file_name,property)
                if results is not None:
                    return results
    except OSError  as err:
        print 'Error Occured'
        return status


    
    
    
def AssetionAnalysis4(program_analysis,program_analysis_decl,file_name,property):
    map_asserts={}

    temp_program_analysis=program_analysis
    program_analysis = program_analysis.replace('_Bool','int')
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+program_analysis_decl+program_analysis
    
    writtingFile( "input_program2.c" , "int main(){}")
    try:
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
    except OSError  as err:
        print 'Error Occured'
    
    writtingFile( "input_program2.c" , program_analysis )
    try :
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
        x=0
        for x in range(0,1):
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
            start_time=current_milli_time()
            command = commandclass.Command(currentdirectory+"/input_program2")
            output = command.run(timeout=60)
            end_time=current_milli_time()
            #if end_time-start_time >300:
            #    return None
            status=output
            if status is None:
                temp_program_analysis = AssetionAnalysis12(temp_program_analysis)
                program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+temp_program_analysis
                #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+program_analysis_decl+program_analysis
                writtingFile( "input_program2.c" , "int main(){}")
                try:
                    subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
                except OSError  as err:
                    print 'Error Occured'
    
                writtingFile( "input_program2.c" , program_analysis )
                subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
                command = commandclass.Command(currentdirectory+"/input_program2")
                output = command.run(timeout=60)
                status=output
            if status is not None and 'Termination Failed' not in status:
                outputs_list = status.split('\n')
                results=processOutput3(outputs_list,file_name,property)
                if results is not None:
                    return results
    except OSError  as err:
        print 'Error Occured'
        return status




def AssetionAnalysis5(program_analysis,program_analysis_decl,concerte_value):
    
    
    map_asserts={}

    program_analysis = program_analysis.replace('_Bool','int')
     
    
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nif(value<0) value=-value;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\n"+"\nreturn "+concerte_value+";\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\n return "+concerte_value+";\n}"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis
    
    writtingFile( "input_program.c" , "int main(){}")
    try:
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program",currentdirectory+"/input_program.c"])
    except OSError  as err:
        print 'Error Occured'
    
    writtingFile( "input_program.c" , program_analysis )
    
    try :
        #proc = subprocess.Popen('gcc -o input_program input_program.c', stdout=subprocess.PIPE,shell=True)
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program",currentdirectory+"/input_program.c"])
        x=0
        for x in range(0,1):
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
            start_time=current_milli_time()
            command = commandclass.Command(currentdirectory+"/input_program")
            output = command.run(timeout=60)
            end_time=current_milli_time()
            #if end_time-start_time >300:
            #    return None
            status=output
            if status is not None and 'Segmentation fault (core dumped)' in status:
                return 'Segmentation fault (core dumped)'
            if status is not None and 'Termination Failed' not in status:
                outputs_list = status.split('--------\n')
                assume_output = processOutputAssume(outputs_list)
                if assume_output is None:
                    result=processOutput(outputs_list)
                    if len(result.keys())>0:
                        for key in result.keys():
                            map_asserts[key]=result[key]
                            return map_asserts
            elif status is not None and 'Termination Failed' in status:
                return 'Termination Failed'
        return map_asserts        
    except OSError  as err:
        print 'Error Occured'



def AssetionAnalysis6(program_analysis,program_analysis_decl,file_name,property,concerte_value):
    map_asserts={}

    program_analysis = program_analysis.replace('_Bool','int')
    
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nif(value<0) value=-value;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\n"+"\nreturn "+concerte_value+";\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis

    
    
    writtingFile( "input_program2.c" , "int main(){}")
    try:
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
    except OSError  as err:
        print 'Error Occured'
    
    writtingFile( "input_program2.c" , program_analysis )
    try :
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
        x=0
        for x in range(0,1):
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
            start_time=current_milli_time()
            command = commandclass.Command(currentdirectory+"/input_program2")
            output = command.run(timeout=60)
            end_time=current_milli_time()
            #if end_time-start_time >300:
            #    return None
            status=output
            #print '-----------------'
            #print status
            #print '-----------------'
            if status is not None and 'Termination Failed' not in status:
                outputs_list = status.split('\n')
                results=processOutput2(outputs_list,file_name,property)
                if results is not None:
                    return results
    except OSError  as err:
        print 'Error Occured'
        return status





def AssetionAnalysis7(program_analysis,program_analysis_decl):
    map_asserts={}
    #print '$$$$$$$$$$$$$--------------'
    #print program_analysis
    #print '$$$$$$$$$$$$$--------------'
    #print program_analysis_decl
    #print '$$$$$$$$$$$$$--------------'
    
    #""
    program_analysis = program_analysis.replace('_Bool','int')
     
    
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nif(value<0) value=-value;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis
    
    writtingFile( "input_program.c" , "int main(){}")
    try:
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program",currentdirectory+"/input_program.c"])
    except OSError  as err:
        print 'Error Occured'
    
    writtingFile( "input_program.c" , program_analysis )
    
    try :
        #proc = subprocess.Popen('gcc -o input_program input_program.c', stdout=subprocess.PIPE,shell=True)
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program",currentdirectory+"/input_program.c"])
        x=0
        for x in range(0,1):
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
            start_time=current_milli_time()
            command = commandclass.Command(currentdirectory+"/input_program")
            output = command.run(timeout=60)
            end_time=current_milli_time()
            #if end_time-start_time >300:
            #    return None
            status=output
            if status is not None and 'Segmentation fault (core dumped)' in status:
                return 'Segmentation fault (core dumped)'
            if status is not None and 'Termination Failed' not in status:
                outputs_list = status.split('--------\n')
                assume_output = processOutputAssume(outputs_list)
                if assume_output is None:
                    result=processOutput(outputs_list)
                    if len(result.keys())>0:
                        for key in result.keys():
                            map_asserts[key]=result[key]
                            return map_asserts
            elif status is not None and 'Termination Failed' in status:
                return 'Termination Failed'
        return map_asserts        
    except OSError  as err:
        print 'Error Occured'



def AssetionAnalysis8(program_analysis,program_analysis_decl):
    map_asserts={}
    #print '$$$$$$$$$$$$$--------------'
    #print program_analysis
    #print '$$$$$$$$$$$$$--------------'
    #print program_analysis_decl
    #print '$$$$$$$$$$$$$--------------'
     

    #""
    program_analysis = program_analysis.replace('_Bool','int')
     
    
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nif(value<0) value=-value;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis
    
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nif(value<0) value=-value;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=int(str(rand())[:3]);\nif(value<0) value=-value;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nif(value<0) value=-value;\nreturn value;\n}\n"+program_analysis_decl+program_analysis

    
    writtingFile( "input_program.c" , "int main(){}")
    try:
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program",currentdirectory+"/input_program.c"])
    except OSError  as err:
        print 'Error Occured'
    
    writtingFile( "input_program.c" , program_analysis )
    
    try :
        #proc = subprocess.Popen('gcc -o input_program input_program.c', stdout=subprocess.PIPE,shell=True)
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program",currentdirectory+"/input_program.c"])
    
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
        start_time=current_milli_time()
        command = commandclass.Command(currentdirectory+"/input_program")
        output = command.run(timeout=60)
        end_time=current_milli_time()
            #print end_time-start_time
            #if end_time-start_time >2000:
            #    return None
            #print '@@@@@@@@@@--------~~~~~~~~'
        status=output
        if status is not None and 'Segmentation fault (core dumped)' in status:
            return 'Segmentation fault (core dumped)'
        if status is not None and 'Termination Failed' not in status:
            outputs_list = status.split('--------\n')
            assume_output = processOutputAssume(outputs_list)
            if assume_output is None:
                result=processOutput(outputs_list)
                if len(result.keys())>0:
                    for key in result.keys():
                        map_asserts[key]=result[key]
                        return map_asserts
        elif status is not None and 'Termination Failed' in status:
            return 'Termination Failed'
        return map_asserts        
    except OSError  as err:
        print 'Error Occured'


def AssetionAnalysis3_8(program_analysis,concret_value_map):
        parser = c_parser.CParser()
        ast = parser.parse(program_analysis)
        for ast_y in ast.ext:
        #    print e.decl.name
            if type(ast_y) is not c_ast.Decl:
                for e in ast_y.body.block_items:
                    if type(e) is c_ast.Decl:
                        if e.type.declname in concret_value_map and type(e.init) is c_ast.FuncCall and '__VERIFIER_nondet_' in e.init.name.name:
                            e.init = c_ast.Constant(type='int', value=str(concret_value_map[e.type.declname]))
                    #print '~~~~~~~~~~~~~~~~Ram Ram'
                    
        generator = c_generator.CGenerator()
        program_analysis = generator.visit(ast)
        return program_analysis






def AssetionAnalysis9(program_analysis):
    #print program
    #print '--------------------------'
    status=False
    parser = GnuCParser()
    ast = parser.parse(program_analysis)
    try:
        new_block=None
        for e in ast.ext:
            if type(e) is c_ast.FuncDef: 
                function_body = e.body
                if function_body.block_items is not None:
                    #for x in function_body.block_items:
                    #    x.show()
                    new_block=updateBlockWithValues(function_body.block_items)
                    
                    
        if e.body.block_items!=new_block:
            e.body.block_items=new_block
            return programPrint(ast)
        else:
            return  None
        
        #return programPrint(ast),status
    except Exception as e:
        writeLogFile( "j2llogs.logs" ,str(e))
        print str(e)
        return None
    

def AssetionAnalysis10(program_analysis,program_analysis_decl,file_name,property):
    map_asserts={}

    program_analysis = program_analysis.replace('_Bool','int')
    
    program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nint _count_long=0;\nint _count_short=0;\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nshort __VERIFIER_nondet_short()\n{\nint value;\n_count_short++;\nsrand(_count_short+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nlong __VERIFIER_nondet_long()\n{\nint value;\n_count_long++;\nsrand(_count_long+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+"void init_array(int a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_int();\nx=x+1;\n }\n}\n"+"void init_array_char(char a[],int size)\n{\n int x = 0;\n while (x < size) \n{\n a[x]=__VERIFIER_nondet_char();\nx=x+1;\n }\n}\n"+program_analysis_decl+program_analysis

    
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nint _count_short=0;\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_short()\n{\nint value;\n_count_short++;\nsrand(_count_short+(short)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nvalue=2;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+program_analysis_decl+program_analysis
    #program_analysis="#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\nchar _count_char='\\0';\nunsigned int _count=0;\nint _count_int=0;\ndouble _count_double=0.0;\nfloat _count_float=0.0f;\nint __VERIFIER_nondet_bool()\n{\nint value;\n_count++;\nsrand(_count+(unsigned int)time(NULL));\nsrand(rand());\nvalue=rand()%2;\nreturn value;\n}\nchar __VERIFIER_nondet_char()\n{\nchar value;\n_count_char++;\nsrand(_count_int+(char)time(NULL));\nsrand(rand());\nvalue=rand()%1000;\nreturn value;\n}\nint __VERIFIER_nondet_int()\n{\nint value;\n _count_int++;\nsrand(_count_int+(int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\nunsigned int __VERIFIER_nondet_uint()\n{\nunsigned int value;\n _count++;\nsrand(_count+(unsigned int)time(NULL));\n srand(rand());\nvalue=rand()%1000;\nreturn value;\n}\n"+"\ndouble __VERIFIER_nondet_double()\n{\ndouble value;\n _count++;\nsrand(_count_double+(double)time(NULL));\n srand(rand());\n value=rand()%1000;\nreturn value;\n}\n"+"\nfloat __VERIFIER_nondet_float()\n{\nfloat value;\n _count++;\nsrand(_count_float+(float)time(NULL));\n srand(rand());\n \n value=rand()%1000;\nreturn value;\n}\n"+program_analysis_decl+program_analysis
    
    writtingFile( "input_program2.c" , "int main(){}")
    try:
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
    except OSError  as err:
        print 'Error Occured'
    
    writtingFile( "input_program2.c" , program_analysis )
    try :
        subprocess.call(["gcc", "-o",currentdirectory+"/input_program2",currentdirectory+"/input_program2.c"])
        x=0
        for x in range(0,1):
            #proc = subprocess.Popen('./input_program', stdout=subprocess.PIPE,shell=True)
            #output = proc.stdout.read()
            #output, err = proc.communicate()
            #print '##################---------------'
            start_time=current_milli_time()
            command = commandclass.Command(currentdirectory+"/input_program2")
            output = command.run(timeout=60)
            end_time=current_milli_time()
            #if end_time-start_time >300:
            #    return None
            status=output
            #print '-----------------'
            #print status
            #print '-----------------'
            if status is not None and 'Termination Failed' not in status:
                outputs_list = status.split('\n')
                results,new_results=processOutput10(outputs_list,file_name,property)
                #results =processOutput10(outputs_list,file_name,property)
                if results is not None and new_results is not None:
                #if results is not None:
                    return results,new_results
    except OSError  as err:
        print 'Error Occured'
        return None,None




def AssetionAnalysis12(program_analysis):
    #print program
    #print '--------------------------'
    status=False
    parser = GnuCParser()
    ast = parser.parse(program_analysis)
    try:
        new_block=None
        for e in ast.ext:
            if type(e) is c_ast.FuncDef: 
                function_body = e.body
                map_dec={}
                if function_body.block_items is not None:
                    new_block=[]
                    for x in function_body.block_items:
                        if type(x) is c_ast.Decl and type(x.type) is not c_ast.ArrayDecl:
                            map_dec[x.name]=x.name
                            new_block.append(x)
                        elif type(x) is c_ast.If:
                            x = updateIfPrintBlock(x,map_dec)
                            new_block.append(x)
                        else:
                            new_block.append(x)
                    e.body.block_items=new_block
        
        return programPrint(ast)
    except Exception as e:
        writeLogFile( "j2llogs.logs" ,str(e))
        print str(e)
        return None




def AssetionAnalysis13(program_analysis):
    #print program
    #print '--------------------------'
    status=False
    parser = GnuCParser()
    ast = parser.parse(program_analysis)
    try:
        for e in ast.ext:
            if type(e) is c_ast.FuncDef: 
                
                function_body = e.body
            
                if function_body.block_items is not None:
                    if e.decl.name=='main':
                        update_stmt=[]
                        for x in function_body.block_items:
                            if type(x) is c_ast.Decl:
                                if type(x.init) is c_ast.Constant:
                                    if is_number(x.init.value)==True and int(x.init.value)>=15:
                                        x.init=c_ast.Constant(type='int', value=str('5'))
                                        update_stmt.append(x)
                                    else:
                                        update_stmt.append(x)
                                else:
                                    update_stmt.append(x)
                            else:
                                update_stmt.append(x)
                        e.body.block_items=update_stmt
                            
                    
        return programPrint(ast)
        #return programPrint(ast),status
    except Exception as e:
        writeLogFile( "j2llogs.logs" ,str(e))
        print str(e)
        return None





def updateIfPrintBlock(statement,map_dec):
    if type(statement) is c_ast.If:
        If_stmt=None
        Else_stmt=None
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=[]
            for x in statement.iftrue.block_items:
                if type(x) is c_ast.FuncCall:
                    if len(x.args.exprs)==2:
                        if type(x.args.exprs[1]) is c_ast.ID:
                            if x.args.exprs[1].name in map_dec:
                                new_block_temp.append(x)
                        else:
                            new_block_temp.append(x)
                    else:
                        new_block_temp.append(x)      
                else:
                    new_block_temp.append(x)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
        Else_stmt=statement.iffalse
        return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)
    else:
        return statement
        
            
    
    



            



    
def AssetionAnalysis11(program_analysis):
    #print program
    #print '--------------------------'
    status=False
    parser = GnuCParser()
    ast = parser.parse(program_analysis)
    try:
        new_block=None
        for e in ast.ext:
            if type(e) is c_ast.FuncDef: 
                function_body = e.body
                if function_body.block_items is not None:
                    #for x in function_body.block_items:
                    #    x.show()
                    stmt,line_no = getErrorCondBlock(function_body.block_items)
                    if stmt is not None and line_no is not None:

                        return stmt,line_no
                    else:
                        return None,None
                    
                    
                    
        
        #return programPrint(ast),status
    except Exception as e:
        writeLogFile( "j2llogs.logs" ,str(e))
        print str(e)
        return None



def getErrorCondBlock(statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.If:
            if getErrorCondBlockIf(statement)==True:
                if type(update_statements[-1]) is c_ast.FuncCall:
                    if ':' in update_statements[-1].args.exprs[0].value:
                        values=update_statements[-1].args.exprs[0].value.split(':')
                        if 'IfCondition1' in values[0]:
                            return values[1],values[2]
                

        else:
            update_statements.append(statement)
    return None,None


def getErrorCondBlockIf(statement):
    
    if type(statement) is c_ast.If:
        
        if type(statement.iftrue) is c_ast.Compound:
            
            if getErrorCondBlockStmts(statement.iftrue.block_items)==True:
                
                return True
    return False



                
def getErrorCondBlockStmts(statements):
    
    for statement in statements:
        
        if type(statement) is c_ast.Label:
            
            if statement.name=='ERROR':
                return True
            
    return False









def updateBlockWithValues(statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.If:
            map_values={}
            updateBlockWithValuesIf(statement,map_values)
            #print '~~~~~~~~~~~~~~~'
            #print map_values
            #print '~~~~~~~~~~~~~~~'
            for id_value in map_values:
                update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=id_value),rvalue=c_ast.Constant(type='int', value=str(map_values[id_value]))))
            update_statements.append(statement)
        else:
            update_statements.append(statement)
    return update_statements


def updateBlockWithValuesIf(statement,map_values):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            if len(statement.iftrue.block_items)==1 and type(statement.iftrue.block_items[0]) is c_ast.Return:
                updateBlockWithValuesStatement(statement.cond,map_values)
                
        else:
            if type(statement.iftrue) is c_ast.Return:
                updateBlockWithValuesStatement(statement.cond,map_values)
    
    
def updateBlockWithValuesStatement(statement,map_values):
    
    if type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.ID and type(statement.right) is c_ast.Constant and is_number(statement.right.value)==True:
            if statement.left.name in map_values:
                if statement.op=="<=":
                    value = map_values[statement.left.name]
                    value = int((value+int(statement.right.value))/2)
                    map_values[statement.left.name]=value
                elif statement.op=="<":
                    value = map_values[statement.left.name]
                    value = int((value+int(statement.right.value)-1)/2)
                    map_values[statement.left.name]=value
                elif statement.op=="==":
                    value = map_values[statement.left.name]
                    value = int(statement.right.value)
                    map_values[statement.left.name]=value
            else:
                if statement.op=="<=" or '==':
                    map_values[statement.left.name]=int(statement.right.value)
                elif statement.op=="<":
                    map_values[statement.left.name]=int(statement.right.value)+1
        elif type(statement.right) is c_ast.ID and type(statement.left) is c_ast.Constant and is_number(statement.left.value)==True:
            if statement.right.name in map_values:
                if statement.op=="<=":
                    value = map_values[statement.right.name]
                    value = int((value+int(statement.left.value))/2)
                    map_values[statement.right.name]=value
                elif statement.op=="<=":
                    value = map_values[statement.right.name]
                    value = int((value+int(statement.left.value)-1)/2)
                    map_values[statement.right.name]=value
                elif statement.op=="==":
                    value = map_values[statement.right.name]
                    value = int(statement.left.value)
                    map_values[statement.right.name]=value
            else:
                if statement.op=="<=" or '==':
                    map_values[statement.right.name]=int(statement.left.value)
                elif statement.op=="<":
                    map_values[statement.right.name]=int(statement.left.value)+1

        else:
            updateBlockWithValuesStatement(statement.left,map_values)
            updateBlockWithValuesStatement(statement.right,map_values)
    elif type(statement) is c_ast.UnaryOp:
        updateBlockWithValuesStatement(statement.expr,map_values)
    






 
def extractFileName(filename):
    if filename is not None:
        filename_list=filename.strip().split('/')
        return filename_list[-1]
    return None



def processOutput1(outputs_list):
    value__VERIFIER_nondet_list=[]
    if len(outputs_list)>0:
        for output_list in outputs_list:
            if ':' in output_list and output_list.strip()!='':
                if '_PROVE' not in output_list and '_FAILED' not in output_list:
                    value__VERIFIER_nondet_list.append(output_list)
                else:
                    if '_PROVE' in output_list:
                        outputs_values = output_list.split(':')
                        if outputs_values[1]=='1':
                            return process__VERIFIER_nondet_list(value__VERIFIER_nondet_list)
                    elif '_FAILED' in output_list:
                        outputs_values = output_list.split(':')
                        if outputs_values[1]=='1':
                            return process__VERIFIER_nondet_list(value__VERIFIER_nondet_list)



def processOutput2(outputs_list,filename,property):
    global line_no_stmt_map
    global back_line_no_stmt_map
    global line_error_assert
    if line_no_stmt_map is None:
        return
    CountNode=0
    file_flag=True
    f_call_map={}
    e_current_assumption=None
    current_assumption=None
    current_assignment=None
    current_functioncall=None
    while_loop=None
    if property is None:
        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
    else:
        if '=' in property:
            value_names=property.split('=')
            fd = open(value_names[1])
            property = "".join(fd.readlines())
        else:
            property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
    if_cond_list=[]
    hashcode=sha1(filename)
    count=0
    
    xml_graph_nodes=[]
    #print outputs_list
    
    violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+filename+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">violation_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+filename+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"
    #violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\"?>"+"\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\""+"\n"+"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" +"\n"+"xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">"+"\n"+"<key id=\"programfile\" attr.name=\"programfile\" for=\"graph\"/>"+"\n"+"<key id=\"programhash\" attr.name=\"programhash\" for=\"graph\"/>"+"\n"+"<key id=\"sourcecodelang\" attr.name=\"sourcecodelang\" for=\"graph\"/>"+"\n"+"<key id=\"producer\" attr.name=\"producer\" for=\"graph\"/>"+"\n"+"<key id=\"specification\" attr.name=\"specification\" for=\"graph\"/>"+"\n"+"<key id=\"creationtime\" attr.name=\"creationtime\" for=\"graph\"/>"+"\n"+"<key id=\"witness-type\" attr.name=\"witness-type\" for=\"graph\"/>"+"\n"+"<key id=\"architecture\" attr.name=\"architecture\" for=\"graph\"/>"+"\n"+"<key id=\"entry\" attr.name=\"entry\" for=\"node\">"+"\n"+"<default>false</default>"+"\n"+"</key>"+"\n"+"<key id=\"nodetype\" attr.name=\"nodetype\" for=\"node\">"+"\n"+"<default>path</default>"+"\n"+"</key>"+"\n"+"<key id=\"violation\" attr.name=\"violation\" for=\"node\">"+"\n"+"<default>false</default>"+"\n"+"</key>"+"\n"+"<key id=\"invariant\" attr.name=\"invariant\" for=\"node\">"+"\n"+"<default>true</default>"+"\n"+"</key>"+"\n"+"<key id=\"endline\" attr.name=\"endline\" for=\"edge\"/>"+"\n"+"<key id=\"enterFunction\" attr.name=\"enterFunction\" for=\"edge\"/>"+"\n"+"<key id=\"startline\" attr.name=\"startline\" for=\"edge\"/>"+"\n"+"<key id=\"returnFrom\" attr.name=\"returnFrom\" for=\"edge\"/>"+"\n"+"<key id=\"assumption\" attr.name=\"assumption\" for=\"edge\"/>"+"\n"+"<key id=\"tokens\" attr.name=\"tokens\" for=\"edge\"/>"+"\n"+"<key id=\"control\" attr.name=\"control\" for=\"edge\"/>"+"\n"+"<key id=\"originfile\" attr.name=\"originfile\" for=\"edge\">"+"\n"+"<default>"+filename+"</default>"+"\n"+"</key>"+"\n"+"<key id=\"sourcecode\" attr.name=\"sourcecode\" for=\"edge\"/>"+"\n"+"<graph edgedefault=\"directed\">"+"\n"+"<data key=\"programfile\">"+filename+"</data>"+"\n"+"<data key=\"programhash\">"+hashcode+"</data>"+"\n"+"<data key=\"sourcecodelang\">C</data>"+"\n"+"<data key=\"producer\">VIAP</data>"+"\n"+"<data key=\"specification\">"+property+"</data>"+"\n"+"<data key=\"creationtime\">"+str(datetime.datetime.now().strftime("%y-%m-%dT%H:%MZ"))+"</data>"+"\n"+"<data key=\"witness-type\">violation_witness</data>"+"\n"+"<data key=\"architecture\">64bit</data>"+"\n"+"<node id=\"N0\">"+"\n"+"<data key=\"entry\">true</data>"+"\n"+"</node>"
    violation_witness2=''
    if len(outputs_list)>0:
        for output_list in outputs_list:
            if 'Assignment:' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            

                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            

                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            break
                    if_cond_list=[]
                    
                    
                    current_assignment=output_list
            elif 'FunctionCall:' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            break
                    if_cond_list=[]
                    #if current_functioncall is not None and current_functioncall==output_list:
                    #    terms=output_list.split(':')
                    #    if CountNode==0:
                    #        violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                    #        violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    #    else:
                    #        violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    #    violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    #    violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    #    violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    #    violation_witness2+="</edge>\n"
                    #    CountNode=CountNode+1
                        
                    
                    
                    
                    terms=output_list.split(':')
                    
                    temp_violation_witness2=''
                    
                    if CountNode==0:
                        temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    else:
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    if terms[-4].strip()=='#':
                        temp_violation_witness2+="<data key=\"sourcecode\">return "+terms[-2].strip()+";</data>\n"
                    else:
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-4].strip()+";</data>\n"
                        current_functioncall = output_list
                        
                    temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"enterFunction\">"+terms[-3]+"</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    CountNode=CountNode+1
                    xml_graph_nodes.append(temp_violation_witness2)
                    
            elif 'RecahCallPoint:' in output_list:
                    if current_assignment is not None:
                        temp_violation_witness2=''
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            xml_graph_nodes.append(temp_violation_witness2)
                            break
                    if_cond_list=[]
                    #terms=output_list.split(':')
                    
                    #temp_violation_witness2=''
                    
                    #if CountNode==0:
                    #    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                    #    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    #else:
                    #    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    #temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    #temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    #temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    #temp_violation_witness2+="</edge>\n"
                    #CountNode=CountNode+1
                    #xml_graph_nodes.append(temp_violation_witness2)

                    
            elif 'Return:' in output_list:
                
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            xml_graph_nodes.append(temp_violation_witness2)
                            break
                    if_cond_list=[]
                    terms=output_list.split(':')
                    
                    temp_violation_witness2=''
                    
                    if len(terms)==5:
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if terms[-4].strip()=='None':
                            temp_violation_witness2+="<data key=\"sourcecode\">return;</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">return "+terms[-4].strip()+";</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"returnFrom\">"+terms[-3]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)
                    else:
                        
                        #if CountNode==0:
                        #    violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        #    violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        #else:
                        #    violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                        #violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        #violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        #violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        #violation_witness2+="</edge>\n"
                        #CountNode=CountNode+1
                        
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if terms[-4].strip()=='None':
                            temp_violation_witness2+="<data key=\"sourcecode\">return;</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">return "+terms[-4].strip()+";</data>\n"
                            
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"returnFrom\">"+terms[-3]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)


                
            elif 'IfCondition1' in output_list or 'Else-IfCondition1' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                            
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1                
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                    if_cond_list.append(output_list)
            elif 'IfCondition2' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)                
                        current_assignment= None
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2) 
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            break
                            
                    if_cond_list=[]
                        
            elif 'WhileCondition' in output_list:
                    terms=output_list.split(':')
                    if int(terms[-1])==1:
                            
                        if current_assignment is not None:
                            
                            temp_violation_witness2=''
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                if while_loop is not None:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                            else:
                                if while_loop is not None:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                            
                            terms=current_assignment.split(':')
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            if 'for' in terms[-2].strip():
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                            else:
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="</edge>\n"
                    

                            CountNode=CountNode+1
                            
                            #print '$$$$$$$$$$$$$$$$$$$1'
                            #print temp_violation_witness2
                            #print '$$$$$$$$$$$$$$$$$$1'

                            current_assignment= None
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            
                        for x in if_cond_list:
                            terms=x.split(':')
                            
                            temp_violation_witness2=''
                            
                            if int(terms[-1])==0:
                            
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
        
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                #print '$$$$$$$$$$$$$$$$$$$2'
                                #print temp_violation_witness2
                                #print '$$$$$$$$$$$$$$$$$$2'

                                
                                xml_graph_nodes.append(temp_violation_witness2)
                            
                            else:
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                #print '$$$$$$$$$$$$$$$$$$$3'
                                #print temp_violation_witness2
                                #print '$$$$$$$$$$$$$$$$$$3'

                                
                                xml_graph_nodes.append(temp_violation_witness2)
                                
                                break
                        if_cond_list=[]
                            
                            
                            
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        while_loop='Current'
                        terms=output_list.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink"+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        CountNode=CountNode+1
                        
                        #print '$$$$$$$$$$$$$$$$$$$4'
                        #print temp_violation_witness2
                        #print '$$$$$$$$$$$$$$$$$$4'

                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    else:
                        
                        temp_violation_witness2=''
                        
                        if while_loop is not None:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                        if current_assignment is not None:
                            
                            temp_violation_witness2=''
                            
                            terms=current_assignment.split(':')
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            if 'for' in terms[-2].strip():
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                            else:
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="</edge>\n"
                    
                            CountNode=CountNode+1
                            #print '$$$$$$$$$$$$$$$$$$$5'
                            #print temp_violation_witness2
                            #print '$$$$$$$$$$$$$$$$$$5'

                            current_assignment= None
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            
                            
                        for x in if_cond_list:
                            terms=x.split(':')
                            
                            temp_violation_witness2=''
                            
                            if int(terms[-1])==0:
                            
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                #print '$$$$$$$$$$$$$$$$$$$6'
                                #print temp_violation_witness2
                                #print '$$$$$$$$$$$$$$$$$$6'

                                
                                xml_graph_nodes.append(temp_violation_witness2)
                            
                            else:
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                #print '$$$$$$$$$$$$$$$$$$$7'
                                #print temp_violation_witness2
                                #print '$$$$$$$$$$$$$$$$$$7'

                                
                                xml_graph_nodes.append(temp_violation_witness2)
                                break
                        if_cond_list=[]
                        
                        while_loop=None
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        
                        terms=output_list.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink"+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        CountNode=CountNode+1
                        
                        #print '$$$$$$$$$$$$$$$$$$$8'
                        #print temp_violation_witness2
                        #print '$$$$$$$$$$$$$$$$$$8'

                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    current_assignment= None
        
            elif '_FAILED' in output_list:
                if current_assignment is not None:
                    terms=current_assignment.split(':')
                    
                    temp_violation_witness2=''
                    
                    if CountNode==0:
                        temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    else:
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    if 'for' in terms[-2].strip():
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                    else:
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"

                    temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    
                    xml_graph_nodes.append(temp_violation_witness2)
                    
                    CountNode=CountNode+1
                    current_assignment= None
                    
                for x in if_cond_list:
                    terms=x.split(':')
                    
                    temp_violation_witness2=''
                    
                    if int(terms[-1])==0:
                            
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        CountNode=CountNode+1
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                            
                    else:
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        CountNode=CountNode+1
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                        break
                if_cond_list=[]
                            
                terms=output_list.split(':')
                
                temp_violation_witness2=''
                
                if terms[-1]=='1':
                    
                    
                    
                    
                    line_no,stmt = getLineNumber("__VERIFIER_error()",None)
                    
                    
                    if line_no is not None:
                    
                        temp_violation_witness2+="<node id=\"N"+str(CountNode)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no)+"</data>\n"+"</node>\n"
                    else:
                        temp_violation_witness2+="<node id=\"N"+str(CountNode)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_error_assert)+"</data>\n"+"</node>\n"

                        
                    
                    temp_replace=xml_graph_nodes[-1].replace("<node id=\"N"+str(CountNode)+"\"/>",'')
                    
                    temp_violation_witness2+=temp_replace
                    
                    del xml_graph_nodes[-1]
                    #temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    #temp_violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                    #temp_violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                    #temp_violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                    #temp_violation_witness2+="</edge>\n"
                    xml_graph_nodes.append(temp_violation_witness2)

                    
                    try:
                        
                        violation_witness2=''
                        for x in xml_graph_nodes:
                            violation_witness2+=x
                            
                        #print len(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")
                        if len(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")<283487754: 
                            xml.dom.minidom.parseString(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")
                    
                    except Exception as e:
                        return violation_witness1+'\n'+"\n</graph>\n</graphml>\n"
                    
                    if CountNode>=924772:
                        
                        new_violation_witness= violation_witness1+"<node id=\"N"+str(CountNode-1)+"\"><data key=\"entry\">true</data></node>\n"+temp_violation_witness2+"\n</graph>\n</graphml>\n"
                        return new_violation_witness
                        
                    else:
                        return violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n"
            elif '__VERIFIER_assert' in output_list:
                if current_assignment is not None:
                    
                    temp_violation_witness2=''
                    
                    terms=current_assignment.split(':')
                    
                    if CountNode==0:
                        temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    else:
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    if 'for' in terms[-2].strip():
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                    else:
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    
                    CountNode=CountNode+1
                    
                    xml_graph_nodes.append(temp_violation_witness2)
                    
                    current_assignment= None
                    
                for x in if_cond_list:
                    terms=x.split(':')
                    
                    temp_violation_witness2=''
                    
                    if int(terms[-1])==0:
                            
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                            
                        CountNode=CountNode+1
                            
                    else:
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        CountNode=CountNode+1
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        break
                if_cond_list=[]
                    
                            
                terms=output_list.split(':')
                temp_violation_witness2=''
                if terms[-1]=='0':
                    line_no,stmt = getLineNumberAssert(terms[-2])
                    line_no1,stmt1 = getLineNumber('! cond','__VERIFIER_assert')
                    line_no2,stmt2 = getLineNumber('__VERIFIER_error()','__VERIFIER_assert')
                    
                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                    temp_violation_witness2+="<data key=\"enterFunction\">__VERIFIER_assert</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    CountNode=CountNode+1
                    

                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    temp_violation_witness2+="<data key=\"sourcecode\">[cond==0]</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+str(line_no1)+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+str(line_no1)+"</data>\n"
                    temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                    temp_violation_witness2+="<data key=\"sourcecode\">[!(cond==0)]</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+str(line_no1)+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+str(line_no1)+"</data>\n"
                    temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    CountNode=CountNode+1
                    

                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no2)+"</data>\n"+"</node>\n"
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    temp_violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+str(line_no2)+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+str(line_no2)+"</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    
                    xml_graph_nodes.append(temp_violation_witness2)
                    
                    
                    try:
                        violation_witness2=''
                        for x in xml_graph_nodes:
                            violation_witness2+=x
                        #print len(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")
                        if len(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")<79000000: 
                            xml.dom.minidom.parseString(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")
                        
                    except Exception as e:
                        return violation_witness1+'\n'+"\n</graph>\n</graphml>\n"
                    
                    #print '$$$$$$$$$$$$$$$$$$$$$$$$$$3'
                    #print CountNode
                    #print '$$$$$$$$$$$$$$$$$$$$$$$$$$4'

                    return violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n"
        
        return None          








def processOutput10(outputs_list,filename,property):
    global line_no_stmt_map
    global back_line_no_stmt_map
    if line_no_stmt_map is None:
        return
    CountNode=0
    file_flag=True
    f_call_map={}
    e_current_assumption=None
    current_assumption=None
    current_assignment=None
    current_functioncall=None
    while_loop=None
    if property is None:
        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
    else:
        if '=' in property:
            value_names=property.split('=')
            fd = open(value_names[1])
            property = "".join(fd.readlines())
        else:
            property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
    if_cond_list=[]
    hashcode=sha1(filename)
    count=0
    
    xml_graph_nodes=[]
    #print outputs_list
    
    violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+filename+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">violation_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+filename+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"
    #violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\"?>"+"\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\""+"\n"+"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" +"\n"+"xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">"+"\n"+"<key id=\"programfile\" attr.name=\"programfile\" for=\"graph\"/>"+"\n"+"<key id=\"programhash\" attr.name=\"programhash\" for=\"graph\"/>"+"\n"+"<key id=\"sourcecodelang\" attr.name=\"sourcecodelang\" for=\"graph\"/>"+"\n"+"<key id=\"producer\" attr.name=\"producer\" for=\"graph\"/>"+"\n"+"<key id=\"specification\" attr.name=\"specification\" for=\"graph\"/>"+"\n"+"<key id=\"creationtime\" attr.name=\"creationtime\" for=\"graph\"/>"+"\n"+"<key id=\"witness-type\" attr.name=\"witness-type\" for=\"graph\"/>"+"\n"+"<key id=\"architecture\" attr.name=\"architecture\" for=\"graph\"/>"+"\n"+"<key id=\"entry\" attr.name=\"entry\" for=\"node\">"+"\n"+"<default>false</default>"+"\n"+"</key>"+"\n"+"<key id=\"nodetype\" attr.name=\"nodetype\" for=\"node\">"+"\n"+"<default>path</default>"+"\n"+"</key>"+"\n"+"<key id=\"violation\" attr.name=\"violation\" for=\"node\">"+"\n"+"<default>false</default>"+"\n"+"</key>"+"\n"+"<key id=\"invariant\" attr.name=\"invariant\" for=\"node\">"+"\n"+"<default>true</default>"+"\n"+"</key>"+"\n"+"<key id=\"endline\" attr.name=\"endline\" for=\"edge\"/>"+"\n"+"<key id=\"enterFunction\" attr.name=\"enterFunction\" for=\"edge\"/>"+"\n"+"<key id=\"startline\" attr.name=\"startline\" for=\"edge\"/>"+"\n"+"<key id=\"returnFrom\" attr.name=\"returnFrom\" for=\"edge\"/>"+"\n"+"<key id=\"assumption\" attr.name=\"assumption\" for=\"edge\"/>"+"\n"+"<key id=\"tokens\" attr.name=\"tokens\" for=\"edge\"/>"+"\n"+"<key id=\"control\" attr.name=\"control\" for=\"edge\"/>"+"\n"+"<key id=\"originfile\" attr.name=\"originfile\" for=\"edge\">"+"\n"+"<default>"+filename+"</default>"+"\n"+"</key>"+"\n"+"<key id=\"sourcecode\" attr.name=\"sourcecode\" for=\"edge\"/>"+"\n"+"<graph edgedefault=\"directed\">"+"\n"+"<data key=\"programfile\">"+filename+"</data>"+"\n"+"<data key=\"programhash\">"+hashcode+"</data>"+"\n"+"<data key=\"sourcecodelang\">C</data>"+"\n"+"<data key=\"producer\">VIAP</data>"+"\n"+"<data key=\"specification\">"+property+"</data>"+"\n"+"<data key=\"creationtime\">"+str(datetime.datetime.now().strftime("%y-%m-%dT%H:%MZ"))+"</data>"+"\n"+"<data key=\"witness-type\">violation_witness</data>"+"\n"+"<data key=\"architecture\">64bit</data>"+"\n"+"<node id=\"N0\">"+"\n"+"<data key=\"entry\">true</data>"+"\n"+"</node>"
    violation_witness2=''
    if len(outputs_list)>0:
        for output_list in outputs_list:
            if 'Assignment:' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            

                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            

                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            break
                    if_cond_list=[]
                    
                    
                    current_assignment=output_list
            elif 'FunctionCall:' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            break
                    if_cond_list=[]
                    #if current_functioncall is not None and current_functioncall==output_list:
                    #    terms=output_list.split(':')
                    #    if CountNode==0:
                    #        violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                    #        violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    #    else:
                    #        violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    #    violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    #    violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    #    violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    #    violation_witness2+="</edge>\n"
                    #    CountNode=CountNode+1
                        
                    
                    
                    
                    terms=output_list.split(':')
                    
                    temp_violation_witness2=''
                    
                    if CountNode==0:
                        temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    else:
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    if terms[-4].strip()=='#':
                        temp_violation_witness2+="<data key=\"sourcecode\">return "+terms[-2].strip()+";</data>\n"
                    else:
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-4].strip()+";</data>\n"
                        current_functioncall = output_list
                        
                    temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"enterFunction\">"+terms[-3]+"</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    CountNode=CountNode+1
                    xml_graph_nodes.append(temp_violation_witness2)
                    
            elif 'RecahCallPoint:' in output_list:
                    if current_assignment is not None:
                        temp_violation_witness2=''
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            xml_graph_nodes.append(temp_violation_witness2)
                            break
                    if_cond_list=[]
                    #terms=output_list.split(':')
                    
                    #temp_violation_witness2=''
                    
                    #if CountNode==0:
                    #    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                    #    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    #else:
                    #    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    #temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    #temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    #temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    #temp_violation_witness2+="</edge>\n"
                    #CountNode=CountNode+1
                    #xml_graph_nodes.append(temp_violation_witness2)

                    
            elif 'Return:' in output_list:
                
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            xml_graph_nodes.append(temp_violation_witness2)
                            break
                    if_cond_list=[]
                    terms=output_list.split(':')
                    
                    temp_violation_witness2=''
                    
                    if len(terms)==5:
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if terms[-4].strip()=='None':
                            temp_violation_witness2+="<data key=\"sourcecode\">return;</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">return "+terms[-4].strip()+";</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"returnFrom\">"+terms[-3]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)
                    else:
                        
                        #if CountNode==0:
                        #    violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        #    violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        #else:
                        #    violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                        #violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        #violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        #violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        #violation_witness2+="</edge>\n"
                        #CountNode=CountNode+1
                        
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if terms[-4].strip()=='None':
                            temp_violation_witness2+="<data key=\"sourcecode\">return;</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">return "+terms[-4].strip()+";</data>\n"
                            
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"returnFrom\">"+terms[-3]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)


                
            elif 'IfCondition1' in output_list or 'Else-IfCondition1' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                            
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1                
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                    if_cond_list.append(output_list)
            elif 'IfCondition2' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)                
                        current_assignment= None
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2) 
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            break
                            
                    if_cond_list=[]
                        
            elif 'WhileCondition' in output_list:
                    terms=output_list.split(':')
                    if int(terms[-1])==1:
                            
                        if current_assignment is not None:
                            
                            temp_violation_witness2=''
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                if while_loop is not None:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                            else:
                                if while_loop is not None:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                            
                            terms=current_assignment.split(':')
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            if 'for' in terms[-2].strip():
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                            else:
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="</edge>\n"
                    

                            CountNode=CountNode+1
                            
                            #print '$$$$$$$$$$$$$$$$$$$1'
                            #print temp_violation_witness2
                            #print '$$$$$$$$$$$$$$$$$$1'

                            current_assignment= None
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            
                        for x in if_cond_list:
                            terms=x.split(':')
                            
                            temp_violation_witness2=''
                            
                            if int(terms[-1])==0:
                            
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
        
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                #print '$$$$$$$$$$$$$$$$$$$2'
                                #print temp_violation_witness2
                                #print '$$$$$$$$$$$$$$$$$$2'

                                
                                xml_graph_nodes.append(temp_violation_witness2)
                            
                            else:
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                #print '$$$$$$$$$$$$$$$$$$$3'
                                #print temp_violation_witness2
                                #print '$$$$$$$$$$$$$$$$$$3'

                                
                                xml_graph_nodes.append(temp_violation_witness2)
                                
                                break
                        if_cond_list=[]
                            
                            
                            
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        while_loop='Current'
                        terms=output_list.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink"+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        CountNode=CountNode+1
                        
                        #print '$$$$$$$$$$$$$$$$$$$4'
                        #print temp_violation_witness2
                        #print '$$$$$$$$$$$$$$$$$$4'

                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    else:
                        
                        temp_violation_witness2=''
                        
                        if while_loop is not None:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                        if current_assignment is not None:
                            
                            temp_violation_witness2=''
                            
                            terms=current_assignment.split(':')
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            if 'for' in terms[-2].strip():
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                            else:
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="</edge>\n"
                    
                            CountNode=CountNode+1
                            #print '$$$$$$$$$$$$$$$$$$$5'
                            #print temp_violation_witness2
                            #print '$$$$$$$$$$$$$$$$$$5'

                            current_assignment= None
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            
                            
                        for x in if_cond_list:
                            terms=x.split(':')
                            
                            temp_violation_witness2=''
                            
                            if int(terms[-1])==0:
                            
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                #print '$$$$$$$$$$$$$$$$$$$6'
                                #print temp_violation_witness2
                                #print '$$$$$$$$$$$$$$$$$$6'

                                
                                xml_graph_nodes.append(temp_violation_witness2)
                            
                            else:
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                #print '$$$$$$$$$$$$$$$$$$$7'
                                #print temp_violation_witness2
                                #print '$$$$$$$$$$$$$$$$$$7'

                                
                                xml_graph_nodes.append(temp_violation_witness2)
                                break
                        if_cond_list=[]
                        
                        while_loop=None
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        
                        terms=output_list.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink"+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        CountNode=CountNode+1
                        
                        #print '$$$$$$$$$$$$$$$$$$$8'
                        #print temp_violation_witness2
                        #print '$$$$$$$$$$$$$$$$$$8'

                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    current_assignment= None
        
            elif '_FAILED' in output_list:
                if current_assignment is not None:
                    terms=current_assignment.split(':')
                    
                    temp_violation_witness2=''
                    
                    if CountNode==0:
                        temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    else:
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    if 'for' in terms[-2].strip():
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                    else:
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"

                    temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    
                    xml_graph_nodes.append(temp_violation_witness2)
                    
                    CountNode=CountNode+1
                    current_assignment= None
                    
                for x in if_cond_list:
                    terms=x.split(':')
                    
                    temp_violation_witness2=''
                    
                    if int(terms[-1])==0:
                            
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        CountNode=CountNode+1
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                            
                    else:
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        CountNode=CountNode+1
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                        break
                if_cond_list=[]
                            
                terms=output_list.split(':')
                
                temp_violation_witness2=''
                
                if terms[-1]=='1':
                    
                    
                    
                    
                    line_no,stmt = getLineNumber("__VERIFIER_error()",None)
                    temp_violation_witness2+="<node id=\"N"+str(CountNode)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no)+"</data>\n"+"</node>\n"
                    
                    temp_replace=xml_graph_nodes[-1].replace("<node id=\"N"+str(CountNode)+"\"/>",'')
                    
                    temp_violation_witness2+=temp_replace
                    
                    del xml_graph_nodes[-1]
                    #temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    #temp_violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                    #temp_violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                    #temp_violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                    #temp_violation_witness2+="</edge>\n"
                    xml_graph_nodes.append(temp_violation_witness2)

                    
                    try:
                        
                        violation_witness2=''
                        for x in xml_graph_nodes:
                            violation_witness2+=x
                            
                        #print len(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")
                        if len(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")<283487754: 
                            xml.dom.minidom.parseString(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")
                    
                    except Exception as e:
                        return violation_witness1+'\n'+"\n</graph>\n</graphml>\n"
                    
                    new_violation_witness= violation_witness1+"<node id=\"N"+str(CountNode-1)+"\"><data key=\"entry\">true</data></node>\n"+temp_violation_witness2+"\n</graph>\n</graphml>\n"

                    
                    return violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n",new_violation_witness
            elif '__VERIFIER_assert' in output_list:
                if current_assignment is not None:
                    
                    temp_violation_witness2=''
                    
                    terms=current_assignment.split(':')
                    
                    if CountNode==0:
                        temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    else:
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    if 'for' in terms[-2].strip():
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                    else:
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    
                    CountNode=CountNode+1
                    
                    xml_graph_nodes.append(temp_violation_witness2)
                    
                    current_assignment= None
                    
                for x in if_cond_list:
                    terms=x.split(':')
                    
                    temp_violation_witness2=''
                    
                    if int(terms[-1])==0:
                            
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                            
                        CountNode=CountNode+1
                            
                    else:
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+="</edge>\n"
                            
                        CountNode=CountNode+1
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        break
                if_cond_list=[]
                    
                            
                terms=output_list.split(':')
                temp_violation_witness2=''
                if terms[-1]=='0':
                    line_no,stmt = getLineNumberAssert(terms[-2])
                    line_no1,stmt1 = getLineNumber('! cond','__VERIFIER_assert')
                    line_no2,stmt2 = getLineNumber('__VERIFIER_error()','__VERIFIER_assert')
                    
                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                    temp_violation_witness2+="<data key=\"enterFunction\">__VERIFIER_assert</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    CountNode=CountNode+1
                    

                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    temp_violation_witness2+="<data key=\"sourcecode\">[cond==0]</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+str(line_no1)+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+str(line_no1)+"</data>\n"
                    temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                    temp_violation_witness2+="<data key=\"sourcecode\">[!(cond==0)]</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+str(line_no1)+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+str(line_no1)+"</data>\n"
                    temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    CountNode=CountNode+1
                    

                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no2)+"</data>\n"+"</node>\n"
                    
                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    temp_violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                    temp_violation_witness2+="<data key=\"startline\">"+str(line_no2)+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+str(line_no2)+"</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    
                    xml_graph_nodes.append(temp_violation_witness2)
                    
                    
                    try:
                        violation_witness2=''
                        for x in xml_graph_nodes:
                            violation_witness2+=x
                        #print len(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")
                        if len(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")<79000000: 
                            xml.dom.minidom.parseString(violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n")
                        
                    except Exception as e:
                        return violation_witness1+'\n'+"\n</graph>\n</graphml>\n"
                    
                    new_violation_witness= violation_witness1+"<node id=\"N"+str(CountNode-1)+"\"><data key=\"entry\">true</data></node>\n"+temp_violation_witness2+"\n</graph>\n</graphml>\n"

                    return violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n", new_violation_witness
        
        return None          












def getTrueconditionalStmt(blocks):
    
    statements = blocks.split('\n')
    list_stmt = []
    for statement in statements:
        if '<data key="control">condition-true</data>'==statement: 
            list_stmt.append(statement)
            return list_stmt
        if '<data key="control">condition-false</data>'==statement:
            list_stmt=[] 
        else:
            if '<data key="sourcecode">' in statement or '<data key="startline">' in statement or '<data key="endline">' in statement:
                list_stmt.append(statement)
    return None






def processOutput3(outputs_list,filename,property):
    global line_no_stmt_map
    global back_line_no_stmt_map
    if line_no_stmt_map is None:
        return
    CountNode=0
    file_flag=True
    f_call_map={}
    e_current_assumption=None
    current_assumption=None
    current_assignment=None
    current_functioncall=None
    while_loop=None
    if property is None:
        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
    else:
        if '=' in property:
            value_names=property.split('=')
            fd = open(value_names[1])
            property = "".join(fd.readlines())
        else:
            property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
    if_cond_list=[]
    hashcode=sha1(filename)
    count=0
    
    xml_graph_nodes=[]
    
    
    violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+filename+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">correctness_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+filename+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"
    #violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\"?>"+"\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\""+"\n"+"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" +"\n"+"xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">"+"\n"+"<key id=\"programfile\" attr.name=\"programfile\" for=\"graph\"/>"+"\n"+"<key id=\"programhash\" attr.name=\"programhash\" for=\"graph\"/>"+"\n"+"<key id=\"sourcecodelang\" attr.name=\"sourcecodelang\" for=\"graph\"/>"+"\n"+"<key id=\"producer\" attr.name=\"producer\" for=\"graph\"/>"+"\n"+"<key id=\"specification\" attr.name=\"specification\" for=\"graph\"/>"+"\n"+"<key id=\"creationtime\" attr.name=\"creationtime\" for=\"graph\"/>"+"\n"+"<key id=\"witness-type\" attr.name=\"witness-type\" for=\"graph\"/>"+"\n"+"<key id=\"architecture\" attr.name=\"architecture\" for=\"graph\"/>"+"\n"+"<key id=\"entry\" attr.name=\"entry\" for=\"node\">"+"\n"+"<default>false</default>"+"\n"+"</key>"+"\n"+"<key id=\"nodetype\" attr.name=\"nodetype\" for=\"node\">"+"\n"+"<default>path</default>"+"\n"+"</key>"+"\n"+"<key id=\"violation\" attr.name=\"violation\" for=\"node\">"+"\n"+"<default>false</default>"+"\n"+"</key>"+"\n"+"<key id=\"invariant\" attr.name=\"invariant\" for=\"node\">"+"\n"+"<default>true</default>"+"\n"+"</key>"+"\n"+"<key id=\"endline\" attr.name=\"endline\" for=\"edge\"/>"+"\n"+"<key id=\"enterFunction\" attr.name=\"enterFunction\" for=\"edge\"/>"+"\n"+"<key id=\"startline\" attr.name=\"startline\" for=\"edge\"/>"+"\n"+"<key id=\"returnFrom\" attr.name=\"returnFrom\" for=\"edge\"/>"+"\n"+"<key id=\"assumption\" attr.name=\"assumption\" for=\"edge\"/>"+"\n"+"<key id=\"tokens\" attr.name=\"tokens\" for=\"edge\"/>"+"\n"+"<key id=\"control\" attr.name=\"control\" for=\"edge\"/>"+"\n"+"<key id=\"originfile\" attr.name=\"originfile\" for=\"edge\">"+"\n"+"<default>"+filename+"</default>"+"\n"+"</key>"+"\n"+"<key id=\"sourcecode\" attr.name=\"sourcecode\" for=\"edge\"/>"+"\n"+"<graph edgedefault=\"directed\">"+"\n"+"<data key=\"programfile\">"+filename+"</data>"+"\n"+"<data key=\"programhash\">"+hashcode+"</data>"+"\n"+"<data key=\"sourcecodelang\">C</data>"+"\n"+"<data key=\"producer\">VIAP</data>"+"\n"+"<data key=\"specification\">"+property+"</data>"+"\n"+"<data key=\"creationtime\">"+str(datetime.datetime.now().strftime("%y-%m-%dT%H:%MZ"))+"</data>"+"\n"+"<data key=\"witness-type\">violation_witness</data>"+"\n"+"<data key=\"architecture\">64bit</data>"+"\n"+"<node id=\"N0\">"+"\n"+"<data key=\"entry\">true</data>"+"\n"+"</node>"
    violation_witness2=''
    if len(outputs_list)>0:
        for output_list in outputs_list:
            if 'Assignment:' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            break
                    if_cond_list=[]
                    
                    
                    current_assignment=output_list
            elif 'FunctionCall:' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            break
                    if_cond_list=[]
                    #if current_functioncall is not None and current_functioncall==output_list:
                    #    terms=output_list.split(':')
                    #    if CountNode==0:
                    #        violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                    #        violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    #    else:
                    #        violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    #    violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    #    violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    #    violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    #    violation_witness2+="</edge>\n"
                    #    CountNode=CountNode+1
                        
                    
                    
                    
                    terms=output_list.split(':')
                    
                    temp_violation_witness2=''
                    
                    if CountNode==0:
                        temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    else:
                        temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    if terms[-4].strip()=='#':
                        temp_violation_witness2+="<data key=\"sourcecode\">return "+terms[-2].strip()+";</data>\n"
                    else:
                        temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-4].strip()+";</data>\n"
                        current_functioncall = output_list
                        
                    temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    temp_violation_witness2+="<data key=\"enterFunction\">"+terms[-3]+"</data>\n"
                    temp_violation_witness2+="</edge>\n"
                    CountNode=CountNode+1
                    xml_graph_nodes.append(temp_violation_witness2)
                    
            elif 'RecahCallPoint:' in output_list:
                    if current_assignment is not None:
                        temp_violation_witness2=''
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            xml_graph_nodes.append(temp_violation_witness2)
                            break
                    if_cond_list=[]
                    #terms=output_list.split(':')
                    
                    #temp_violation_witness2=''
                    
                    #if CountNode==0:
                    #    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                    #    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                    #else:
                    #    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                    #temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                    #temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                    #temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                    #temp_violation_witness2+="</edge>\n"
                    #CountNode=CountNode+1
                    #xml_graph_nodes.append(temp_violation_witness2)

                    
            elif 'Return:' in output_list:
                
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            xml_graph_nodes.append(temp_violation_witness2)
                            break
                    if_cond_list=[]
                    terms=output_list.split(':')
                    
                    temp_violation_witness2=''
                    
                    if len(terms)==5:
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if terms[-4].strip()=='None':
                            temp_violation_witness2+="<data key=\"sourcecode\">return;</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">return "+terms[-4].strip()+";</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"returnFrom\">"+terms[-3]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)
                    else:
                        
                        #if CountNode==0:
                        #    violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                        #    violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        #else:
                        #    violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                        #violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        #violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        #violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        #violation_witness2+="</edge>\n"
                        #CountNode=CountNode+1
                        
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"

                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        if terms[-4].strip()=='None':
                            temp_violation_witness2+="<data key=\"sourcecode\">return;</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">return "+terms[-4].strip()+";</data>\n"
                            
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"returnFrom\">"+terms[-3]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)


                
            elif 'IfCondition1' in output_list or 'Else-IfCondition1' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                            
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1                
                        current_assignment= None
                        xml_graph_nodes.append(temp_violation_witness2)
                    if_cond_list.append(output_list)
            elif 'IfCondition2' in output_list:
                    if current_assignment is not None:
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        terms=current_assignment.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        
                        if 'for' in terms[-2].strip():
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                        else:
                            temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                        
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                        temp_violation_witness2+="</edge>\n"
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)                
                        current_assignment= None
                        
                    for x in if_cond_list:
                        terms=x.split(':')
                        
                        temp_violation_witness2=''
                        
                        if int(terms[-1])==0:
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2) 
                            
                        else:
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            else:
                                temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                            temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                            temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                            temp_violation_witness2+="</edge>\n"
                            
                            CountNode=CountNode+1
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            break
                            
                    if_cond_list=[]
                        
            elif 'WhileCondition' in output_list:
                    terms=output_list.split(':')
                    if int(terms[-1])==1:
                            
                        if current_assignment is not None:
                            
                            temp_violation_witness2=''
                            
                            if CountNode==0:
                                temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                if while_loop is not None:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                            else:
                                if while_loop is not None:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                            
                            terms=current_assignment.split(':')
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            if 'for' in terms[-2].strip():
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                            else:
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="</edge>\n"
                    

                            CountNode=CountNode+1
                            current_assignment= None
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            
                        for x in if_cond_list:
                            terms=x.split(':')
                            
                            temp_violation_witness2=''
                            
                            if int(terms[-1])==0:
                            
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
        
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                xml_graph_nodes.append(temp_violation_witness2)
                            
                            else:
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                xml_graph_nodes.append(temp_violation_witness2)
                                
                                break
                        if_cond_list=[]
                            
                            
                            
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                        while_loop='Current'
                        terms=output_list.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink"+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        CountNode=CountNode+1
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    else:
                        
                        temp_violation_witness2=''
                        
                        if while_loop is not None:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"><data key=\"loopHead\">true</data></node>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                        if current_assignment is not None:
                            
                            temp_violation_witness2=''
                            
                            terms=current_assignment.split(':')
                            temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                            if 'for' in terms[-2].strip():
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-3].strip()+"</data>\n"
                            else:
                                temp_violation_witness2+="<data key=\"sourcecode\">"+terms[-2].strip()+"</data>\n"
                            temp_violation_witness2+="<data key=\"startline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="<data key=\"endline\">"+terms[-1]+"</data>\n"
                            temp_violation_witness2+="</edge>\n"
                    
                            CountNode=CountNode+1
                            current_assignment= None
                            
                            xml_graph_nodes.append(temp_violation_witness2)
                            
                            
                            
                        for x in if_cond_list:
                            terms=x.split(':')
                            
                            temp_violation_witness2=''
                            
                            if int(terms[-1])==0:
                            
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                xml_graph_nodes.append(temp_violation_witness2)
                            
                            else:
                                if CountNode==0:
                                    temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                                else:
                                    temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink\">\n"
                                temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                                temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                                temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                                temp_violation_witness2+="</edge>\n"
                            
                                CountNode=CountNode+1
                                
                                xml_graph_nodes.append(temp_violation_witness2)
                                break
                        if_cond_list=[]
                        
                        while_loop=None
                        
                        temp_violation_witness2=''
                        
                        if CountNode==0:
                            temp_violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        else:
                            temp_violation_witness2+="<node id=\"N"+str(CountNode+1)+"\"/>\n"
                        
                        terms=output_list.split(':')
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"N"+str(CountNode+1)+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">[!("+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+")]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-false</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        temp_violation_witness2+="<edge source=\"N"+str(CountNode)+"\" target=\"sink"+"\">\n"
                        temp_violation_witness2+="<data key=\"sourcecode\">["+terms[-3].replace('>','&gt;').replace('<','&lt;').replace('&&','&amp;&amp;')+"]</data>\n"
                        temp_violation_witness2+="<data key=\"startline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"endline\">"+terms[-2]+"</data>\n"
                        temp_violation_witness2+="<data key=\"control\">condition-true</data>\n"
                        temp_violation_witness2+= "</edge>\n"
                        
                        CountNode=CountNode+1
                        
                        xml_graph_nodes.append(temp_violation_witness2)
                        
                    current_assignment= None
        
        try:
            violation_witness2=''
            for x in xml_graph_nodes:
                violation_witness2+=x
                
            if CountNode>7500:
                
                return violation_witness1+'\n'+"\n</graph>\n</graphml>\n"
            
        except Exception as e:
            return violation_witness1+'\n'+"\n</graph>\n</graphml>\n"
        
        return violation_witness1+'\n'+violation_witness2+"\n</graph>\n</graphml>\n"           










def sha1(fname):
    hash_sha1 = hashlib.sha1()
    with open(fname, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_sha1.update(chunk)
    return hash_sha1.hexdigest()






def reduceArraySize(program):
    #print program
    #print '--------------------------'
    status=False
    parser = GnuCParser()
    ast = parser.parse(program)
    try:
        for e in ast.ext:
            if type(e) is c_ast.FuncDef: 
                function_body = e.body
                if function_body.block_items is not None:
                    for x in function_body.block_items:
                        if type(x) is c_ast.Decl:
                            stmt = programPrint(x)
                            if ('[100000]' in stmt) and '_PROVE' not in stmt:
                                status=True
                            elif ('[200000]' in stmt) and '_PROVE' not in stmt:
                                status=True
                    e.body.block_items=reduceArraySizeBlock(function_body.block_items)
        return programPrint(ast),status
    except Exception as e:
        writeLogFile( "j2llogs.logs" ,str(e))
        #print str(e)
        return None,False
    
    
    
def reduceArraySizeNonDet(program):
    #print program
    #print '--------------------------'
    status=False
    parser = GnuCParser()
    ast = parser.parse(program)
    try:
        for e in ast.ext:
            if type(e) is c_ast.FuncDef: 
                function_body = e.body
                if function_body.block_items is not None:
                    updated_stmt=[]
                    for x in function_body.block_items:
                        if type(x) is c_ast.Decl and type(x.type) is c_ast.ArrayDecl and '_PROVE' not in x.name and '_ASSUME' not in x.name:
                            degree=0
                            dimensionmap={}
                            data_type,degree,structType=getArrayDetails(x,degree,dimensionmap)
                            if degree==1:
                                if is_number(dimensionmap.values()[0])!=True:
                                    var_str=dimensionmap.values()[0]
                                    if is_number(var_str[-1]):
                                        var_str = var_str[0:-1]
                                        updated_stmt.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=var_str),rvalue=c_ast.Constant(type='int',value='10')))
                                        updated_stmt.append(x)
                                        status=True
                                    else:
                                        updated_stmt.append(x)
                                else:
                                    updated_stmt.append(x)
                            elif degree==2:
                                #print dimensionmap.values()[0]
                                #print dimensionmap.values()[1]
                                if is_number(dimensionmap.values()[0])!=True and is_number(dimensionmap.values()[1])!=True:
                                    var_str1=dimensionmap.values()[0]
                                    var_str2=dimensionmap.values()[1]
                                    if is_number(var_str1[-1]) and is_number(var_str2[-1]):
                                        var_str1 = var_str1[0:-1]
                                        var_str2 = var_str2[0:-1]
                                        updated_stmt.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=var_str1),rvalue=c_ast.Constant(type='int',value='10')))
                                        updated_stmt.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=var_str2),rvalue=c_ast.Constant(type='int',value='10')))
                                        updated_stmt.append(x)
                                        status=True
                                    else:
                                        updated_stmt.append(x)
                                else:
                                    updated_stmt.append(x)

                            else:
                                updated_stmt.append(x)
                        else:
                            updated_stmt.append(x)
                    if status==True:
                        update_statements=[]
                        for statement in updated_stmt:
                            if type(statement) is c_ast.Decl:
                                stmt = programPrint(statement)
                                if '[100000]' in stmt:
                                    stmt=stmt.replace('[100000]','[10]')
                                    ast1 = parser.parse(stmt+';')
                                    update_statements.append(ast1.ext[0])
                                else:
                                    update_statements.append(statement)
                            else:
                                update_statements.append(statement)
                        e.body.block_items=update_statements
        return programPrint(ast),status
    except Exception as e:
        writeLogFile( "j2llogs.logs" ,str(e))
        #print str(e)
        return None,False

    
    




def reduceArraySizeBlock(statements):
    parser = GnuCParser()
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            stmt = programPrint(statement)
            if '[100000]' in stmt:
                stmt=stmt.replace('[100000]','[10]')
                ast1 = parser.parse(stmt+';')
                update_statements.append(ast1.ext[0])
            else:
                 update_statements.append(statement)
        elif type(statement) is c_ast.While:
            cond=reduceArrayStatement(statement.cond)
            stmts=reduceArraySizeBlock(statement.stmt.block_items)
            statement=c_ast.While(cond=cond, stmt=c_ast.Compound(block_items=stmts))
            update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(reduceArraySizeBlockIf(statement))
        elif type(statement) is c_ast.FuncCall:
            if statement.args is not None:
                para_list=[]
                for para_meter in statement.args.exprs:
                    para_list.append(reduceArrayStatement(para_meter))
                update_statements.append(c_ast.FuncCall(name=statement.name, args=c_ast.ExprList(exprs=para_list)))
            else:
                update_statements.append(statement)
        else:
            update_statements.append(statement)
    return update_statements


def reduceArraySizeBlockIf(statement):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=reduceArraySizeBlock(statement.iftrue.block_items)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=reduceArraySizeBlock(statement.iffalse.block_items)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=reduceArraySizeBlockIf(statement.iffalse)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=reduceArrayStatement(statement.cond), iftrue=If_stmt, iffalse=Else_stmt)
    
    
def reduceArrayStatement(statement):
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op, left=reduceArrayStatement(statement.left), right=reduceArrayStatement(statement.right))
    if type(statement) is c_ast.Constant:
        if statement.type=='int' and statement.value=='100000':
            return c_ast.Constant(type=statement.type,value='10')
        return statement
    else:
        return statement




def reduceLoopSize(program):
    #print program
    #print '--------------------------'
    status=False
    parser = GnuCParser()
    ast = parser.parse(program)
    try:
        for e in ast.ext:
            if type(e) is c_ast.FuncDef: 
                function_body = e.body
                if function_body.block_items is not None:
                    #for x in function_body.block_items:
                    #    x.show()
                    e.body.block_items=reduceLoopSizeBlock(function_body.block_items)
        return programPrint(ast)
        #return programPrint(ast),status
    except Exception as e:
        writeLogFile( "j2llogs.logs" ,str(e))
        print str(e)
        return None







def reduceLoopSizeBlock(statements):
    parser = GnuCParser()
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl and type(statement.type) is c_ast.ArrayDecl and '_PROVE' not in statement.name and '_ASSUME' not in statement.name:
            degree=0
            dimensionmap={}
            data_type,degree,structType=getArrayDetails(statement,degree,dimensionmap)
            #print data_type
            if degree==1:
                #statement.show()
                var_str=dimensionmap.values()[0]
                if is_number(var_str)==True:
                    var_int = int(var_str[0:2]+var_str[-1])
                    #var_int = int(var_str[0:-1])
                    #while var_int>10:
                    #    var_int=var_int/10
                    stmt = programPrint(statement)
                    if "["+var_str+"]" in stmt:
                        stmt=stmt.replace("["+var_str+"]","["+str(var_int)+"]")
                        #print stmt
                        ast1 = parser.parse(stmt+';')
                    update_statements.append(ast1.ext[0])
                    #update_statements.append(statement)
                #elif is_number(var_str[-1])==True:
                    
                else:
                    update_statements.append(statement)
            else:
                update_statements.append(statement)
        elif type(statement) is c_ast.While:
            cond=reduceLoopStatement(statement.cond)
            stmts=reduceLoopSizeBlock(statement.stmt.block_items)
            statement=c_ast.While(cond=cond, stmt=c_ast.Compound(block_items=stmts))
            update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(reduceLoopSizeBlockIf(statement))
        elif type(statement) is c_ast.Assignment:
            if type(statement.lvalue) is c_ast.ID and '_con_flag' in statement.lvalue.name:
                update_statements.append(c_ast.Assignment(op='=',lvalue=statement.lvalue,rvalue=reduceLoopStatement(statement.rvalue)))
            elif type(statement.lvalue) is c_ast.ID and type(statement.rvalue) is c_ast.Constant:
                update_statements.append(c_ast.Assignment(op='=',lvalue=statement.lvalue,rvalue=reduceLoopStatement(statement.rvalue)))
            else:
                update_statements.append(statement)
        elif type(statement) is c_ast.FuncCall:
            if statement.args is not None:
                if statement.name.name=='init_array':
                    para_list=[]
                    for para_meter in statement.args.exprs:
                        para_list.append(reduceLoopStatement(para_meter))
                    update_statements.append(c_ast.FuncCall(name=statement.name, args=c_ast.ExprList(exprs=para_list)))
                else:
                    update_statements.append(statement)
            else:
                update_statements.append(statement)
        else:
            update_statements.append(statement)
    return update_statements


def reduceLoopSizeBlockIf(statement):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=reduceLoopSizeBlock(statement.iftrue.block_items)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=reduceLoopSizeBlock(statement.iffalse.block_items)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=reduceLoopSizeBlockIf(statement.iffalse)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=reduceLoopStatement(statement.cond), iftrue=If_stmt, iffalse=Else_stmt)
    
    
def reduceLoopStatement(statement):
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op, left=reduceLoopStatement(statement.left), right=reduceLoopStatement(statement.right))
    elif type(statement) is c_ast.Constant:
        if statement.type=='int' and is_number(statement.value)==True:
            var_int = int(statement.value[0:2]+statement.value[-1])
            #while var_int>10:
            #    var_int=var_int/10
            return c_ast.Constant(type=statement.type,value=str(var_int))
        return statement
    else:
        return statement







def reduceArraySize1(program):
    #print program
    #print '--------------------------'
    status=False
    sub_status=False
    parser = GnuCParser()
    
    
    
    ast = parser.parse(program)
    try:
        for e in ast.ext:
            if type(e) is c_ast.FuncDef: 
                function_body = e.body
                if function_body.block_items is not None:
                    for x in function_body.block_items:
                        if type(x) is c_ast.Decl:
                            stmt = programPrint(x)
                            
                            if isSubsVar(x.name)==True:
                                sub_status=True

                            if ('[60]' in stmt) and '_PROVE' not in stmt:
                                status=True
                            elif ('[40]' in stmt) and '_PROVE' not in stmt:
                                status=True
                    e.body.block_items=reduceArraySizeBlock1(function_body.block_items)
                    return ast.ext[0],status,sub_status
        return None,False,False
    except Exception as e:
        writeLogFile( "j2llogs.logs" ,str(e))
        print str(e)
        return None,False,False



def reduceArraySizeBlock1(statements):
    parser = GnuCParser()
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            stmt = programPrint(statement)
            if '[60]' in stmt:
                stmt=stmt.replace('[60]','[10]')
                ast1 = parser.parse(stmt+';')
                update_statements.append(ast1.ext[0])
            elif '[40]' in stmt:
                stmt=stmt.replace('[40]','[10]')
                ast1 = parser.parse(stmt+';')
                update_statements.append(ast1.ext[0])
            else:
                 update_statements.append(statement)
        elif type(statement) is c_ast.While:
            cond=reduceArrayStatement1(statement.cond)
            stmts=reduceArraySizeBlock1(statement.stmt.block_items)
            statement=c_ast.While(cond=cond, stmt=c_ast.Compound(block_items=stmts))
            update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(reduceArraySizeBlockIf1(statement))
        elif type(statement) is c_ast.Assignment:
            update_statements.append(c_ast.Assignment(op=statement.op,lvalue=reduceArrayStatement1(statement.lvalue),rvalue=reduceArrayStatement1(statement.rvalue)))
        else:
            update_statements.append(statement)
    return update_statements


def reduceArraySizeBlockIf1(statement):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=reduceArraySizeBlock1(statement.iftrue.block_items)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=reduceArraySizeBlock1(statement.iffalse.block_items)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=reduceArraySizeBlockIf1(statement.iffalse)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=reduceArrayStatement1(statement.cond), iftrue=If_stmt, iffalse=Else_stmt)
    
    
def reduceArrayStatement1(statement):
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op, left=reduceArrayStatement1(statement.left), right=reduceArrayStatement1(statement.right))
    elif type(statement) is c_ast.Constant:
        if statement.type=='int' and (statement.value=='40'):
            return c_ast.Constant(type=statement.type,value='10')
        elif statement.type=='int' and (statement.value=='60'):
            return c_ast.Constant(type=statement.type,value='10')
        return statement
    elif type(statement) is c_ast.ArrayRef:
        return c_ast.ArrayRef(name=statement.name,subscript=reduceArrayStatement1(statement.subscript))
    else:
        return statement




















def process__VERIFIER_nondet_list(values__VERIFIER_nondet_list):
    value__VERIFIER_nondet_map={}
    for value__VERIFIER_nondet_list in values__VERIFIER_nondet_list:
        outputs_values = value__VERIFIER_nondet_list.split(':')
        key=outputs_values[0]+outputs_values[1]
        if key not in value__VERIFIER_nondet_map.keys():
            value__VERIFIER_nondet_map[key]=outputs_values
    return value__VERIFIER_nondet_map
        
    


#def processOutput(outputs_list):
#    map_asserts={}
#    value_others=None
#    for output_list in outputs_list:
#        if len(output_list)>1:
#            elements = output_list.split('\n')
#            temp_value_others,eval_value = getOtherValues(elements)
#            #print '%%%%%%%%%%%%%%%%%%%%%%%%%%%'
#            #print temp_value_others
#            #print '--------------------------'
#            #print eval_value
#            #print '%%%%%%%%%%%%%%%%%%%%%%%%%%%'
#            if temp_value_others is not None:
#                value_others=temp_value_others
#            if eval_value is not None and value_others is not None:
#                if '_PROVE' in eval_value and ':' in eval_value:
#                    element = eval_value.split(':')
#                    if int(element[1])==0:
#                        map_asserts[eval_value]=value_others
#                elif '_FAILED' in eval_value and ':' in eval_value:
#                    element = eval_value.split(':')
#                    if int(element[1])==1:
#                        map_asserts[eval_value]=value_others
#    return map_asserts



def processOutput(outputs_list):
    map_asserts={}
    for output_list in outputs_list:
        if len(output_list)>1:
            elements = output_list.split('\n')
            if '_PROVE' in elements[0] and ':' in elements[0]:
                element = elements[0].split(':')
                try:
                    if int(element[1])==0:
                        map_asserts[elements[0]]=elements[1:]
                except Exception as e:
                    print element[1]
            elif '_FAILED' in elements[0] and ':' in elements[0]:
                element = elements[0].split(':')
                try:
                    if int(element[1])==1:
                        map_asserts[elements[0]]=elements[1:]
                except Exception as e:
                    print element[1]

    return map_asserts

def getOtherValues(elements):
    otherelements=None
    eval_value=None
    for element in elements:
        if '_FAILED' not in element and '_PROVE' not in element and element.strip() !='':
            if otherelements is None:
                otherelements=[]
                otherelements.append(element)
            else:
                otherelements.append(element)
        elif '_FAILED' in element:
            eval_value=element 
        elif '_PROVE' in element:
            eval_value=element
    return otherelements,eval_value

    
def processOutputAssume(outputs_list):
    for output_list in outputs_list:
        if len(output_list)>1:
            elements = output_list.split('\n')
            if '_ASSUME' in elements[0] and ':' in elements[0]:
                element = elements[0].split(':')
                try:
                    if int(element[1])==0:
                        return elements[1:]
                except Exception as e:
                    print element[1]
    return None    




def translate(file_name):
	if not(os.path.exists(file_name)): 
        	print "File not exits"
		return

	start_time=current_milli_time()
	content=None
	global new_variable
	global fail_count
	global error_count
	global assume_count
        global assert_count
        global defineMap
        global defineDetaillist
        global map___VERIFIER_nondet
        global new_variable_array
        global counter_variableMap
        global counter_variableMap_Conf
        global sub_vfact
        global external_var_map
        global fun_call_map
        global current_fun_call
        global fun_substitution_map
        struct_map={}
        fail_count=0
        error_count=0
        assume_count=0
        assert_count=0
        map___VERIFIER_nondet={}
        new_variable_array={}
        counter_variableMap={}
        counter_variableMap_Conf={}
        fun_call_map={}
        fun_substitution_map={}
        function_vfacts=[]
        program_analysis=''
        program_analysis_decl=''
        program_analysis_var_decl=''
        current_fun_call=None
        struct_list=None
        type_struct_list=None
        
	try:
		fd = open(file_name)
		text = "".join(fd.readlines())
                defineMap={}
                content,defineMap=preProcessorHandling(text)
		text=replaceAddOperator(text)
    		filtered_program = SyntaxFilter.SLexer(text)
		filtered_program.build()
                
		content,struct_list,type_struct_list=filtered_program.filterSyntax()
                #print '--------------'
                #print content
                #print '--------------'
                #print struct_list
                #print '--------------'
                #print type_struct_list
                #print '--------------'
	except SyntaxFilter.SLexerError as e:
                print 'Error(Find Error in Input File)'
		#print(e)
		return
	text = r""" """+content
	parser = GnuCParser()
        
	#ast = parse_file(file_name, use_cpp=True)
        try:
            
            ast = parser.parse(text)
            for struct_str in struct_list:
                
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    struct_name=ast_struct.ext[0].type.name
                
                    isPointer=False
                
                    isTypedef=False
                
                    defName=None
                
                    variable_map=getVariablesC(ast_struct.ext[0].type.decls)
                
                    structobject = structclass(struct_name, isTypedef,  variable_map , defName, isPointer)
                
                    struct_map[struct_name]=structobject
                
            for struct_str in type_struct_list:
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    isPointer=False
                
                    isTypedef=False
                
                    struct_name = ast_struct.ext[0].name
                
                    if type(ast_struct.ext[0]) is c_ast.Typedef:
                        isTypedef=True
                    
                    if type(ast_struct.ext[0].type) is c_ast.PtrDecl:
                        isPointer=True
                    if isPointer==True:
                        struct_name = ast_struct.ext[0].type.type.type.name
                        defName = ast_struct.ext[0].type.type.declname
                        if struct_name is None and defName is not None:
                            struct_name=defName
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                    else:
                        struct_name = ast_struct.ext[0].type.declname
                        defName = ast_struct.ext[0].type.type.name
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                
        except Exception as e:
            print 'Error(Find Error in Input File)'
            writeLogFile( "j2llogs.logs" ,str(e))
            #print str(e)
            return
        #ast.show()
	generator = c_generator.CGenerator()
	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Translate \n"+"\nParameters--\n File Name--"+file_name+"\n")
	if ast is None:
		print "Error present in code. Please verify you input file"
	       	return
	if len(ast.ext)==0:
		print "Error present in code. Please verify you input file"
	        return
    	externalvarmap={}
        externalarraymap={}
	functionvarmap={}
	memberfunctionmap={}
	axiomeMap={}
	addition_array_map={}
	function_vfact_map={}
	witnessXml_map={}
	
    	counter=0 
        
    	for e in ast.ext:
    		if type(e) is c_ast.Decl:
    			if type(e.type) is c_ast.FuncDecl:
    				parametermap={}
    				structType=None
				new_e,pointer_list,array_list=pointerHandlingParameter(e)
				if new_e is None:
					function_decl=e
				else:
					function_decl=new_e
				if function_decl.type.args is not None:
					for param_decl in function_decl.type.args.params:
						if param_decl.name is not None:
							structType=None
				    			if type(param_decl.type) is c_ast.ArrayDecl:
				    	    			degree=0
				    	    			data_type,degree,structType=getArrayDetails(param_decl,degree)
								variable=variableclass(param_decl.name, data_type,None,degree,None,structType)
							else:
                                                                try:
                                                                    variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                except Exception as e:
                                                                    print 'Error(Translation to Intermate Intermediate)'
                                                                    writeLogFile( "j2llogs.logs" ,str(e))
                                                                    #print str(e)
                                                                    return
        						parametermap[param_decl.name]=variable

				membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,None,None,0,0,None,None,None)
				functionvarmap[membermethod.getMethodname()]=membermethod

    			elif type(e.type) is c_ast.TypeDecl:
                                #e.type.show()
            			var_type=None
            			initial_value=None
            			structType=None
                                e=change_var_name_decl(e)
            			for child in e.children():
                			if type(child[1].type) is c_ast.IdentifierType:
                    				var_type=child[1].type.names[0]
					else:
                    				
                    				initial_value=child[1].value
            			variable=variableclass(e.name, var_type,None,None,initial_value,structType)
                                program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
            			externalvarmap[e.name]=variable
                                external_var_map[e.name]=e.name
                        elif type(e.type) is c_ast.ArrayDecl:
                            program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
                            array_name=getArrayNameDecl(e.type)
                            externalarraymap[array_name]=change_var_name_decl(e)
                            external_var_map[array_name]=e.name
    		else:
    			if type(e) is c_ast.FuncDef:                          
    				parametermap={}
    				new_e,pointer_list,array_list=pointerHandlingParameter(e)
				if new_e is None:
					function_decl=e
				else:
					function_decl=new_e
    				
    				function_decl=e.decl
                                
                                
    				function_body = e.body
                                
                                if function_body.block_items is not None:
                                    #function_body=pointerHandlingDecl(function_body,pointer_list,array_list)
                                    statements=function_body.block_items
                                    statements=change_var_name(statements)
                                    function_body= c_ast.Compound(block_items=statements)
                                    localvarmap=getVariables(function_body)
                                    counter=counter+1
                                    if function_decl.type.args is not None:
                                            for param_decl in function_decl.type.args.params:
                                                    new_param_decl=declarationModifying(param_decl)
                                                    if new_param_decl is not None:
                                                        param_decl=new_param_decl
                                                    param_decl=change_var_name_decl(param_decl)
                                                    if param_decl.name is not None:
                                                            structType=None
                                                            if type(param_decl.type) is c_ast.ArrayDecl:
                                                                    #print param_decl.show()
                                                                    degree=0
                                                                    data_type,degree,structType=getArrayDetails(param_decl,degree)
                                                                    variable=variableclass(param_decl.name, data_type,None,degree,None,structType)
                                                            elif type(param_decl.type) is c_ast.PtrDecl:
                                                                    stmt=pointerToArray(param_decl)
                                                                    #print stmt.show()
                                                                    if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
                                                                            degree=0
                                                                            data_type,degree,structType=getArrayDetails(param_decl,degree)
                                                                            variable=variableclass(stmt.name, data_type,None,degree,None,structType)
                                                            else:				
                                                                    try:
                                                                        variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                    except Exception as e:
                                                                        print 'Error(Translation to Intermate Intermediate)'
                                                                        writeLogFile( "j2llogs.logs" ,str(e))
                                                                        #print str(e)
                                                                        return
                                                            parametermap[param_decl.name]=variable
    				if function_decl.name in functionvarmap.keys():
					if function_decl.name!='__VERIFIER_assert':
                                            membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,None,function_decl)
                                            functionvarmap[function_decl.name]=membermethod
				else:
					if function_decl.type.args is not None:
						for param_decl in function_decl.type.args.params:
                                                        new_param_decl=declarationModifying(param_decl)
                                                        if new_param_decl is not None:
                                                            param_decl=new_param_decl
                                                            param_decl=change_var_name_decl(param_decl)
							if param_decl.name is not None:
								structType=None
								if type(param_decl.type) is c_ast.ArrayDecl:
									degree=0
									data_type,degree,structType=getArrayDetails(param_decl,degree)
									variable=variableclass(param_decl.name, data_type,None,degree,None,structType)
								elif type(param_decl.type) is c_ast.PtrDecl:
									stmt=pointerToArray(param_decl)
									if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
										degree=0
										data_type,degree,structType=getArrayDetails(param_decl,degree)
										variable=variableclass(stmt.name, data_type,None,degree,None,structType)
								
								else:	
									try:
                                                                            variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                        except Exception as e:
                                                                            print 'Error(Translation to Intermate Intermediate)'
                                                                            writeLogFile( "j2llogs.logs" ,str(e))
                                                                            #print str(e)
                                                                            return
								parametermap[param_decl.name]=variable
					if function_decl.name!='__VERIFIER_assert' and function_decl.name!='exit':
                                            membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,copy.deepcopy(function_body),function_decl)
                                            functionvarmap[membermethod.getMethodname()]=membermethod

    	for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
    		body=membermethod.getBody()
    		if body is not None:
                    if body.block_items is not None: 
                        
                        try:

                            statements,pa_statements=programTransformation(body,functionvarmap,medthod)
                        
                            statements = updatePointerStruct(statements,struct_map)
                        
                            pa_statements = updatePointerStruct(pa_statements,struct_map)
                        
                        except Exception as e:
                            print 'Error(Translation to Intermate Intermediate)'
                            writeLogFile( "j2llogs.logs" ,str(e))
                            #print str(e)
                            return
                        
                        
                        
                        for temp_method in externalarraymap.keys():
                            if isVarPresnt(statements,temp_method)==True:
                                new_statements=[]
                                new_statements.append(externalarraymap[temp_method])
                                statements=construct_program(new_statements+statements)
                        body_comp = c_ast.Compound(block_items=statements)
                        statements,localvarmap=addAllExtVariables(statements,externalvarmap,localvarmap)
                        statements = translateStruct(statements,localvarmap,struct_map)
                        #statements=pointerHandling(statements,pointer_list,array_list)
                        body_comp = c_ast.Compound(block_items=statements)
                        
                        print '^^^^^^^^^^^^^^^^'
                        body_comp.show()
                        print '^^^^^^^^^^^^^^^^'
                        membermethod.setBody(body_comp)
                        membermethod.setLocalvar(localvarmap)
                        membermethod.setAnalysis_module(c_ast.Compound(block_items=pa_statements))
                    else:
                        membermethod.setBody(None)
                        membermethod.setLocalvar(None)
    		else:
		    membermethod.setBody(None)
    		    membermethod.setLocalvar(None)
    	#program in intermediate form
    	programeIF=[]

    	programeIF.append('-1')
    			
    	programeIF.append('prog')

    	programe_array=[]

    	variables_list_map={}
        
    	for medthod in functionvarmap.keys():
                f_vfact=[]
                f_vfact_para=[]
    		membermethod=functionvarmap[medthod]
                if membermethod.getreturnType() is not 'void':
                    f_vfact.append(medthod)
                    f_vfact_para.append(membermethod.getreturnType())
                    for iv in membermethod.getInputvar():
                        i_var=membermethod.getInputvar()[iv]
                        f_vfact_para.append(i_var.getVariableType())
                    f_vfact.append(len(f_vfact_para)-1)
                    f_vfact.append(f_vfact_para)
                    function_vfacts.append(f_vfact)

                
    		body=membermethod.getBody()
                
    		if body is not None:
    			new_variable={}
    			update_statements=[]
    			   		
	    		body_comp=body
	    		
	    		membermethod.setTempoary(body_comp)
	    		
	    		statements=body.block_items
	    		
	    		new_variable.clear()

	    		update_statements=[]
			
			for var in new_variable.keys():
				if isBoolVariable( var )==True:
			    	    	#temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
                                        temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
			    		update_statements.append(temp)
			    	else:
			    		if type(new_variable[var]) is tuple:
                                            type_stmt,t_degree=new_variable[var]
                                            program_temp=type_stmt+' '+var
                                            for x in range(0,t_degree):
                                                program_temp+='[]'
                                            program_temp+=';'
                                            temp_ast = parser.parse(program_temp)
                                            update_statements.append(temp_ast.ext[0])
                                        else:
                                            if var in new_variable_array.keys():
                                                type_stmt='int'
                                                t_degree=new_variable_array[var]
                                                program_temp=type_stmt+' '+var
                                                for x in range(0,t_degree):
                                                    program_temp+='[]'
                                                program_temp+=';'
                                                temp_ast = parser.parse(program_temp)
                                                update_statements.append(temp_ast.ext[0])
                                            else:
                                                temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                                                update_statements.append(temp)
			        	
			for statement in statements:
    				update_statements.append(statement)
                        
                        body_comp=c_ast.Compound(block_items=update_statements)
	    		
    			membermethod.setBody(body_comp)
   
    			
    			localvarmap=getVariables(body_comp)
    			
    			for var in externalvarmap.keys():
				variable=externalvarmap[var]
				localvarmap[var]=variable
    			
    			membermethod.setLocalvar(localvarmap)
    			membermethod=functionvarmap[medthod]
    			    			
    			function=[]
    			
    			function.append('-1')
    			
    			function.append('fun')    			
    			
    			functionName=[]
    			
    			allvariable={}
    			
    			for x in membermethod.getInputvar():
				allvariable[x]=membermethod.getInputvar()[x]
			for x in membermethod.getLocalvar():
        			allvariable[x]=membermethod.getLocalvar()[x]
    			if validationOfInput(allvariable)==True:
				print "Please Rename variable Name {S,Q,N,in,is} to other Name"
          			return
    			
    			try:
                            
                            program,variablesarray,fname,iputmap,opvariablesarray,module_analysis=translate2IntForm(membermethod.getMethodname(),membermethod.getreturnType(),membermethod.getBody(),membermethod.getInputvar(),membermethod.getTempoary(),membermethod.getAnalysis_module(),struct_map)

                        except Exception as e:
                            print 'Error(error occurred during translation intermediate format)'
                            writeLogFile( "j2llogs.logs" ,str(e))
                            return
		

			functionName.append(fname)
			
			for var in iputmap:
				functionName.append(str(var))
				
			function.append(functionName)
			
			function.append(program)

			programe_array.append(function)
		
			variables_list_map[fname]=variablesarray
			
			addition_array=[]
			
			addition_array.append(iputmap)
			
			addition_array.append(allvariable)
			
			addition_array.append(opvariablesarray)
			
			addition_array_map[fname]=addition_array
			
			memberfunctionmap[fname]=membermethod
                        
                        
			
			function_vfact_list=[]
			function_vfact=[]
			function_vfact.append(fname)
			function_vfact.append(len(iputmap))
			parameters_type=[]
			parameters_type.append(membermethod.getreturnType())
			for x in defineDetaillist:
				function_vfact_list.append(x)
					
			
			defineDetaillist=[]
			for element in iputmap.keys():
				variable=iputmap[element]
				if variable is not None:
					parameters_type.append(variable.getVariableType())
			function_vfact.append(parameters_type)
			function_vfact_list.append(function_vfact)
			function_vfact_map[fname]=function_vfact_list	
                        
                        resultfunction='__VERIFIER_nondet_int'
                        
                        filename=file_name
                        functionname=functionName
                        
                        witnessXml=getWitness(filename,fname,resultfunction)
                        witnessXml_map[fname]= witnessXml
                        if program_analysis is not None:
                            #print '###########################3'
                            #print membermethod.getFun_decl().show()
                            #print '###########################3'
                            program_decl=programPrint(membermethod.getFun_decl())
                            #print '^^^^^^^^^^^^^^^^^^^'
                            #print membermethod.getMethodname()
                            #print membermethod.getreturnType()
                            #print program_decl
                            #print '^^^^^^^^^^^^^^^^^^^'
                            if 'main' not in program_decl:
                                program_analysis_decl+=programPrint(membermethod.getFun_decl())+';\n'
                            program_analysis=program_decl+programPrint(module_analysis)+program_analysis
        
        
        program_analysis=program_analysis_var_decl+program_analysis
        programeIF.append(programe_array)
        
        #print '--------------------------------'
        #print programeIF
        #print '--------------------------------'
        #print variables_list_map
        #print '--------------------------------'
        #return
        try:
            f_map,o_map,a_map,cm_map,assert_map,assume_map,assert_key_map=translate1(programeIF,variables_list_map,1)
            
        except Exception as e:
            print 'Error(Translation Failed)'
            writeLogFile( "j2llogs.logs" ,str(e))
            print str(e)
            return




def translate2IM(file_name):
	if not(os.path.exists(file_name)): 
        	print "File not exits"
		return

	start_time=current_milli_time()
	content=None
	global new_variable
	global fail_count
	global error_count
	global assume_count
        global assert_count
        global defineMap
        global defineDetaillist
        global map___VERIFIER_nondet
        global new_variable_array
        global counter_variableMap
        global counter_variableMap_Conf
        global sub_vfact
        global external_var_map
        global fun_call_map
        global current_fun_call
        global fun_substitution_map
        struct_map={}
        fail_count=0
        error_count=0
        assume_count=0
        assert_count=0
        map___VERIFIER_nondet={}
        new_variable_array={}
        counter_variableMap={}
        counter_variableMap_Conf={}
        fun_call_map={}
        fun_substitution_map={}
        function_vfacts=[]
        program_analysis=''
        program_analysis_decl=''
        program_analysis_var_decl=''
        current_fun_call=None
        struct_list=None
        type_struct_list=None
        
	try:
		fd = open(file_name)
		text = "".join(fd.readlines())
                defineMap={}
                content,defineMap=preProcessorHandling(text)
		text=replaceAddOperator(text)
    		filtered_program = SyntaxFilter.SLexer(text)
		filtered_program.build()
                
		content,struct_list,type_struct_list=filtered_program.filterSyntax()
                #print '--------------'
                #print content
                #print '--------------'
                #print struct_list
                #print '--------------'
                #print type_struct_list
                #print '--------------'
	except SyntaxFilter.SLexerError as e:
                print 'Error(Find Error in Input File)'
		#print(e)
		return
	text = r""" """+content
	parser = GnuCParser()
        
	#ast = parse_file(file_name, use_cpp=True)
        try:
            
            ast = parser.parse(text)
            for struct_str in struct_list:
                
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    struct_name=ast_struct.ext[0].type.name
                
                    isPointer=False
                
                    isTypedef=False
                
                    defName=None
                
                    variable_map=getVariablesC(ast_struct.ext[0].type.decls)
                
                    structobject = structclass(struct_name, isTypedef,  variable_map , defName, isPointer)
                
                    struct_map[struct_name]=structobject
                
            for struct_str in type_struct_list:
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    isPointer=False
                
                    isTypedef=False
                
                    struct_name = ast_struct.ext[0].name
                
                    if type(ast_struct.ext[0]) is c_ast.Typedef:
                        isTypedef=True
                    
                    if type(ast_struct.ext[0].type) is c_ast.PtrDecl:
                        isPointer=True
                    if isPointer==True:
                        struct_name = ast_struct.ext[0].type.type.type.name
                        defName = ast_struct.ext[0].type.type.declname
                        if struct_name is None and defName is not None:
                            struct_name=defName
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                    else:
                        struct_name = ast_struct.ext[0].type.declname
                        defName = ast_struct.ext[0].type.type.name
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                
        except Exception as e:
            print 'Error(Find Error in Input File)'
            writeLogFile( "j2llogs.logs" ,str(e))
            #print str(e)
            return
        #ast.show()
	generator = c_generator.CGenerator()
	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Translate \n"+"\nParameters--\n File Name--"+file_name+"\n")
	if ast is None:
		print "Error present in code. Please verify you input file"
	       	return
	if len(ast.ext)==0:
		print "Error present in code. Please verify you input file"
	        return
    	externalvarmap={}
        externalarraymap={}
	functionvarmap={}
	memberfunctionmap={}
	axiomeMap={}
	addition_array_map={}
	function_vfact_map={}
	witnessXml_map={}
	
    	counter=0 
        
    	for e in ast.ext:
    		if type(e) is c_ast.Decl:
    			if type(e.type) is c_ast.FuncDecl:
    				parametermap={}
    				structType=None
				new_e,pointer_list,array_list=pointerHandlingParameter(e)
				if new_e is None:
					function_decl=e
				else:
					function_decl=new_e
				if function_decl.type.args is not None:
					for param_decl in function_decl.type.args.params:
						if param_decl.name is not None:
							structType=None
				    			if type(param_decl.type) is c_ast.ArrayDecl:
				    	    			degree=0
				    	    			data_type,degree,structType=getArrayDetails(param_decl,degree)
								variable=variableclass(param_decl.name, data_type,None,degree,None,structType)
							else:
                                                                try:
                                                                    variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                except Exception as e:
                                                                    print 'Error(Translation to Intermate Intermediate)'
                                                                    writeLogFile( "j2llogs.logs" ,str(e))
                                                                    #print str(e)
                                                                    return
        						parametermap[param_decl.name]=variable

				membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,None,None,0,0,None,None,None)
				functionvarmap[membermethod.getMethodname()]=membermethod

    			elif type(e.type) is c_ast.TypeDecl:
                                #e.type.show()
            			var_type=None
            			initial_value=None
            			structType=None
                                e=change_var_name_decl(e)
            			for child in e.children():
                			if type(child[1].type) is c_ast.IdentifierType:
                    				var_type=child[1].type.names[0]
					else:
                    				
                    				initial_value=child[1].value
            			variable=variableclass(e.name, var_type,None,None,initial_value,structType)
                                program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
            			externalvarmap[e.name]=variable
                                external_var_map[e.name]=e.name
                        elif type(e.type) is c_ast.ArrayDecl:
                            program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
                            array_name=getArrayNameDecl(e.type)
                            externalarraymap[array_name]=change_var_name_decl(e)
                            external_var_map[array_name]=e.name
    		else:
    			if type(e) is c_ast.FuncDef:                          
    				parametermap={}
    				new_e,pointer_list,array_list=pointerHandlingParameter(e)
				if new_e is None:
					function_decl=e
				else:
					function_decl=new_e
    				
    				function_decl=e.decl
                                
                                
    				function_body = e.body
                                
                                if function_body.block_items is not None:
                                    #function_body=pointerHandlingDecl(function_body,pointer_list,array_list)
                                    statements=function_body.block_items
                                    statements=change_var_name(statements)
                                    function_body= c_ast.Compound(block_items=statements)
                                    localvarmap=getVariables(function_body)
                                    counter=counter+1
                                    if function_decl.type.args is not None:
                                            for param_decl in function_decl.type.args.params:
                                                    new_param_decl=declarationModifying(param_decl)
                                                    if new_param_decl is not None:
                                                        param_decl=new_param_decl
                                                    param_decl=change_var_name_decl(param_decl)
                                                    if param_decl.name is not None:
                                                            structType=None
                                                            if type(param_decl.type) is c_ast.ArrayDecl:
                                                                    #print param_decl.show()
                                                                    degree=0
                                                                    data_type,degree,structType=getArrayDetails(param_decl,degree)
                                                                    variable=variableclass(param_decl.name, data_type,None,degree,None,structType)
                                                            elif type(param_decl.type) is c_ast.PtrDecl:
                                                                    stmt=pointerToArray(param_decl)
                                                                    #print stmt.show()
                                                                    if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
                                                                            degree=0
                                                                            data_type,degree,structType=getArrayDetails(param_decl,degree)
                                                                            variable=variableclass(stmt.name, data_type,None,degree,None,structType)
                                                            else:				
                                                                    try:
                                                                        variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                    except Exception as e:
                                                                        print 'Error(Translation to Intermate Intermediate)'
                                                                        writeLogFile( "j2llogs.logs" ,str(e))
                                                                        #print str(e)
                                                                        return
                                                            parametermap[param_decl.name]=variable
    				if function_decl.name in functionvarmap.keys():
					if function_decl.name!='__VERIFIER_assert':
                                            membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,None,function_decl)
                                            functionvarmap[function_decl.name]=membermethod
				else:
					if function_decl.type.args is not None:
						for param_decl in function_decl.type.args.params:
                                                        new_param_decl=declarationModifying(param_decl)
                                                        if new_param_decl is not None:
                                                            param_decl=new_param_decl
                                                            param_decl=change_var_name_decl(param_decl)
							if param_decl.name is not None:
								structType=None
								if type(param_decl.type) is c_ast.ArrayDecl:
									degree=0
									data_type,degree,structType=getArrayDetails(param_decl,degree)
									variable=variableclass(param_decl.name, data_type,None,degree,None,structType)
								elif type(param_decl.type) is c_ast.PtrDecl:
									stmt=pointerToArray(param_decl)
									if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
										degree=0
										data_type,degree,structType=getArrayDetails(param_decl,degree)
										variable=variableclass(stmt.name, data_type,None,degree,None,structType)
								
								else:	
									try:
                                                                            variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                        except Exception as e:
                                                                            print 'Error(Translation to Intermate Intermediate)'
                                                                            writeLogFile( "j2llogs.logs" ,str(e))
                                                                            #print str(e)
                                                                            return
								parametermap[param_decl.name]=variable
					if function_decl.name!='__VERIFIER_assert' and function_decl.name!='exit':
                                            membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,copy.deepcopy(function_body),function_decl)
                                            functionvarmap[membermethod.getMethodname()]=membermethod

    	for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
    		body=membermethod.getBody()
    		if body is not None:
                    if body.block_items is not None: 
                        
                        try:

                            statements,pa_statements=programTransformation(body,functionvarmap,medthod)
                        
                            statements = updatePointerStruct(statements,struct_map)
                        
                            pa_statements = updatePointerStruct(pa_statements,struct_map)
                            pa_statements = organizeInnerDeclartionMain(pa_statements)
                        
                        except Exception as e:
                            print 'Error(Translation to Intermate Intermediate)'
                            writeLogFile( "j2llogs.logs" ,str(e))
                            #print str(e)
                            return
                        
                        
                        
                        for temp_method in externalarraymap.keys():
                            if isVarPresnt(statements,temp_method)==True:
                                new_statements=[]
                                new_statements.append(externalarraymap[temp_method])
                                statements=construct_program(new_statements+statements)
                        body_comp = c_ast.Compound(block_items=statements)
                        statements,localvarmap=addAllExtVariables(statements,externalvarmap,localvarmap)
                        statements = translateStruct(statements,localvarmap,struct_map)
                        #statements=pointerHandling(statements,pointer_list,array_list)
                        body_comp = c_ast.Compound(block_items=statements)
                        membermethod.setBody(body_comp)
                        membermethod.setLocalvar(localvarmap)
                        membermethod.setAnalysis_module(c_ast.Compound(block_items=pa_statements))
                    else:
                        membermethod.setBody(None)
                        membermethod.setLocalvar(None)
    		else:
		    membermethod.setBody(None)
    		    membermethod.setLocalvar(None)
    	#program in intermediate form
    	programeIF=[]

    	programeIF.append('-1')
    			
    	programeIF.append('prog')

    	programe_array=[]

    	variables_list_map={}
        
    	for medthod in functionvarmap.keys():
                f_vfact=[]
                f_vfact_para=[]
    		membermethod=functionvarmap[medthod]
                if membermethod.getreturnType() is not 'void':
                    f_vfact.append(medthod)
                    f_vfact_para.append(membermethod.getreturnType())
                    for iv in membermethod.getInputvar():
                        i_var=membermethod.getInputvar()[iv]
                        f_vfact_para.append(i_var.getVariableType())
                    f_vfact.append(len(f_vfact_para)-1)
                    f_vfact.append(f_vfact_para)
                    function_vfacts.append(f_vfact)

                
    		body=membermethod.getBody()
                
    		if body is not None:
    			new_variable={}
    			update_statements=[]
    			   		
	    		body_comp=body
	    		
	    		membermethod.setTempoary(body_comp)
	    		
	    		statements=body.block_items
	    		
	    		new_variable.clear()

	    		update_statements=[]
			
			for var in new_variable.keys():
				if isBoolVariable( var )==True:
			    	    	#temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
                                        temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
			    		update_statements.append(temp)
			    	else:
			    		if type(new_variable[var]) is tuple:
                                            type_stmt,t_degree=new_variable[var]
                                            program_temp=type_stmt+' '+var
                                            for x in range(0,t_degree):
                                                program_temp+='[]'
                                            program_temp+=';'
                                            temp_ast = parser.parse(program_temp)
                                            update_statements.append(temp_ast.ext[0])
                                        else:
                                            if var in new_variable_array.keys():
                                                type_stmt='int'
                                                t_degree=new_variable_array[var]
                                                program_temp=type_stmt+' '+var
                                                for x in range(0,t_degree):
                                                    program_temp+='[]'
                                                program_temp+=';'
                                                temp_ast = parser.parse(program_temp)
                                                update_statements.append(temp_ast.ext[0])
                                            else:
                                                temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                                                update_statements.append(temp)
			        	
			for statement in statements:
    				update_statements.append(statement)
                        
                        body_comp=c_ast.Compound(block_items=update_statements)
	    		
    			membermethod.setBody(body_comp)
   
    			
    			localvarmap=getVariables(body_comp)
    			
    			for var in externalvarmap.keys():
				variable=externalvarmap[var]
				localvarmap[var]=variable
    			
    			membermethod.setLocalvar(localvarmap)
    			membermethod=functionvarmap[medthod]
    			    			
    			function=[]
    			
    			function.append('-1')
    			
    			function.append('fun')    			
    			
    			functionName=[]
    			
    			allvariable={}
    			
    			for x in membermethod.getInputvar():
				allvariable[x]=membermethod.getInputvar()[x]
			for x in membermethod.getLocalvar():
        			allvariable[x]=membermethod.getLocalvar()[x]
    			if validationOfInput(allvariable)==True:
				print "Please Rename variable Name {S,Q,N,in,is} to other Name"
          			return
    			
    			try:
                            
                            program,variablesarray,fname,iputmap,opvariablesarray,module_analysis=translate2IntForm(membermethod.getMethodname(),membermethod.getreturnType(),membermethod.getBody(),membermethod.getInputvar(),membermethod.getTempoary(),membermethod.getAnalysis_module(),struct_map)

                        except Exception as e:
                            print 'Error(error occurred during translation intermediate format)'
                            writeLogFile( "j2llogs.logs" ,str(e))
                            return
		

			functionName.append(fname)
			
			for var in iputmap:
				functionName.append(str(var))
				
			function.append(functionName)
			
			function.append(program)

			programe_array.append(function)
		
			variables_list_map[fname]=variablesarray
			
			addition_array=[]
			
			addition_array.append(iputmap)
			
			addition_array.append(allvariable)
			
			addition_array.append(opvariablesarray)
			
			addition_array_map[fname]=addition_array
			
			memberfunctionmap[fname]=membermethod
                        
                        
			
			function_vfact_list=[]
			function_vfact=[]
			function_vfact.append(fname)
			function_vfact.append(len(iputmap))
			parameters_type=[]
			parameters_type.append(membermethod.getreturnType())
			for x in defineDetaillist:
				function_vfact_list.append(x)
					
			
			defineDetaillist=[]
			for element in iputmap.keys():
				variable=iputmap[element]
				if variable is not None:
					parameters_type.append(variable.getVariableType())
			function_vfact.append(parameters_type)
			function_vfact_list.append(function_vfact)
			function_vfact_map[fname]=function_vfact_list	
                        
                        resultfunction='__VERIFIER_nondet_int'
                        
                        filename=file_name
                        functionname=functionName
                        
                        witnessXml=getWitness(filename,fname,resultfunction)
                        witnessXml_map[fname]= witnessXml
                        if program_analysis is not None:
                            #print '###########################3'
                            #print membermethod.getFun_decl().show()
                            #print '###########################3'
                            program_decl=programPrint(membermethod.getFun_decl())
                            #print '^^^^^^^^^^^^^^^^^^^'
                            #print membermethod.getMethodname()
                            #print membermethod.getreturnType()
                            #print program_decl
                            #print '^^^^^^^^^^^^^^^^^^^'
                            if 'main' not in program_decl:
                                program_analysis_decl+=programPrint(membermethod.getFun_decl())+';\n'
                            program_analysis=program_decl+programPrint(module_analysis)+program_analysis
        
        
        program_analysis=program_analysis_var_decl+program_analysis
        
        programeIF.append(programe_array)
        
        print 'Final Input To Translator'
        print 
        print 'Parameter One'
        print  programeIF
        print 'Parameter Two'
        print variables_list_map
        
        
    



def getZ3query(file_name):
	if not(os.path.exists(file_name)): 
        	print "File not exits"
		return

	start_time=current_milli_time()
	content=None
	global new_variable
	global fail_count
	global error_count
	global assume_count
        global assert_count
        global defineMap
        global defineDetaillist
        global map___VERIFIER_nondet
        global new_variable_array
        global counter_variableMap
        global counter_variableMap_Conf
        global sub_vfact
        global external_var_map
        global fun_call_map
        global current_fun_call
        global fun_substitution_map
        struct_map={}
        fail_count=0
        error_count=0
        assume_count=0
        assert_count=0
        map___VERIFIER_nondet={}
        new_variable_array={}
        counter_variableMap={}
        counter_variableMap_Conf={}
        fun_call_map={}
        fun_substitution_map={}
        function_vfacts=[]
        program_analysis=''
        program_analysis_decl=''
        program_analysis_var_decl=''
        current_fun_call=None
        struct_list=None
        type_struct_list=None
        
	try:
		fd = open(file_name)
		text = "".join(fd.readlines())
                defineMap={}
                content,defineMap=preProcessorHandling(text)
		text=replaceAddOperator(text)
    		filtered_program = SyntaxFilter.SLexer(text)
		filtered_program.build()
                
		content,struct_list,type_struct_list=filtered_program.filterSyntax()
                #print '--------------'
                #print content
                #print '--------------'
                #print struct_list
                #print '--------------'
                #print type_struct_list
                #print '--------------'
	except SyntaxFilter.SLexerError as e:
                print 'Error(Find Error in Input File)'
		#print(e)
		return
	text = r""" """+content
	parser = GnuCParser()
        
	#ast = parse_file(file_name, use_cpp=True)
        try:
            
            ast = parser.parse(text)
            for struct_str in struct_list:
                
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    struct_name=ast_struct.ext[0].type.name
                
                    isPointer=False
                
                    isTypedef=False
                
                    defName=None
                
                    variable_map=getVariablesC(ast_struct.ext[0].type.decls)
                
                    structobject = structclass(struct_name, isTypedef,  variable_map , defName, isPointer)
                
                    struct_map[struct_name]=structobject
                
            for struct_str in type_struct_list:
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    isPointer=False
                
                    isTypedef=False
                
                    struct_name = ast_struct.ext[0].name
                
                    if type(ast_struct.ext[0]) is c_ast.Typedef:
                        isTypedef=True
                    
                    if type(ast_struct.ext[0].type) is c_ast.PtrDecl:
                        isPointer=True
                    if isPointer==True:
                        struct_name = ast_struct.ext[0].type.type.type.name
                        defName = ast_struct.ext[0].type.type.declname
                        if struct_name is None and defName is not None:
                            struct_name=defName
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                    else:
                        struct_name = ast_struct.ext[0].type.declname
                        defName = ast_struct.ext[0].type.type.name
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                
        except Exception as e:
            print 'Error(Find Error in Input File)'
            writeLogFile( "j2llogs.logs" ,str(e))
            #print str(e)
            return
        #ast.show()
	generator = c_generator.CGenerator()
	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Translate \n"+"\nParameters--\n File Name--"+file_name+"\n")
	if ast is None:
		print "Error present in code. Please verify you input file"
	       	return
	if len(ast.ext)==0:
		print "Error present in code. Please verify you input file"
	        return
    	externalvarmap={}
        externalarraymap={}
	functionvarmap={}
	memberfunctionmap={}
	axiomeMap={}
	addition_array_map={}
	function_vfact_map={}
	witnessXml_map={}
	
    	counter=0 
        
    	for e in ast.ext:
    		if type(e) is c_ast.Decl:
    			if type(e.type) is c_ast.FuncDecl:
    				parametermap={}
    				structType=None
				new_e,pointer_list,array_list=pointerHandlingParameter(e)
				if new_e is None:
					function_decl=e
				else:
					function_decl=new_e
				if function_decl.type.args is not None:
					for param_decl in function_decl.type.args.params:
						if param_decl.name is not None:
							structType=None
				    			if type(param_decl.type) is c_ast.ArrayDecl:
				    	    			degree=0
				    	    			data_type,degree,structType=getArrayDetails(param_decl,degree)
								variable=variableclass(param_decl.name, data_type,None,degree,None,structType)
							else:
                                                                try:
                                                                    variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                except Exception as e:
                                                                    print 'Error(Translation to Intermate Intermediate)'
                                                                    writeLogFile( "j2llogs.logs" ,str(e))
                                                                    #print str(e)
                                                                    return
        						parametermap[param_decl.name]=variable

				membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,None,None,0,0,None,None,None)
				functionvarmap[membermethod.getMethodname()]=membermethod

    			elif type(e.type) is c_ast.TypeDecl:
                                #e.type.show()
            			var_type=None
            			initial_value=None
            			structType=None
                                e=change_var_name_decl(e)
            			for child in e.children():
                			if type(child[1].type) is c_ast.IdentifierType:
                    				var_type=child[1].type.names[0]
					else:
                    				
                    				initial_value=child[1].value
            			variable=variableclass(e.name, var_type,None,None,initial_value,structType)
                                program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
            			externalvarmap[e.name]=variable
                                external_var_map[e.name]=e.name
                        elif type(e.type) is c_ast.ArrayDecl:
                            program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
                            array_name=getArrayNameDecl(e.type)
                            externalarraymap[array_name]=change_var_name_decl(e)
                            external_var_map[array_name]=e.name
    		else:
    			if type(e) is c_ast.FuncDef:                          
    				parametermap={}
    				new_e,pointer_list,array_list=pointerHandlingParameter(e)
				if new_e is None:
					function_decl=e
				else:
					function_decl=new_e
    				
    				function_decl=e.decl
                                
                                
    				function_body = e.body
                                
                                if function_body.block_items is not None:
                                    #function_body=pointerHandlingDecl(function_body,pointer_list,array_list)
                                    statements=function_body.block_items
                                    statements=change_var_name(statements)
                                    function_body= c_ast.Compound(block_items=statements)
                                    localvarmap=getVariables(function_body)
                                    counter=counter+1
                                    if function_decl.type.args is not None:
                                            for param_decl in function_decl.type.args.params:
                                                    new_param_decl=declarationModifying(param_decl)
                                                    if new_param_decl is not None:
                                                        param_decl=new_param_decl
                                                    param_decl=change_var_name_decl(param_decl)
                                                    if param_decl.name is not None:
                                                            structType=None
                                                            if type(param_decl.type) is c_ast.ArrayDecl:
                                                                    #print param_decl.show()
                                                                    degree=0
                                                                    data_type,degree,structType=getArrayDetails(param_decl,degree)
                                                                    variable=variableclass(param_decl.name, data_type,None,degree,None,structType)
                                                            elif type(param_decl.type) is c_ast.PtrDecl:
                                                                    stmt=pointerToArray(param_decl)
                                                                    #print stmt.show()
                                                                    if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
                                                                            degree=0
                                                                            data_type,degree,structType=getArrayDetails(param_decl,degree)
                                                                            variable=variableclass(stmt.name, data_type,None,degree,None,structType)
                                                            else:				
                                                                    try:
                                                                        variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                    except Exception as e:
                                                                        print 'Error(Translation to Intermate Intermediate)'
                                                                        writeLogFile( "j2llogs.logs" ,str(e))
                                                                        #print str(e)
                                                                        return
                                                            parametermap[param_decl.name]=variable
    				if function_decl.name in functionvarmap.keys():
					if function_decl.name!='__VERIFIER_assert':
                                            membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,None,function_decl)
                                            functionvarmap[function_decl.name]=membermethod
				else:
					if function_decl.type.args is not None:
						for param_decl in function_decl.type.args.params:
                                                        new_param_decl=declarationModifying(param_decl)
                                                        if new_param_decl is not None:
                                                            param_decl=new_param_decl
                                                            param_decl=change_var_name_decl(param_decl)
							if param_decl.name is not None:
								structType=None
								if type(param_decl.type) is c_ast.ArrayDecl:
									degree=0
									data_type,degree,structType=getArrayDetails(param_decl,degree)
									variable=variableclass(param_decl.name, data_type,None,degree,None,structType)
								elif type(param_decl.type) is c_ast.PtrDecl:
									stmt=pointerToArray(param_decl)
									if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
										degree=0
										data_type,degree,structType=getArrayDetails(param_decl,degree)
										variable=variableclass(stmt.name, data_type,None,degree,None,structType)
								
								else:	
									try:
                                                                            variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                        except Exception as e:
                                                                            print 'Error(Translation to Intermate Intermediate)'
                                                                            writeLogFile( "j2llogs.logs" ,str(e))
                                                                            #print str(e)
                                                                            return
								parametermap[param_decl.name]=variable
					if function_decl.name!='__VERIFIER_assert' and function_decl.name!='exit':
                                            membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,copy.deepcopy(function_body),function_decl)
                                            functionvarmap[membermethod.getMethodname()]=membermethod

    	for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
    		body=membermethod.getBody()
    		if body is not None:
                    if body.block_items is not None: 
                        
                        try:

                            statements,pa_statements=programTransformation(body,functionvarmap,medthod)
                        
                            statements = updatePointerStruct(statements,struct_map)
                        
                            pa_statements = updatePointerStruct(pa_statements,struct_map)
                        
                        except Exception as e:
                            print 'Error(Translation to Intermate Intermediate)'
                            writeLogFile( "j2llogs.logs" ,str(e))
                            #print str(e)
                            return
                        
                        
                        
                        for temp_method in externalarraymap.keys():
                            if isVarPresnt(statements,temp_method)==True:
                                new_statements=[]
                                new_statements.append(externalarraymap[temp_method])
                                statements=construct_program(new_statements+statements)
                        body_comp = c_ast.Compound(block_items=statements)
                        statements,localvarmap=addAllExtVariables(statements,externalvarmap,localvarmap)
                        statements = translateStruct(statements,localvarmap,struct_map)
                        #statements=pointerHandling(statements,pointer_list,array_list)
                        body_comp = c_ast.Compound(block_items=statements)
                        membermethod.setBody(body_comp)
                        membermethod.setLocalvar(localvarmap)
                        membermethod.setAnalysis_module(c_ast.Compound(block_items=pa_statements))
                    else:
                        membermethod.setBody(None)
                        membermethod.setLocalvar(None)
    		else:
		    membermethod.setBody(None)
    		    membermethod.setLocalvar(None)
    	#program in intermediate form
    	programeIF=[]

    	programeIF.append('-1')
    			
    	programeIF.append('prog')

    	programe_array=[]

    	variables_list_map={}
        
    	for medthod in functionvarmap.keys():
                f_vfact=[]
                f_vfact_para=[]
    		membermethod=functionvarmap[medthod]
                if membermethod.getreturnType() is not 'void':
                    f_vfact.append(medthod)
                    f_vfact_para.append(membermethod.getreturnType())
                    for iv in membermethod.getInputvar():
                        i_var=membermethod.getInputvar()[iv]
                        f_vfact_para.append(i_var.getVariableType())
                    f_vfact.append(len(f_vfact_para)-1)
                    f_vfact.append(f_vfact_para)
                    function_vfacts.append(f_vfact)

                
    		body=membermethod.getBody()
                
    		if body is not None:
    			new_variable={}
    			update_statements=[]
    			   		
	    		body_comp=body
	    		
	    		membermethod.setTempoary(body_comp)
	    		
	    		statements=body.block_items
	    		
	    		new_variable.clear()

	    		update_statements=[]
			
			for var in new_variable.keys():
				if isBoolVariable( var )==True:
			    	    	#temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
                                        temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
			    		update_statements.append(temp)
			    	else:
			    		if type(new_variable[var]) is tuple:
                                            type_stmt,t_degree=new_variable[var]
                                            program_temp=type_stmt+' '+var
                                            for x in range(0,t_degree):
                                                program_temp+='[]'
                                            program_temp+=';'
                                            temp_ast = parser.parse(program_temp)
                                            update_statements.append(temp_ast.ext[0])
                                        else:
                                            if var in new_variable_array.keys():
                                                type_stmt='int'
                                                t_degree=new_variable_array[var]
                                                program_temp=type_stmt+' '+var
                                                for x in range(0,t_degree):
                                                    program_temp+='[]'
                                                program_temp+=';'
                                                temp_ast = parser.parse(program_temp)
                                                update_statements.append(temp_ast.ext[0])
                                            else:
                                                temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                                                update_statements.append(temp)
			        	
			for statement in statements:
    				update_statements.append(statement)
                        
                        body_comp=c_ast.Compound(block_items=update_statements)
	    		
    			membermethod.setBody(body_comp)
   
    			
    			localvarmap=getVariables(body_comp)
    			
    			for var in externalvarmap.keys():
				variable=externalvarmap[var]
				localvarmap[var]=variable
    			
    			membermethod.setLocalvar(localvarmap)
    			membermethod=functionvarmap[medthod]
    			    			
    			function=[]
    			
    			function.append('-1')
    			
    			function.append('fun')    			
    			
    			functionName=[]
    			
    			allvariable={}
    			
    			for x in membermethod.getInputvar():
				allvariable[x]=membermethod.getInputvar()[x]
			for x in membermethod.getLocalvar():
        			allvariable[x]=membermethod.getLocalvar()[x]
    			if validationOfInput(allvariable)==True:
				print "Please Rename variable Name {S,Q,N,in,is} to other Name"
          			return
    			
    			try:
                            
                            program,variablesarray,fname,iputmap,opvariablesarray,module_analysis=translate2IntForm(membermethod.getMethodname(),membermethod.getreturnType(),membermethod.getBody(),membermethod.getInputvar(),membermethod.getTempoary(),membermethod.getAnalysis_module(),struct_map)

                        except Exception as e:
                            print 'Error(error occurred during translation intermediate format)'
                            writeLogFile( "j2llogs.logs" ,str(e))
                            return
		

			functionName.append(fname)
			
			for var in iputmap:
				functionName.append(str(var))
				
			function.append(functionName)
			
			function.append(program)

			programe_array.append(function)
		
			variables_list_map[fname]=variablesarray
			
			addition_array=[]
			
			addition_array.append(iputmap)
			
			addition_array.append(allvariable)
			
			addition_array.append(opvariablesarray)
			
			addition_array_map[fname]=addition_array
			
			memberfunctionmap[fname]=membermethod
                        
                        
			
			function_vfact_list=[]
			function_vfact=[]
			function_vfact.append(fname)
			function_vfact.append(len(iputmap))
			parameters_type=[]
			parameters_type.append(membermethod.getreturnType())
			for x in defineDetaillist:
				function_vfact_list.append(x)
					
			
			defineDetaillist=[]
			for element in iputmap.keys():
				variable=iputmap[element]
				if variable is not None:
					parameters_type.append(variable.getVariableType())
			function_vfact.append(parameters_type)
			function_vfact_list.append(function_vfact)
			function_vfact_map[fname]=function_vfact_list	
                        
                        resultfunction='__VERIFIER_nondet_int'
                        
                        filename=file_name
                        functionname=functionName
                        
                        witnessXml=getWitness(filename,fname,resultfunction)
                        witnessXml_map[fname]= witnessXml
                        if program_analysis is not None:
                            #print '###########################3'
                            #print membermethod.getFun_decl().show()
                            #print '###########################3'
                            program_decl=programPrint(membermethod.getFun_decl())
                            #print '^^^^^^^^^^^^^^^^^^^'
                            #print membermethod.getMethodname()
                            #print membermethod.getreturnType()
                            #print program_decl
                            #print '^^^^^^^^^^^^^^^^^^^'
                            if 'main' not in program_decl:
                                program_analysis_decl+=programPrint(membermethod.getFun_decl())+';\n'
                            program_analysis=program_decl+programPrint(module_analysis)+program_analysis
        
        
        program_analysis=program_analysis_var_decl+program_analysis
        programeIF.append(programe_array)
        
        #print '--------------------------------'
        #print programeIF
        #print '--------------------------------'
        #print variables_list_map
        #print '--------------------------------'
        #return
        try:
            f_map,o_map,a_map,cm_map,assert_map,assume_map,assert_key_map=translate1(programeIF,variables_list_map,1)
            
        except Exception as e:
            print 'Error(Translation Failed)'
            writeLogFile( "j2llogs.logs" ,str(e))
            print str(e)
            return

        #Comment me to use Z3
        #return
        f_list=f_map.keys()
        cycle_list=[]
        programgraph_map=construct_graph(f_map,o_map,a_map,f_list)
        programgraph = graphclass.Graph(programgraph_map)
        if programgraph.cyclic():
            cycle_list=list(itertools.chain.from_iterable(programgraph.getAllNodesInCycle()))
        f_list=removeCycles(f_list,cycle_list)
        
                
        function_substitution_test('main',programgraph_map,f_map,o_map,a_map,cycle_list)
        
        #print '$$$$$$$$$$$$$$$$$$$$'
        
        #print cycle_list
        
        #print '$$$$$$$$$$$$$$$$$$$$'
        
        
        
        
        #for x in f_map.keys():
        #    f=f_map[x]
        #    o=o_map[x]
        #    a=a_map[x]
        #    f,o,a=updateAxoimsRecurrences(f,o,a,cycle_list)
        #    f_map[x]=f
        #    o_map[x]=o
        #    a_map[x]=a
        
        if type(f_map) is dict and type(o_map) is dict and type(a_map) is dict and type(cm_map) is dict and type(assert_key_map) is dict:
                for key in f_map.keys():
                        membermethod=functionvarmap[key]                        
                        #print membermethod.getreturnType()
        		f=f_map[key]
        		o=o_map[key]
        		a=a_map[key]
        		cm=cm_map[key]
                        
        		assert_list=assert_map[key]
        		assume_list=assume_map[key]
                        
                        assert_list=function_substitution_main_Assert(assert_list,f_map,o_map,a_map,cycle_list)
                        
                        
        		addition_array=addition_array_map[key]
        		
        		vfacts,constraints=getVariFunDetails(f,o,a,addition_array[1],addition_array[2])
        		
        		vfacts2=getVariFunDetails2(f,o,a,addition_array[1],constraints,assert_list,assume_list)
                        
                        
                        for x in a:
                            equ=getConstraints_Eq(x,addition_array[1],constraints)
                            if equ is not None:
                                constraints.append(equ)
        		vfacts=[]
        		for vfact in vfacts2:
        			vfacts.append(vfacts2[vfact])
                        
                        for x in function_vfacts:
                             vfacts.append(x)
        		#for element in function_vfact_map.keys():
        		#	function_vfact_list=function_vfact_map[element]
        		#	for x in function_vfact_list:
                        #                if x[0] not in vfacts2.keys():
                        #                    vfacts.append(x)
        		f,o,a,vfacts=organizeAxioms(f,o,a,vfacts)
        		axiom=axiomclass(f,o,a,membermethod.getInputvar(), vfacts, constraints,cm,assert_list,assume_list,addition_array[1])
        		axiomeMap[key]=axiom

                #print '#######'
                #print external_var_map
                #print program_analysis
                #print '#######'
                
                end_time=current_milli_time()
                print "Translation Time--"
		print end_time-start_time
                
                #results=AssetionAnalysis(program_analysis,program_analysis_decl)
                #print '$$$$$$$$$$$$$$$$$'
                #print results
                #print '$$$$$$$$$$$$$$$$$'
                results={}
                if results is None:
                    print 'Result--'
                    print 'Program Terminates Failed'
                    return
                for fun in assert_key_map.keys():
                    assert_key_list = assert_key_map[fun]
                    assert_list=axiomeMap[fun].getAsserts()
                    new_assert_key_list=[]
                    for result in results:
                        new_assert_list=[]
                        for key in assert_key_list:
                            if key in result:
                                assertion=assert_key_list[key]
                                if '_FAILED' not in key:
                                    print 'Assertion :'+wff2z3_update_postCond(assertion)
                                    print 'Counter Example'
                                    for term in results[result]:
                                        print term
                                    if assertion in assert_list:
                                        assert_list.remove(assertion)
                                else:
                                    for x in assert_list:
                                        if x[0]=='c1':
                                            if key in x[1][1][0]:
                                                print 'Assertion :'+wff2z3_update_postCond(x)
                                                assert_list.remove(x)
                                    print 'Counter Example'
                                    for term in results[result]:
                                        print term
                
                if len(f_list)==1 and 'main' in f_list:
                    axiommain=axiomeMap['main']
                    vfactsmain=axiommain.getVfact()
                    
                    a=axiommain.getOther_axioms()
                    assert_list_main=axiommain.getAsserts()
                    re_equations=[]
                    for fun in cycle_list:
                        axiom=axiomeMap[fun]
                        if axiom is not None:
                            equations=[]
                            list_exps={}
                            f=axiom.getFrame_axioms()
                            o=axiom.getOutput_equations()
                            witnessXml= witnessXml_map[fun]
                            assert_list=axiom.getAsserts()
                            vfacts=axiom.getVfact()
                            inputvar=axiom.getInputvariable()
                            for x in o:
                                equation=[]
                                equation.append('R')
                                equation.append(inputvar.keys())
                                print '%%%%%%%%%%%%%'
                                print o[x][1]
                                print '%%%%%%%%%%%%%'
                                equation.append(o[x][1])
                                equation.append(o[x][2])
                                a.append(equation)
                                equations.append(copy.deepcopy(equation))
                                re_equations.append(copy.deepcopy(equation))
                            for x in axiommain.getOutput_equations():
                                e=axiommain.getOutput_equations()[x]
                                if '_FAILED' in x and e[0]=='e':
                                    getRecuresiveFunDef(e[2],cycle_list,list_exps)
                            for vfact in vfacts:
                                #if vfact[0][-1]!='1' and vfact[0]!=fun:
                                if vfact[0][0:len(vfact[0])-1] not in inputvar and vfact[0]!=fun:
                                    vfactsmain.append(vfact)
                                if vfact[0][-1]=='1' and '_FAILED1' in vfact[0]:
                                    vfactsmain.append(vfact)
                            for list_exp in list_exps:
                                status=prove_assert_tactic6(equations,list_exps[list_exp],cycle_list,vfactsmain,witnessXml)
                                if status is not None:
                                    a.append(status)
                            for tassert in assert_list:
                                assert_list_main.append(tassert)
                    
                    #print '--------------------'
                    #print re_equations
                    vfactsmain=axiommain.getVfact()
                    a=axiommain.getOther_axioms()
                    #for x in axiommain.getOutput_equations():
                    #    if '_FAILED' in x:
                    #        e=axiommain.getOutput_equations()[x][2]
                    #        #print e
                    #        addition_equs = prove_assert_tactic7(e,re_equations,cycle_list,vfactsmain,witnessXml)
                    #        for addition_equ in addition_equs:
                    #            a.append(addition_equ)
                    axiommain.setOther_axioms(a)
                    axiomeMap['main']=axiommain
                    #print '--------------------'
                #return

                program=programclass(file_name, memberfunctionmap , externalvarmap, axiomeMap, witnessXml_map) 
                getZ3query_auto_process(program)
                #return program
        else:
        	print 'Error in  Translation'





def getZ3query_auto_process(program):
        start_time=current_milli_time()
	if program is None:
		print "Something is Wrong"
		return
	if program is not None:
		print '\n----Proving Process----\n'
		for name in program.getAxiomeMap():
                        if 'main' in name:
                            print
                            print 'Function Name--'+name
                        
                            axiom=program.getAxiomeMap()[name]
                            
                            witnessXml=program.getWitnessXmlMap()[name]
                            #writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+str(post_condition)+"\n Strategy--Direct")
                            post_condition={}
                            for w in axiom.getAsserts():
                                    #print '-------------'
                                    #print w
                                    #print wff2string1(w)
                                    #print w[-1][:1]
                                    #print '-------------'
                                    if w[-1][:1]==['ite']:
                                                w[-1]=simplifyPostCondition(w[-1])
                                                
                                    if w[0]=='i1':
                                        
                                            var_cstr_map={}
                                            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                            list_var_str=qualifier_list(var_cstr_map.keys())
                                            list_cstr_str=cstr_list(var_cstr_map.values())
                                            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                            if list_var_str is not None and list_cstr_str is not None:
                                                    if w[0] == 'i1':
                                                            post_condition["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                    else:
                                                            post_condition['ForAll(['+list_var_str+'],'+rhs+")"]=w
                                            else:
                                                    post_condition[rhs]=w
                                    elif w[0]=='c1':
                                            var_cstr_map={}
                                            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                            list_var_str=qualifier_list(var_cstr_map.keys())
                                            list_cstr_str=cstr_list(var_cstr_map.values())
                                            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                            if list_var_str is not None and list_cstr_str is not None:
                                                    if w[0] == 'i1':
                                                            post_condition["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                    else:
                                                            post_condition['ForAll(['+list_var_str+'],'+rhs+")"]=w
                                            else:
                                                    post_condition[rhs]=w
                                    else:
                                            if w[0]!='i0':
                                                    var_cstr_map={}
                                                    rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                                    list_var_str=qualifier_list(var_cstr_map.keys())
                                                    list_cstr_str=cstr_list(var_cstr_map.values())
                                                    if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                                            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                                    if list_var_str is not None and list_cstr_str is not None:
                                                            if w[0] == 'i1':
                                                                    post_condition["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                            else:
                                                                    post_condition['ForAll(['+list_var_str+'],'+rhs+")"]=w
                                                    else:
                                                            post_condition[rhs]=w

                            for p_condition in post_condition.keys():
                                    axiom.setAsserts((p_condition,post_condition[p_condition]))
                                    status=getZ3query_assert_tactic1(axiom,witnessXml)
                                    
                end_time=current_milli_time()
                print "Time Taken by Proving Process--"
                print end_time-start_time



def getZ3query_assert_tactic1(axiom,witnessXml):
	pre_condition=[]
	post_condition=[]
	
	str_value,word=axiom.getAsserts()

	#post_condition.append(str_value)
        post_condition.append(wff2z3_update(word))

			
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
			
	for x in post_condition:
		print('\nAssertion To Prove:'+x)
		temp_post_condition=[]
		temp_post_condition.append(x)
		if post_condition is not None:
			start_time=current_milli_time()
			writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
			getZ3query_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
			#status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())




def getZ3query_update(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
	frame_axioms=eqset2constraintlist_update(f)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(o)

	subs_list=eqset2subs_list(o)
	
	
	for x in out_axioms:
		constraint_list.append(x)
	for x in a: 
        	equations=wff2z3_update(x)
        	equations_sp=None
                constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
	for conclusion in conclusions:
		writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
		if conclusion is None:
			return "Failed to Prove"
		if "factorial" in conclusion:
			cfact=eval("['factorial',1,['int','int']]")
			vfact.append(cfact)
		getZ3query_query2z3(constraint_list,conclusion,vfact,inputmap,witnessXml)




"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def getZ3query_query2z3(constraint_list,conclusion,vfact,inputmap,witnessXml):
	pythonProgram="from z3 import *\n"
	pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
	pythonProgram+="\t_p1=Int('_p1')\n"
	pythonProgram+="\t_p2=Int('_p2')\n"
	pythonProgram+="\t_n=Int('_n')\n"
	pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
	pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"


	status=""
	for [x,k,l] in vfact:
		if k==0:
			if '_PROVE' not in x or '_ASSUME' not in x:
				if l[0]=="int":
					if '_N' in x:
						pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
					else:				
						pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="double":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
				elif l[0]=="float":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        	elif l[0]=="Bool":
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="constant":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
				elif l[0]=="array":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
				else:
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
		else:
			if '_PROVE' not in x or '_ASSUME' not in x:
				pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
				for e in l:
					if e=="int":
						pythonProgram+=",IntSort()"
					elif e=="array":
						pythonProgram+=",arraySort"
					else:
						pythonProgram+=",RealSort()"
			pythonProgram+=")\n"
	power_flag=False
	for equation in constraint_list:
		if '**' in equation or 'power' in equation:
			power_flag=True
	if '**' in conclusion or 'power' in conclusion:
		power_flag=True
	if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
                pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
		pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

	pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
	pythonProgram+="\t_s.set(\"timeout\","+str(TIMEOUT)+")\n"
	for equation in constraint_list:
		pythonProgram+="\t_s.add("+str(equation)+")\n"
	finalProgram=pythonProgram
	#finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
	finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tif sat==_s.check():\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\t\twitnessXmlStr="+str(witnessXml)+"\n"+"\t\tmiddle=''\n"+"\t\tfor element in _s.model():\n"+"\t\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\t\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\t\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\t\tfile.close()\n"+"\telif unsat==_s.check():\n"+"\t\t_s.check()\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#print finalProgram
	print "\nQuery to z3 \n"
	print str(finalProgram)







def translate2IntForm(function_name,function_type,function_body,parametermap,tempory,function_body_pa,struct_map):
    global current_fun_call
    if function_body is None: 
        print "Empty Body"
	return None
        
    start_time=current_milli_time()
    
    statements=function_body.block_items
       
    localvarmap=getVariables(function_body)
    
    
    print 'Program Body'
    
    generator = c_generator.CGenerator()
    
    
    print(generator.visit(tempory))
    #print(generator.visit(function_body))
    
    
    
    membermethod=membermethodclass(function_name,function_type,parametermap,localvarmap,function_body,0,0,tempory,function_body_pa,None)

    input_value_extract=constructProgAssertAnalysis2(copy.deepcopy(membermethod.getAnalysis_module()),localvarmap,membermethod.getInputvar(),membermethod.getMethodname())

    
    membermethod.setAnalysis_module(constructProgAssertAnalysis(membermethod.getAnalysis_module(),localvarmap,membermethod.getInputvar()))
    
    
    #print '!!!!!!!!!!!!!!!!!!'
    #print(generator.visit(membermethod.getAnalysis_module()))
    #print '!!!!!!!!!!!!!!!!!!'

    
    print "Function Name:"
    print membermethod.getMethodname()
    print "Return Type:"
    print membermethod.getreturnType()
    print "Input Variables:"
    var_list="{"
    for x in membermethod.getInputvar():

        if membermethod.getInputvar()[x].getDimensions() is not None and len(membermethod.getInputvar()[x].getDimensions())>0:
            if membermethod.getInputvar()[x].getStructType() is None:
                var_list+=' '+x+':array'
            else:
                var_list+=' '+x+':array'
                #var_list+=' '+x+':'+membermethod.getInputvar()[x].getStructType()
	else:
	    var_list+=' '+x+':'+membermethod.getInputvar()[x].getVariableType()
    var_list+='}'
    print var_list
    print "Local Variables:"
    var_list="{"
    for x in membermethod.getLocalvar():
        if membermethod.getLocalvar()[x].getDimensions() is not None and len(membermethod.getLocalvar()[x].getDimensions())>0:
            if membermethod.getLocalvar()[x].getStructType() is None:
                var_list+=' '+x+':array'
            else:
                var_list+=' '+x+':array'
                #var_list+=' '+x+':'+membermethod.getLocalvar()[x].getStructType()
	else:
            var_list+=' '+x+':'+membermethod.getLocalvar()[x].getVariableType()
    var_list+='}'
    print var_list
    allvariable={}
    program_dec_start=""
    program_dec_end=""
    for lvap in localvarmap:
        var=localvarmap[lvap]
        if var is not None and var.getInitialvalue() is not None:
            #print var.getInitialvalue()
            #print type(var.getInitialvalue())
            #type(var.getInitialvalue()).show()
            
	    #if type(var.getInitialvalue()) is not c_ast.BinaryOp and '__VERIFIER_nondet' in var.getInitialvalue():
	    #	defineDetailtemp=[]
	    #	parameter_list=[]
	    #	parameter_list.append('int')
	    #	defineDetailtemp.append(var.getInitialvalue())
	    #	defineDetailtemp.append(0)
	    #	defineDetailtemp.append(parameter_list)
	    # 	defineDetaillist.append(defineDetailtemp)
            if program_dec_start=="":
            	if type(var.getInitialvalue()) is c_ast.BinaryOp:
            	        program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+expressionCreator_C(var.getInitialvalue())+"]"
                	program_dec_end="]"
            	else:
            		if is_hex(str(var.getInitialvalue())) is not None:
                		program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+is_hex(str(var.getInitialvalue()))+"')]"
                	else:
                		program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue())+"')]"
                	program_dec_end="]"
            else:
            	if type(var.getInitialvalue()) is c_ast.BinaryOp:
            	        program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+expressionCreator_C(var.getInitialvalue())+"]"
                	program_dec_end+="]"
            	else:
            		if is_hex(str(var.getInitialvalue())) is not None:
                		program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+is_hex(str(var.getInitialvalue()))+"')]"
                	else:
                		program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue())+"')]"
                	program_dec_end+="]"

    
    for x in membermethod.getInputvar():
        allvariable[x]=membermethod.getInputvar()[x]
    for x in membermethod.getLocalvar():
        allvariable[x]=membermethod.getLocalvar()[x]
    
    
    current_fun_call = membermethod.getMethodname()
       
    expressions=organizeStatementToObject_C(statements)
    
    primeStatement(expressions)
    variablesarray={}
    opvariablesarray={}
    count=0
    arrayFlag=False
    
    struct_var_def_map={}
    
    
    
    for variable in allvariable:
        count+=1
        if allvariable[variable].getDimensions() is not None and len(allvariable[variable].getDimensions())>0:
            if allvariable[variable].getStructType() is None:
                variablesarray[variable]=eval("['_y"+str(count)+"','array']")
                opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','array']")
                list_parameter="'array'"
                for i in range(0, len(allvariable[variable].getDimensions())):
                    if list_parameter=='':
                        list_parameter="'int'"
                    else:
                        list_parameter+=",'int'"
                list_parameter+=",'"+allvariable[variable].getVariableType()+"'"
                #key1=str(allvariable[variable].getDimensions())+'array'
                key1='d'+str(len(allvariable[variable].getDimensions()))+'array'
                arrayFlag=True
                if key1 not in variablesarray.keys():
                    count+=1
                    variablesarray[key1]=eval("['_y"+str(count)+"',"+list_parameter+"]")
                    opvariablesarray[key1+"1"]=eval("['_y"+str(count)+"',"+list_parameter+"]")
            else:
                variablesarray[variable]=eval("['_y"+str(count)+"','array']")
                opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','array']")
                #variablesarray[variable]=eval("['_y"+str(count)+"','"+allvariable[variable].getStructType()+"']")
                #opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','"+allvariable[variable].getStructType()+"']")
                if allvariable[variable].getStructType() in struct_map.keys():
                    var_mem_list=struct_map[allvariable[variable].getStructType()]
                    print var_mem_list.getName()
                    for var_mem in var_mem_list.getVariablemap().keys():
                        member_var=var_mem_list.getVariablemap()[var_mem]
                        struct_key=allvariable[variable].getStructType()+"_"+member_var.getVariablename()
                        if struct_key not in struct_var_def_map.keys():
                            count+=1
                            struct_var_def_map[struct_key]=eval("['_y"+str(count)+"',"+"'"+allvariable[variable].getStructType()+"','"+member_var.getVariableType()+"'"+"]")

                    #for var_men in var_mem_list:
                    #    print var_men
                    #    var_member=var_mem_list[var_men]
                    #    print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
                    #    print var_member
                    #    print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
                
        else:
            variablesarray[variable]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")
            opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")

    
    for element in struct_var_def_map.keys():
         variablesarray[element]=struct_var_def_map[element]
         opvariablesarray[element+"1"]=struct_var_def_map[element]
            
    if program_dec_start=="":
        str_program=programToinductiveDefination_C(expressions , allvariable)
    else:
        try:
            str_program=program_dec_start+','+programToinductiveDefination_C(expressions , allvariable)+program_dec_end
        except Exception as e:
            print e
    
    
    program=eval(str_program)
    return program,variablesarray,membermethod.getMethodname(),membermethod.getInputvar(),opvariablesarray,membermethod.getAnalysis_module(),input_value_extract





def translate2IntForm_Java(function_name,function_type,function_body,parametermap,localvarmap,class_variable,class_name):
    if function_body is None: 
        print "Empty Body"
	return None
        
    start_time=current_milli_time()
    
    statements=function_body.block_items
       
    #localvarmap=getVariables(function_body)
    
    
    print 'Program Body'
    
    generator = c_generator.CGenerator()
    
    
    print(generator.visit(function_body))

    membermethod=membermethodclass(function_name,function_type,parametermap,localvarmap,function_body,0,0,None)
    print "Function Name:"
    print membermethod.getMethodname()
    print "Return Type:"
    print membermethod.getreturnType()
    print "Input Variables:"
    var_list="{"
    for x in membermethod.getInputvar():
        if membermethod.getInputvar()[x].getDimensions()>0:
            var_list+=' '+x+':array'
	else:
	    var_list+=' '+x+':'+membermethod.getInputvar()[x].getVariableType()
    var_list+='}'
    print var_list
    print "Local Variables:"
    var_list="{"
    for x in membermethod.getLocalvar():
        if membermethod.getLocalvar()[x].getDimensions()>0:
            var_list+=' '+x+':array'
	else:
            var_list+=' '+x+':'+membermethod.getLocalvar()[x].getVariableType()
    var_list+='}'
    print var_list
    allvariable={}
    program_dec_start=""
    program_dec_end=""
    for lvap in localvarmap:
        var=localvarmap[lvap]
        var.setInitialvalue(None)
        if var is not None and var.getInitialvalue() is not None:
	    if type(var.getInitialvalue()) is not c_ast.BinaryOp and '__VERIFIER_nondet' in var.getInitialvalue():
	    	defineDetailtemp=[]
	    	parameter_list=[]
	    	parameter_list.append('int')
		defineDetailtemp.append(var.getInitialvalue())
		defineDetailtemp.append(0)
		defineDetailtemp.append(parameter_list)
		defineDetaillist.append(defineDetailtemp)
            if program_dec_start=="":
            	if type(var.getInitialvalue()) is c_ast.BinaryOp:
            	        program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+expressionCreator_C(var.getInitialvalue())+"]"
                	program_dec_end="]"
            	else:
            		if is_hex(str(var.getInitialvalue())) is not None:
                		program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+is_hex(str(var.getInitialvalue()))+"')]"
                	else:
                		program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue())+"')]"
                	program_dec_end="]"
            else:
            	if type(var.getInitialvalue()) is c_ast.BinaryOp:
            	        program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+expressionCreator_C(var.getInitialvalue())+"]"
                	program_dec_end+="]"
            	else:
            		if is_hex(str(var.getInitialvalue())) is not None:
                		program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+is_hex(str(var.getInitialvalue()))+"')]"
                	else:
                		program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue())+"')]"
                	program_dec_end+="]"
    for x in membermethod.getInputvar():
        allvariable[x]=membermethod.getInputvar()[x]
    for x in membermethod.getLocalvar():
        allvariable[x]=membermethod.getLocalvar()[x]
    


       
    expressions=organizeStatementToObject_C(statements)
    
    primeStatement(expressions)
    variablesarray={}
    opvariablesarray={}
    count=0
    arrayFlag=False
    for variable in allvariable:
        count+=1
        if allvariable[variable].getDimensions()>0:
            variablesarray[variable]=eval("['_y"+str(count)+"','array']")
            opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','array']")
            list_parameter="'array'"
            for i in range(0, allvariable[variable].getDimensions()):
                if list_parameter=='':
                    list_parameter="'int'"
                else:
                    list_parameter+=",'int'"
            list_parameter+=",'"+allvariable[variable].getVariableType()+"'"
            #key1=str(allvariable[variable].getDimensions())+'array'
            key1='d'+str(allvariable[variable].getDimensions())+'array'
            arrayFlag=True
            if key1 not in variablesarray.keys():
             	count+=1
                variablesarray[key1]=eval("['_y"+str(count)+"',"+list_parameter+"]")
                opvariablesarray[key1+"1"]=eval("['_y"+str(count)+"',"+list_parameter+"]")
        else:
            variablesarray[variable]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")
            opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")

    for variable in class_variable:
        count+=1
        if class_variable[variable].getDimensions()>0:
            variablesarray[variable]=eval("['_y"+str(count)+"','"+class_name+"','array']")
            opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','array']")
            list_parameter="'"+class_name+"','array'"
            for i in range(0, class_variable[variable].getDimensions()):
                if list_parameter=='':
                    list_parameter="'int'"
                else:
                    list_parameter+=",'int'"
            list_parameter+=",'"+class_variable[variable].getVariableType()+"'"
            #key1=str(allvariable[variable].getDimensions())+'array'
            key1='d'+str(class_variable[variable].getDimensions())+'array'
            arrayFlag=True
            if key1 not in variablesarray.keys():
             	count+=1
                variablesarray[key1]=eval("['_y"+str(count)+"',"+list_parameter+"]")
                opvariablesarray[key1+"1"]=eval("['_y"+str(count)+"',"+list_parameter+"]")
        else:
            variablesarray[variable]=eval("['_y"+str(count)+"','"+class_name+"','"+class_variable[variable].getVariableType()+"']")
            opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','"+class_name+"','"+class_variable[variable].getVariableType()+"']")
    
    if program_dec_start=="":
        str_program=programToinductiveDefination_C(expressions , allvariable)
    else:
        str_program=program_dec_start+','+programToinductiveDefination_C(expressions , allvariable)+program_dec_end
    program=eval(str_program)
    return program,variablesarray,membermethod.getMethodname(),membermethod.getInputvar(),opvariablesarray






















defineDetaillist=[] 
defineMap={}

def translate_C(file_name):
    if not(os.path.exists(file_name)): 
        print "File not exits"
	return
    #Global Variables
    global break_count
    global continue_count
    global new_variable
    
    
    start_time=current_milli_time()
    content=None
    with open(file_name) as f:
    	content = f.read()
    content=content.replace('\r','')
    text = r""" """+content
    parser = c_parser.CParser()
    #ast = parse_file(file_name, use_cpp=True)
    ast = parser.parse(text)
    generator = c_generator.CGenerator()
    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Translate \n"+"\nParameters--\n File Name--"+file_name+"\n")
    if ast is None:
        print "Error present in code. Please verify you input file"
        return
    if len(ast.ext)==0:
        print "Error present in code. Please verify you input file"
        return
    generator = c_generator.CGenerator()
    function_decl = ast.ext[0].decl
    
    parametermap={}
    if function_decl.type.args is not None:
    	for param_decl in function_decl.type.args.params:
    		if type(param_decl.type) is c_ast.ArrayDecl:
    	    		degree=0
    	    		data_type,degree=getArrayDetails(param_decl,degree)
			variable=variableclass(param_decl.name, data_type,None,degree,None)
		else:
			variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None)
        	parametermap[param_decl.name]=variable
    function_body = ast.ext[0].body
    
    
    new_variable={}
    
    
        
    defineMap={}
    
    defineDetaillist=[]
   
        
    statements=function_body.block_items
       
    localvarmap=getVariables(function_body)

    membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,0)
    print "Function Name:"
    print membermethod.getMethodname()
    print "Return Type:"
    print membermethod.getreturnType()
    print "Input Variables:"
    var_list="{"
    for x in membermethod.getInputvar():
        if membermethod.getInputvar()[x].getDimensions()>0:
            var_list+=' '+x+':array'
	else:
	    var_list+=' '+x+':'+membermethod.getInputvar()[x].getVariableType()
    var_list+='}'
    print var_list
    print "Local Variables:"
    var_list="{"
    for x in membermethod.getLocalvar():
        if membermethod.getLocalvar()[x].getDimensions()>0:
            var_list+=' '+x+':array'
	else:
            var_list+=' '+x+':'+membermethod.getLocalvar()[x].getVariableType()
    var_list+='}'
    print var_list
    allvariable={}
    program_dec_start=""
    program_dec_end=""
    for lvap in localvarmap:
        var=localvarmap[lvap]
        if var is not None and var.getInitialvalue() is not None:
            if program_dec_start=="":
                program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue())+"')]"
                program_dec_end="]"
            else:
                program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue())+"')]"
                program_dec_end+="]"
    for x in membermethod.getInputvar():
        allvariable[x]=membermethod.getInputvar()[x]
    for x in membermethod.getLocalvar():
        allvariable[x]=membermethod.getLocalvar()[x]
        
    #print getBody(function_body)
       
    expressions=organizeStatementToObject_C(statements)
    
    primeStatement(expressions)
    variablesarray={}
    opvariablesarray={}
    count=0
    arrayFlag=False
    for variable in allvariable:
        count+=1
        if allvariable[variable].getDimensions()>0:
            variablesarray[variable]=eval("['_y"+str(count)+"','array']")
            opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','array']")
            list_parameter="'array'"
            for i in range(0, allvariable[variable].getDimensions()):
                if list_parameter=='':
                    list_parameter="'int'"
                else:
                    list_parameter+=",'int'"
                list_parameter+=",'"+allvariable[variable].getVariableType()+"'"
                #key1=str(allvariable[variable].getDimensions())+'array'
                key1='d'+str(allvariable[variable].getDimensions())+'array'
                arrayFlag=True
                if key1 not in variablesarray.keys():
                    count+=1
                    variablesarray[key1]=eval("['_y"+str(count)+"',"+list_parameter+"]")
                    opvariablesarray[key1+"1"]=eval("['_y"+str(count)+"',"+list_parameter+"]")
        else:
            variablesarray[variable]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")
            opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")
    if program_dec_start=="":
        str_program=programToinductiveDefination_C(expressions , allvariable)
    else:
        str_program=program_dec_start+','+programToinductiveDefination_C(expressions , allvariable)+program_dec_end
    
    program=eval(str_program)
    print ""
    print "Output of The Translator Written By Prof Lin"
    print ""
    print "Inputs to Translator"
    print "Parameter One:"
    print program
    print "Parameter Two:"
    print variablesarray
    print "Parameter Two Three:"
    print 1             
    f,o,a,cm=translate1(program,variablesarray,1)
    #f,o,a,cm=translate1(program,variablesarray,2)
    vfacts,constraints=getVariFunDetails(f,o,a,allvariable,opvariablesarray)
    end_time=current_milli_time()
    print "Times to Translate"
    print end_time-start_time
    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\n End of Translation\n")
    axiom=axiomclass(f,o,a,membermethod.getInputvar(), vfacts, constraints,cm)
    return axiom
 
 

 
 

 
#Construct Program for Assetion Analysis

def constructProgAssertAnalysis(functionbody,localvariables,inputvariables):
    #arg_list=[]
    #arg_list.append(c_ast.Constant(type="string", value="\"j:%d\\n\""))
    #arg_list.append(c_ast.ID(name="j"))
    #print_function=c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list))
    temp_localvariables = getVariables(functionbody)
    functionbody=c_ast.Compound(block_items=addPrintStmt(functionbody.block_items,temp_localvariables,inputvariables))
    return functionbody

count_for__VERIFIER_nondet=0
count_for__insert_flag=0
count_for__function_flag=0
line_count_trace=0
new_program_trace_var={}
back_line_no_stmt_map={}
main_line_no_stmt_ast_map={}
count_ast_line_no=0



def constructProgAssertAnalysis2(functionbody,localvariables,inputvariables,methodname):
    global count_for__VERIFIER_nondet
    global count_for__insert_flag
    global count_for__function_flag
    global count_ast_line_no
    global new_program_trace_var
    global line_no_stmt_map
    global back_line_no_stmt_map
    global main_line_no_stmt_ast_map
    
    
    if line_no_stmt_map is None:
        
        return (functionbody,functionbody)
    
    
    back_line_no_stmt_map=copy.deepcopy(line_no_stmt_map)
    

    count_for__VERIFIER_nondet=0
    count_for__insert_flag=0
    count_for__function_flag=0
    new_program_trace_var={}
    all_variable_map={}
    update_statements=[]
    parser = c_parser.CParser()
    try:
        new_statements=copy.deepcopy(functionbody.block_items)
        
        statements = constructExcutionTraceBlock(copy.deepcopy(functionbody.block_items),all_variable_map,methodname,new_statements)
        
        for x in new_program_trace_var.keys():
            program_temp='int '+x+'=0;'
            temp_ast = parser.parse(program_temp)
            update_statements.append(temp_ast.ext[0])
        for x in statements:
             update_statements.append(x)
    except Exception as e:
        print e
    functionbody.block_items=modify__VERIFIER_nondet_block(functionbody.block_items)
    functionbody=c_ast.Compound(block_items=addPrintStmt2(functionbody.block_items,localvariables,inputvariables))
    functionbody1=c_ast.Compound(block_items=update_statements)
    return (functionbody,functionbody1)


def getLineNumber(stmt,fun_name):
    global back_line_no_stmt_map
    find_list=[]
    find_list_ast=[]
    
    value=None
    value1=None
    if fun_name is not None:
        z=None
        list=back_line_no_stmt_map[fun_name]
        for x in list:
            if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x[1]):
                z=x
                break;
        
        if z is not None:
            list.remove(z)
            back_line_no_stmt_map[fun_name]=list
            value=z[0]
            value1=z[1]

    else:
        z=None
        list=back_line_no_stmt_map.keys()
        for x in list:
            if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x):
                z=x
                break;
        if z is not None:
            value=back_line_no_stmt_map[z]
            value1=z
            del back_line_no_stmt_map[z]
    
    return value,value1





def getLineNumberAssert(stmt):
    global back_line_no_stmt_map
    find_list=[]
    find_list_ast=[]
    
    value=None
    value1=None
    z=None
    for y in back_line_no_stmt_map.keys():
        TEMP_LIST= back_line_no_stmt_map[y]
        if isinstance(TEMP_LIST,list)==True:
            
            TEMP_LIST=back_line_no_stmt_map[y]
            for x in TEMP_LIST:
                if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x[1]):
                    z=x
                    break;
            if z!=None:
                break;

    if z is not None:
        value=z[0]
        value1=z[1]
    
    return value,value1


def getLineNumber_terminate(stmt,fun_name):
    global line_no_stmt_map
    find_list=[]
    find_list_ast=[]
    
    value=None
    value1=None
    if fun_name is not None:
        z=None
        list=line_no_stmt_map[fun_name]
        for x in list:
            if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x[1]):
                z=x
                break;
        
        if z is not None:
            list.remove(z)
            line_no_stmt_map[fun_name]=list
            value=z[0]
            value1=z[1]

    else:
        z=None
        list=line_no_stmt_map.keys()
        for x in list:
            if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x):
                z=x
                break;
        if z is not None:
            value=line_no_stmt_map[z]
            value1=z
            del line_no_stmt_map[z]
    
    return value,value1








def more2equality(expression):
    count=0
    if "&&" not in expression and "||" not in expression and "<" not in expression and ">" not in expression:
        for x in expression:
            if x is '=':
                count+=1
        if count>2:
            return count
        else:
            return None
    return None
    
            

def getSpaceRemoveStr(expression):
    
    new_expression=''
    for x in expression:
        if x!=' ' and x!='' and x!='(' and x!=')' and x!='\n':
            new_expression+=x
    return new_expression
        




def getVariablesExcutionTrace(statement,all_variable_map):
    if type(statement) is c_ast.BinaryOp:
        getVariablesExcutionTrace(statement.left,all_variable_map)
        getVariablesExcutionTrace(statement.right,all_variable_map)
    elif type(statement) is c_ast.Assignment:
        getVariablesExcutionTrace(statement.lvalue,all_variable_map)
        getVariablesExcutionTrace(statement.rvalue,all_variable_map)
    elif type(statement) is c_ast.FuncCall:
        if statement.args is not None:
            for x in statement.args.exprs:
                getVariablesExcutionTrace(x,all_variable_map)
    elif type(statement) is c_ast.ID:
        key = programPrint(statement)
        if '_FAILED' not in key and '_PROVE' not in key:
            all_variable_map[key]=key
    elif type(statement) is c_ast.ArrayRef:
        key = programPrint(statement)
        if '_FAILED' not in key and '_PROVE' not in key:
            all_variable_map[key]=key
            




def line_count_ast_Block(statements):
    global main_count_ast_line_no
    global main_line_no_stmt_ast_map
    for statement in statements:
        if type(statement) is c_ast.While:
            main_count_ast_line_no+=1
            main_line_no_stmt_ast_map[main_count_ast_line_no]=programPrint(statement.cond)
            line_count_ast_Block(statement.stmt.block_items)
        elif type(statement) is c_ast.If:
            line_count_ast_If(statement)
        elif type(statement) is c_ast.Return:
            main_count_ast_line_no+=1
            main_line_no_stmt_ast_map[main_count_ast_line_no]=programPrint(statement)
        else:
            main_count_ast_line_no+=1
            main_line_no_stmt_ast_map[main_count_ast_line_no]=programPrint(statement)
            

            
def line_count_ast_If(statement):
    global main_count_ast_line_no
    global main_line_no_stmt_ast_map
    if type(statement) is c_ast.If:
         if type(statement.iftrue) is c_ast.Compound:
             main_count_ast_line_no+=1
             main_line_no_stmt_ast_map[main_count_ast_line_no]=programPrint(statement.cond)
             line_count_ast_Block(statement.iftrue.block_items)
         if type(statement.iffalse) is c_ast.Compound:
             line_count_ast_Block(statement.iffalse.block_items)
         elif type(statement.iffalse) is c_ast.If:
             line_count_ast_If(statement.iffalse)


def getVariablesExcutionTraceBlock(statements,all_variable_map):
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            getVariablesExcutionTrace(statement,all_variable_map)
        elif type(statement) is c_ast.While:
            getVariablesExcutionTrace(statement.cond,all_variable_map)
            getVariablesExcutionTraceBlock(statement.stmt.block_items,all_variable_map)
        elif type(statement) is c_ast.If:
            getVariablesExcutionTraceIf(statement,all_variable_map)
        elif type(statement) is c_ast.Return:
            getVariablesExcutionTraceIf(statement.expr,all_variable_map)
            
            getVariablesExcutionTrace(statement.expr,all_variable_map)
            
def getVariablesExcutionTraceIf(statement,all_variable_map):
    if type(statement) is c_ast.If:
         if type(statement.iftrue) is c_ast.Compound:
             getVariablesExcutionTraceBlock(statement.iftrue.block_items,all_variable_map)
         if type(statement.iffalse) is c_ast.Compound:
             getVariablesExcutionTraceBlock(statement.iffalse.block_items,all_variable_map)
         elif type(statement.iffalse) is c_ast.If:
             getVariablesExcutionTraceIf(statement.iffalse,all_variable_map)
    


def constructExcutionTraceBlock(statements,all_variable_map,methodname,new_statements):
    global count_for__insert_flag
    global back_line_no_stmt_map
    global count_ast_line_no
    global main_count_ast_line_no
    prev_line_no=None
    update_statements=[]
    prev_line_no=None
    prev_stmt=None
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            count_ast_line_no+=1
            line_no,stmt = getLineNumber(programPrint(statement),methodname)
            function_assgmt={}
            
            new_statement=getFunctionCallAssigment(statement,function_assgmt)
            
            
            if len(function_assgmt)>0:
                for x in function_assgmt:
                    new_program_trace_var[x]=x
                    arg_list1=[]
                    arg_list1.append(c_ast.Constant(type="string", value="\"FunctionCall:"+programPrint(statement)+":"+function_assgmt[x].rvalue.name.name+":"+programPrint(function_assgmt[x].rvalue)+":"+str(line_no)+""+"\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                    
                    update_statements.append(function_assgmt[x])
                    
                    arg_list2=[]
                    arg_list2.append(c_ast.Constant(type="string", value="\"RecahCallPoint:"+":"+programPrint(function_assgmt[x].rvalue)+":"+str(line_no)+""+"\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list2)))
                    
                    

                update_statements.append(new_statement)
            else:
                update_statements.append(statement)
            
            getVariablesExcutionTrace(statement,all_variable_map)
            
            
            str_printf_stmt=None
            arg_list1=[]
            temp_arg_list1=[]
            for x in all_variable_map:
                if str_printf_stmt is None:
                    str_printf_stmt="\"assumption:"+x+"==%d;"
                    temp_arg_list1.append(x)
                else:
                    str_printf_stmt+=x+"==%d;"
                    temp_arg_list1.append(x)
            if str_printf_stmt is not None:
                str_printf_stmt+="\\n\""
                arg_list1.append(c_ast.Constant(type="string", value=str_printf_stmt))
                for x in temp_arg_list1:
                    arg_list1.append(c_ast.ID(name=x))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
            

            if line_no==0 and stmt is None:
                line_no=prev_line_no
                stmt=prev_stmt

            if line_no>0 and stmt is not None:
                status = more2equality(expression)
                if status is not None:
                    prev_line_no=line_no
                    prev_stmt=stmt
                else:
                    prev_line_no=0
                    prev_stmt=None
                arg_list=[]
                #arg_list.append(c_ast.Constant(type="string", value="\"Assignment:"+programPrint(statement)+":"+stmt+":"+str(line_no)+"\\n\""))
                arg_list.append(c_ast.Constant(type="string", value="\"Assignment:"+programPrint(statement)+":"+stmt+":"+str(line_no)+"\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                
    
                
            else:
                if ('_FAILED' in programPrint(statement.lvalue) or '_PROVE' in programPrint(statement.lvalue)) and type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\""+programPrint(statement.lvalue)+":%d\\n\""))
                    arg_list.append(statement.lvalue)
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                elif '_PROVE' in programPrint(statement.lvalue) and type(statement.rvalue) is not c_ast.Constant :
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\"__VERIFIER_assert("+programPrint(statement.rvalue)+"):%d\\n\""))
                    arg_list.append(statement.lvalue)
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
        elif type(statement) is c_ast.While:
            #statement.show()
            count_ast_line_no+=1
            arg_list=[]
            count_for__insert_flag=count_for__insert_flag+1
            ID_name='_con_flag'+str(count_for__insert_flag)
            update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_con_flag'+str(count_for__insert_flag)),rvalue=statement.cond))
            new_program_trace_var['_con_flag'+str(count_for__insert_flag)]='_con_flag'+str(count_for__insert_flag)
            line_no,stmt = getLineNumber(programPrint(statement.cond),methodname)
            if line_no>0:
                arg_list.append(c_ast.Constant(type="string", value="\"WhileCondition:"+programPrint(statement.cond)+":"+str(line_no)+":%d"+"\\n\""))
                arg_list.append(c_ast.ID(name='_con_flag'+str(count_for__insert_flag)))
                
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
            
            temp_block = constructExcutionTraceBlock(statement.stmt.block_items,all_variable_map,methodname,new_statements)
            temp_block.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=ID_name),rvalue=statement.cond))
            if len(arg_list)>0:
                temp_block.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
            update_statements.append(c_ast.While(cond=c_ast.ID(name=ID_name), stmt=c_ast.Compound(block_items=temp_block)))
        elif type(statement) is c_ast.If:
            temp_stmt,list_of_con_ex_trace,list_of_con_ex_trace1 = constructExcutionTraceIf(statement,all_variable_map,None,methodname,new_statements)
            for x in list_of_con_ex_trace:
                update_statements.append(x)
                new_program_trace_var[x.lvalue.name]=x.lvalue.name
                #line_no,stmt = getLineNumber(programPrint(x.rvalue))
            for x in list_of_con_ex_trace1:
                update_statements.append(x)
            update_statements.append(temp_stmt)
        elif type(statement) is c_ast.Return:
            count_ast_line_no+=1
            line_no,stmt = getLineNumber(programPrint(statement),methodname)

            function_assgmt={}
            new_statement=getFunctionCallAssigment(statement.expr,function_assgmt)
            
            
            if len(function_assgmt)>0:
                
                t_all_variable_map={}
            
                if methodname=='main':
                    getVariablesExcutionTrace(statement,t_all_variable_map)
                else:
                    getVariablesExcutionTraceBlock(new_statements,t_all_variable_map)
                
                t_str_printf_stmt=None
                
                
                t_temp_arg_list1=[]
                    
                for x in t_all_variable_map:
                    if t_str_printf_stmt is None:
                        t_str_printf_stmt="\"essumption:"+x+"==%d;"
                        t_temp_arg_list1.append(x)
                    else:
                        t_str_printf_stmt+=x+"==%d;"
                        t_temp_arg_list1.append(x)
                
                for x in function_assgmt:
                    new_program_trace_var[x]=x
                    arg_list1=[]
                    arg_list1.append(c_ast.Constant(type="string", value="\"FunctionCall:#:"+function_assgmt[x].rvalue.name.name+":"+programPrint(function_assgmt[x].rvalue)+":"+str(line_no)+""+"\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                    update_statements.append(function_assgmt[x])
                    
                    if t_str_printf_stmt is None:
                            t_str_printf_stmt="\"essumption:"+programPrint(function_assgmt[x].rvalue)+"==%d;"
                            t_temp_arg_list1.append(x)
                    else:
                            t_str_printf_stmt+=programPrint(function_assgmt[x].rvalue)+"==%d;"
                            t_temp_arg_list1.append(x)
                    
                    if t_str_printf_stmt is not None:
                        t_arg_list1=[]
                        t_arg_list1.append(c_ast.Constant(type="string", value=t_str_printf_stmt+"@"+programPrint(function_assgmt[x].rvalue)+"\\n\""))
                        for x in t_temp_arg_list1:
                            t_arg_list1.append(c_ast.ID(name=x))
                        update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=t_arg_list1)))
                
                
                
                
                if methodname=='main':
                    getVariablesExcutionTrace(statement,all_variable_map)
                else:
                    getVariablesExcutionTraceBlock(new_statements,all_variable_map)
                str_printf_stmt=None
                arg_list1=[]
                temp_arg_list1=[]
                for x in all_variable_map:
                    if str_printf_stmt is None and x!='':
                        str_printf_stmt="\"assumption:"+x+"==%d;"
                        temp_arg_list1.append(x)
                    else:
                        str_printf_stmt+=x+"==%d;"
                        temp_arg_list1.append(x)
                if str_printf_stmt is not None:
                    str_printf_stmt+="\\n\""
                    arg_list1.append(c_ast.Constant(type="string", value=str_printf_stmt))
                    for x in temp_arg_list1:
                        arg_list1.append(c_ast.ID(name=x))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                
                
                arg_list=[]
                

                #arg_list.append(c_ast.Constant(type="string", value="\"Return:"+methodname+":"+programPrint(statement.expr)+":"+str(line_no)+""+"\\n\""))
                if statement.expr is not None:
                    arg_list.append(c_ast.Constant(type="string", value="\"Return:"+programPrint(statement.expr)+":"+programPrint(statement.expr)+":"+methodname+":%d"+":"+str(line_no)+"\\n\""))
                    arg_list.append(new_statement)
                else:
                    arg_list.append(c_ast.Constant(type="string", value="\"Return:None:None:"+methodname+":None"+":"+str(line_no)+""+"\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                update_statements.append(c_ast.Return(expr=new_statement))
            else:
                
                
                if methodname=='main':
                    getVariablesExcutionTrace(statement,all_variable_map)
                else:
                    getVariablesExcutionTraceBlock(new_statements,all_variable_map)
                str_printf_stmt=None
                arg_list1=[]
                temp_arg_list1=[]
                for x in all_variable_map:
                    if str_printf_stmt is None:
                        str_printf_stmt="\"assumption:"+x+"==%d;"
                        temp_arg_list1.append(x)
                    else:
                        str_printf_stmt+=x+"==%d;"
                        temp_arg_list1.append(x)
                if str_printf_stmt is not None:
                    str_printf_stmt+="\\n\""
                    arg_list1.append(c_ast.Constant(type="string", value=str_printf_stmt))
                    for x in temp_arg_list1:
                        arg_list1.append(c_ast.ID(name=x))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                    
                
                arg_list=[]
                
                #arg_list.append(c_ast.Constant(type="string", value="\"Return:"+methodname+":"+programPrint(statement.expr)+":"+str(line_no)+""+"\\n\""))
                if statement.expr is not None:
                    arg_list.append(c_ast.Constant(type="string", value="\"Return:"+programPrint(statement.expr)+":"+methodname+":%d"+":"+str(line_no)+""+"\\n\""))
                    arg_list.append(statement.expr)
                else:
                    arg_list.append(c_ast.Constant(type="string", value="\"Return:None:"+methodname+":None"+":"+str(line_no)+""+"\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                update_statements.append(statement)
        else:
            count_ast_line_no+=1
            update_statements.append(statement)

    return update_statements


def constructExcutionTraceIf(statement,all_variable_map,isElse,methodname,new_statements):
    global count_for__insert_flag
    global count_ast_line_no
    global main_count_ast_line_no
    If_stmt=None
    Else_stmt=None
    list_of_con_ex_trace=[]
    list_of_con_ex_trace1=[]
    if type(statement) is c_ast.If:
        count_ast_line_no+=1
        count_for__insert_flag=count_for__insert_flag+1
        list_of_con_ex_trace.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_con_flag'+str(count_for__insert_flag)),rvalue=statement.cond))
        cond_stmt=c_ast.ID(name='_con_flag'+str(count_for__insert_flag))
        if type(statement.iftrue) is c_ast.Compound:
            
            update_new_block_temp=[]
            
            line_no,stmt = getLineNumber(programPrint(statement.cond),methodname)
            
            new_block_temp=constructExcutionTraceBlock(statement.iftrue.block_items,all_variable_map,methodname,new_statements)
            
            
            #print '-------------------'
            #print programPrint(statement.cond)
            #print line_no
            #print stmt
            #print count_ast_line_no
            #print main_count_ast_line_no
            #print '-------------------'
            
            if line_no>0:
                arg_list=[]
                arg_list.append(c_ast.Constant(type="string", value="\"IfCondition2:"+programPrint(statement.cond)+":"+str(line_no)+":%d"+"\\n\""))
                arg_list.append(c_ast.ID(name='_con_flag'+str(count_for__insert_flag)))
                update_new_block_temp.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                arg_list1=[]
                if isElse is not None:
                    arg_list1.append(c_ast.Constant(type="string", value="\"Else-IfCondition1:"+programPrint(statement.cond)+":"+str(line_no)+":%d"+"\\n\""))
                else:
                    arg_list1.append(c_ast.Constant(type="string", value="\"IfCondition1:"+programPrint(statement.cond)+":"+str(line_no)+":%d"+"\\n\""))
                arg_list1.append(c_ast.ID(name='_con_flag'+str(count_for__insert_flag)))
                list_of_con_ex_trace1.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
            
            
            If_stmt=c_ast.Compound(block_items=update_new_block_temp+new_block_temp)
            
        else:
            If_stmt=statement.iftrue
            
        if type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                update_new_block_temp=[]
                
                line_no,stmt = getLineNumber(programPrint(statement.cond),methodname)
                
                new_block_temp=constructExcutionTraceBlock(statement.iffalse.block_items,all_variable_map,methodname,new_statements)
                
                #if line_no>0:
                    #arg_list=[]
                    #arg_list.append(c_ast.Constant(type="string", value="\"IfCondition2:"+programPrint(c_ast.UnaryOp(op='!',expr=statement.cond))+":"+str(line_no)+":%d"+"\\n\""))
                    #arg_list.append(c_ast.UnaryOp(op='!',expr=c_ast.ID(name='_con_flag'+str(count_for__insert_flag))))
                    #update_new_block_temp.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                    #arg_list1=[]
                    #arg_list1.append(c_ast.Constant(type="string", value="\"Else-IfCondition1:"+programPrint(c_ast.UnaryOp(op='!',expr=statement.cond))+":"+str(line_no)+":%d"+"\\n\""))
                    #arg_list1.append(c_ast.UnaryOp(op='!',expr=c_ast.ID(name='_con_flag'+str(count_for__insert_flag))))
                    #list_of_con_ex_trace1.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                Else_stmt=c_ast.Compound(block_items=new_block_temp)
                #Else_stmt=c_ast.Compound(block_items=update_new_block_temp+new_block_temp)
            else:
                Else_stmt=statement.iffalse
        else:
            if type(statement.iffalse) is c_ast.If:
                Else_stmt,list_of_con_ex_trace_temp,list_of_con_ex_trace1_temp=constructExcutionTraceIf(statement.iffalse,all_variable_map,'Else',methodname,new_statements)
                list_of_con_ex_trace=list_of_con_ex_trace+list_of_con_ex_trace_temp
                list_of_con_ex_trace1=list_of_con_ex_trace1+list_of_con_ex_trace1_temp
            else:
                Else_stmt=statement.iffalse
    return c_ast.If(cond=cond_stmt, iftrue=If_stmt, iffalse=Else_stmt),list_of_con_ex_trace,list_of_con_ex_trace1



def getFunctionCallAssigment(statement,function_assgmt):
    global count_for__function_flag
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op,left=getFunctionCallAssigment(statement.left,function_assgmt),right=getFunctionCallAssigment(statement.right,function_assgmt))
    elif type(statement) is c_ast.Assignment:
        return c_ast.Assignment(op=statement.op,lvalue=getFunctionCallAssigment(statement.lvalue,function_assgmt),rvalue=getFunctionCallAssigment(statement.rvalue,function_assgmt))
    elif type(statement) is c_ast.FuncCall:
        if '__VERIFIER_nondet' not in statement.name.name:
            if statement.args is not None:
                count_for__function_flag+=1
                function_assgmt['_fun_call'+str(count_for__function_flag)]=c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_fun_call'+str(count_for__function_flag)),rvalue=statement)
                return c_ast.ID(name='_fun_call'+str(count_for__function_flag))
            else:
                return statement
        else:
            return statement
    else:
        return statement




def getAllNodesOfAssetion(statement,map_nodes):
    if type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.BinaryOp:
            getAllNodesOfAssetion(statement.left,map_nodes)
        elif type(statement.left) is c_ast.ID:
            map_nodes.append(statement.left)
        elif type(statement.left) is c_ast.ArrayRef:
            map_nodes.append(statement.left)
        if type(statement.right) is c_ast.BinaryOp:
            getAllNodesOfAssetion(statement.right,map_nodes)
        elif type(statement.right) is c_ast.ID and ('_PROVE' in statement.right.name or '_FAILED' in statement.right.name or '_ASSUME' in statement.right.name):
            map_nodes.append(statement.right)
        elif type(statement.right) is c_ast.ArrayRef:
            array_name=getArrayRef_Name(statement.right)
            if ('_PROVE' in array_name or '_FAILED' in array_name or '_ASSUME' in array_name):
                map_nodes.append(statement.right)
    


def addPrintStmt(statements,localvariables,inputvariables):
    update_statements=[]
    #print '$$$$$$$$$$$$$$$$4'
    #for x in localvariables:
    #    print x
    #    print localvariables[x].getVariableType()
    #print '$$$$$$$$$$$$$$$$4'
    for statement in statements:
        #print '--------------'
        #statement.show()
        #print '--------------'

        if type(statement) is c_ast.Assignment:
            if type(statement.lvalue) is c_ast.ID and '_PROVE' in statement.lvalue.name:
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                getAllNodesOfAssetion(statement.rvalue,nodes)
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                for node in nodes:
                        if type(node) is c_ast.ID:
                            list_variables.append(node.name)
                        update_statements.append(createPrint(node,localvariables,inputvariables))
                for var in localvariables.keys():
                    varObject=localvariables[var]
                    if varObject.getDimensions()==0 or varObject.getDimensions() is None:
                        if varObject.getVariablename() not in list_variables and '_PROVE' not in varObject.getVariablename() and '_ASSUME' not in varObject.getVariablename() and 'RET' not in varObject.getVariablename() and '_FAILED' not in varObject.getVariablename() and 'DUMMY' not in varObject.getVariablename() and 'break_' not in varObject.getVariablename() and 'bool_go' not in varObject.getVariablename():
                            update_statements.append(createPrint(c_ast.ID(name=varObject.getVariablename()),localvariables,inputvariables))
                arg_list=[]
                arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
            
            elif type(statement.lvalue) is c_ast.ID and '_FAILED' in statement.lvalue.name and type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                getAllNodesOfAssetion(statement.rvalue,nodes)
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                for node in nodes:
                        if type(node) is c_ast.ID:
                            list_variables.append(node.name)
                        update_statements.append(createPrint(node,localvariables,inputvariables))
                for var in localvariables.keys():
                    varObject=localvariables[var]
                    if varObject.getDimensions()==0 or varObject.getDimensions() is None:
                        if varObject.getVariablename() not in list_variables and '_PROVE' not in varObject.getVariablename() and '_ASSUME' not in varObject.getVariablename() and '_FAILED' not in varObject.getVariablename() and 'RET' not in varObject.getVariablename() and 'DUMMY' not in varObject.getVariablename() and 'break_' not in varObject.getVariablename() and 'bool_go' not in varObject.getVariablename():
                            update_statements.append(createPrint(c_ast.ID(name=varObject.getVariablename()),localvariables,inputvariables))
                arg_list=[]
                arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))            
            
            
            elif type(statement.lvalue) is c_ast.ID and '_ASSUME' in statement.lvalue.name and type(statement.rvalue) is c_ast.BinaryOp:
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                getAllNodesOfAssetion(statement.rvalue,nodes)
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                arg_list=[]
                arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
            
            
            
            else:
                if type(statement.lvalue) is c_ast.ArrayRef and '_PROVE' in getArrayRef_Name(statement.lvalue):
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    getAllNodesOfAssetion(statement.rvalue,nodes)
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                    for node in nodes:
                        if type(node) is c_ast.ID:
                            list_variables.append(node.name)
                        update_statements.append(createPrint(node,localvariables,inputvariables))
                    for var in localvariables.keys():
                        varObject=localvariables[var]
                        if varObject.getDimensions()==0 or varObject.getDimensions() is None:
                            if varObject.getVariablename() not in list_variables and '_PROVE' not in varObject.getVariablename() and '_ASSUME' not in varObject.getVariablename() and '_FAILED' not in varObject.getVariablename() and 'RET' not in varObject.getVariablename() and 'DUMMY' not in varObject.getVariablename() and 'break_' not in varObject.getVariablename() and 'bool_go' not in varObject.getVariablename():
                                update_statements.append(createPrint(c_ast.ID(name=varObject.getVariablename()),localvariables,inputvariables))
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                
                elif type(statement.lvalue) is c_ast.ID and '_FAILED' in statement.lvalue.name and  type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    getAllNodesOfAssetion(statement.rvalue,nodes)
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                    for node in nodes:
                            if type(node) is c_ast.ID:
                                list_variables.append(node.name)
                            update_statements.append(createPrint(node,localvariables,inputvariables))
                    for var in localvariables.keys():
                        varObject=localvariables[var]
                        if varObject.getDimensions()==0 or varObject.getDimensions() is None:
                            if varObject.getVariablename() not in list_variables and '_PROVE' not in varObject.getVariablename() and '_ASSUME' not in varObject.getVariablename() and '_FAILED' not in varObject.getVariablename() and 'DUMMY' not in varObject.getVariablename() and 'break_' not in varObject.getVariablename() and 'bool_go' not in varObject.getVariablename():
                                update_statements.append(createPrint(c_ast.ID(name=varObject.getVariablename()),localvariables,inputvariables))
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list))) 
                
                elif type(statement.lvalue) is c_ast.ArrayRef and '_ASSUME' in getArrayRef_Name(statement.lvalue):
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    getAllNodesOfAssetion(statement.rvalue,nodes)
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                        
                else:
                    update_statements.append(statement)
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=addPrintStmt(statement.stmt.block_items,localvariables,inputvariables))))
        elif type(statement) is c_ast.If:
            update_statements.append(addPrintStmtIf(statement,localvariables,inputvariables))
        else:
            update_statements.append(statement)
    
    return update_statements



def addPrintStmtIf(statement,localvariables,inputvariables):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=addPrintStmt(statement.iftrue.block_items,localvariables,inputvariables)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=addPrintStmt(statement.iffalse.block_items,localvariables,inputvariables)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=addPrintStmtIf(statement.iffalse,localvariables,inputvariables)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)






def addPrintStmt2(statements,localvariables,inputvariables):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            if type(statement.lvalue) is c_ast.ID and '_PROVE' in statement.lvalue.name:
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
            
            elif type(statement.lvalue) is c_ast.ID and '_FAILED' in statement.lvalue.name and type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))            
            
            elif type(statement.lvalue) is c_ast.ID and '_ASSUME' in statement.lvalue.name and type(statement.rvalue) is c_ast.BinaryOp:
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
            
            
            
            else:
                if type(statement.lvalue) is c_ast.ArrayRef and '_PROVE' in getArrayRef_Name(statement.lvalue):
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))                
                elif type(statement.lvalue) is c_ast.ID and '_FAILED' in statement.lvalue.name and  type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))

                
                elif type(statement.lvalue) is c_ast.ArrayRef and '_ASSUME' in getArrayRef_Name(statement.lvalue):
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]

                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                        
                else:
                    update_statements.append(statement)
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=addPrintStmt2(statement.stmt.block_items,localvariables,inputvariables))))
        elif type(statement) is c_ast.If:
            update_statements.append(addPrintStmtIf2(statement,localvariables,inputvariables))
        else:
            update_statements.append(statement)
    
    return update_statements



def addPrintStmtIf2(statement,localvariables,inputvariables):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=addPrintStmt2(statement.iftrue.block_items,localvariables,inputvariables)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=addPrintStmt2(statement.iffalse.block_items,localvariables,inputvariables)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=addPrintStmtIf2(statement.iffalse,localvariables,inputvariables)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)


def modify__VERIFIER_nondet_block(statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            update_statements.append(modify__VERIFIER_nondet_stmt(statement))
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=modify__VERIFIER_nondet_stmt(statement.cond), stmt=c_ast.Compound(block_items=modify__VERIFIER_nondet_block(statement.stmt.block_items))))
        elif type(statement) is c_ast.If:
            update_statements.append(modify__VERIFIER_nondet_blockIf(statement))
        else:
            update_statements.append(statement)
    
    return update_statements
    
def modify__VERIFIER_nondet_blockIf(statement):
    If_stmt=None
    Else_stmt=None
    cond_stmt=modify__VERIFIER_nondet_stmt(statement.cond)
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=modify__VERIFIER_nondet_block(statement.iftrue.block_items)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=modify__VERIFIER_nondet_block(statement.iffalse.block_items)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=modify__VERIFIER_nondet_blockIf(statement.iffalse)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=cond_stmt, iftrue=If_stmt, iffalse=Else_stmt)
    
    
    
def modify__VERIFIER_nondet_stmt(statement):
    global count_for__VERIFIER_nondet
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op,left=modify__VERIFIER_nondet_stmt(statement.left),right=modify__VERIFIER_nondet_stmt(statement.right))
    elif type(statement) is c_ast.Assignment:
        return c_ast.Assignment(op=statement.op,lvalue=modify__VERIFIER_nondet_stmt(statement.lvalue),rvalue=modify__VERIFIER_nondet_stmt(statement.rvalue))
    elif type(statement) is c_ast.FuncCall:
        if '__VERIFIER_nondet' in statement.name.name:
            if statement.args is None:
                arg_list=[]
                count_for__VERIFIER_nondet=count_for__VERIFIER_nondet+1
                arg_list.append(c_ast.Constant(type="int", value=str(count_for__VERIFIER_nondet)))
                return c_ast.FuncCall(name=statement.name, args=c_ast.ExprList(exprs=arg_list))
            else:
                return statement
        else:
            return statement
    else:
        return statement
    


def getArrayRef_Name(statement):
    if type(statement.name) is c_ast.ArrayRef:
        return getArrayRef_Name(statement.name)
    else:
        return statement.name.name
        

def createPrint(statement,localvariables,inputvariables):
    generator = c_generator.CGenerator()
    arg_list=[]
    mod_operator=None
    #print '$$$$$$$$$$$$$$$$4'
    #for x in localvariables:
    #    print x
    #    print localvariables[x].getVariableType()
    #print '$$$$$$$$$$$$$$$$4'

    
    if type(statement) is c_ast.ID:
        if statement.name in localvariables.keys():
            mod_operator=localvariables[statement.name].getVariableType()
        elif statement.name in inputvariables.keys():
            mod_operator=inputvariables[statement.name].getVariableType()
    elif type(statement) is c_ast.ArrayRef:
        array_name=getArrayRef_Name(statement)
        if array_name in inputvariables.keys():
            mod_operator=inputvariables[array_name].getVariableType()
        elif array_name in localvariables.keys():
            mod_operator=localvariables[array_name].getVariableType()

    
    if mod_operator is not None:
        if mod_operator=='int':
            mod_operator='%d'
        elif mod_operator=='unsigned':
            mod_operator='%u'
        elif mod_operator=='long':
             mod_operator='%ld'
        elif mod_operator=='long long':
             mod_operator='%lld'
        elif mod_operator=='long long int':
             mod_operator='%lld'
        elif mod_operator=='float':
            mod_operator='%f'
        elif mod_operator=='double':
            mod_operator='%f'
        else:
            mod_operator='%d'
            
    else:
        mod_operator='%d'
    var_name=str(generator.visit(statement))
    arg_list.append(c_ast.Constant(type="string", value="\""+var_name+":"+mod_operator+"\\n\""))
    arg_list.append(statement)
    print_stmt=c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list))
    return print_stmt

def programPrint(statement):
    generator = GnuCGenerator()
    return str(generator.visit(statement))
 
    
def getArrayDetails(statement,degree,dimension_map):
	if type(statement.type) is c_ast.ArrayDecl:
		degree=degree+1
                if type(statement.type.dim) is c_ast.ID:
                    if is_number(statement.type.dim.name)==True:
                        dimension_map['_x'+str(degree+1)]=statement.type.dim.name+'_var1'
                    elif statement.type.dim.name in ['S','Q','N','in','is']:
                        dimension_map['_x'+str(degree+1)]=statement.type.dim.name+'_var1'
                    else:
                        dimension_map['_x'+str(degree+1)]=statement.type.dim.name+'1'
                elif type(statement.type.dim) is c_ast.Constant:
                    dimension_map['_x'+str(degree+1)]=statement.type.dim.value
		return getArrayDetails(statement.type,degree,dimension_map)
	elif type(statement.type) is c_ast.PtrDecl:
		degree=degree+1
		return getArrayDetails(statement.type,degree,dimension_map)
	else:
		if type(statement.type.type) is c_ast.Struct:
			return statement.type.type.name,degree,statement.type.type.name
                elif type(statement.type.type) is c_ast.Union:
                        return statement.type.type.name,degree,statement.type.type.name
		else:
			return statement.type.type.names[0],degree,None


#Simplify Declaration 

def simplificationOfDec(statements):
        update_statements=[]
        for statement in statements:
        	if type(statement) is c_ast.Decl:
			statement.show()
		else:
			update_statements.append(statement)



#Get All Variables


def getVariables(function_body):
    #statements=handlingPointer(function_body.block_items)
    statements=function_body.block_items
    #for decl in function_body.block_items:
    return getVariablesC(statements)


#Get Variable 

def getVariablesC(statements):
    localvarmap={}
    if statements is None:
        return localvarmap
    for decl in statements:
        if type(decl) is c_ast.Decl:
            var_type=None
            initial_value=None
            structType=None
            if type(decl.type) is c_ast.ArrayDecl:
                #if checkingArrayName(decl.type)==True:
                if is_number(decl.name[-1])==True:
                    decl=c_ast.Decl(name=decl.name+'_var', quals=decl.quals, storage=decl.storage, funcspec=decl.funcspec, type=renameArrayName(decl.type), init=decl.init, bitsize=decl.bitsize)
                elif decl.name in ['S','Q','N','in','is']:
                    decl=c_ast.Decl(name=decl.name+'_var', quals=decl.quals, storage=decl.storage, funcspec=decl.funcspec, type=renameArrayName(decl.type), init=decl.init, bitsize=decl.bitsize)
            elif type(decl.type) is c_ast.PtrDecl:
                if type(decl.type.type) is c_ast.TypeDecl:
                    if is_number(decl.type.type.declname[-1])==True:
                        decl.type.type=c_ast.TypeDecl(decl.type.type.declname+'_var', quals=decl.type.type.quals, type=decl.type.type.type)
                    elif decl.name in ['S','Q','N','in','is']:
                        decl.type.type=c_ast.TypeDecl(decl.type.type.declname+'_var', quals=decl.type.type.quals, type=decl.type.type.type)
            else:
                if is_number(decl.type.declname[-1])==True :
                    decl=c_ast.Decl(name=decl.name+'_var', quals=decl.quals, storage=decl.storage, funcspec=decl.funcspec, type=c_ast.TypeDecl(declname=decl.type.declname+'_var', quals=decl.type.quals, type=decl.type.type), init=decl.init, bitsize=decl.bitsize)


            if type(decl.type) is c_ast.ArrayDecl:
            	degree=0
                dimensionmap={}
	    	var_type,degree,structType=getArrayDetails(decl,degree,dimensionmap)
		variable=variableclass(decl.name, var_type,None,dimensionmap,initial_value,structType)
	    elif type(decl.type) is c_ast.PtrDecl:
                degree=0
                dimensionmap={}
	    	var_type,degree,structType=getArrayDetails(decl,degree,dimensionmap)
		variable=variableclass(decl.name, var_type,'Pointer',dimensionmap,initial_value,structType)
	    else:
            	for child in decl.children():
                    
            		if type(child[1]) is c_ast.TypeDecl:
                		if type(child[1].type) is c_ast.IdentifierType:
                    			var_type=child[1].type.names[0]
				else:
					if type(child[1].type) is c_ast.Struct:
						structType=child[1].type.name
                                                var_type=child[1].type.name
					else:
                    				initial_value=child[1].value
                    	else:
                    		if type(child[1]) is c_ast.FuncCall:
			    		parameter=''
					if child[1].args is not None:
			    			for param in child[1].args.exprs:
			    				if type(param) is c_ast.ID:
			    					if parameter=='':
					        			parameter = "expres('"+param.name+"')"
					        		else:
					        			parameter += ",expres('"+param.name+"')"
			    				elif type(param) is c_ast.Constant:
			    		    			if parameter=='':
									parameter = "expres('"+param.value+"')"
								else:
					        			parameter += ",expres('"+param.value+"')"
							else:
								if type(statement) is c_ast.ArrayRef:
									degree=0
									stmt,degree=createArrayList_C(statement,degree)
								    	if parameter=='':
										parameter = "expres('d"+str(degree)+'array'+"',["+stmt+"])"
									else:
		        							parameter += ","+"expres('d"+str(degree)+'array'+"',["+stmt+"])"
						#initial_value="['"+child[1].name.name+"',"+parameter+"]"
						initial_value="['"+child[1].name.name+"',"+parameter+"]"
					else:
						#initial_value="expres('"+child[1].name.name+"'"+")"
						initial_value=child[1].name.name
				else:
					if type(child[1]) is c_ast.Constant:
						initial_value=child[1].value
                                        elif type(child[1]) is c_ast.ID:
						initial_value=child[1].name
					else:
                                                #print expressionCreator_C(child[1])
						initial_value=child[1]
            	#print '##############################'
                #print decl.name
                #print var_type
            	#print '##############################'
            	variable=variableclass(decl.name, var_type,None,None,initial_value,structType)
            localvarmap[decl.name]=variable
        elif type(decl) is c_ast.While:
        	localvarmap_temp=getVariablesC(decl.stmt.block_items)
        	for var in localvarmap_temp.keys():
        		localvarmap[var]=localvarmap_temp[var]
        elif type(decl) is c_ast.If:
        	localvarmap_temp=getVariablesC_If(decl)
        	for var in localvarmap_temp.keys():
        		localvarmap[var]=localvarmap_temp[var]
    return localvarmap


def getVariablesC_If(statement):
	localvarmap={}
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			localvarmap_temp=getVariablesC(statement.iftrue.block_items)
		        for var in localvarmap_temp.keys():
        			localvarmap[var]=localvarmap_temp[var]				
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				localvarmap_temp=getVariablesC(statement.iffalse.block_items)
				for var in localvarmap_temp.keys():
        				localvarmap[var]=localvarmap_temp[var]	
		else:
			if type(statement.iffalse) is c_ast.If:
				localvarmap_temp=getVariablesC_If(statement.iffalse)
				for var in localvarmap_temp.keys():
        				localvarmap[var]=localvarmap_temp[var]	
	return localvarmap





def getVariablesInit(statements):
    update_statement=[]
    for decl in statements:
        if type(decl) is c_ast.Decl:
            if type(decl.type) is not c_ast.ArrayDecl and type(decl.type) is not c_ast.PtrDecl:
                if decl.init is not None and '_PROVE' not in decl.name:
                    new_word=None
                    if new_word is None:
                        new_word=copy.deepcopy(decl.init)
                    decl=c_ast.Decl(name=decl.name, quals=decl.quals, storage=decl.storage, funcspec=decl.funcspec, type=c_ast.TypeDecl(declname=decl.type.declname, quals=decl.type.quals, type=decl.type.type), init=None, bitsize=decl.bitsize)
                    update_statement.append(decl)
                    if '_PROVE' not in decl.name:
                        if new_word is not None:
                            update_statement.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=decl.name), rvalue=new_word))
                else:
                    update_statement.append(decl)
            else:
                update_statement.append(decl)
        elif type(decl) is c_ast.While:
        	new_block_temp=getVariablesInit(decl.stmt.block_items)
                update_statement.append(c_ast.While(cond=decl.cond, stmt=c_ast.Compound(block_items=new_block_temp)))
        elif type(decl) is c_ast.If:
                update_statement.append(getVariablesInit_If(decl))
        else:
             update_statement.append(decl)
    return update_statement


def getVariablesInit_If(statement):
	If_stmt=None
        Else_stmt=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			new_block_temp=getVariablesInit(statement.iftrue.block_items)
                        If_stmt=c_ast.Compound(block_items=new_block_temp)
                else:
                    If_stmt=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_block_temp=getVariablesInit(statement.iffalse.block_items)
				Else_stmt=c_ast.Compound(block_items=new_block_temp)
                        else:
                            Else_stmt=statement.iffalse
		else:
			if type(statement.iffalse) is c_ast.If:
				Else_stmt=getVariablesInit_If(statement.iffalse)
                        else:
                                Else_stmt=statement.iffalse
	return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)
















"""

Organization of AST 

"""
               
def organizeStatementToObject_C(statements):
	count=0
	degree=0
	expressions=[]
	for statement in statements:
                if type(statement) is c_ast.Assignment:
			count=count+1
			expression=expressionclass(statement, count, True,degree)
			expressions.append(expression)
                elif type(statement) is c_ast.While:
                    blockexpressions=[]
                    if statement.stmt is not None:
                        degree=degree+1
			count,blockexpressions=blockToExpressions_C(statement.stmt.block_items, degree, count)
			degree=degree-1
		    block=blockclass( blockexpressions, statement.cond, count , True, degree)
		    expressions.append(block)
		else:
			if type(statement) is c_ast.If:
				count,ifclass=ifclassCreator_C(statement, degree, count)
				expressions.append(ifclass)
			else:
				count=count+1
				expression=expressionclass(statement, count, True,degree)
				expressions.append(expression)
					
     	return expressions



"""

Organization of AST 

"""


               
def organize__VERIFIER_nondet_C(statements,count):
	expressions=[]
	for statement in statements:
                if type(statement) is c_ast.Assignment:
			expressions.append(expression)
                elif type(statement) is c_ast.While:
                    blockexpressions=[]
                    if statement.stmt is not None:
			count,blockexpressions=organize__VERIFIER_nondet_C(statement.stmt.block_items,count)
		    block=blockclass( blockexpressions, statement.cond, count , True, degree)
		    expressions.append(block)
		else:
			if type(statement) is c_ast.If:
				count,ifclass=ifclassCreator_C(statement, degree, count)
				expressions.append(ifclass)
			else:
				count=count+1
				expression=expressionclass(statement, count, True,degree)
				expressions.append(expression)
					
     	return expressions,count

"""

Conditionl Loop to a Array of Statement Compatible to Translator Program 
IfClass Creator

"""

def ifclassCreator_C(statement, degree, count):
        blockexpressions1=None
	blockexpressions2=None
	predicate=statement.cond
	#print statement.iftrue.show()
	#print statement.iffalse.show()
        if statement.iftrue is not None:
        	if type(statement.iftrue) is c_ast.Compound:
            		count,blockexpressions1=blockToExpressions_C(statement.iftrue.block_items, degree, count)
            	else:
            		new_block_items=[]
            		new_block_items.append(statement.iftrue)
            		count,blockexpressions1=blockToExpressions_C(new_block_items, degree, count)
        if statement.iffalse is not None and type(statement.iffalse) is c_ast.If:
        	count,blockexpressions2=ifclassCreator_C(statement.iffalse, degree, count)
        else:
        	if statement.iffalse is not None:
        		if type(statement.iffalse) is c_ast.Compound:
        			count,blockexpressions2=blockToExpressions_C(statement.iffalse.block_items, degree, count)
        		else:
        			new_block_items=[]
        			new_block_items.append(statement.iffalse)
            			count,blockexpressions2=blockToExpressions_C(new_block_items, degree, count)
	ifclass=Ifclass(predicate, blockexpressions1, blockexpressions2, count ,True ,degree)
	return count,ifclass



"""

Converting code block,while loop ,conditional expression and expression to corresponding Classes

"""

def blockToExpressions_C(body, degree, count):
	expressions=[]
	if body is not None:
		for statement in body:
                    if type(statement) is c_ast.Assignment:
			count=count+1
			expression=expressionclass(statement, count, True,degree)
			expressions.append(expression)
                    elif type(statement) is c_ast.While:
                        blockexpressions=[]
                        if statement.stmt is not None:
                            degree=degree+1
                            count,blockexpressions=blockToExpressions_C(statement.stmt.block_items, degree, count)
                            degree=degree-1
                        block=blockclass( blockexpressions, statement.cond, count , True, degree)
                        expressions.append(block)
                    else:
			if type(statement) is c_ast.If:
				count,ifclass=ifclassCreator_C(statement, degree, count)
				expressions.append(ifclass)
	return count,expressions




"""

Block of Statement to Array of Statement Compatible to Translator Program 

"""
def programToinductiveDefination_C(expressions, allvariable):
	programsstart=""
	programsend=""
	statements=""
	for expression in expressions:
		if type(expression) is expressionclass:
                    
			if type(expression.getExpression()) is c_ast.Assignment:
                                var=None
                                if type(expression.getExpression().lvalue) is c_ast.ID:
                                    var=str(eval("expres('"+str(expression.getExpression().lvalue.name)+"')"))
                                elif type(expression.getExpression().lvalue) is c_ast.Constant:
                                    var=str(eval("expres('"+str(expression.getExpression().lvalue.value)+"')"))
                                elif type(expression.getExpression().lvalue) is c_ast.ArrayRef:
                                    degree=0
       				    stmt,degree=createArrayList_C(expression.getExpression().lvalue,degree)
                                    var=str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
                                    
                                    
                                elif type(expression.getExpression().lvalue) is c_ast.FuncCall:
                                	parameter=''
				        statement=expression.getExpression().lvalue
					if statement.args is not None:
						for param in statement.args.exprs:
							if type(param) is c_ast.ID:
								if parameter=='':
									parameter = str(eval("expres('"+param.name+"')"))
								else:
									parameter += ","+str(eval("expres('"+param.name+"')"))
							elif type(param) is c_ast.Constant:
								if parameter=='':
									parameter = str(eval("expres('"+param.value+"')"))
								else:
									parameter += ","+str(eval("expres('"+param.value+"')"))
							elif type(param) is c_ast.BinaryOp:
							    	if parameter=='':
									parameter =expressionCreator_C(param)
								else:
					        			parameter += ","+expressionCreator_C(param)
                                                        else:
                                                            if type(param) is c_ast.ArrayRef:
                                                            #parameter_list.append('int')
                                                                degree=0
                                                                stmt,degree=createArrayList_C(param,degree)
                                                                if parameter=='':
                                                                    parameter = str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
                                                                else:
                                                                    parameter += ","+str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
					var="['"+statement.name.name+"',"+parameter+"]"
		
                                
				if expression.getIsPrime()==False:
                                    if programsstart=="":
                                        programsstart="['-1','seq',['-1','=',"+str(var)+","+str(expressionCreator_C(expression.getExpression().rvalue))+"]"
                                        programsend="]"
				    else:
					programsstart+=",['-1','seq',['-1','=',"+str(var)+","+str(expressionCreator_C(expression.getExpression().rvalue))+"]"
					programsend+="]"
				else:
                                    if programsstart=="":
                                        programsstart="['-1','=',"+str(var)+","+str(expressionCreator_C(expression.getExpression().rvalue))+"]"+programsend
                                    else:
                                        programsstart+=",['-1','=',"+str(var)+","+str(expressionCreator_C(expression.getExpression().rvalue))+"]"+programsend

                        elif type(expression.getExpression()) is c_ast.FuncCall:
                        	parameter=''
                        	statement=expression.getExpression()
				if statement.args is not None:
			    		for param in statement.args.exprs:
			    			if type(param) is c_ast.ID:
			    				if parameter=='':
					        		parameter = str(eval("expres('"+param.name+"')"))
					        	else:
					        		parameter += ","+str(eval("expres('"+param.name+"')"))
			    			elif type(param) is c_ast.Constant:
			    		    		if parameter=='':
								parameter = str(eval("expres('"+param.value+"')"))
							else:
					        		parameter += ","+str(eval("expres('"+param.value+"')"))
						elif type(param) is c_ast.BinaryOp:
			    		    		if parameter=='':
								parameter =expressionCreator_C(param)
							else:
					        		parameter += ","+expressionCreator_C(param)
                                                else:
                                                    if type(param) is c_ast.ArrayRef:
                                                        #parameter_list.append('int')
                                                        degree=0
                                                        stmt,degree=createArrayList_C(param,degree)
                                                        if parameter=='':
                                                            parameter = str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
                                                        else:
                                                            parameter += ","+str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
					
                                        if expression.getIsPrime()==False:
						if programsstart=="":
							programsstart="['-1','seq',"+"['"+statement.name.name+"',"+parameter+"]"
					                programsend="]"
						else:
							programsstart+=","+"['-1','seq',"+"['"+statement.name.name+"',"+parameter+"]"
							programsend+="]"
					else:
						if programsstart=="":
					        	programsstart="['-1','seq',"+"['"+statement.name.name+"',"+parameter+"]"+programsend
					        else:
                                        		programsstart+=","+"['-1','seq',"+"['"+statement.name.name+"',"+parameter+"]"+programsend
				else:
  					if expression.getIsPrime()==False:
						if programsstart=="":
							programsstart="['-1','seq',"+str(eval("expres('"+statement.name.name+"'"+")"))
							programsend="]"
						else:
							programsstart+=","+"['-1','seq',"+str(eval("expres('"+statement.name.name+"'"+")"))
							programsend+="]"
					else:
						if programsstart=="":
							programsstart="['-1','seq',"+str(eval("expres('"+statement.name.name+"'"+")"))+programsend
						else:
                                        		programsstart+=","+"['-1','seq',"+str(eval("expres('"+statement.name.name+"'"+")"))+programsend
		elif type(expression) is blockclass:
			predicatestmt="['-1','while',"+expressionCreator_C(expression.predicate)+","+programToinductiveDefination_C( expression.getExpression(), allvariable)+"]"
			if expression.getIsPrime()==False:
				if programsstart=="":
					programsstart="['-1','seq',"+predicatestmt
					programsend="]"
				else:
					programsstart+=",['-1','seq',"+predicatestmt
					programsend+="]"
			else:
				programsstart+=","+predicatestmt+programsend
		elif type(expression) is Ifclass:
			condition=expressionCreator_C(expression.predicate)
			expressionif=None
			expressionelse=None
			predicatestmt=""
			if expression.getExpressionif() is not None:
				expressionif=programToinductiveDefination_C( expression.getExpressionif(), allvariable)
			if expression.getExpressionelse() is not None:
				if type(expression.getExpressionelse()) is Ifclass:
					#expressionelse=programToinductiveDefination( expression.getExpressionelse().getExpressionif(), allvariable)
					expressionelse=programToinductiveDefinationIfElse_C( expression.getExpressionelse(), allvariable)
				else:
					expressionelse=programToinductiveDefination_C( expression.getExpressionelse(), allvariable)
			if expressionif is not None and expressionelse is not None:
                          	predicatestmt="['-1','if2',"+condition+","+expressionif+","+expressionelse+"]"
			elif expressionif is not None and expressionelse is None:
				predicatestmt="['-1','if1',"+condition+","+expressionif+"]"
			if expression.getIsPrime()==False:
				if programsstart=="":
					programsstart="['-1','seq',"+predicatestmt
					programsend="]"
				else:
					programsstart+=",['-1','seq',"+predicatestmt
					programsend+="]"
			else:
				if programsstart=="":
					programsstart=predicatestmt+programsend
				else:
					programsstart+=","+predicatestmt+programsend
	if programsstart[0]==',':
		programsstart=programsstart[1:]	
	return programsstart





"""

IfElse Block Statement to Array of Statement Compatible to Translator Program 

"""
def programToinductiveDefinationIfElse_C(expression, allvariable):
	programsstart=""
	programsend=""
	statements=""
	if type(expression) is expressionclass:
		if type(expression.getExpression()) is c_ast.Assignment:
                        var=None
                        if type(expression.getExpression().lvalue) is c_ast.ID:
                            var=str(eval("expres('"+str(expression.getExpression().lvalue.name)+"')"))
                        elif type(expression.getExpression().lvalue) is c_ast.Constant:
                            var=str(eval("expres('"+str(expression.getExpression().lvalue.value)+"')"))
                        elif type(expression.getExpression().lvalue) is c_ast.ArrayRef:
			    	degree=0
			       	stmt,degree=createArrayList_C(expression.getExpression().lvalue,degree)
    				var=str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
			if expression.getIsPrime()==False:
                            if programsstart=="":
                                programsstart="['-1','seq',['-1','=',"+str(var)+","+str(expressionCreator(expression.getExpression().rhs))+"]"
                                programsend="]"
			    else:
                                programsstart+=",['-1','seq',['-1','=',"+str(var)+","+str(expressionCreator(expression.getExpression().rhs))+"]"
                                programsend+="]"
                        else:
                            if programsstart=="":
                                programsstart+="['-1','=',"+str(var)+","+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
                            else:
                                programsstart+=",['-1','=',"+str(var)+","+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend

	elif type(expression) is blockclass:
		predicatestmt="['-1','while',"+expressionCreator_C(expression.predicate)+","+programToinductiveDefination_C( expression.getExpression(), allvariable)+"]"
		if expression.getIsPrime()==False:
			if programsstart=="":
				programsstart="['-1','seq',"+predicatestmt
				programsend="]"
			else:
				programsstart+=",['-1','seq',"+predicatestmt
				programsend+="]"
		else:
			if programsstart=="":
				programsstart+=","+predicatestmt+programsend
			
	elif type(expression) is Ifclass:
		condition=expressionCreator_C(expression.predicate)
		expressionif=None
		expressionelse=None
		predicatestmt=""
		if expression.getExpressionif() is not None:
			expressionif=programToinductiveDefination_C( expression.getExpressionif(), allvariable)
		if expression.getExpressionelse() is not None:
			if type(expression.getExpressionelse()) is Ifclass:
				#expressionelse=programToinductiveDefination( expression.getExpressionelse().getExpressionif(), allvariable)
				expressionelse=programToinductiveDefinationIfElse_C( expression.getExpressionelse(), allvariable)
			else:
				expressionelse=programToinductiveDefination_C( expression.getExpressionelse(), allvariable)
		if expressionif is not None and expressionelse is not None:
                	predicatestmt="['-1','if2',"+condition+","+expressionif+","+expressionelse+"]"
		elif expressionif is not None and expressionelse is None:
			predicatestmt="['-1','if1',"+condition+","+expressionif+"]"
		if expression.getIsPrime()==False:
			if programsstart=="":
				programsstart="['-1','seq',"+predicatestmt
				programsend="]"
			else:
				programsstart+=",['-1','seq',"+predicatestmt
				programsend+="]"
		else:
			if programsstart=="":
				programsstart=predicatestmt+programsend
			else:
				programsstart+=","+predicatestmt+programsend
 	return programsstart


"""

Program Expression to a Array of Statement Compatible to Translator Program 

"""

fun_call_map={}
current_fun_call=None


def expressionCreator_C(statement):
    expression=""
    global defineMap
    global defineDetaillist
    global fun_call_map
    global current_fun_call
    if type(statement) is c_ast.ID:
    	if statement.name in defineMap.keys():
    		value = defineMap[statement.name]
    		return str(eval("expres('"+value+"')"))
        else:
        	return str(eval("expres('"+statement.name+"')"))
    elif type(statement) is c_ast.Constant:
    	if statement.type=='char':
                if str(statement.value)==str("'\\0'"):
                    return str(eval("expres('0')"))
                else:
                    return "['char',expres("+statement.value+")]"
    	elif statement.type=='float':
    		if statement.value[-1]=='f':
    			#return "expres('"+str(round(float(statement.value[:-1]), 7))+"')"
                        return str(eval("expres('"+str(statement.value[:-1])+"')"))
	        #return "expres('"+str(float(statement.value))+"')"
                return str(eval("expres('"+str(statement.value)+"')"))
	elif statement.type=='double':
                #return "expres('"+str(float(statement.value))+"')"
                return str(eval("expres('"+str(statement.value)+"')"))
    	else:
        	if is_hex(statement.value) is not None:
        		return str(eval("expres('"+is_hex(statement.value)+"')"))
        	else:
        		return str(eval("expres('"+statement.value+"')"))
    elif type(statement) is c_ast.FuncCall:
    	parameter=''
    	parameter_list=[]
    	defineDetaillist=[]
    	defineDetailtemp=[]
    	parameter_list.append('int')
	if statement.args is not None:
    		for param in statement.args.exprs:
    			if type(param) is c_ast.ID:
    				parameter_list.append('int')
    				if param.name in defineMap.keys():
    					param.name = defineMap[param.name]
    				if parameter=='':
		        		parameter = str(eval("expres('"+param.name+"')"))
		        	else:
		        		parameter += ","+str(eval("expres('"+param.name+"')"))
    			elif type(param) is c_ast.Constant:
    				parameter_list.append('int')
    		    		if parameter=='':
					if is_hex(param.value) is not None:
						parameter = str(eval("expres('"+is_hex(param.value)+"')"))
					else:
						parameter = str(eval("expres('"+param.value+"')"))
				else:
		        		if is_hex(param.value) is not None:
		        			parameter += ","+str(eval("expres('"+is_hex(param.value)+"')"))
		        		else:
		        			parameter += ","+str(eval("expres('"+param.value+"')"))
		        elif type(param) is c_ast.UnaryOp:
				if parameter=='':
                                    
			        	parameter = str(eval("expres('"+param.op+"',["+expressionCreator_C(param.expr)+"])"))
			        else:
                                	parameter +=','+str(eval("expres('"+param.op+"',["+expressionCreator_C(param.expr)+"])"))
		        
		        elif type(param) is c_ast.BinaryOp:
				if parameter=='':
			        	parameter =expressionCreator_C(param)
			        else:
                                	parameter +=','+expressionCreator_C(param)
                        elif type(param) is c_ast.FuncCall:
            
				if parameter=='':
                                        #param.show()
			        	parameter =expressionCreator_C(param)
			        else:
                                        #param.show()
                                	parameter +=','+expressionCreator_C(param)
			else:
				if type(param) is c_ast.ArrayRef:
					parameter_list.append('int')
				    	degree=0
				       	stmt,degree=createArrayList_C(param,degree)
    					if parameter=='':
						parameter = str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
					else:
		        			parameter += ","+str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
				
				#print '@@@@@@@@@@@RamRam'
				#print param.show()
				#print '@@@@@@@@@@@'
		defineDetailtemp.append(statement.name.name)
		defineDetailtemp.append(len(parameter_list)-1)
		defineDetailtemp.append(parameter_list)
		defineDetaillist.append(defineDetailtemp)
                
                #if statement.name.name in fun_call_map.keys() and statement.name.name != current_fun_call and '__VERIFIER_nondet_' not in statement.name.name:
                #    fc_count=fun_call_map[statement.name.name]
                #    fc_count+=1
                #    fun_call_map[statement.name.name]=fc_count
                #    return "['"+statement.name.name+"_"+str(fc_count)+"',"+parameter+"]"
                #else:
                #    fun_call_map[statement.name.name]=0
                return "['"+statement.name.name+"',"+parameter+"]"
	else:
		if '__VERIFIER_nondet_' not in statement.name.name:
                    defineDetailtemp.append(statement.name.name)
                    defineDetailtemp.append(len(parameter_list)-1)
                    defineDetailtemp.append(parameter_list)
                    defineDetaillist.append(defineDetailtemp)
		#if statement.name.name in fun_call_map.keys() and statement.name.name != current_fun_call and '__VERIFIER_nondet_' not in statement.name.name:
                #    fc_count=fun_call_map[statement.name.name]
                #    fc_count+=1
                #    fun_call_map[statement.name.name]=fc_count
                #    return str(eval("expres('"+statement.name.name+"_"+str(fc_count)+"'"+")"))
                #else:
                #    fun_call_map[statement.name.name]=0
                return str(eval("expres('"+statement.name.name+"'"+")"))
                    
    elif type(statement) is c_ast.ArrayRef:
    	degree=0
       	stmt,degree=createArrayList_C(statement,degree)
    	return str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
    else:
        if type(statement) is c_ast.Cast:
            if statement.to_type.type.type.names[0]=='float':
                return "['"+"_ToReal"+"',"+expressionCreator_C(statement.expr)+"]"
            elif statement.to_type.type.type.names[0]=='double':
                return "['"+"_ToReal"+"',"+expressionCreator_C(statement.expr)+"]"
            elif statement.to_type.type.type.names[0]=='int':
                return "['"+"_ToInt"+"',"+expressionCreator_C(statement.expr)+"]"
        else:
            
            if statement.op in ['+','-','*','/','%']:
                expression="expres('"
                expression+=statement.op
                if type(statement) is c_ast.BinaryOp:
                    expression+="',["+expressionCreator_C(statement.left)
                    expression+=','+expressionCreator_C(statement.right)
                else:
                    expression+="',["+expressionCreator_C(statement.expr)
                expression+='])'
                expression=str(eval(expression))
                return expression
            else:
                #if statement.op == '!=':
                #    statement=c_ast.UnaryOp(op='!', expr=c_ast.BinaryOp(op='==',left=statement.left, right=statement.right))

                expression="['"
                if statement.op == '&&':
                    expression+='and'
                elif statement.op == '||':
                    expression+='or'
                elif statement.op == '!':
                    expression+='not'
                else:
                    expression+=statement.op
                if type(statement) is c_ast.BinaryOp:
                    expression+="',"+expressionCreator_C(statement.left)

                    expression+=','+expressionCreator_C(statement.right)
                    expression+=']'
                else:
                    expression="expres('"
                    if statement.op == '!':
                            expression+='not'
                    else:
                            expression+=statement.op
                    expression+="',["+expressionCreator_C(statement.expr)+"]"
                    expression+=')'
                    expression=str(eval(expression))
                return expression




"""

Construct Array List

"""
def createArrayList_C(statement,degree):
	if type(statement) is c_ast.ArrayRef:
		degree=degree+1
		stmt=''
		if type(statement.name) is c_ast.ArrayRef:
			stmt,degree=createArrayList_C(statement.name,degree)
			if type(statement.subscript) is c_ast.ID:
				stmt+=",expres('"+statement.subscript.name+"')"
                        elif type(statement.subscript) is c_ast.BinaryOp:
                                stmt+=","+expressionCreator_C(statement.subscript)
			else:
				stmt+=",expres('"+statement.subscript.value+"')"
			return stmt,degree
		else:
			if type(statement.name) is c_ast.ID:
				if type(statement.subscript) is c_ast.ID:
					stmt+="expres('"+statement.name.name+"')"+",expres('"+statement.subscript.name+"')"
					return stmt,degree
				elif type(statement.subscript) is c_ast.BinaryOp:
					stmt+="expres('"+statement.name.name+"')"+","+expressionCreator_C(statement.subscript)
					return stmt,degree
				else:
                                        if type(statement.subscript) is c_ast.ArrayRef:
                                            temp_degree=0
                                            temp_stmt,temp_degree=createArrayList_C(statement.subscript,temp_degree)
                                            stmt+="expres('"+statement.name.name+"')"+","+"expres('d"+str(temp_degree)+'array'+"',["+temp_stmt+"])"
                                            return stmt,degree 
                                        else:
                                            stmt+="expres('"+statement.name.name+"')"+",expres('"+statement.subscript.value+"')"
                                            return stmt,degree
			else:
				if type(statement.name) is c_ast.FuncCall:
					if type(statement.subscript) is c_ast.FuncCall:
						stmt+=expressionCreator_C(statement.name)+","+expressionCreator_C(statement.subscript)
					elif type(statement.subscript) is c_ast.BinaryOp:
						stmt+=expressionCreator_C(statement.name)+","+expressionCreator_C(statement.subscript)
					else:
						stmt+=expressionCreator_C(statement.name)+",expres('"+statement.subscript.value+"')"
				else:
					stmt+="expres('"+statement.name.value+"')"+",expres('"+statement.subscript.value+"')"
				return stmt,degree
	else:
		return "expres('"+statement.name+"')",degree














    
"""
 
Translate Syntax Code 
 
"""
 

"""

Syntax translation module

"""



def syntaxTranslate(statements):
        update_statements=[]
        for statement in statements:
                if type(statement) is c_ast.UnaryOp:
                        
                        if statement.op=='++' or statement.op=='p++':
                                update_statements.append(c_ast.Assignment(op='=',lvalue=statement.expr, rvalue=c_ast.BinaryOp(op='+',left=statement.expr, right=c_ast.Constant('int','1'))))
                        elif statement.op=='--' or statement.op=='p--':
                                update_statements.append(c_ast.Assignment(op='=',lvalue=statement.expr, rvalue=c_ast.BinaryOp(op='-',left=statement.expr, right=c_ast.Constant('int','1'))))
                        else:
                                update_statements.append(statement)
                elif type(statement) is c_ast.For:
                        if type(statement.init) is c_ast.DeclList:
                            for stmt in statement.init.decls:
                                update_statements.append(stmt)
                        else:
                            update_statements.append(statement.init)
                        if type(statement.stmt) is c_ast.Compound:
                        	new_block_items=statement.stmt.block_items
                        	if new_block_items is None:
                                    new_block_items=[]
                        	new_block_items.append(statement.next)
                        	new_block_items=syntaxTranslate(new_block_items)
                        	new_stmt=c_ast.Compound(block_items=new_block_items)
                        	update_while=c_ast.While(statement.cond,new_stmt)
                        	update_statements.append(update_while)
                        else:
                        	new_block_items=[]
                        	new_block_items.append(statement.stmt)
                        	new_block_items.append(statement.next)
				new_block_items=syntaxTranslate(new_block_items)
				new_stmt=c_ast.Compound(block_items=new_block_items)
				update_while=c_ast.While(statement.cond,new_stmt)
                        	update_statements.append(update_while)
                elif type(statement) is c_ast.DoWhile:
                	if type(statement.stmt) is c_ast.Compound:
		        	new_block_items=statement.stmt.block_items
		        	if new_block_items is None:
                                    new_block_items=[]
		        	for item in new_block_items:
		        		update_statements.append(item)
		        	new_block_items=syntaxTranslate(new_block_items)
		        	new_stmt=c_ast.Compound(block_items=new_block_items)
		        	update_while=c_ast.While(statement.cond,new_stmt)
                        	update_statements.append(update_while)
                        else:
                        	new_block_items=[]
                        	new_block_items.append(statement.stmt)
                        	for item in new_block_items:
					update_statements.append(item)
				new_block_items=syntaxTranslate(new_block_items)
				new_stmt=c_ast.Compound(block_items=new_block_items)
				update_while=c_ast.While(statement.cond,new_stmt)
                        	update_statements.append(update_while)
                elif type(statement) is c_ast.Switch:
                	stmts=statement.stmt.block_items
                	statement=convertToIfElse(stmts,statement.cond)
                	#update_statements.append(statement)
                        update_statements.append(syntaxTranslateIf(statement))
                elif type(statement) is c_ast.While:
                	if type(statement.stmt) is c_ast.Compound:
                		update_statements.append(c_ast.While(cond=syntaxTranslateStmt(statement.cond),stmt=c_ast.Compound(block_items=syntaxTranslate(statement.stmt.block_items))))
                	else:
                		new_block_items=[]
				new_block_items.append(statement.stmt)
				update_statements.append(c_ast.While(cond=syntaxTranslateStmt(statement.cond),stmt=c_ast.Compound(block_items=syntaxTranslate(new_block_items))))
                elif type(statement) is c_ast.If:
                	update_statements.append(syntaxTranslateIf(statement))
                elif type(statement) is c_ast.Assignment:
                	if statement.op=='+=':
                		if type(statement.lvalue) is c_ast.ID:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='+', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                		else:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='+', left=statement.lvalue, right=statement.rvalue)))
                	elif statement.op=='-=':
                		if type(statement.lvalue) is c_ast.ID:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='-', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                		else:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='-', left=statement.lvalue.name, right=statement.rvalue)))
                	elif statement.op=='/=':
                		if type(statement.lvalue) is c_ast.ID:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='/', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                		else:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='/', left=statement.lvalue, right=statement.rvalue)))
                	elif statement.op=='%=':
                		if type(statement.lvalue) is c_ast.ID:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='%', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                		else:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='%', left=statement.lvalue, right=statement.rvalue)))
                	elif statement.op=='*=':
                		if type(statement.lvalue) is c_ast.ID:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='*', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                		else:
                			update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='*', left=statement.lvalue, right=statement.rvalue)))
                	
                	else:
                		if type(statement.rvalue) is c_ast.Assignment:
                			stmts=[]
                			separateAllAssignment(statement,stmts)
                			for stmt in stmts:
                				update_statements.append(stmt)
                		else:
                			if type(statement.lvalue) is c_ast.ID and type(statement.rvalue) is c_ast.TernaryOp:
                                            
                                            update_statements.append(syntaxTranslateStmtTernaryOp(statement))
                                            
                                        else:
                                            update_statements.append(c_ast.Assignment(op=statement.op, lvalue=statement.lvalue, rvalue=statement.rvalue))
                
                elif type(statement) is c_ast.ExprList:
                    statement=syntaxTranslate(statement.exprs)
                    for exp_stmt in statement:
                         update_statements.append(exp_stmt)
                elif type(statement) is c_ast.Label:
			update_statements.append(c_ast.Label(name=statement.name, stmt=None))
			if type(statement.stmt) is c_ast.Compound:
				new_block_items=syntaxTranslate(statement.stmt.block_items)
				for item in new_block_items:
					update_statements.append(item)	
			else:
				if statement.stmt is not None:
					new_block_items=[]
					new_block_items.append(statement.stmt)
					new_block_items=syntaxTranslate(new_block_items)
					for item in new_block_items:
						update_statements.append(item)

                elif type(statement) is c_ast.Compound:
                	new_stmts=syntaxTranslate(statement.block_items)
                	for stmt in new_stmts:
                		update_statements.append(stmt)
                	
                else:
                        if type(statement) is not c_ast.EmptyStatement:
                        	update_statements.append(statement)
        return update_statements



def syntaxTranslateIf(statement):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=syntaxTranslate(statement.iftrue.block_items))
			else:
				new_iftrue=c_ast.Compound(block_items=[])
		else:
			if type(statement.iftrue) is c_ast.UnaryOp:
				new_iftrue=syntaxTranslateStmt(statement.iftrue)
			elif type(statement.iftrue) is c_ast.BinaryOp:
				new_iftrue=syntaxTranslateStmt(statement.iftrue)
			else:
				new_blocks=[]
				new_blocks.append(statement.iftrue)
				new_iftrue=c_ast.Compound(block_items=syntaxTranslate(new_blocks))
				
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=syntaxTranslate(statement.iffalse.block_items))
			else:
				new_iffalse=c_ast.Compound(block_items=[])
		else:
			if type(statement.iffalse) is c_ast.If:
				new_iffalse=syntaxTranslateIf(statement.iffalse)
			else:
				if type(statement.iffalse) is c_ast.UnaryOp:
					new_iffalse=syntaxTranslateStmt(statement.iffalse)
				elif type(statement.iffalse) is c_ast.BinaryOp:
					new_iffalse=syntaxTranslateStmt(statement.iffalse)
				else:
					new_blocks=[]
					new_blocks.append(statement.iffalse)
					new_iffalse=c_ast.Compound(block_items=syntaxTranslate(new_blocks))
	return c_ast.If(cond=syntaxTranslateStmt(statement.cond), iftrue=new_iftrue, iffalse=new_iffalse)


#
# Change Assignment statement to a list of Assignment statements
#


def separateAllAssignment(statement,stmts):
	if type(statement) is c_ast.Assignment:
		if type(statement.rvalue) is c_ast.Assignment:
			value=separateAllAssignment(statement.rvalue,stmts)
			stmts.append(c_ast.Assignment(op=statement.op, lvalue=statement.lvalue, rvalue=value))
			return value
		else:
			stmts.append(c_ast.Assignment(op=statement.op, lvalue=statement.lvalue, rvalue=statement.rvalue))
			return statement.rvalue
	return None
	

"""

Covert Switch Case to If-Else-If loop

"""



def convertToIfElse(statements,condition):
	if statements is not None and len(statements)>0:
		statement=statements[0]
		if type(statement) is not c_ast.Default:
			new_condition_left=constructCondition(statements,condition)
			new_condition_right,new_block_items,statements,is_break=constructBody(statements,condition)
			new_compund_left=c_ast.Compound(block_items=new_block_items)
			
			if new_condition_left is not None:
				new_Else_stmt=convertToIfElse(statements,condition)
				new_If_stmt=c_ast.If(cond=c_ast.BinaryOp(op='||', left=new_condition_left, right=new_condition_right),iftrue=new_compund_left,iffalse=new_Else_stmt)
				return new_If_stmt
			else:
				new_Else_stmt=convertToIfElse(statements,condition)
				new_If_stmt=c_ast.If(cond=new_condition_right,iftrue=new_compund_left,iffalse=new_Else_stmt)
				return new_If_stmt
		else:
			update_stmts=[]
			for stmt in statement.stmts:
				#if type(stmt) is not c_ast.Break:
                                update_stmts.append(stmt)
			return c_ast.Compound(block_items=update_stmts)
		

	return None


def syntaxTranslateStmt(statement):
	if type(statement) is c_ast.UnaryOp:
		if statement.op=='++' or statement.op=='p++':
	        	return c_ast.Assignment(op='=',lvalue=statement.expr, rvalue=c_ast.BinaryOp(op='+',left=statement.expr, right=c_ast.Constant('int','1')))
		elif statement.op=='--' or statement.op=='p--':
	        	return c_ast.Assignment(op='=',lvalue=statement.expr, rvalue=c_ast.BinaryOp(op='-',left=statement.expr, right=c_ast.Constant('int','1')))
	        else:
                        return statement
	else:
		if type(statement) is c_ast.BinaryOp:
			return c_ast.BinaryOp(op=statement.op,left=syntaxTranslateStmt(statement.left),right=syntaxTranslateStmt(statement.right))
		else:
			return statement



def syntaxTranslateStmtTernaryOp(statement):
    new_blocks_true=[]
    
    new_blocks_true.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=statement.rvalue.iftrue))
    new_iftrue=c_ast.Compound(block_items=syntaxTranslate(new_blocks_true))
                        
    new_blocks_false=[]
    
    new_blocks_false.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=statement.rvalue.iffalse))
    new_iffalse=c_ast.Compound(block_items=syntaxTranslate(new_blocks_false))
                        
    return c_ast.If(cond=statement.rvalue.cond,iftrue=new_iftrue,iffalse=new_iffalse)




"""

Covert Switch Case to If-Else-If loop

"""

	
def constructCondition(statements,condition):
	if statements is not None and len(statements)>0:
		statement=statements[0]
		if type(statement) is not c_ast.Default:
			if len(statement.stmts)==0:
				new_condition_left=c_ast.BinaryOp(op='==', left=condition, right=statement.expr)
				new_condition_right=constructCondition(statements[1:],condition)
				if new_condition_right is None:
					return new_condition_left
				else:
					return c_ast.BinaryOp(op='||', left=new_condition_left, right=new_condition_right)
			else:
				return None
		else:
			return None
	return None


"""

Covert Switch Case to If-Else-If loop

"""


def constructBody(statements,condition):
	if statements is not None and len(statements)>0:
		statement=statements[0]
		if type(statement) is not c_ast.Default:
			if len(statement.stmts)>0:
				update_stmts=[]
				new_condition=c_ast.BinaryOp(op='==', left=condition, right=statement.expr)
				is_break=False
				for stmt in statement.stmts:
					if type(stmt) is c_ast.Break:
						is_break=True;
					else:
						update_stmts.append(stmt)
				return new_condition,update_stmts,statements[1:],is_break
			else:
				return constructBody(statements[1:],condition)
		else:
			return None,None,None,False
	return None,None,None,False



			    
"""
 
Goto removal Modules Start

"""

new_variable={}

break_count=0

continue_count=0



def remove_return(statements,membermethod):
	end_label_map={}
	statements=returnReplacement(statements,end_label_map)
	update_statements=[]
        if isRetPresent(statements)==True:
            if membermethod is not None:
                if membermethod.getreturnType() is not None and membermethod.getreturnType() is not 'array':
                    temp=c_ast.Decl(name='RET', quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname='RET', quals=[], type=c_ast.IdentifierType(names=[membermethod.getreturnType()])), init=c_ast.Constant(type=membermethod.getreturnType(), value='0'), bitsize=None)
                    update_statements.append(temp)
                else:
                    temp=c_ast.Decl(name='RET', quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname='RET', quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                    update_statements.append(temp)
	for statement in statements:
		update_statements.append(statement)
	for label in end_label_map.keys():
    		update_statements.append(c_ast.Label(name=label, stmt=None))
    	return update_statements



def isRetPresent(statements):
    status_flag=False
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            if type(statement.lvalue) is not c_ast.UnaryOp and type(statement.lvalue.name) is str and 'RET' in statement.lvalue.name:
                status_flag=True
        elif type(statement) is c_ast.If:
            if isRetPresentIf(statement)==True:
                status_flag=True
    return status_flag

def isRetPresentIf(statement):
        status_flag=False
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
                                if isRetPresent(statement.iftrue.block_items)==True:
                                    status_flag=True
		else:
                    if type(statement.iftrue) is c_ast.Assignment:
                        if type(statement.iftrue.lvalue) is not c_ast.UnaryOp and type(statement.iftrue.lvalue.name) is str and 'RET' in statement.iftrue.lvalue.name:
                            status_flag=True
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
                            if isRetPresent(statement.iffalse.block_items)==True:
                                    status_flag=True
		elif type(statement.iffalse) is c_ast.If:
			new_iffalse=isRetPresentIf(statement.iffalse)
		else:
                    if type(statement.iffalse) is c_ast.Assignment:
                        if type(statement.iffalse.lvalue) is not c_ast.UnaryOp and type(statement.iffalse.lvalue.name) is str and 'RET' in statement.iffalse.lvalue.name:
                            status_flag=True
	return status_flag


"""

Is Variable is present and Type


"""

def isVarPresnt(statements,variable_name):
    status_flag=False
    for statement in statements:
        if type(statement) is c_ast.Assignment:
                flag_r=isVarPresntStmt(statement.rvalue,variable_name)
                flag_l=isVarPresntStmt(statement.lvalue,variable_name)
                if flag_r==True and flag_l==True:
                    return True
                elif flag_r==False and flag_l==True:
                    return True 
                elif flag_r==True and flag_l==False:
                    return True 
        elif type(statement) is c_ast.If:
            if isVarPresntIf(statement,variable_name)==True:
                return True
        elif type(statement) is c_ast.While:
            if type(statement.stmt) is c_ast.Compound:
                if isVarPresnt(statement.stmt.block_items,variable_name)==True:
                    return True
    return False

def isVarPresntIf(statement,variable_name):
        status_flag=False
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
                                if isVarPresnt(statement.iftrue.block_items,variable_name)==True:
                                    status_flag=True
		else:
                    if type(statement.iftrue) is c_ast.Assignment:
                        flag_r=isVarPresntStmt(statement.iftrue.rvalue,variable_name)
                        flag_l=isVarPresntStmt(statement.iftrue.lvalue,variable_name)
                        if flag_r==True and flag_l==True:
                            status_flag = True
                        elif flag_r==False and flag_l==True:
                            status_flag = True 
                        elif flag_r==True and flag_l==False:
                            status_flag = True
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
                            if isVarPresnt(statement.iffalse.block_items,variable_name)==True:
                                    status_flag=True
		elif type(statement.iffalse) is c_ast.If:
			if isVarPresntIf(statement.iffalse,variable_name):
                            status_flag=True
		else:
                    if type(statement.iffalse) is c_ast.Assignment:
                        flag_r=isVarPresntStmt(statement.iffalse.rvalue,variable_name)
                        flag_l=isVarPresntStmt(statement.iffalse.lvalue,variable_name)
                        if flag_r==True and flag_l==True:
                            status_flag = True
                        elif flag_r==False and flag_l==True:
                            status_flag = True 
                        elif flag_r==True and flag_l==False:
                            status_flag = True
	return status_flag


def isVarPresntStmt(statement,variable_name):
	if type(statement) is c_ast.UnaryOp:
                return isVarPresntStmt(statement.expr,variable_name)
        elif type(statement) is c_ast.BinaryOp:
                flag_r=isVarPresntStmt(statement.right,variable_name)
                flag_l=isVarPresntStmt(statement.left,variable_name)
                if flag_r==True and flag_l==True:
                    return True
                elif flag_r==False and flag_l==True:
                    return True 
                elif flag_r==True and flag_l==False:
                    return True 
                else:
                    return False 
        elif type(statement) is c_ast.ID:
            if variable_name==statement.name:
                return True
            else:
                return False
        elif type(statement) is c_ast.StructRef:
            return isVarPresntStmt(statement.name,variable_name)
        elif type(statement) is c_ast.ArrayRef:
            if variable_name == getArrayName(statement):
                return True
            else:
                return False
	else:
            return False









"""

Method for simplification of Condition

"""

def simplifyCondition(statement):
	if type(statement) is c_ast.UnaryOp:
		if statement.op=='!':
			if type(statement.expr) is c_ast.ID:
				return statement
			elif type(statement.expr) is c_ast.Constant:
				return statement
			elif type(statement.expr) is c_ast.ArrayRef:
				return statement
			elif type(statement.expr) is c_ast.FuncCall:
				return statement
			else:
				return getComplement(statement.expr)
		else:
			return c_ast.UnaryOp(op=statement.op,expr=simplifyCondition(statement.expr))
	elif type(statement) is c_ast.BinaryOp:
		return c_ast.BinaryOp(op=statement.op,left=simplifyCondition(statement.left), right=simplifyCondition(statement.right))
	else:
		return statement

"""

Method for Generate  Complement of Condition

"""


def getComplement(statement):
	if type(statement) is c_ast.UnaryOp:
		if statement.op=='!': 
			return simplifyCondition(statement.expr)
		else:
			return c_ast.UnaryOp(op=statement.op,expr=simplifyCondition(statement.expr))
	
	elif type(statement) is c_ast.BinaryOp:
		if statement.op=='<':
			return c_ast.BinaryOp(op='>=',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='>':
			return c_ast.BinaryOp(op='<=',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='<=':
			return c_ast.BinaryOp(op='>',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='>=':
			return c_ast.BinaryOp(op='<',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='!=':
			return c_ast.BinaryOp(op='==',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='==':
			return c_ast.BinaryOp(op='!=',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='&&':
			return c_ast.BinaryOp(op='||',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='||':
			return c_ast.BinaryOp(op='&&',left=getComplement(statement.left), right=getComplement(statement.right))
		else:
			return c_ast.BinaryOp(op=statement.op,left=getComplement(statement.left), right=getComplement(statement.right))


	else:
		return statement




"""

For Whole program

"""

def changeCondition(statement):
	if type(statement) is c_ast.ID:
		return c_ast.BinaryOp(op='>',left=statement,right=c_ast.Constant(type='int', value='0'))
	elif type(statement) is c_ast.Constant:
		return c_ast.BinaryOp(op='>',left=statement,right=c_ast.Constant(type='int', value='0'))
	elif type(statement) is c_ast.FuncCall:
		return c_ast.BinaryOp(op='>',left=statement,right=c_ast.Constant(type='int', value='0'))
	elif type(statement) is c_ast.ArrayRef:
		return c_ast.BinaryOp(op='>',left=statement,right=c_ast.Constant(type='int', value='0'))
	elif type(statement) is c_ast.UnaryOp:
		if statement.op=='!':
			if type(statement.expr) is c_ast.ID:
				return c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
			elif type(statement.expr) is c_ast.Constant:
				return c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
			elif type(statement.expr) is c_ast.FuncCall:
				return c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
			elif type(statement.expr) is c_ast.ArrayRef:
				return c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
			else:
				return statement
		else:
			return statement
	elif type(statement) is c_ast.BinaryOp:
                left_stmt=None
                right_stmt=None
                if statement.op=='||':
                    if type(statement.left) is c_ast.ID:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.Constant:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.FuncCall:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.ArrayRef:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    else:
                        left_stmt=changeCondition(statement.left)
                        
                    if type(statement.right) is c_ast.ID:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.Constant:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.FuncCall:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.ArrayRef:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    else:
                        right_stmt=changeCondition(statement.right)
                    return c_ast.BinaryOp(op=statement.op,left=left_stmt, right=right_stmt)
                elif statement.op=='&&':
                    if type(statement.left) is c_ast.ID:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.Constant:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.FuncCall:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.ArrayRef:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    else:
                        left_stmt=changeCondition(statement.left)
                        
                    if type(statement.right) is c_ast.ID:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.Constant:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.FuncCall:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.ArrayRef:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    else:
                        right_stmt=changeCondition(statement.right)
                    return c_ast.BinaryOp(op=statement.op,left=left_stmt, right=right_stmt)
                else:
                 	return statement
                        
		
	else:
		return statement




def modificationOfCondition(statement):
	if type(statement) is c_ast.ID:
		return True,statement
	elif type(statement) is c_ast.Constant:
		return True,statement
	elif type(statement) is c_ast.FuncCall:
		return True,statement
	elif type(statement) is c_ast.UnaryOp:
		if statement.op=='!':
			status,statement.expr=modificationOfCondition(statement.expr)
			if status==True:
				return False,c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
			else:
				return True,statement
		else:
			return True,statement
	elif type(statement) is c_ast.BinaryOp:
		left_stmt=None
                right_stmt=None
		if statement.op=='||':
			status,left_stmt=modificationOfCondition(statement.left)
			if status==True:
				left_stmt=c_ast.BinaryOp(op='>',left=left_stmt,right=c_ast.Constant(type='int', value='0'))
			status=False
			status,right_stmt=modificationOfCondition(statement.right)
			if status==True:
				right_stmt=c_ast.BinaryOp(op='>',left=right_stmt,right=c_ast.Constant(type='int', value='0'))
			return False,c_ast.BinaryOp(op=statement.op,left=left_stmt, right=right_stmt)
		elif statement.op=='&&':
			status,left_stmt=modificationOfCondition(statement.left)
			if status==True:
				left_stmt=c_ast.BinaryOp(op='>',left=left_stmt,right=c_ast.Constant(type='int', value='0'))
			status=False
			status,right_stmt=modificationOfCondition(statement.right)
			if status==True:
				right_stmt=c_ast.BinaryOp(op='>',left=right_stmt,right=c_ast.Constant(type='int', value='0'))
			return False,c_ast.BinaryOp(op=statement.op,left=left_stmt, right=right_stmt)
		elif statement.op=='>':
			return False,statement
		elif statement.op=='<':
			return False,statement
		elif statement.op=='>=':
			return False,statement
		elif statement.op=='<=':
			return False,statement
		elif statement.op=='=':
			return False,statement
		elif statement.op=='==':
			return False,statement
		elif statement.op=='!=':
			return False,statement
		else:
			status1,left_stmt=modificationOfCondition(statement.left)
			status2,right_stmt=modificationOfCondition(statement.right)
			if status1==True and status2==True:
				return True,c_ast.BinaryOp(op=statement.op,left=left_stmt,right=right_stmt)
			else:
				return False,c_ast.BinaryOp(op=statement.op,left=left_stmt,right=right_stmt)
			
	else:
		return False,statement
		


def changeConditionProgram(statements):
	if statements is not None:
		update_statements=[]
		for statement in statements:
			if type(statement) is c_ast.If:
				update_statements.append(changeConditionProgramIf(statement))
			elif type(statement) is c_ast.While:
				update_statements.append(c_ast.While(cond=changeCondition(statement.cond),stmt=c_ast.Compound(block_items=changeConditionProgram(statement.stmt.block_items))))
			else:
				update_statements.append(statement)
		return update_statements			
	return None



def changeConditionProgramIf(statement):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=changeConditionProgram(statement.iftrue.block_items))
			else:
				new_iftrue=statement.iftrue
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=changeConditionProgram(statement.iffalse.block_items))
			else:
				new_iftrue=statement.iffalse
		elif type(statement.iffalse) is c_ast.If:
			new_iffalse=changeConditionProgramIf(statement.iffalse)
		else:
			new_iffalse=statement.iffalse
	return c_ast.If(cond=changeCondition(statement.cond),iftrue=new_iftrue,iffalse=new_iffalse)




def simplifyProgram(statements):
	if statements is not None:
		update_statements=[]
		for statement in statements:
			if type(statement) is c_ast.If:
				update_statements.append(simplifyProgram_If(statement))
			elif type(statement) is c_ast.While:
				update_statements.append(c_ast.While(cond=simplifyCondition(statement.cond),stmt=c_ast.Compound(block_items=simplifyProgram(statement.stmt.block_items))))
			else:
				update_statements.append(statement)
		return update_statements			
	return None



def simplifyProgram_If(statement):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=simplifyProgram(statement.iftrue.block_items))
			else:
				new_iftrue=statement.iftrue
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=simplifyProgram(statement.iffalse.block_items))
			else:
				new_iftrue=statement.iffalse
		elif type(statement.iffalse) is c_ast.If:
			new_iffalse=simplifyProgram_If(statement.iffalse)
		else:
			new_iffalse=statement.iffalse
	return c_ast.If(cond=simplifyCondition(statement.cond),iftrue=new_iftrue,iffalse=new_iffalse)



def removeDeadCode(statements):
	update_statements=[]
	flag=False
	if statements is not None:
		for statement in statements:
			if type(statement) is c_ast.Goto:
				flag=True
			elif type(statement) is c_ast.Label:
				flag=False
				stmts=statement.stmt
				if stmts is not None:
					for stmt in stmts:
						update_statements.append(stmt)
			else:
				if flag==False:
					update_statements.append(statement)
	return update_statements



def gotoremoval(statements):
	if statements is not None:
		label_map=constructLabelTable(statements,0,0,0)
		updateLabelTable(statements,0,0,0,label_map)
		keys=label_map.keys()
		for key in keys:
			labelMap={}
			listL=label_map[key]
			if len(listL[3])>1:
		    		statements=removeMultipleLabel(statements,key,labelMap)
		    		statements=addMultipleLabel(statements,key,labelMap)
		    		label_map=constructLabelTable(statements,0,0,0)
    				updateLabelTable(statements,0,0,0,label_map)
    			else:
    				if len(listL[3])==0:
					#statements=removeOrphanLabel(statements,key)
					label_map=constructLabelTable(statements,0,0,0)
    					updateLabelTable(statements,0,0,0,label_map)
    			
		label_map=constructLabelTable(statements,0,0,0)
    		updateLabelTable(statements,0,0,0,label_map)
    		
    		
		blank_label_map1={}
		blank_label_map2={}
		for element in label_map.keys():
			temp_list=label_map[element]
			temp_temp_list=temp_list[3]
			temp_temp_list1=[]
			temp_temp_list2=[]
			for iteam in temp_temp_list:
				if iteam[3] is not None:
					temp_temp_list1.append(iteam)
				else:
					temp_temp_list2.append(iteam)
			
			
			if len(temp_temp_list1)>0:
				temp_list1=[]
				temp_list1.append(temp_list[0])
				temp_list1.append(temp_list[1])
				temp_list1.append(temp_list[2])
				temp_list1.append(temp_temp_list1)
				blank_label_map1[element]=temp_list1
			
			if len(temp_temp_list2)>0:
				temp_list2=[]
				temp_list2.append(temp_list[0])
				temp_list2.append(temp_list[1])
				temp_list2.append(temp_list[2])
				temp_list2.append(temp_temp_list2)
				blank_label_map2[element]=temp_list2
		
		#print '$$$$$$$$$$$'
                #print statements
                #print '$$$$$$$$$$$'
		label_map=blank_label_map1
		keys=label_map.keys()
		if len(keys)>0:
			item=keys[0]
			element = label_map[item]
    			lists = element[3]
    			for list in lists:
    				if element[0]>=list[0] and element[1]>=list[1]:
                                        #print 'xxxxx1'
        				statements=goto_finder(statements,item)
                                        #print '$$$$$$$$$$$1'
                                        #generator = c_generator.CGenerator()
                                        #print(generator.visit(c_ast.Compound(block_items=statements)))
                                        #print item
                                        #print '$$$$$$$$$$$1'
    					statements=go_block_finder(statements,item)
    					statements=gotoremoval(statements)
    				else:
                                        if element[1]>=1:
                                                #print 'xxxxx2'
    						statements=label_finder_inside(statements,item)
    						statements=go_block_finder(statements,item)
       						statements=gotoremoval(statements)
       					else:
                                                #print 'xxxxx3'
						statements=label_finder(statements,item)
						statements=go_block_finder(statements,item)
       						statements=gotoremoval(statements)
    	return statements





#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label
testcount=0

def go_block_finder(statements,label):
	if statements is not None:
		flag_block_label=check_label_block(statements,label)  
		flag_block_goto=check_goto_block_Sp(statements,label)
		if flag_block_label==True and flag_block_goto==True:
                        #print 'XXXYYYYY1'
                        #print '#######jai shree ram'
                        #generator = c_generator.CGenerator() 
                        #print(generator.visit(c_ast.Compound(block_items=statements)))
                        #print '#######jai shree ram'
			return remove_goto_block(statements,label)
		else:
			update_statements=[]
                        #print 'XXXYYYYY2'
			for statement in statements:
				if type(statement) is c_ast.If:
					update_statements.append(go_block_finder_if(statement,label))
				elif type(statement) is c_ast.While:
					update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=go_block_finder(statement.stmt.block_items,label))))
				else:
					update_statements.append(statement)
		return update_statements
	return statements
				


#Finding Goto in a If Block to Call gotomovein
#Parameter pass statement 
#Label

def go_block_finder_if(statement,label):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=go_block_finder(statement.iftrue.block_items,label))
			else:
				new_iftrue=statement.iftrue
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=go_block_finder(statement.iffalse.block_items,label))
			else:
				new_iftrue=statement.iffalse
		elif type(statement.iffalse) is c_ast.If:
			new_iffalse=go_block_finder_if(statement.iffalse,label)
		else:
			new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond,iftrue=new_iftrue,iffalse=new_iffalse)






#Method to Remove Goto 


def remove_goto_block(statements,label): 
	flag_block_label=check_label_block(statements,label)  
	flag_block_goto=check_goto_block_Sp(statements,label)
	flag_block2,condition=check_goto(statements,label)
	flag_label=False
	flag_goto=False
	new_statements1=[]
	new_statements2=[]
	process_part1=False
	process_part2=False
	if flag_block_label==True and flag_block_goto==True:
                #print '#######1234'
                #generator = c_generator.CGenerator() 
                #print(generator.visit(c_ast.Compound(block_items=statements)))
                #print '#######1234'
		for statement in statements:
			#print type(statement)
			#print flag_label
			#print flag_goto
			if type(statement) is c_ast.Label:
				if label==statement.name:
					process_part2=True			
					if flag_goto==True:
                                                #print 'XXXX1'
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2),iffalse=None))
						if type(statement.stmt) is c_ast.Assignment:
							new_statements1.append(statement.stmt)
						elif type(statement.stmt) is c_ast.Compound:
							if statement.stmt is not None and statement.stmt.block_items is not None:
								for stmt in statement.stmt.block_items:
									new_statements1.append(stmt)
						else:
							new_statements1.append(statement.stmt)
						flag_label=False
						flag_goto=False
					else:
						#print 'XXXX2'
						if type(statement.stmt) is c_ast.Assignment:
							new_statements2.append(statement.stmt)
						elif type(statement.stmt) is c_ast.Compound:
							if statement.stmt is not None and statement.stmt.block_items is not None:
								for stmt in statement.stmt.block_items:
									new_statements2.append(stmt)
						
						#print '%%%%%%%%%%%%%%%%%%%%%%%%%'
                                                #print statement.stmt
                                                #for y in new_statements2:
                                                #    print y
                                                #print '%%%%%%%%%%%%%%%%%%%%%%%%%'
						flag_label=True
				else:
					if flag_goto==True or flag_label==True:
                                                #print 'XXXX3'
						if type(statement.stmt) is c_ast.Assignment:
                                                        new_statements2.append(c_ast.Label(name=statement.name, stmt=None))
							new_statements2.append(statement.stmt)
						elif type(statement.stmt) is c_ast.Compound:
                                                        new_statements2.append(c_ast.Label(name=statement.name, stmt=None))
							if statement.stmt is not None and statement.stmt.block_items is not None:
								for stmt in statement.stmt.block_items:
									new_statements2.append(stmt)
                                                else:
                                                    new_statements2.append(statement)
					else:
						new_statements1.append(statement)
			elif type(statement) is c_ast.If:
				flag_block_goto=check_goto_block_If(statement,label)
				if flag_block_goto:
					process_part1=True
					if flag_label==True:
                                                #print 'XXXX4'
                                                #print '$$$$$$$$$$$$$$$$$$1'
                                                #statement.show()
                                                #print '$$$$$$$$$$$$$$$$$$1'
						statement_1,statement_2=getRidOfGoto2(statement,label)
                                                #print '$$$$$$$$$$$$$$$$$$2'
                                                #print statement_1
                                                #print statement_2
                                                #statement.show()
                                                #print '$$$$$$$$$$$$$$$$$$'
						for stmt in new_statements2:
							new_statements1.append(stmt)
                    						
						new_break_map={}
                                                if statement_1 is not None:
                                                    new_statements2=new_statements2+statement_1
						new_statements2=reOrganizeBreaks(new_statements2,new_break_map)

						new_statements1.append(c_ast.While(cond=condition, stmt=c_ast.Compound(block_items=new_statements2)))
                                                new_statements1.append(statement_2)
						new_statements1=addingBreakVariables(new_statements1,new_break_map)
						flag_label=False
						flag_goto=False
					else:
						#print 'XXXX5'
                                                #print '#######12345'
                                                #generator = c_generator.CGenerator() 
                                                #print(generator.visit(statement))
                                                #print '#######12345'
						statement=getRidOfGoto(statement,label)
                                                #print '#######123456'
                                                #generator = c_generator.CGenerator() 
                                                #print(generator.visit(statement))
                                                #print '#######123456'
						new_statements1.append(statement)
						flag_goto=True
				else:
					if flag_goto==True or flag_label==True:
						new_statements2.append(statement)
					else:
						new_statements1.append(statement)
			else:
				if flag_goto==True or flag_label==True:
					new_statements2.append(statement)
				else:
					new_statements1.append(statement)
	
	#print '$$$$$$$$$$$$$$$$$4'
        #print process_part1
        #print process_part2
	#print '$$$$$$$$$$$$$$$$$4'
	if process_part1==True and process_part2==True:
		return new_statements1
	else:
		return None
		#return None
				
				
def remove_goto_block_sp(statements,label): 
	flag_block_label=check_label_block(statements,label)  
	flag_block_goto=check_goto_block_Sp(statements,label)
	flag_block2,condition=check_goto(statements,label)
	flag_label=False
	flag_goto=False
	new_statements1=[]
	new_statements2=[]
	if flag_block_label==True and flag_block_goto==True:
		for statement in statements:
			if type(statement) is c_ast.If:
				flag_block_goto=check_goto_block_If(statement,label)
				flag_label_sp=check_label_block_If(statement,label)  
				if flag_label_sp==True and flag_block_goto==False:
					new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2),iffalse=None))
					stmt=update_If_removegoto(statement,label,condition)
					new_statements1.append(stmt)
				elif flag_block_goto:
					if flag_label==True:
						statement=getRidOfGoto(statement,label)
						for stmt in new_statements2:
							new_statements1.append(stmt)
						new_statements1.append(statement)
						
						new_break_map={}
						new_statements2=reOrganizeBreaks(new_statements2,new_break_map)

						new_statements1.append(c_ast.While(cond=condition, stmt=c_ast.Compound(block_items=new_statements2)))
						new_statements1=addingBreakVariables(new_statements1,new_break_map)
						flag_label=False
						flag_goto=False
					else:
						statement=getRidOfGoto(statement,label)
						new_statements1.append(statement)
						flag_goto=True
				else:
					if flag_goto==True or flag_label==True:
						new_statements2.append(statement)
					else:
						new_statements1.append(statement)
			else:
				if flag_goto==True or flag_label==True:
					new_statements2.append(statement)
				else:
					new_statements1.append(statement)
	
	return new_statements1



def update_If_removegoto(statement,label,condition):
	new_if_stmt=None
	new_else_stmt=None
	if type(statement) is c_ast.If:
			if type(statement.iftrue) is c_ast.Label:
				if statement.iftrue.name==label:
                                        new_statements=[]
                                        new_statements.append(c_ast.If(cond=condition,iftrue=c_ast.Goto(name=label),iffalse=None))
                                        new_statements.append(statement.iftrue)
                                        new_if_stmt=c_ast.Compound(block_items=remove_goto_block(new_statements,label))
                                else:
                                	new_if_stmt=statement.iftrue
                                        
			else:
	            		if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
	            			status=False
	            			for element in statement.iftrue.block_items:
	            				if type(element) is c_ast.Label:
                                                        if element.name==label:
                                                                status = True
                                        if status==True:
                                        	new_statements=[]
                                        	new_statements.append(c_ast.If(cond=condition,iftrue=c_ast.Goto(name=label),iffalse=None))
                                        	for element in statement.iftrue.block_items:
                                        		new_statements.append(element)
                                        	new_if_stmt=c_ast.Compound(block_items=remove_goto_block(new_statements,label))
                                        else:
                                        	new_if_stmt=statement.iftrue
                                        		
                                                                
			if type(statement.iffalse) is c_ast.Label:
                                if statement.iffalse.name==label:
                                         new_statements=[]
					 new_statements.append(c_ast.If(cond=condition,iftrue=c_ast.Goto(name=label),iffalse=None))
					 new_statements.append(statement.iftrue)
                                         new_if_stmt=c_ast.Compound(block_items=remove_goto_block(new_statements,label))
                                else:
                                	new_else_stmt=statement.iffalse
			else:
				if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
	            			status=False
	            			for element in statement.iffalse.block_items:
	            				if type(element) is c_ast.Label:
	            					if element.name==label:
                                                                status = True
                                        if status==True:
						new_statements=[]
					        new_statements.append(c_ast.If(cond=condition,iftrue=c_ast.Goto(name=label),iffalse=None))
					        for element in statement.iffalse.block_items:
					        	new_statements.append(element)
					        new_else_stmt=c_ast.Compound(block_items=remove_goto_block(new_statements,label))
					else:
                                        	new_else_stmt=statement.iffalse
				else:
					if type(statement.iffalse) is c_ast.If:
						new_else_stmt=update_If_removegoto(statement.iffalse,label,condition)
	return c_ast.If(cond=c_ast.BinaryOp(op='&&', left=statement.cond, right=condition),iftrue=new_if_stmt,iffalse=new_else_stmt)







    
    
def constructLabelTable(statements,level,block,lineCount):
	label_map={}
	if statements is not None:
		for statement in statements:
			if type(statement) is c_ast.If:
				block=block+1
				label_map_temp=constructLabelTable_If(statement,level,block,lineCount)
	            		for item in label_map_temp:
            				label_map[item]=label_map_temp[item]
            			block=block-1
			elif type(statement) is c_ast.Label:
				lineCount=lineCount+1
			        info=[]
			        info.append(level)
	            		info.append(block)
	            		info.append(lineCount)
	            		info.append([])
				label_map[statement.name]=info
	        	else:
	        		if type(statement) is c_ast.While:
	        			level=level+1
	            			label_map_temp=constructLabelTable(statement.stmt.block_items,level,block,lineCount)
	            			for item in label_map_temp:
            					label_map[item]=label_map_temp[item]
            				level=level-1
            			else:
            				lineCount=lineCount+1
	return label_map




def constructLabelTable_If(statement,level,block,lineCount):
	label_map={}
	if type(statement) is c_ast.If:
			if type(statement.iftrue) is c_ast.Label:
				lineCount=lineCount+1	            				
				info=[]
				info.append(level)
				info.append(block)
				info.append(lineCount)
				info.append([])
				label_map[statement.iftrue.name]=info
			else:
	            		if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
	            			for element in statement.iftrue.block_items:
	            				if type(element) is c_ast.Label:
							lineCount=lineCount+1	            				
	            					info=[]
	            					info.append(level)
	            					info.append(block)
	            					info.append(lineCount)
	            					info.append([])
	            					label_map[element.name]=info
	            				elif type(element) is c_ast.If:
	            					block=block+1
							label_map_temp=constructLabelTable_If(element,level,block,lineCount)
							for item in label_map_temp:
            							label_map[item]=label_map_temp[item]
            						block=block-1
						else:
							if type(element) is c_ast.While:
								level=level+1
						        	label_map_temp=constructLabelTable(element.stmt.block_items,level,block,lineCount)
						        	for item in label_map_temp:
					            			label_map[item]=label_map_temp[item]
            							level=level-1
            						else:
            							lineCount=lineCount+1
	
			if type(statement.iffalse) is c_ast.Label:
				lineCount=lineCount+1	            				
				info=[]
				info.append(level)
				info.append(block)
				info.append(lineCount)
				info.append([])
				label_map[statement.iffalse.name]=statement.iffalse.name
			else:
				if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
	            			for element in statement.iffalse.block_items:
	            				if type(element) is c_ast.Label:
	            					lineCount=lineCount+1
	            					info=[]
							info.append(level)
	            					info.append(block)
	            					info.append(lineCount)
	            					info.append([])
	            					label_map[element.name]=info
	            				elif type(element) is c_ast.If:
	            					block=block+1
							label_map_temp=constructLabelTable_If(element,level,block,lineCount)
							for item in label_map_temp:
            							label_map[item]=label_map_temp[item]
            						block=block-1
						else:
							if type(element) is c_ast.While:
								level=level+1
						        	label_map_temp=constructLabelTable(element.stmt.block_items,level,block,lineCount)
						        	for item in label_map_temp:
					            			label_map[item]=label_map_temp[item]
            							level=level-1
            						else:
            							lineCount=lineCount+1
				else:
					if type(statement.iffalse) is c_ast.If:
						label_map_temp=constructLabelTable_If(statement.iffalse,level,block,lineCount)
						for item in label_map_temp:
							label_map[item]=label_map_temp[item]
	return label_map

    
    

def updateLabelTable(statements,level,block,lineCount,label_map):
	if statements is not None:
		for statement in statements:
			if type(statement) is c_ast.If:
				updateLabelTable_If(statement,level,block,lineCount,label_map)
	        	else:
	        		if type(statement) is c_ast.While:
	        			level=level+1
	            			updateLabelTable(statement.stmt.block_items,level,block,lineCount,label_map)
            				level=level-1
            			elif type(statement) is c_ast.Goto:
                                    lineCount=lineCount+1	            				
                                    info=[]
                                    info.append(level)
                                    info.append(block)
                                    info.append(lineCount)
                                    info.append(None)
                                    if statement.name in label_map.keys():
					info_update=label_map[statement.name]
				        list=info_update[3]
				        list.append(info)	
            			
            			else:
            				lineCount=lineCount+1





def updateLabelTable_If(statement,level,block,lineCount,label_map):
	if type(statement) is c_ast.If:
			if type(statement.iftrue) is c_ast.Goto:
				lineCount=lineCount+1	            				
				info=[]
				info.append(level)
				info.append(block)
				info.append(lineCount)
				info.append(statement.cond)
				if statement.iftrue.name in label_map.keys():
					info_update=label_map[statement.iftrue.name]
				        list=info_update[3]
				        list.append(info)		

			else:
	            		if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
	            			for element in statement.iftrue.block_items:
	            				if type(element) is c_ast.Goto:
							lineCount=lineCount+1	            				
	            					info=[]
	            					info.append(level)
	            					info.append(block)
	            					info.append(lineCount)
	            					info.append(statement.cond)
	            					if element.name in label_map.keys():
	            						info_update=label_map[element.name]
	            						list=info_update[3]
	            						list.append(info)
	            				elif type(element) is c_ast.If:
	            					block=block+1
							updateLabelTable_If(element,level,block,lineCount,label_map)
            						block=block-1
						else:
							if type(element) is c_ast.While:
								level=level+1
						        	updateLabelTable(element.stmt.block_items,level,block,lineCount,label_map)
            							level=level-1
            						else:
            							lineCount=lineCount+1
	
			if type(statement.iffalse) is c_ast.Goto:
				lineCount=lineCount+1	            				
				info=[]
				info.append(level)
				info.append(block)
				info.append(lineCount)
				info.append(statement.cond)
				if statement.iffalse.name in label_map.keys():
					info_update=label_map[statement.iffalse.name]
					list=info_update[3]
					list.append(info)
			else:
				if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
	            			for element in statement.iffalse.block_items:
	            				if type(element) is c_ast.Goto:
	            					lineCount=lineCount+1
	            					info=[]
							info.append(level)
	            					info.append(block)
	            					info.append(lineCount)
	            					info.append(statement.cond)
	            					if element.name in label_map.keys():
	            						info_update=label_map[element.name]
	            						list=info_update[3]
	            						list.append(info)
	            				elif type(element) is c_ast.If:
	            					block=block+1
							updateLabelTable_If(element,level,block,lineCount,label_map)
            						block=block-1
						else:
							if type(element) is c_ast.While:
								level=level+1
						        	updateLabelTable(element.stmt.block_items,level,block,lineCount,label_map)
            							level=level-1
            						else:
            							lineCount=lineCount+1
				else:
					if type(statement.iffalse) is c_ast.If:
						updateLabelTable_If(statement.iffalse,level,block,lineCount,label_map)
					
					
#Check a label in a block of statement


def check_label_block(statements,label):
        status=False
	for statement in statements:
		if type(statement) is c_ast.If:
                        temp_status=check_label_block_If(statement,label)
                        if temp_status==True:
                               status=True 
		elif type(statement) is c_ast.Label:
                        if statement.name==label:
                                status = True
	return status
	



def check_label_block_sp(statements,label):
        status=False
	for statement in statements:
		if type(statement) is c_ast.Label:
                        if statement.name==label:
                                status = True
	return status

#Check a label in the blocks of statement of if loop
	
def check_label_block_If(statement,label):
        status=False
	if type(statement) is c_ast.If:
			if type(statement.iftrue) is c_ast.Label:
				if statement.iftrue.name==label:
                                        status = True
			else:
	            		if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
	            			for element in statement.iftrue.block_items:
	            				if type(element) is c_ast.Label:
                                                        if element.name==label:
                                                                status = True
                                                                
			if type(statement.iffalse) is c_ast.Label:
                                if statement.iffalse.name==label:
                                        status = True
			else:
				if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
	            			for element in statement.iffalse.block_items:
	            				if type(element) is c_ast.Label:
	            					if element.name==label:
                                                                status = True
				else:
					if type(statement.iffalse) is c_ast.If:
						temp_status = check_label_block_If(statement.iffalse,label)
						if temp_status==True:
                                                	status=True
	return status



#Check a label in statement


def check_label(statements,label):
        status=False
	for statement in statements:
		if type(statement) is c_ast.If:
                        temp_status=check_label_If(statement,label)
                        if temp_status==True:
                               status=True 
		elif type(statement) is c_ast.Label:
                        if statement.name==label:
                                status = True
	        else:
	        	if type(statement) is c_ast.While:
	            		temp_status= check_label(statement.stmt.block_items,label)
	            		if temp_status==True:
                                        status=True
	return status



def check_label_sp(statements,label):
        status=False
	for statement in statements:
		if type(statement) is c_ast.If:
                        temp_status=check_label_If(statement,label)
                        if temp_status==True:
                               status=True 
		elif type(statement) is c_ast.Label:
                        if statement.name==label:
                                status = True
	return status



#Check a label in statement of if loop

def check_label_If(statement,label):
        status=False
	if type(statement) is c_ast.If:
			if type(statement.iftrue) is c_ast.Label:
				if statement.iftrue.name==label:
                                        status = True
			else:
	            		if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
	            			for element in statement.iftrue.block_items:
	            				if type(element) is c_ast.Label:
                                                        if element.name==label:
                                                                status = True
	            				elif type(element) is c_ast.If:
							temp_status = check_label_If(element,label)
							if temp_status==True:
                                                               status=True
						else:
							if type(element) is c_ast.While:
						        	temp_status = check_label(element.stmt.block_items,label)
						        	if temp_status==True:
                                                                        status=True
	
			if type(statement.iffalse) is c_ast.Label:
                                if statement.iffalse.name==label:
                                        status = True
			else:
				if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
	            			for element in statement.iffalse.block_items:
	            				if type(element) is c_ast.Label:
	            					if element.name==label:
                                                                status = True
	            				elif type(element) is c_ast.If:
                                                        temp_status = check_label_If(element,label)
                                                        if temp_status==True:
                                                                status=True
						else:
							if type(element) is c_ast.While:
								temp_status = check_label(element.stmt.block_items,label)
								if temp_status==True:
                                                                        status=True

				else:
					temp_status = check_label_If(statement.iffalse,label)
					if temp_status==True:
                                                status=True
	return status





#Check a goto-label in a block of statement


def check_goto_block(statements,label):
        status=False
	for statement in statements:
		if type(statement) is c_ast.Goto:
                        if statement.name==label:
                                status = True

	return status


def check_goto_block_Sp(statements,label):
        status=False
	for statement in statements:
		if type(statement) is c_ast.Goto:
                        if statement.name==label:
                                status = True
               	elif type(statement) is c_ast.If:
                	temp_status=check_goto_block_If(statement,label)
                	if temp_status==True:
                		status=True
	return status
	
	

#Check a label in the blocks of statement of if loop
	
def check_goto_block_If(statement,label):
        status=False
	if type(statement) is c_ast.If:
			if type(statement.iftrue) is c_ast.Goto:
				if statement.iftrue.name==label:
                                        status = True
			else:
	            		if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
	            			for element in statement.iftrue.block_items:
	            				if type(element) is c_ast.Goto:
                                                        if element.name==label:
                                                                status = True
			if type(statement.iffalse) is c_ast.Label:
                                if statement.iffalse.name==label:
                                        status = True
			else:
				if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
	            			for element in statement.iffalse.block_items:
	            				if type(element) is c_ast.Goto:
	            					if element.name==label:
                                                                status = True
				else:
					if type(statement.iffalse) is c_ast.If:
						temp_status = check_goto_block_If(statement.iffalse,label)
						if temp_status==True:
                                                	status=True
	return status



#Check a label in statement


def check_goto(statements,label):
        status=False
        condition=None
	for statement in statements:
		if type(statement) is c_ast.If:
                        temp_status,temp_cond=check_goto_If(statement,label)
                        if temp_status==True:
                               status=True
                               condition=temp_cond
		elif type(statement) is c_ast.Goto:
                        if statement.name==label:
                                status = True
	        else:
	        	if type(statement) is c_ast.While:
	            		temp_status,temp_cond= check_goto(statement.stmt.block_items,label)
	            		if temp_status==True:
                                        status=True
                                        condition=temp_cond
	return status,condition




#Check a label in statement of if loop

def check_goto_If(statement,label):
        status=False
        condition=None
	if type(statement) is c_ast.If:
			if type(statement.iftrue) is c_ast.Goto:
				if statement.iftrue.name==label:
                                        status = True
                                        condition=statement.cond
			else:
	            		if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
	            			for element in statement.iftrue.block_items:
	            				if type(element) is c_ast.Goto:
                                                        if element.name==label:
                                                                status = True
                                                                condition=statement.cond
	            				elif type(element) is c_ast.If:
							temp_status,temp_cond = check_goto_If(element,label)
							if temp_status==True:
                                                               status=True
                                                               #condition=temp_cond
                                                               condition=c_ast.BinaryOp(op='&&', left=temp_cond, right=statement.cond)
						else:
							if type(element) is c_ast.While:
						        	temp_status,temp_cond = check_goto(element.stmt.block_items,label)
						        	if temp_status==True:
                                                                        status=True
                                                                        condition=temp_cond
	
			if type(statement.iffalse) is c_ast.Goto:
                                if statement.iffalse.name==label:
                                        status = True
                                        condition = c_ast.UnaryOp(op='!', expr=statement.cond)
			else:
				if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
	            			for element in statement.iffalse.block_items:
	            				if type(element) is c_ast.Goto:
	            					if element.name==label:
                                                                status = True
                                                                condition = c_ast.UnaryOp(op='!', expr=statement.cond)
	            				elif type(element) is c_ast.If:
                                                        temp_status,temp_cond = check_goto_If(element,label)
                                                        if temp_status==True:
                                                                status=True
                                                                #condition=temp_cond
                                                                condition=c_ast.BinaryOp(op='&&', left=temp_cond, right=c_ast.UnaryOp(op='!', expr=statement.cond))
						else:
							if type(element) is c_ast.While:
								temp_status,temp_cond = check_goto(element.stmt.block_items,label)
								if temp_status==True:
                                                                        status=True
                                                                        condition=temp_cond

				else:
					temp_status,temp_cond = check_goto_If(statement.iffalse,label)
					if temp_status==True:
                                                status=True
                                                #condition=temp_cond
                                                condition=c_ast.BinaryOp(op='&&', left=temp_cond, right=c_ast.UnaryOp(op='!', expr=statement.cond))
	return status,condition






#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label


def label_finder(statements,label):
	if statements is not None:
		flag_block1=check_label_block(statements,label)
		if flag_block1==True:
			return gotomoveout(statements,label)
		else:
			update_statements=[]
			if statements is not None:
				for statement in statements:
					if type(statement) is c_ast.If:
						update_statements.append(label_finder_if(statement,label))
					elif type(statement) is c_ast.While:
						update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=label_finder(statement.stmt.block_items,label))))
					else:
						update_statements.append(statement)
				return update_statements
			return statements
	return statements
				




#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label


def label_finder_inside(statements,label):
	if statements is not None:
		flag_block1=check_label_block(statements,label)
		flag_block2=check_label_block_sp(statements,label)
		flag_block3=check_goto_block_Sp(statements,label)
		#if flag_block1==False and flag_block2==False and flag_block3==False:
		if flag_block2==False and flag_block3==False:
			status,condition=check_goto(statements,label)
			if status==True:
				statements=gotomoveout_inside(statements,label)
				flag_block1=check_label_block(statements,label)
				flag_block2=check_label_block_sp(statements,label)
				flag_block3=check_goto_block_Sp(statements,label)
				#if flag_block1==False and flag_block2==False and flag_block3==True:
				if flag_block2==False and flag_block3==True:
					statements=gotomovein(statements,label)
	return statements







#Finding Goto in a If Block to Call gotomovein
#Parameter pass statement 
#Label

def label_finder_if(statement,label):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=label_finder(statement.iftrue.block_items,label))
			else:
				new_iftrue=statement.iftrue
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=label_finder(statement.iffalse.block_items,label))	
			else:
				new_iffalse=statement.iffalse
		elif type(statement.iffalse) is c_ast.If:
			new_iffalse=label_finder_if(statement.iffalse,label)
		else:
			new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond,iftrue=new_iftrue,iffalse=new_iffalse)






#Method to Move Goto Outside
#Parameter pass statement 
#Label


def gotomoveout(statements,label):
	flag_block1=check_label_block(statements,label)
	update_statements=[]
	condition=None
	if flag_block1==True:
		for statement in statements:
			if type(statement) is c_ast.If:
				flag_block2,condition=check_goto_If(statement,label)
				flag_stmt2=check_goto_block_If(statement,label)
				if flag_block2==True and flag_stmt2==False:
					statement=gotomoveoutrec_if(statement,label)
			                update_statements.append(statement)
			                update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
				elif flag_block2==True and flag_stmt2==True:
					statement=getRidOfGoto(statement,label)
			                if statement is not None:
			                	update_statements.append(statement)
			                	update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
			        else:
					update_statements.append(statement)
			
			elif type(statement) is c_ast.While:
				flag_block2,condition=check_goto(statement.stmt.block_items,label)
				flag_stmt2=check_goto_block(statement.stmt.block_items,label)
				if flag_block2==True and flag_stmt2==False:
					stmts=gotomoveoutrec(statement.stmt.block_items,label)
					stmts.append(c_ast.If(cond=condition, iftrue=c_ast.Break(), iffalse=None))
					statement=c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=stmts))
					update_statements.append(statement)
					update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
				elif flag_block2==True and flag_stmt2==True:
			                update_statements.append(statement)
			        else:
					update_statements.append(statement)
			                       
			else:
				update_statements.append(statement)
                                
		return update_statements




#Method to Move Goto Outside
#Parameter pass statement 
#Label


def gotomoveout_inside(statements,label):
	update_statements=[]
	condition=None
	for statement in statements:
		if type(statement) is c_ast.If:
			flag_block2,condition=check_goto_If(statement,label)
			flag_stmt2=check_goto_block_If(statement,label)
			if flag_block2==True and flag_stmt2==False:
				statement=gotomoveoutrec_if(statement,label)
			        update_statements.append(statement)
			        update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
			elif flag_block2==True and flag_stmt2==True:
				statement=getRidOfGoto(statement,label)
			        if statement is not None:
			                update_statements.append(statement)
			                update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
			else:
				update_statements.append(statement)
			
		elif type(statement) is c_ast.While:
			flag_block2,condition=check_goto(statement.stmt.block_items,label)
			flag_stmt2=check_goto_block(statement.stmt.block_items,label)
			if flag_block2==True and flag_stmt2==False:
				stmts=gotomoveoutrec(statement.stmt.block_items,label)
				stmts.append(c_ast.If(cond=condition, iftrue=c_ast.Break(), iffalse=None))
				statement=c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=stmts))
				update_statements.append(statement)
				update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
			elif flag_block2==True and flag_stmt2==True:
			        update_statements.append(statement)
			else:
				update_statements.append(statement)
			                       
		else:
			update_statements.append(statement)
                                
	return update_statements












#Method to Move Goto Outside Recursive
#Parameter pass statement 
#Label

def gotomoveoutrec(statements,label):
	new_statements1=[]
	new_statements2=[]
	flag=False
	condition=None
	for statement in statements:
		if type(statement) is c_ast.If:
			flag_block2,condition_new=check_goto_If(statement,label)
			flag_stmt2=check_goto_block_If(statement,label)
			if condition_new is not None:
				condition=condition_new
			if flag_block2==True and flag_stmt2==False:
				statement=gotomoveoutrec_if(statement,label)
                        	new_statements1.append(statement)
                        	flag=True
			elif flag_block2==True and flag_stmt2==True:
				statement=getRidOfGoto(statement,label)
                                flag=True
                                if statement is not None:
                                	new_statements1.append(statement)
                        else:
                        	if flag==True:
					new_statements2.append(statement)
				else:
                        		new_statements1.append(statement)

		elif type(statement) is c_ast.While:
			flag_block2,condition_new=check_goto(statement.stmt.block_items,label)
			flag_stmt2=check_goto_block(statement.stmt.block_items,label)
			if condition_new is not None:
				condition=condition_new
			if flag_block2==True and flag_stmt2==False:
				stmts=gotomoveoutrec(statement.stmt.block_items,label)
				stmts.append(c_ast.If(cond=condition, iftrue=c_ast.Break(), iffalse=None))
				statement=c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=stmts))
				new_statements1.append(statement)
			elif flag_block2==True and flag_stmt2==True:
                                flag=True
                                new_statements1.append(statement)
                        else:
                        	if flag==True:
					new_statements2.append(statement)
				else:
                        		new_statements1.append(statement)
                       
                else:
                	if flag==True:
				new_statements2.append(statement)
			else:
                        	new_statements1.append(statement)
	if condition is not None:
                if len(new_statements2)>0:
                	new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
        	statements=new_statements1

        return statements



#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label
				
				
def gotomoveoutrec_if(statement,label):
	#print statement.show()
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Goto:
			if statement.iftrue.name==label:
	                	status = True
		else:
		        if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
		        	flag_block2,condition=check_goto(statement.iftrue.block_items,label)
				flag_stmt2=check_goto_block(statement.iftrue.block_items,label)
				if flag_block2==True and flag_stmt2==False:
					statement.iftrue.block_items=gotomoveoutrec(statement.iftrue.block_items,label)
					statement.iftrue=c_ast.Compound(block_items=statement.iftrue.block_items)
				elif flag_block2==True and flag_stmt2==True:
					statement.iftrue=c_ast.Compound(block_items=statement.iftrue.block_items)
	                                                                
		if type(statement.iffalse) is c_ast.Label:
	        	if statement.iffalse.name==label:
	                	status = True
		else:
			if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
				flag_block2,condition=check_goto(statement.iffalse.block_items,label)
				flag_stmt2=check_goto_block(statement.iffalse.block_items,label)
				if flag_block2==True and flag_stmt2==False:
					statement.iffalse.block_items=gotomoveoutrec(statement.iffalse.block_items,label)
					statement.iffalse=c_ast.Compound(block_items=statement.iffalse.block_items)
				elif flag_block2==True and flag_stmt2==True:
					statement.iffalse=c_ast.Compound(block_items=statement.iffalse.block_items)
			else:
				if type(statement.iffalse) is c_ast.If: 
					gotomoveoutrec_if(statement.iffalse,label)
	#print statement.show()
	return c_ast.If(cond=statement.cond, iftrue=statement.iftrue, iffalse=statement.iffalse)
				



#Updating Each If Else for Goto
#Parameter pass statement 
#Label
		
	
def getRidOfGoto(statement,label):
	generator = c_generator.CGenerator()
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Goto:
			if statement.iftrue.name==label:
	                	new_iftrue=None
		else:
		        if type(statement.iftrue) is c_ast.Compound:
		        	new_block=[]
				for stmt in statement.iftrue.block_items:
					if type(stmt) is c_ast.Goto:
						if stmt.name!=label:
							new_block.append(stmt)
					else:
						
						if stmt is not None:
                                                    if type(stmt) is c_ast.Label:
                                                        if stmt.name!=label:
                                                            new_block.append(stmt)
                                                    else: 
                                                        new_block.append(stmt)
				new_iftrue=c_ast.Compound(block_items=new_block)
                                     
		
		if type(statement.iffalse) is c_ast.Label:
	        	if statement.iffalse.name==label:
	                	new_iffalse=None
		else:
			if type(statement.iffalse) is c_ast.Compound:
				new_block=[]
				for stmt in statement.iffalse.block_items:
					if type(stmt) is c_ast.Goto:
						if stmt.name!=label:
							new_block.append(stmt)
					else:
						if stmt is not None:
                                                    if type(stmt) is c_ast.Label and stmt.name!=label:
                                                        new_block.append(stmt)
                                                    else: 
                                                        new_block.append(stmt)

				new_iffalse=c_ast.Compound(block_items=new_block)
			else:
				if type(statement.iffalse) is c_ast.If:
					new_iffalse=getRidOfGoto(statement.iffalse,label)
	if new_iftrue is not None:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
	else:
		return None


def getRidOfGoto2(statement,label):
	generator = c_generator.CGenerator()
	new_iftrue=None
	new_iffalse=None
        up_statemets=[]
        down_statemets=[]
        up_statemets_else=[]
        down_statemets_else=[]
        flag=False
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Goto:
			if statement.iftrue.name==label:
	                	new_iftrue=None
		else:
		        if type(statement.iftrue) is c_ast.Compound:
                                up_statemets=[]
                                down_statemets=[]
				for stmt in statement.iftrue.block_items:
                                        
                                        if stmt is not None:
                                            if type(stmt) is c_ast.Goto:
                                                    if stmt.name!=label:
                                                            if flag==False:
                                                                up_statemets.append(stmt)
                                                            else:
                                                                down_statemets.append(stmt)
                                                    else:
                                                        flag==True
                                                            
                                            else:
                                                    if flag==False:
                                                        up_statemets.append(stmt)
                                                    else:
                                                        down_statemets.append(stmt)
				
				if len(down_statemets)==0:
                                    new_iftrue=None
                                else:
                                    new_iftrue=c_ast.Compound(block_items=down_statemets)
                                     
		if type(statement.iffalse) is c_ast.Label:
	        	if statement.iffalse.name==label:
	                	new_iffalse=None
		else:
			if type(statement.iffalse) is c_ast.Compound:
				new_block=[]
				for stmt in statement.iffalse.block_items:
					if type(stmt) is c_ast.Goto:
						if stmt.name!=label:
							new_block.append(stmt)
					else:
						new_block.append(stmt)
				new_iffalse=c_ast.Compound(block_items=new_block)
			else:
				if type(statement.iffalse) is c_ast.If:
					new_iffalse=getRidOfGoto(statement.iffalse,label)
	if new_iftrue is not None:
                if len(up_statemets)==0:
                    return None,up_statemets,c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
                else:
                    return up_statemets,c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
	elif new_iftrue is None and new_iffalse is not None:
		if len(up_statemets)==0:
                    return None,c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
                else:
                    return up_statemets,c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
	else:
		if len(up_statemets)==0:
                    return None,None
                else:
                    return up_statemets,None



#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label


def goto_finder(statements,label):
	flag_block1=check_goto_block_Sp(statements,label)
	if flag_block1==True:
		flag_block1=check_label_block_sp(statements,label)
		if flag_block1==True:
			return statements
		else:
			return gotomovein(statements,label)
	else:
		update_statements=[]
		for statement in statements:
			if type(statement) is c_ast.If:
				update_statements.append(goto_finder_if(statement,label))
			elif type(statement) is c_ast.While:
				update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=goto_finder(statement.stmt.block_items,label))))
			else:
				update_statements.append(statement)
		return update_statements


#Finding Goto in a If Block to Call gotomovein
#Parameter pass statement 
#Label

def goto_finder_if(statement,label):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement) is c_ast.If:
			if type(statement.iftrue) is c_ast.Compound:
				if statement.iftrue.block_items is not None:
					new_iftrue=c_ast.Compound(block_items=goto_finder(statement.iftrue.block_items,label))
				else:
					new_iftrue=statement.iftrue				
			else:
				new_iftrue=statement.iftrue
			if type(statement.iffalse) is c_ast.Compound:
				if statement.iffalse.block_items is not None:
					new_iffalse=c_ast.Compound(block_items=goto_finder(statement.iffalse.block_items,label))
				else:
					new_iffalse=statement.iffalse
			elif type(statement.iffalse) is c_ast.If:
				new_iffalse=goto_finder_if(statement.iffalse,label)
			else:
				new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond,iftrue=new_iftrue,iffalse=new_iffalse)




#Method to Move Goto Inside
#Parameter pass statement 
#Label

def gotomovein(statements,label):
	flag_block1=check_goto_block_Sp(statements,label)
	new_statements1=[]
	new_statements2=[]
	flag=False
	if flag_block1==True:
		flag_block1,condition=check_goto(statements,label)
		for statement in statements:
			if type(statement) is c_ast.If:
				flag_stmt3=check_goto_block_If(statement,label)				
				flag_block2=check_label_If(statement,label)
				flag_stmt2=check_label_block_If(statement,label)
				if flag_stmt3==True:
					if flag_block2==True and flag_stmt2==True:
						new_statements1.append(statement)
					else:
						para_list=[]
                                                para_list.append(condition)
						newFun=c_ast.FuncCall(name=c_ast.ID(name='_Bool2Int'), args=c_ast.ExprList(exprs=para_list))
						new_statement=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label), rvalue=newFun)
						new_variable['bool_go_'+label]='bool_go_'+label
						condition=c_ast.BinaryOp(op='>', left=c_ast.ID(name='bool_go_'+label), right=c_ast.Constant(type='int', value='0'))
						new_statements1.append(new_statement)
						flag=True
				else:
					if flag_block2==True and flag_stmt2==False:
						flag=False
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
						new_statements1.append(updateIfBlock(statement,label,condition))

						new_statements2=[]
					else:
						if flag_block2==True and flag_stmt2==True:
							flag=False
							new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
							new_statements1.append(updateIfBlock(statement,label,condition))
							new_statements2=[]
						else:
							if flag==False:
								new_statements1.append(statement)
							else:
								new_statements2.append(statement)
			elif type(statement) is c_ast.While:
				flag_block2=check_label(statement.stmt.block_items,label)
				#flag_stmt2=check_label_block(statement.stmt.block_items,label)
				flag_stmt2=check_label_block_sp(statement.stmt.block_items,label)			
				if flag_block2==False and flag_stmt2==False:
					statement=c_ast.While(cond=statement.cond, stmt=statement.stmt)
				elif flag_block2==True and flag_stmt2==True:
					if len(new_statements2)>0:
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
					new_cond=c_ast.BinaryOp(op='||', left=condition, right=statement.cond)
					new_blocks=[]
					new_blocks.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
					for stmt in statement.stmt.block_items:
						new_blocks.append(stmt)
					new_blocks.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label) , rvalue= c_ast.Constant(type='int', value='0')))
					statement=c_ast.While(cond=new_cond, stmt=c_ast.Compound(block_items=new_blocks))
					flag=False
					new_statements2=[]
				elif flag_block2==True and flag_stmt2==False:
					if len(new_statements2)>0:
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
					new_cond=c_ast.BinaryOp(op='||', left=condition, right=statement.cond)
					new_blocks=[]
					new_blocks.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
					for stmt in statement.stmt.block_items:
						new_blocks.append(stmt)
					new_blocks.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label) , rvalue= c_ast.Constant(type='int', value='0')))
					new_blocks=gotomoveinrec(new_blocks,label,condition)
					statement=c_ast.While(cond=new_cond, stmt=c_ast.Compound(block_items=new_blocks))
					flag=False
					new_statements2=[]
				else:
					statement=c_ast.While(cond=statement.cond, stmt=statement.stmt)
				if flag==False:
					new_statements1.append(statement)
				else:
					new_statements2.append(statement)
			else:
				if flag==False:
					new_statements1.append(statement)
				else:
					new_statements2.append(statement)

		return new_statements1
	else:
		return statements



#Method to Move Goto Inside Recursive 
#Parameter pass statement 
#Label


def gotomoveinrec(statements,label,condition):
	flag_block1,condition=check_goto(statements,label)
	new_statements1=[]
	new_statements2=[]
	flag=False
	if flag_block1==True:
		for statement in statements:
			if type(statement) is c_ast.If:
				flag_stmt3=check_goto_block_If(statement,label)				
				flag_block2=check_label_If(statement,label)
				flag_stmt2=check_label_block_If(statement,label)
				if flag_stmt3==True:
					if flag_block2==True and flag_stmt2==True:
						new_statements1.append(statement)
					else:
						flag=True
				else:
					if flag_block2==True and flag_stmt2==False:
						flag=False
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
						new_statements1.append(updateIfBlock(statement,label,condition))

						new_statements2=[]
					else:
						if flag_block2==True and flag_stmt2==True:
							flag=False
							if len(new_statements2)>0:
								new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
							new_statements1.append(updateIfBlock(statement,label,condition))
							new_statements2=[]
						else:
							if flag==False:
								new_statements1.append(statement)
							else:
								new_statements2.append(statement)
			elif type(statement) is c_ast.While:
				flag_block2=check_label(statement.stmt.block_items,label)
				#flag_stmt2=check_label_block(statement.stmt.block_items,label)
				flag_stmt2=check_label_block_sp(statement.stmt.block_items,label)
				if flag_block2==False and flag_stmt2==False:
					statement=c_ast.While(cond=statement.cond, stmt=statement.stmt)
				elif flag_block2==True and flag_stmt2==True:
					if len(new_statements2)>0:
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
					new_cond=c_ast.BinaryOp(op='||', left=condition, right=statement.cond)
					new_blocks=[]
					new_blocks.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
					for stmt in statement.stmt.block_items:
						new_blocks.append(stmt)
					new_blocks.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label) , rvalue= c_ast.Constant(type='int', value='0')))
					statement=c_ast.While(cond=new_cond, stmt=c_ast.Compound(block_items=new_blocks))
					flag=False
					new_statements2=[]
				elif flag_block2==True and flag_stmt2==False:
					if len(new_statements2)>0:
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
					new_cond=c_ast.BinaryOp(op='||', left=condition, right=statement.cond)
					new_blocks=[]
					new_blocks.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
					for stmt in statement.stmt.block_items:
						new_blocks.append(stmt)
					new_blocks.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label) , rvalue= c_ast.Constant(type='int', value='0')))
					new_blocks=gotomoveinrec(new_blocks,label,condition)
					statement=c_ast.While(cond=new_cond, stmt=c_ast.Compound(block_items=new_blocks))
					flag=False
					new_statements2=[]
				else:
					statement=c_ast.While(cond=statement.cond, stmt=statement.stmt)
				if flag==False:
					new_statements1.append(statement)
				else:
					new_statements2.append(statement)
			else:
				if flag==False:
					new_statements1.append(statement)
				else:
					new_statements2.append(statement)
		return new_statements1
	else:
		return statements




#Updating Each If Else for Goto
#Parameter pass statement 
#Label

def updateIfBlock(statement,label,condition):
	new_iftrue=None
	new_iffalse=None
	new_condtion=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Goto:
			if statement.iftrue.name==label:
				new_block=[]
				new_block.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
				new_block.append(statement.iftrue)
		        	new_iftrue=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iftrue) is c_ast.Compound:
				flag_stmt=check_label(statement.iftrue.block_items,label)
				flag_stmt_block=check_label_block_sp(statement.iftrue.block_items,label)
			        if flag_stmt==True:
			        	new_block=[]
			        	new_block.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
					for stmt in statement.iftrue.block_items:
						new_block.append(stmt)
					if flag_stmt_block==False:
						new_block=gotomoveinrec(new_block,label,condition)
					new_iftrue=c_ast.Compound(block_items=new_block)
				else:
					new_condtion=c_ast.BinaryOp(op='&&', left=c_ast.UnaryOp(op='!', expr=condition), right=statement.cond)
					new_iftrue=statement.iftrue
                         
			
		if type(statement.iffalse) is c_ast.Label:
			new_block=[]
			new_block.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
			new_block.append(statement.iffalse)
		        new_iftrue=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iffalse) is c_ast.Compound:
				flag_stmt=check_label(statement.iffalse.block_items,label)
				flag_stmt_block=check_label_block_sp(statement.iffalse.block_items,label)
				if flag_stmt==True:
			        	new_block=[]
			        	new_block.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
					for stmt in statement.iffalse.block_items:
						new_block.append(stmt)
					if flag_stmt_block==False:
						new_block=gotomoveinrec(new_block,label,condition)
					new_iffalse=c_ast.Compound(block_items=new_block)
				else:
					new_condtion=c_ast.BinaryOp(op='&&', left=c_ast.UnaryOp(op='!', expr=condition), right=statement.cond)
					new_iffalse=statement.iffalse
			else:
				if type(statement.iffalse) is c_ast.If:
					new_iffalse=updateIfBlock(statement.iffalse,label,condition)
	if new_condtion is not None:
		return c_ast.If(cond=new_condtion, iftrue=new_iftrue, iffalse=new_iffalse)
	else:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
	
	
	

def reOrganizeBreaks(statements,new_break_map):
	update_statement=[]
	if statements is not None:
		for statement in statements:
			if type(statement) is c_ast.If:
				statement=reOrganizeBreaksIf(statement,new_break_map)
				update_statement.append(statement)
			elif type(statement) is c_ast.Break:
				update_statement.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='do_break'+str(len(new_break_map.keys())+1)), rvalue=c_ast.Constant(type='int', value='1')))
				new_break_map['do_break'+str(len(new_break_map.keys())+1)]='do_break'+str(len(new_break_map.keys())+1)
				update_statement.append(statement)
			else:
				update_statement.append(statement)
		return update_statement
	else:
		return None


def reOrganizeBreaksIf(statement,new_break_map):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Break:
			new_block=[]
			new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='do_break'+str(len(new_break_map.keys())+1)), rvalue=c_ast.Constant(type='int', value='1')))
			new_break_map['do_break'+str(len(new_break_map.keys())+1)]='do_break'+str(len(new_break_map.keys())+1)
			new_block.append(statement.iftrue)
			new_iftrue=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iftrue) is c_ast.Compound:
				new_block=reOrganizeBreaks(statement.iftrue.block_items,new_break_map)
				new_iftrue=c_ast.Compound(block_items=new_block)
		
		if type(statement.iffalse) is c_ast.Break:
			new_block=[]
			new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='do_break'+str(len(new_break_map.keys())+1)), rvalue=c_ast.Constant(type='int', value='1')))
			new_break_map['do_break'+str(len(new_break_map.keys())+1)]='do_break'+str(len(new_break_map.keys())+1)
			new_block.append(statement.iffalse)
			new_iffalse=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iffalse) is c_ast.Compound:
				new_block=reOrganizeBreaks(statement.iffalse.block_items,new_break_map)
				new_iffalse=c_ast.Compound(block_items=new_block)
			else:
				if type(statement.iffalse) is c_ast.If:
					new_iffalse=reOrganizeBreaksIf(statement.iffalse,new_break_map)
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
		
		
		
def addingBreakVariables(statements,new_break_map):
	for variable in new_break_map.keys():
		global new_variable
		new_variable[variable]=variable
		new_block=[]
		new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=variable), rvalue=c_ast.Constant(type='int', value='0')))
		new_block.append(c_ast.Break())
		new_iftrue=c_ast.Compound(block_items=new_block)
		statements.append(c_ast.If(cond=c_ast.BinaryOp(op='==', left=c_ast.ID(name=variable), right=c_ast.Constant(type='int', value='1')), iftrue=new_iftrue, iffalse=None))
	return statements
	
	

def removeEmptyIfLoop(statements):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.If:
			statement=removeEmptyIfLoop_If(statement)
			if statement is not None:
				update_statements.append(statement)
		elif type(statement) is c_ast.While:
                        if len(statement.stmt.block_items)>0:
                            new_block_items=removeEmptyIfLoop(statement.stmt.block_items)
                            update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=new_block_items)))
		else:
			if statement is not None:
				if type(statement) is not c_ast.EmptyStatement:
					update_statements.append(statement)
	return update_statements
			
			
			
def removeEmptyIfLoop_If(statement):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if len(statement.iftrue.block_items)==0:
				new_iftrue=None
			else:
				new_block=removeEmptyIfLoop(statement.iftrue.block_items)
				if len(new_block)==0:
					new_iftrue=None
				else:
					new_iftrue=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iftrue) is c_ast.EmptyStatement:
				new_iftrue=None
			else:
				new_iftrue=statement.iftrue
				
		if type(statement.iffalse) is c_ast.Compound:
			if len(statement.iffalse.block_items)==0:
				new_iffalse=None
			else:
				new_block=removeEmptyIfLoop(statement.iffalse.block_items)
				if len(new_block)==0:
					new_iffalse=None 
				else:
					new_iffalse=c_ast.Compound(block_items=new_block) 
		elif type(statement.iffalse) is c_ast.If:
			result=removeEmptyIfLoop_If(statement.iffalse)
			if result is not None:
				new_iffalse=result
		else:
			if type(statement.iffalse) is c_ast.EmptyStatement:
				new_iftrue=None
			else:
				new_iffalse=statement.iffalse
	
	
	if new_iftrue is not None and new_iffalse is None:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=None)
	elif new_iftrue is not None and new_iffalse is not None:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
	elif new_iffalse is not None and type(new_iffalse) is c_ast.Compound:
		return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
	elif new_iffalse is not None and type(new_iffalse) is c_ast.If:
		return new_iffalse
	else:
		return None

		
		
def returnReplacement(statements,end_label_map):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.If:
			statement=returnReplacementIf(statement,end_label_map)
			if statement is not None:
				update_statements.append(statement)
		elif type(statement) is c_ast.While:
			new_block_items=returnReplacement(statement.stmt.block_items,end_label_map)
			update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=new_block_items)))
		elif type(statement) is c_ast.Return:
			if statement.expr is not None:
				label='Label'+str(len(end_label_map.keys())+1)
				update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='RET'), rvalue=statement.expr))
				update_statements.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			else:
				label='Label'+str(len(end_label_map.keys())+1)
				update_statements.append(c_ast.Goto(name=label))
				end_label_map[label]=label
		elif type(statement) is c_ast.Label:
			update_statements.append(c_ast.Label(name=statement.name, stmt=None))
			if type(statement.stmt) is c_ast.Return:
				if statement.stmt.expr is not None:
					label='Label'+str(len(end_label_map.keys())+1)
					update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='RET'), rvalue=statement.stmt.expr))
					update_statements.append(c_ast.Goto(name=label))
					end_label_map[label]=label
				else:
					label='Label'+str(len(end_label_map.keys())+1)
					update_statements.append(c_ast.Goto(name=label))
					end_label_map[label]=label
			else:
				if statement.stmt is not None:
					update_statements.append(statement.stmt)
			
		else:
			update_statements.append(statement)
	return update_statements
	
	
	
	
	
	
def returnReplacementIf(statement,end_label_map):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Return:
			new_block=[]
			if statement.iftrue.expr is not None:
				label='Label'+str(len(end_label_map.keys())+1)
				new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='RET'), rvalue=statement.iftrue.expr))
				new_block.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			else:
				label='Label'+str(len(end_label_map.keys())+1)
				new_block.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			new_iftrue=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iftrue) is c_ast.Compound:
				new_block=returnReplacement(statement.iftrue.block_items,end_label_map)
				new_iftrue=c_ast.Compound(block_items=new_block)
			else:
                                new_iftrue=statement.iftrue
			
		if type(statement.iffalse) is c_ast.Return:
			new_block=[]
			if statement.iffalse.expr is not None:
				label='Label'+str(len(end_label_map.keys())+1)
				new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='RET'), rvalue=statement.iffalse.expr))
				new_block.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			else:
				label='Label'+str(len(end_label_map.keys())+1)
				new_block.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			new_iffalse=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iffalse) is c_ast.Compound:
				new_block=returnReplacement(statement.iffalse.block_items,end_label_map)
				new_iffalse=c_ast.Compound(block_items=new_block)
			else:
				if type(statement.iffalse) is c_ast.If:
					new_iffalse=returnReplacementIf(statement.iffalse,end_label_map)
				else:
                                        new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)









"""
 
Goto removal Modules End 

"""


break_count=0

continue_count=0	
	


def getBreakStmt(statements,break_map):
	update_statement1=[]
	update_statement2=[]
	flag=False
	global break_count
	global continue_count
        global new_variable
	for statement in statements:
		if type(statement) is c_ast.If:
			if flag==False:
				break_map_temp={}
				statement=getBreakStmtIf(statement,break_map_temp)
				for e_break in break_map_temp.keys():
					break_map[e_break]=break_map_temp[e_break]
				update_statement1.append(statement)
				if len(break_map_temp.keys())>0:
					flag=True
			else:
				update_statement2.append(statement)
		elif type(statement) is c_ast.While:
			break_map_temp={}
			new_block_items1=getBreakStmt(statement.stmt.block_items,break_map_temp)
			new_block_items2=[]
			new_condtion=statement.cond
			if len(break_map_temp.keys())>0:
				for var_name in break_map_temp.keys():
                                        new_block_items2.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='0')))
					if break_map_temp[var_name]=='Break':
						temp_new_condition=c_ast.BinaryOp(op='&&', left=new_condtion, right=c_ast.BinaryOp(op='==', left=c_ast.ID(name=var_name), right=c_ast.Constant(type='int', value='0')))
						new_condtion=temp_new_condition
			
                        for item in new_block_items1:
                            new_block_items2.append(item)
			if flag==False:
				update_statement1.append(c_ast.While(cond=new_condtion, stmt=c_ast.Compound(block_items=new_block_items2)))
			else:
				update_statement2.append(c_ast.While(cond=new_condtion, stmt=c_ast.Compound(block_items=new_block_items2)))
		elif type(statement) is c_ast.Break:
                        break_count=break_count+1
                        var_name='break_'+str(break_count)+'_flag'
                        new_variable[var_name]=var_name
                        update_statement1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
			break_map[var_name]='Break'
		elif type(statement) is c_ast.Continue:
		        continue_count=continue_count+1
		       	var_name='continue_'+str(continue_count)+'_flag'
		        new_variable[var_name]=var_name
		        update_statement1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
			break_map[var_name]='Continue'
		else:
			if flag==False:
				update_statement1.append(statement)
			else:
				update_statement2.append(statement)
	if flag==True:
		update_condition=None
		for var_name in break_map.keys():
			if update_condition is None:
				update_condition=c_ast.BinaryOp(op='==', left=c_ast.ID(name=var_name), right=c_ast.Constant(type='int', value='0'))
			else:
				update_condition=c_ast.BinaryOp(op='&&', left=update_condition, right=c_ast.BinaryOp(op='==', left=c_ast.ID(name=var_name), right=c_ast.Constant(type='int', value='0')))
		if len(update_statement2)>0:
			update_statement1.append(c_ast.If(cond=update_condition, iftrue=c_ast.Compound(block_items=update_statement2), iffalse=None))
		
		return getBreakStmt(update_statement1,break_map)
	else:
		return update_statement1
			
		




def getBreakStmtIf(statement,break_map):
	new_iftrue=None
	new_iffalse=None
	global break_count
	global new_variable
	global continue_count
	if type(statement) is c_ast.If:
			
		if type(statement.iftrue) is c_ast.Break:
                        new_block_items=[]
                        break_count=break_count+1
                        var_name='break_'+str(break_count)+'_flag'
                        new_variable[var_name]=var_name
                        new_block_items.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
			break_map[var_name]='Break'
			new_iftrue=c_ast.Compound(block_items=new_block_items)
		elif type(statement.iftrue) is c_ast.Continue:
		        new_block_items=[]
		        break_count=break_count+1
		        var_name='continue_'+str(continue_count)+'_flag'
		        new_variable[var_name]=var_name
		        new_block_items.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
			break_map[var_name]='Continue'
			new_iftrue=c_ast.Compound(block_items=new_block_items)
		elif type(statement.iftrue) is c_ast.Compound:
			new_block_items=getBreakStmt(statement.iftrue.block_items,break_map)
			new_iftrue=c_ast.Compound(block_items=new_block_items)
		else:
			new_iftrue=statement.iftrue
			
		if type(statement.iffalse) is c_ast.Break:
                        new_block_items=[]
                        break_count=break_count+1
                        var_name='break_'+str(break_count)+'_flag'
                        new_variable[var_name]=var_name
                        new_block_items.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
			break_map[var_name]='Break'
			new_iffalse=c_ast.Compound(block_items=new_block_items)
		elif type(statement.iffalse) is c_ast.Continue:
		        new_block_items=[]
		        continue_count=continue_count+1
		        var_name='continue_'+str(continue_count)+'_flag'
		        new_variable[var_name]=var_name
		        new_block_items.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
			break_map[var_name]='Continue'
			new_iffalse=c_ast.Compound(block_items=new_block_items)	
		elif type(statement.iffalse) is c_ast.Compound:
			new_block_items=getBreakStmt(statement.iffalse.block_items,break_map)
			new_iffalse=c_ast.Compound(block_items=new_block_items)
		else:
			if type(statement.iffalse) is c_ast.If:
				new_iffalse=getBreakStmtIf(statement.iffalse,break_map)
			else:
				new_iffalse=statement.iffalse
	if new_iftrue is not None and new_iffalse is None:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=None)
	elif new_iftrue is not None and new_iffalse is not None:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
	elif new_iffalse is not None and type(new_iffalse) is c_ast.Compound:
		return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
	elif new_iffalse is not None and type(new_iffalse) is c_ast.If:
		return new_iffalse
	else:
		return None
		
		


"""

#Program Class
#Plain Python object to store Information about Member Method of a Java Class 
"""
class programclass(object):
 	def __init__(self, filename, functionMap , variableMap, axiomeMap, witnessXmlMap):
        	self.filename = filename
        	self.functionMap = functionMap
        	self.variableMap = variableMap
        	self.axiomeMap = axiomeMap
        	self.witnessXmlMap = witnessXmlMap
        def getFilename(self):
        	return self.filename
        def getFunctionMap(self):
        	return self.functionMap
        def getVariableMap(self):
        	return self.variableMap
        def getAxiomeMap(self):
        	return self.axiomeMap
        def getWitnessXmlMap(self):
        	return self.witnessXmlMap
	def setFilename(self, filename):
	        self.filename=filename
	def setFunctionMap(self, functionMap):
		self.functionMap=functionMap
	def setVariableMap(self, variableMap):
		self.variableMap=variableMap
	def setAxiomeMap(self, axiomeMap):
		self.axiomeMap=axiomeMap
	def setWitnessXmlMap(self, witnessXmlMap):
		self.witnessXmlMap=witnessXmlMap


"""


#Function Substitution Modules


"""

counter_variableMap={}
counter_variableMap_Conf={}


def substituteFunBlock(statements,functionvarmap,functionname,externalvarmap):
	update_statements=[]
	global new_variable
        global counter_variableMap
        global counter_variableMap_Conf
	for statement in statements:
		if type(statement) is c_ast.FuncCall:
			membermethod=functionvarmap[statement.name.name]
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)
			
			if membermethod_cur is not None:
				in_var_map_cu=[]
				in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				if in_var_map is not None:
					for x in in_var_map:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if in_var_map_cu is not None:
					for x in in_var_map_cu:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
						
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
		
													
				input_map={}
			
			

				for x in range(0, len(statement.args.exprs)):
					arg=statement.args.exprs
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
					input_map[in_var_map[x]]=arg[x]
				
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),membermethod.getInputvar(),membermethod.getSerialNo())
                            
				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)

				for x in membermethod.getInputvar():
					if x in all_var_int:
						if membermethod.getInputvar()[x].getDimensions()>0:
			        			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=(membermethod.getInputvar()[x].getVariableType(),membermethod.getInputvar()[x].getDimensions())
			        		else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
                                        else:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable[x]=(membermethod.getInputvar()[x].getVariableType(),membermethod.getInputvar()[x].getDimensions())
						else:
                                			new_variable[x]=membermethod.getInputvar()[x].getVariableType()
				
				for x in membermethod.getLocalvar():
					if x in all_var_int:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=(membermethod.getLocalvar()[x].getVariableType(),membermethod.getLocalvar()[x].getDimensions())
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
                                        else:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable[x]=(membermethod.getLocalvar()[x].getVariableType(),membermethod.getLocalvar()[x].getDimensions())
						else:
                                			new_variable[x]=membermethod.getLocalvar()[x].getVariableType()
			
			for stmt in new_blocks:
				update_statements.append(stmt)
		elif type(statement) is c_ast.Assignment:
			new_statement,new_block=substituteFun(statement.rvalue,functionvarmap,functionname,externalvarmap)
			if new_block is not None and len(new_block)>0:
				for stmt in new_block:
					update_statements.append(stmt)
			if type(statement.lvalue) is c_ast.ID:
				if 'DUMMY' not in statement.lvalue.name:
					update_statements.append(c_ast.Assignment(op='=',lvalue=statement.lvalue,rvalue=new_statement))
                                else:
                                        if new_block is None:
                                            update_statements.append(c_ast.Assignment(op='=',lvalue=statement.lvalue,rvalue=statement.rvalue))
			else:
				update_statements.append(c_ast.Assignment(op='=',lvalue=statement.lvalue,rvalue=new_statement))
		elif type(statement) is c_ast.While:
                    
                        counter_variableMap_Conf={}
                        counter_variableMap={}
                        local_counter_varMap=getCounterVariables(statement.cond,counter_variableMap)
			getConfirmationVariables(statement.stmt.block_items,counter_variableMap,counter_variableMap_Conf)                        
			statement.cond,new_block=substituteFun(statement.cond,functionvarmap,functionname,externalvarmap)
			if new_block is not None and len(new_block)>0:
				for stmt in new_block:
					update_statements.append(stmt)
			temp_new_block=substituteFunBlock(statement.stmt.block_items,functionvarmap,functionname,externalvarmap)
			if new_block is not None:
				for stmt in new_block:
					temp_new_block.append(stmt)
			update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=temp_new_block)))	
		elif type(statement) is c_ast.If:
			statement,new_block=substituteFunBlockIf(statement,functionvarmap,functionname,externalvarmap)
			if new_block is not None and len(new_block)>0:
				for stmt in new_block:
					update_statements.append(stmt)
			update_statements.append(statement)
		else:
			update_statements.append(statement)
	return update_statements





def substituteFunBlockIf(statement,functionvarmap,functionname,externalvarmap):
	new_iftrue=None
	new_iffalse=None
	update_statements=None
	if type(statement) is c_ast.If:
		statement.cond,new_block=substituteFun(statement.cond,functionvarmap,functionname,externalvarmap)
		if new_block is not None and len(new_block)>0:
			update_statements=[]
			for stmt in new_block:
				update_statements.append(stmt)
		if type(statement.iftrue) is c_ast.Compound:
			new_iftrue=c_ast.Compound(block_items=substituteFunBlock(statement.iftrue.block_items,functionvarmap,functionname,externalvarmap))
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			new_iffalse=c_ast.Compound(block_items=substituteFunBlock(statement.iffalse.block_items,functionvarmap,functionname,externalvarmap))
		else:
			if type(statement.iffalse) is c_ast.If:
				statement.iffalse,new_block =substituteFunBlockIf(statement.iffalse,functionvarmap,functionname,externalvarmap)
				if new_block is not None and len(new_block)>0:
					if update_statements is None:
						update_statements=[]
					for stmt in new_block:
						update_statements.append(stmt)
				new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse),update_statements



def substituteFun(statement,functionvarmap,functionname,externalvarmap):
	new_block=None
	global new_variable
	if type(statement) is c_ast.ID:
                return statement,new_block
        elif type(statement) is c_ast.Constant:
                return statement,new_block
        if type(statement) is c_ast.ArrayRef:
        	return statement,new_block
        elif type(statement) is c_ast.UnaryOp:
                stmt,new_block_t=substituteFun(statement.expr,functionvarmap,functionname,externalvarmap)
                return c_ast.UnaryOp(op=statement.op, expr=stmt),new_block_t
        elif type(statement) is c_ast.FuncCall:
                update_statements=[]
                if statement.name.name not in functionvarmap.keys():
                	return statement,new_block
 		membermethod=functionvarmap[statement.name.name]
		in_var_map=membermethod.getInputvar().keys()
		count=membermethod.getUsedCounter()
		count=count+1
		membermethod.setUsedCounter(count)
		
		membermethod_cur=functionvarmap[functionname]
                
		if membermethod_cur is not None:
			in_var_map_cu=[]
			in_var_map_cu=membermethod_cur.getInputvar().keys()
			all_local_var=[]
			all_local_var_cu=[]
			if in_var_map is not None:
				for x in in_var_map:
					if externalvarmap is not None:
						if x not in externalvarmap.keys():
							all_local_var.append(x)
			if membermethod.getLocalvar() is not None:
				for x in membermethod.getLocalvar().keys():
					if externalvarmap is not None:
						if x not in externalvarmap.keys():
							all_local_var.append(x)
			if in_var_map_cu is not None:
				for x in in_var_map_cu:
					if externalvarmap is not None:
						if x not in externalvarmap.keys():
							all_local_var_cu.append(x)
			if membermethod_cur.getLocalvar() is not None:
				for x in membermethod_cur.getLocalvar().keys():
					if externalvarmap is not None:
						if x not in externalvarmap.keys():
							all_local_var_cu.append(x)
						
			if membermethod.getInputvar() is not None:
				all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
	
								
			input_map={}
		
		
			if '__VERIFIER_nondet' not in statement.name.name:
				if statement.args is not None:
					for x in range(0, len(statement.args.exprs)):
                        			arg=statement.args.exprs
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=arg[x]))
						input_map[in_var_map[x]]=arg[x]

				
				
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
                                
                                
                                
				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
                                
                                
				for x in membermethod.getInputvar().keys():
					if x in all_var_int:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=(membermethod.getInputvar()[x].getVariableType(),membermethod.getInputvar()[x].getDimensions())
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
                                        else:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable[x]=(membermethod.getInputvar()[x].getVariableType(),membermethod.getInputvar()[x].getDimensions())
						else:
                                			new_variable[x]=membermethod.getInputvar()[x].getVariableType()
				
				for x in membermethod.getLocalvar():
					if x in all_var_int:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=(membermethod.getLocalvar()[x].getVariableType(),membermethod.getLocalvar()[x].getDimensions())
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
                                        else:
                                                if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable[x]=(membermethod.getLocalvar()[x].getVariableType(),membermethod.getLocalvar()[x].getDimensions())
						else:
                                			new_variable[x]=membermethod.getLocalvar()[x].getVariableType()
		
		
				for stmt in new_blocks:
					update_statements.append(stmt)
 		
 				return c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+'RET'),update_statements	
 			else:
 				return statement,new_block
 		else:
 			return statement,new_block
 	elif type(statement) is c_ast.BinaryOp:
 		if type(statement.left) is c_ast.ID and type(statement.right) is c_ast.ID:
 			
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
 		if type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.ArrayRef:
 			
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block	
 		elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.BinaryOp:
                                               
                        stmt_right,new_block=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)

 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right),new_block
 			
 		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ID:
 			
                        stmt_left,new_block=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
                        
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right),new_block
 			
 		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.Constant:
 		
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
 			
 		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ID:

 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
 			
 		elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.Constant:
 		
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
 		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.Constant:
		 		
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
 		elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.ArrayRef:
		 		
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
 		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ArrayRef:
				 		
		 	return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.ID:
				 		
		 	return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block 		
 		
 		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.BinaryOp:
		
		        stmt_right,new_block=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)
		                        
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right),new_block
 		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.BinaryOp:

                        stmt_right,new_block=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)
                        
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right),new_block
 			
 		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.Constant:

                        stmt_left,new_block=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
 		
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right),new_block
 			
 		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ArrayRef:
		
		        stmt_left,new_block=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
		 		
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right),new_block
 		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.BinaryOp:
		
		        stmt_right,new_block=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)
		                        
		 	return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right),new_block
		 			
		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ArrayRef:
		
		        stmt_left,new_block=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
		 		
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right),new_block
 		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.BinaryOp:

                        stmt_left,new_block1=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)

                        stmt_right,new_block2=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)

                        if new_block1 is not None and new_block2 is None:
 		
                                return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right),new_block1

                        elif new_block1 is None and new_block2 is not None:

                                return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right),new_block2
                        else:
                                new_block=[]
                                if new_block1 is not None:
                                	for stmt in new_block1:
                                        	new_block.append(stmt)
                                if new_block2 is not None:
                                	for stmt in new_block2:
                                        	new_block.append(stmt)
                                return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right),new_block
 		
  		elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.BinaryOp:
 		 	update_statements=[]
		 	
		 	if statement.left.name.name not in functionvarmap.keys():
		 		return statement,new_block
		 	
		 	membermethod=functionvarmap[statement.left.name.name]
		 	
		 	if membermethod.getBody() is None:
		 		return statement,new_block
		 	
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)
			
			
			membermethod_cur=functionvarmap[functionname]
			if membermethod_cur is not None:
				in_var_map_cu=[]
				in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				if in_var_map is not None:
					for x in in_var_map:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if in_var_map_cu is not None:
					for x in in_var_map_cu:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
						
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
	
								
				input_map={}
			
			
			
				if statement.left.args is not None:
					for x in range(0, len(statement.left.args.exprs)):
						arg=statement.left.args.exprs
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
						input_map[in_var_map[x]]=arg[x]
			
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),membermethod.getInputvar(),membermethod.getSerialNo())
			
			
				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
				for stmt in new_blocks:
					update_statements.append(stmt)
				
				
				
				for x in membermethod.getInputvar():
					if x in all_var_int:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
				for x in membermethod.getLocalvar():
					if x in all_var_int:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()

			
			stmt_right,new_block1=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)
			if new_block1 is not None:
				for stmt in new_block1:
					update_statements.append(stmt)
				
 			return c_ast.BinaryOp(op=statement.op,left=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET'), right=stmt_right),update_statements			
 		
 		
 		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.FuncCall:
 		 	update_statements=[]
		 	stmt_left,new_block1=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
		 	if new_block1 is not None:
		 		for stmt in new_block1:
					update_statements.append(stmt)
		 	
		 	if statement.right.name.name not in functionvarmap.keys():
		 		return statement,new_block
		 	
		 	membermethod=functionvarmap[statement.right.name.name]
		 	
		 	if membermethod.getBody() is None:
		 		return statement,new_block
		 	
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)
			
			
			membermethod_cur=functionvarmap[functionname]
			if membermethod_cur is not None:
				in_var_map_cu=[]
				in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				if in_var_map is not None:
					for x in in_var_map:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if in_var_map_cu is not None:
					for x in in_var_map_cu:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
						
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
		
					
				input_map={}
			
			
			
			
			
				if statement.right.args is not None:
					for x in range(0, len(statement.right.args.exprs)):
						arg=statement.right.args.exprs
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=arg[x]))
						input_map[in_var_map[x]]=arg[x]
			
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
				for x in membermethod.getInputvar():
					if x in all_var_int:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
				for x in membermethod.getLocalvar():
					if x in all_var_int:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
				for stmt in new_blocks:
					update_statements.append(stmt)
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')),update_statements	
 			
 		elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.FuncCall:
 			update_statements=[]
 			
 			if statement.right.name.name not in functionvarmap.keys():
		 		return statement,new_block
 			
 			membermethod=functionvarmap[statement.right.name.name]
 			
 			
 			if membermethod.getBody() is None:
		 		return statement,new_block
 			
 			
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)
			
			
			membermethod_cur=functionvarmap[functionname]
			

			
			
			if membermethod_cur is not None:
				in_var_map_cu=[]
				in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				if in_var_map is not None:
					for x in in_var_map:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if in_var_map_cu is not None:
					for x in in_var_map_cu:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
						
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
		
				input_map={}
						
				if statement.right.args is not None:
					for x in range(0, len(statement.right.args.exprs)):
						arg=statement.right.args.exprs
						input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=arg[x]))
					
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
						
				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
				

				
				for x in membermethod.getInputvar():
					if x in all_var_int:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
				for x in membermethod.getLocalvar():
					if x in all_var_int:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
				for stmt in new_blocks:
					update_statements.append(stmt)
 		
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')),update_statements	
 		
  		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.FuncCall:
  			update_statements=[]
  			
  			if statement.right.name.name not in functionvarmap.keys():
		 		return statement,new_block
  			
  			membermethod=functionvarmap[statement.right.name.name]
  			
  			if membermethod.getBody() is None:
		 		return statement,new_block
  			
  			
 			in_var_map=membermethod.getInputvar().keys()
 			count=membermethod.getUsedCounter()
 			count=count+1
 			membermethod.setUsedCounter(count)
 			
 			
 			membermethod_cur=functionvarmap[functionname]
 			if membermethod_cur is not None:
 				in_var_map_cu=[]
 				in_var_map_cu=membermethod_cur.getInputvar().keys()
 				all_local_var=[]
 				all_local_var_cu=[]
 				if in_var_map is not None:
 					for x in in_var_map:
 						if externalvarmap is not None:
 							if x not in externalvarmap.keys():
 								all_local_var.append(x)
 				if membermethod.getLocalvar() is not None:
 					for x in membermethod.getLocalvar().keys():
 						if externalvarmap is not None:
 							if x not in externalvarmap.keys():
 								all_local_var.append(x)
 				if in_var_map_cu is not None:
 					for x in in_var_map_cu:
 						if externalvarmap is not None:
 							if x not in externalvarmap.keys():
 								all_local_var_cu.append(x)
 				if membermethod_cur.getLocalvar() is not None:
 					for x in membermethod_cur.getLocalvar().keys():
 						if externalvarmap is not None:
 							if x not in externalvarmap.keys():
 								all_local_var_cu.append(x)
 						
 				if membermethod.getInputvar() is not None:
 					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
 			
 		
 				input_map={}
 						
 				if statement.right.args is not None:
 					for x in range(0, len(statement.right.args.exprs)):
 						arg=statement.right.args.exprs
 						input_map[in_var_map[x]]=arg[x]
 					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
 				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=arg[x]))
 					
 				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
 						
 				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
 				
 
 				
 				for x in membermethod.getInputvar():
 					if x in all_var_int:
 						if membermethod.getInputvar()[x].getDimensions()>0:
 							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
 						else:
                                 			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
 				
 				for x in membermethod.getLocalvar():
 					if x in all_var_int:
 						if membermethod.getLocalvar()[x].getDimensions()>0:
 							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
 						else:
                                 			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
 				for stmt in new_blocks:
 					update_statements.append(stmt)
  		
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')),update_statements	
 		
 		elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.ID :
			update_statements=[]
			
			if statement.left.name.name not in functionvarmap.keys():
		 		return statement,new_block
			
		 	membermethod=functionvarmap[statement.left.name.name]
		 	
		 	
		 	if membermethod.getBody() is None:
		 		return statement,new_block
		 	
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)
			
			
			
			membermethod_cur=functionvarmap[functionname]
			if membermethod_cur is not None:
				in_var_map_cu=[]
				in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				if in_var_map is not None:
					for x in in_var_map:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if in_var_map_cu is not None:
					for x in in_var_map_cu:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
						
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
								
				input_map={}
			
			
				if statement.left.args is not None:
					for x in range(0, len(statement.left.args.exprs)):
						arg=statement.left.args.exprs
						input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
			
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
			new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
			for x in membermethod.getInputvar():
				if x in all_var_int:
					if membermethod.getInputvar()[x].getDimensions()>0:
						new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
					else:
                                		new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
			for x in membermethod.getLocalvar():
				if x in all_var_int:
					if membermethod.getLocalvar()[x].getDimensions()>0:
						new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
					else:
                                		new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
			for stmt in new_blocks:
				update_statements.append(stmt)
		 		
 			return c_ast.BinaryOp(op=statement.op,left=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET'), right=statement.right),update_statements	

 		elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.ArrayRef :
			update_statements=[]
			
			if statement.left.name.name not in functionvarmap.keys():
		 		return statement,new_block
			
			
		 	membermethod=functionvarmap[statement.left.name.name]
		 	
		 	
		 	if membermethod.getBody() is None:
		 		return statement,new_block
		 	
		 	
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)
			
			
			
			membermethod_cur=functionvarmap[functionname]
			if membermethod_cur is not None:
				in_var_map_cu=[]
				in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				if in_var_map is not None:
					for x in in_var_map:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if in_var_map_cu is not None:
					for x in in_var_map_cu:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
						
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
								
				input_map={}
			
			
				if statement.left.args is not None:
					for x in range(0, len(statement.left.args.exprs)):
						arg=statement.left.args.exprs
						input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
			
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
			new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
			for x in membermethod.getInputvar():
				if x in all_var_int:
					if membermethod.getInputvar()[x].getDimensions()>0:
						new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
					else:
                                		new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
			for x in membermethod.getLocalvar():
				if x in all_var_int:
					if membermethod.getLocalvar()[x].getDimensions()>0:
						new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
					else:
                                		new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
			for stmt in new_blocks:
				update_statements.append(stmt)
		 		
 			return c_ast.BinaryOp(op=statement.op,left=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET'), right=statement.right),update_statements	
 		
 		
 		
 		
 		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.FuncCall:
		 	update_statements=[]
		 	
		 	if statement.right.name.name not in functionvarmap.keys():
		 		return statement,new_block
		 	
		 	membermethod=functionvarmap[statement.right.name.name]
		 	
		 	if membermethod.getBody() is None:
		 		return statement,new_block
		 	
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)
			
					
						
			membermethod_cur=functionvarmap[functionname]
			if membermethod_cur is not None:
				in_var_map_cu=[]
				in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				if in_var_map is not None:
					for x in in_var_map:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if in_var_map_cu is not None:
					for x in in_var_map_cu:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
									
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
											
				input_map={}
			
			
				for x in range(0, len(statement.right.args.exprs)):
					arg=statement.right.args.exprs
					input_map[in_var_map[x]]=arg[x]
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
				for x in membermethod.getInputvar():
					if x in all_var_int:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
				for x in membermethod.getLocalvar():
					if x in all_var_int:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
				for stmt in new_blocks:
					update_statements.append(stmt)
		 		
		 	return c_ast.BinaryOp(op=statement.op,left=statement.left, right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')),update_statements	
		 		
		elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.Constant :
			update_statements=[]
			
			if statement.left.name.name not in functionvarmap.keys():
		 		return statement,new_block
			
			membermethod=functionvarmap[statement.left.name.name]
			
			if membermethod.getBody() is None:
		 		return statement,new_block
			
			
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)
						
			membermethod_cur=functionvarmap[functionname]
			
			
			if membermethod_cur is not None:
				in_var_map_cu=[]
				in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				for x in in_var_map:
					if externalvarmap is not None:
						if x not in externalvarmap.keys():
							all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				for x in in_var_map_cu:
					if externalvarmap is not None:
						if x not in externalvarmap.keys():
							all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
									
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
											
				input_map={}
						
			
				if statement.left.args is not None:
					for x in range(0, len(statement.left.args.exprs)):
						arg=statement.left.args.exprs
						input_map[in_var_map[x]]=arg[x]
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
				
				
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
				for x in membermethod.getInputvar():
					if x in all_var_int:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
				for x in membermethod.getLocalvar():
					if x in all_var_int:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
				for stmt in new_blocks:
					update_statements.append(stmt)
		
				 		
 			return c_ast.BinaryOp(op=statement.op,left=c_ast.ID(name='t_'+str(count)+'_RET'), right=statement.right),update_statements	
 		
 		elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.FuncCall:
		 	update_statements=[]
		 	
		 	if statement.left.name.name not in functionvarmap.keys():
		 		return statement,new_block
		 	
		 	membermethod=functionvarmap[statement.left.name.name]
		 	
		 	
		 	if membermethod.getBody() is None:
		 		return statement,new_block
		 		
		 	
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)
			
			membermethod_cur=functionvarmap[functionname]
			
			if membermethod_cur is not None:
				in_var_map_cu=[]
				if membermethod_cur.getInputvar() is not None:
					in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				if in_var_map is not None:
					for x in in_var_map:
						if x not in externalvarmap.keys():
							all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if in_var_map_cu is not None:
					for x in in_var_map_cu:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
									
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
											
				input_map={}
						
				if statement.left.args is not None:
					for x in range(0, len(statement.left.args.exprs)):
						arg=statement.left.args.exprs
						input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
			
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
			
				for x in membermethod.getInputvar():
					if x in all_var_int:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
				for x in membermethod.getLocalvar():
					if x in all_var_int:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
				for stmt in new_blocks:
					update_statements.append(stmt)
		 	
		 		stmt_left=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')
		 	else:
		 		stmt_left=statement.left
		 	
		 	
		 	if statement.right.name.name not in functionvarmap.keys():
		 		return statement,new_block
		 		
		 	membermethod=functionvarmap[statement.right.name.name]
		 	
		 	if membermethod.getBody() is None:
		 		return statement,new_block
		 	
		 	
			in_var_map=membermethod.getInputvar().keys()
			count=membermethod.getUsedCounter()
			count=count+1
			membermethod.setUsedCounter(count)

			if membermethod_cur is not None:
				membermethod_cur=functionvarmap[functionname]
				in_var_map_cu=membermethod_cur.getInputvar().keys()
				all_local_var=[]
				all_local_var_cu=[]
				if in_var_map is not None:
					for x in in_var_map:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if membermethod.getLocalvar() is not None:
					for x in membermethod.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var.append(x)
				if in_var_map_cu is not None:
					for x in in_var_map_cu:
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
				if membermethod_cur.getLocalvar() is not None:
					for x in membermethod_cur.getLocalvar().keys():
						if externalvarmap is not None:
							if x not in externalvarmap.keys():
								all_local_var_cu.append(x)
									
				if membermethod.getInputvar() is not None:
					all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
											
				input_map={}
			
			
				if statement.left.args is not None:
					for x in range(0, len(statement.right.args.exprs)):
						arg=statement.right.args.exprs
						input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
			
			
				new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
				new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
				for x in membermethod.getInputvar():
					if x in all_var_int:
						if membermethod.getInputvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
				for x in membermethod.getLocalvar():
					if x in all_var_int:
						if membermethod.getLocalvar()[x].getDimensions()>0:
							new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
						else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
						
		
		
				for stmt in new_blocks:
					update_statements.append(stmt)
		 	
		 		stmt_right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')
		 	else:
		 		stmt_right=statement.right
		 	
		 	return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right),update_statements	
	
 		else:
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
 	return None


def getIndexVariable(statement,local_map):
    if type(statement) is c_ast.BinaryOp:
        getIndexVariable(statement.left,local_map)
        getIndexVariable(statement.right,local_map)
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ArrayRef:
            getIndexVariable(statement.name,local_map)
        local_map[statement.subscript.name]=statement.subscript.name
    

new_variable_array={}

def reconstructStmtBlock(statements,count,var_map,in_var_map,fun_count,all_var_int):
	update_statements=[]
        global counter_variableMap
        global counter_variableMap_Conf
        global new_variable_array
	for statement in statements:
                if type(statement) is c_ast.Decl:
                    if type(statement.type) is c_ast.ArrayDecl:
                        if statement.name in all_var_int:
                            update_statements.append(c_ast.Decl(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=renameArrayName(statement.type), init=statement.init, bitsize=statement.bitsize))
                        else:
                            update_statements.append(statement)
                    elif type(statement.type) is c_ast.PtrDecl:
                        if type(statement.type.type) is c_ast.TypeDecl:
                            update_statements.append(c_ast.TypeDecl('f'+str(fun_count)+'_'+str(count)+'_'+statement.name, quals=statement.type.type.quals, type=statement.type.type.type))
                    else:
                        if statement.name in all_var_int:
                            update_statements.append(c_ast.Decl(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.TypeDecl(declname='f'+str(fun_count)+'_'+str(count)+'_'+statement.type.declname, quals=statement.type.quals, type=statement.type.type), init=statement.init, bitsize=statement.bitsize))
                        else:
                            update_statements.append(statement)

		elif type(statement) is c_ast.Assignment:
			if type(statement.lvalue) is c_ast.ID:
				if statement.lvalue.name in all_var_int:
					update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.lvalue.name), rvalue=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)))
				else:
					if statement.lvalue.name in in_var_map.keys():
                                                r_statement=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                                l_statement=in_var_map[statement.lvalue]
                                                if '_PROVE' in statement.lvalue.name:
                                                    #local_map={}
                                                    #getIndexVariable(r_statement,local_map)
                                                    #if local_map==counter_variableMap_Conf:
                                                    #new_variable_array[l_statement.name]=creatArrayDec(l_statement.name,counter_variableMap_Conf.keys())
                                                    new_variable_array[l_statement.name]=len(counter_variableMap_Conf.keys())
                                                    l_statement=create_Assert_Array(l_statement.name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
						update_statements.append(c_ast.Assignment(op='=', lvalue=l_statement, rvalue=r_statement))
					else:
                                                r_statement=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                                l_statement=statement.lvalue
                                                #if '_PROVE' in statement.lvalue.name:
                                                #    new_variable_array[l_statement.name]=len(counter_variableMap_Conf.keys())
                                                #    l_statement=create_Assert_Array(l_statement,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
						update_statements.append(c_ast.Assignment(op='=', lvalue=l_statement, rvalue=r_statement))
			else:
                                r_statement=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                l_statement=reconstructStmt(statement.lvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                #if '_PROVE' in statement.lvalue.name:
                                #    new_variable_array[l_statement.name]=len(counter_variableMap_Conf.keys())
                                #    l_statement=create_Assert_Array(l_statement.name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
				update_statements.append(c_ast.Assignment(op='=', lvalue=l_statement, rvalue=r_statement))
		elif type(statement) is c_ast.While:
			update_statements.append(reconstructStmt(c_ast.While(cond=reconstructStmt(statement.cond,count,var_map,in_var_map,fun_count,all_var_int),stmt=c_ast.Compound(block_items=reconstructStmtBlock(statement.stmt.block_items,count,var_map,in_var_map,fun_count,all_var_int))),count,var_map,in_var_map,fun_count,all_var_int ))
		elif type(statement) is c_ast.If:
			update_statements.append(reconstructStmtIf(statement,count,var_map,in_var_map,fun_count,all_var_int))
		else:
			if type(statement) is c_ast.FuncCall:
				update_statements.append(statement)
			else:
                                #if type(statement) is c_ast.Decl:
                                #        var_type=None
                                #        initial_value=None
                                #        for child in statement.children():
                                #                if type(child[1]) is c_ast.TypeDecl:
                                #                	if type(child[1].type) is c_ast.IdentifierType:
                                #                        	var_type=child[1].type.names[0]
                                #                else:
                                #                        initial_value=child[1]
                                #        if initial_value is not None:
                                #        	
                                #        	if statement.name in all_var_int:
                                #        		update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name), rvalue=reconstructStmt(initial_value,count,var_map,in_var_map,fun_count,all_var_int)))	
                                #        	else:
                                #        		if statement.name in in_var_map.keys():
                                #        			update_statements.append(c_ast.Assignment(op='=',lvalue=in_var_map[statement.name], rvalue=reconstructStmt(initial_value,count,var_map,in_var_map,fun_count,all_var_int)))
                                #        		else:
                                #        			update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=statement.name), rvalue=reconstructStmt(initial_value,count,var_map,in_var_map,fun_count,all_var_int)))
                                        	
                                #else:
                                if type(statement) is not c_ast.Decl:
                                    update_statements.append(statement)
	return update_statements





def reconstructStmtIf(statement,count,var_map,in_var_map,fun_count,all_var_int):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			new_iftrue=c_ast.Compound(block_items=reconstructStmtBlock(statement.iftrue.block_items,count,var_map,in_var_map,fun_count,all_var_int))
		else:
			new_iftrue=reconstructStmt(statement.iftrue,count,var_map,in_var_map,fun_count,all_var_int)
		if type(statement.iffalse) is c_ast.Compound:
			new_iffalse=c_ast.Compound(block_items=reconstructStmtBlock(statement.iffalse.block_items,count,var_map,in_var_map,fun_count,all_var_int))
		else:
			if type(statement.iffalse) is c_ast.If:
				new_iffalse=reconstructStmtIf(statement.iffalse,count,var_map,in_var_map,all_var_int)
                        else:
                                new_iffalse=reconstructStmt(statement.iffalse,count,var_map,in_var_map,fun_count,all_var_int)
	
	return c_ast.If(cond=reconstructStmt(statement.cond,count,var_map,in_var_map,fun_count,all_var_int), iftrue=new_iftrue, iffalse=new_iffalse)






def reconstructStmt(statement,count,var_map,in_var_map,fun_count,all_var_int):
	if type(statement) is c_ast.ID:
		if statement.name in var_map.keys() or statement.name in in_var_map.keys():
			if statement.name in all_var_int:
				return c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name)
			else:
				return statement
		else:
			return statement
 	elif type(statement) is c_ast.ArrayRef:
                stmt_right=renameArrayName1(statement,count,var_map,in_var_map,fun_count,all_var_int)
                return stmt_right

 	elif type(statement) is c_ast.UnaryOp:
 		return c_ast.UnaryOp(op=statement.op,expr=reconstructStmt(statement.expr,count,var_map,in_var_map,fun_count,all_var_int))
 	elif type(statement) is c_ast.Constant:
 		return statement
 	elif type(statement) is c_ast.BinaryOp:
 		if type(statement.left) is c_ast.ID and type(statement.right) is c_ast.ID:
 			stmt_left=None
 			stmt_right=None
 			if statement.left.name in var_map.keys() or statement.left.name in in_var_map.keys():
 				if statement.left.name in all_var_int:
 					stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
 				else:
 					stmt_left=statement.left
 						
 			else:
 				stmt_left=statement.left
 				
 			if statement.right.name in var_map.keys() or statement.right.name in in_var_map.keys():
				if statement.right.name in all_var_int:
					stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.right.name)
				else:
					stmt_right=statement.right
						
			else:
 				stmt_right=statement.right
 			
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right)
                        
 		elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.ArrayRef:
 			stmt_left=None
 			stmt_right=None
 			if statement.left.name in var_map.keys() or statement.left.name in in_var_map.keys():
 				if statement.left.name in all_var_int:
 					stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
 				else:
 					stmt_left=statement.left
 						
 			else:
 				stmt_left=statement.left
 				
 			stmt_right=renameArrayName1(statement.right,count,var_map,in_var_map,fun_count,all_var_int)
 			
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right)

 		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.ID:
 			stmt_left=None
 			stmt_right=None
                        
 			stmt_left=renameArrayName1(statement.left,count,var_map,in_var_map,fun_count,all_var_int)
 				
 			if statement.right.name in var_map.keys() or statement.right.name in in_var_map.keys():
				if statement.right.name in all_var_int:
					stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.right.name)
				else:
					stmt_right=statement.right
						
			else:
 				stmt_right=statement.right
 			
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right)
 				
 		elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.BinaryOp:
 			stmt_left=None
			if statement.left.name in all_var_int:
				stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
			else:
				stmt_left=statement.left
					
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 				
 			
 		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ID:
 			stmt_right=None
 			
			if statement.right.name in all_var_int:
				stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+statement.right.name)
			else:
				stmt_right=statement.right
					
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=stmt_right)
 				
  		elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.UnaryOp:
 			stmt_left=None
 			
			if statement.left.name in all_var_int:
				stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
			else:
				
				stmt_left=statement.left
					
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 				
 			
 		elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.ID:
 			stmt_right=None
 			
 		
			if statement.right.name in all_var_int:
				stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+statement.right.name)
			else:
				stmt_right=statement.right
					
 			
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=stmt_right)
 					
 		

 		
 		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.Constant:
 		
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right)
 			
 		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ID:
 			stmt_right=None
  
			if statement.right.name in all_var_int:
				stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.right.name)
			else:
				stmt_right=statement.right
								
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right)
 				
 			
 		elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.Constant:
 			stmt_left=None
 			
 		 	if statement.left.name in all_var_int:
				stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
			else:
				stmt_left=statement.left
					
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right)
 			
 		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ArrayRef:
 			stmt_right=None
  
			stmt_right=renameArrayName1(statement.right,count,var_map,in_var_map,fun_count,all_var_int)
								
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right)
 				
 			
 		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.Constant:
 			stmt_left=None
 			
 		 	stmt_left=renameArrayName1(statement.left,count,var_map,in_var_map,fun_count,all_var_int)
					
 			return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right)
                    
                        
 				
 		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.UnaryOp:
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.Constant:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=statement.right)	
                        	
                elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ArrayRef:
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.Constant:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=statement.right)
  		
  		elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.BinaryOp:
  			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
  		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.Constant:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=statement.right)
 		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.BinaryOp:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.UnaryOp:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.BinaryOp:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.UnaryOp:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		
 		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.BinaryOp:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ArrayRef:
 			
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		
 		elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.ArrayRef:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.UnaryOp:
 			return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		
 		else:
 			return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right)
                        
 	else:
		if type(statement) is c_ast.Assignment:
			if type(statement.lvalue) is c_ast.ID:
				if statement.lvalue.name in all_var_int:
					return c_ast.Assignment(op='=', lvalue=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.lvalue.name), rvalue=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int))
				else:
					if statement.lvalue.name in in_var_map.keys():
                                                r_statement=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                                l_statement=in_var_map[statement.lvalue]
                                                if '_PROVE' in statement.lvalue.name:
                                                    #local_map={}
                                                    #getIndexVariable(r_statement,local_map)
                                                    #if local_map==counter_variableMap_Conf:
                                                    #new_variable_array[l_statement.name]=creatArrayDec(l_statement.name,counter_variableMap_Conf.keys())
                                                    new_variable_array[l_statement.name]=len(counter_variableMap_Conf.keys())
                                                    l_statement=create_Assert_Array(l_statement.name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
						return c_ast.Assignment(op='=', lvalue=l_statement, rvalue=r_statement)
					else:
                                                r_statement=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                                l_statement=statement.lvalue
                                                #if '_PROVE' in statement.lvalue.name:
                                                #    new_variable_array[l_statement.name]=len(counter_variableMap_Conf.keys())
                                                #    l_statement=create_Assert_Array(l_statement,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
						return c_ast.Assignment(op='=', lvalue=l_statement, rvalue=r_statement)
			else:
                                r_statement=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                l_statement=reconstructStmt(statement.lvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                #if '_PROVE' in statement.lvalue.name:
                                #    new_variable_array[l_statement.name]=len(counter_variableMap_Conf.keys())
                                #    l_statement=create_Assert_Array(l_statement.name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
				return c_ast.Assignment(op='=', lvalue=l_statement, rvalue=r_statement)

            
 		return statement
 	return None
	







#
#Reconstruct Program by Removing assert,assume,error
#

def reconstructPreDefinedFun(statements):
	global fail_count
	global error_count
	global assume_count
	global assert_count
	global new_variable
        global counter_variableMap
        global counter_variableMap_Conf
        global array_size_variableMap
        
        counter_variableMap={}

        counter_variableMap_Conf={}

        array_size_variableMap={}
        
	statements=getPreDefinedFun(statements,0,{})
        
        
    	update_statements=[]
        temp_update_statements=[]

    	for var in new_variable.keys():
    		if type(new_variable[var]) is str:
    			temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
    		else:
    			temp=new_variable[var]
    		temp_update_statements.append(temp)
                
        for statement in temp_update_statements:
            update_statements.append(statement)
    	for statement in statements:
            update_statements.append(statement)

        #for statement in statements:
        #    #statement.show()
        #    #if type(statement) is not c_ast.Decl:
        #    update_statements.append(statement)
        
    	new_variable={}
    	return update_statements



counter_variableMap={}

counter_variableMap_Conf={}

array_size_variableMap={}

def getPreDefinedFun(statements,degree,dec_map):
	update_statements=[]
	global fail_count
	global error_count
	global assume_count
	global assert_count
	global new_variable
        global counter_variableMap
        global counter_variableMap_Conf
        global array_size_variableMap
        #print '$$$$$$$$$$$$$$$$$@@@@@@@@@@@@'
        #print new_variable
        #print '$$$$$$$$$$$$$$$$$@@@@@@@@@@@@'
	for statement in statements:
		if type(statement) is c_ast.If:
			stmt=getPreDefinedFunIf(statement,degree,dec_map)
			if stmt is not None:
				update_statements.append(stmt)
		elif type(statement) is c_ast.While:
			local_counter_varMap=getCounterVariables(statement.cond,counter_variableMap)

			getConfirmationVariables(statement.stmt.block_items,counter_variableMap,counter_variableMap_Conf)
                        

                        getCounterVariablesConst(statement.cond,array_size_variableMap)
                        
                        getArraySizeVar(local_counter_varMap,counter_variableMap_Conf,array_size_variableMap)
                        

                        degree=degree+1
                        
			new_block_items1=getPreDefinedFun(statement.stmt.block_items,degree,dec_map)
                        
                        degree=degree-1
                        
                        
			for item in local_counter_varMap.keys():
				if item in counter_variableMap.keys():
					del counter_variableMap[item]
				if item in counter_variableMap_Conf.keys():
					del counter_variableMap_Conf[item]
                                if item in array_size_variableMap.keys():
                                        del array_size_variableMap[item]
			#start comment on 16/08/2017
			#if degree==0:
                        #    array_size_variableMap.clear()
                        #    for var in dec_map.keys():
                        #        if type(dec_map[var]) is str:
                        #            temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                        #        else:
                        #            temp=dec_map[var]
                        #        update_statements.append(temp)
                        #        del dec_map[var]
                        #        del new_variable[var]
                        #end comment on 16/08/2017
			update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=new_block_items1)))
		#elif type(statement) is c_ast.Label:
		#	if statement.name=='ERROR':
                #                print 'XXXXXXXXXXXXXXXXXXXXXXXX'
		#		fail_count=fail_count+1
		#		update_statements.append(statement)
		#		update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
		#		new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                #                dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
		#		
		#	else:
		#		update_statements.append(statement)
		elif type(statement) is c_ast.FuncCall:
			parameters=[]
			if statement.args is not None:
				for param in statement.args.exprs:
					if type(param) is c_ast.ID:
						parameters.append(param)
					elif type(param) is c_ast.Constant:
						parameters.append(param)
					elif type(param) is c_ast.BinaryOp:
						parameters.append(param)
					elif type(param) is c_ast.FuncCall:
						parameters.append(param)
					else:
						parameters.append(param)
                                if statement.name.name=='__VERIFIER_assert':
                                    new_statement=None
                                    for parameter in parameters:
                                            if new_statement is None:
                                                    assert_count=assert_count+1
                                                    new_var_name=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE')
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                        
                                                            if len(counter_variableMap_Conf)==degree:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                            elif len(counter_variableMap)==degree:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap.keys(),counter_variableMap)
                                                            else:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                            
                                                
                                                    status,parameter=modificationOfCondition(parameter)
                                                    if status==True:
                                                            parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
						
                                                    new_statement= c_ast.Assignment(op='=', lvalue=new_var_name, rvalue=parameter)
						#new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                    if len(counter_variableMap_Conf.keys())>0:
                                            
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']=creatArrayDec('_'+str(assert_count)+'_'+'PROVE',array_size_variableMap.keys(),degree)
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']=creatArrayDec('_'+str(assert_count)+'_'+'PROVE',array_size_variableMap.keys(),degree)
                                                        
                                                    else:
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                        
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                        
                                                #print '#############@@@@@@@@'
                                                #print new_variable['_'+str(assert_count)+'_'+'PROVE'].show()
						#print '#############@@@@@@@@'
                                            else:
                                                    assert_count=assert_count+1
                                                    
                                                    new_var_name=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE')
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                            if len(counter_variableMap_Conf)==degree:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                            elif len(counter_variableMap)==degree:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap.keys(),counter_variableMap)
                                                            else:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                            #new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)

                                                    status,stmt=modificationOfCondition(parameter)
                                                    if status==True:
                                                            parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
                                                    new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=new_var_name, rvalue=parameter), right=new_statement)
                                                    #new_variable['_'+str(assert_count)+'_'+'PROVE']='Array'
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']=creatArrayDec('_'+str(assert_count)+'_'+'PROVE',array_size_variableMap.keys(),degree)
                                                            

                                                        
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']=creatArrayDec('_'+str(assert_count)+'_'+'PROVE',array_size_variableMap.keys(),degree)
                                                    else:
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                        
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                        

                                    update_statements.append(new_statement)
                                elif statement.name.name=='__VERIFIER_assume':
                                    new_statement=None
                                    for parameter in parameters:
                                            if new_statement is None:
                                                    assume_count=assume_count+1
						
                                                    new_var_name=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME')
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                            new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)

                                                    status,parameter=modificationOfCondition(parameter)
                                                    if status==True:
                                                            parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
						
                                                    new_statement= c_ast.Assignment(op='=', lvalue=new_var_name, rvalue=parameter)
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                        new_variable['_'+str(assume_count)+'_'+'ASSUME']=creatArrayDec('_'+str(assume_count)+'_'+'ASSUME',array_size_variableMap.keys(),degree)
                                                    
                                                        dec_map['_'+str(assume_count)+'_'+'ASSUME']=creatArrayDec('_'+str(assume_count)+'_'+'ASSUME',array_size_variableMap.keys(),degree)
                                                    
                                                    else:
                                                        new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                    
                                                        dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                            else:
                                                    assume_count=assume_count+1
						
                                                    new_var_name=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME')
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                            new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
						
                                                    status,stmt=modificationOfCondition(parameter)
                                                    if status==True:
                                                            parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))						
						
                                                    new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=new_var_name, rvalue=parameter), right=new_statement)
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                        new_variable['_'+str(assume_count)+'_'+'ASSUME']=creatArrayDec('_'+str(assume_count)+'_'+'ASSUME',array_size_variableMap.keys(),degree)
                                                    
                                                        dec_map['_'+str(assume_count)+'_'+'ASSUME']=creatArrayDec('_'+str(assume_count)+'_'+'ASSUME',array_size_variableMap.keys(),degree)
                                                    
                                                    else:
                                                        new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                    
                                                        dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                    update_statements.append(new_statement)
				else:
                                    update_statements.append(statement)
			else:
				if statement.name.name=='__VERIFIER_error':
                                    fail_count=fail_count+1
                                    #update_statements.append(statement)
                                    update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
                                    new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                    dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                else:
                                    update_statements.append(statement)
		
		else:
			update_statements.append(statement)
	return update_statements
	


#
#Get Counter Variable
#

def getCounterVariables(statement,variableMap):
	variableMap_Local={}
	if type(statement) is c_ast.UnaryOp:
		if type(statement.expr) is c_ast.ID:
			variableMap[statement.expr.name]=statement.expr.name
			variableMap_Local[statement.expr.name]=statement.expr.name
	        else:
                        temp_variableMap=getCounterVariables(statement.expr,variableMap)
                        if temp_variableMap is not None:
                        	for item in temp_variableMap.keys():
                        		variableMap_Local[item]=item
	elif type(statement) is c_ast.ID:
		variableMap[statement.name]=statement.name
		variableMap_Local[statement.name]=statement.name
	#elif type(statement) is c_ast.ArrayRef:
	#	getCounterVariables(statement.expr,variableMap)
	elif type(statement) is c_ast.BinaryOp:
		if type(statement.left) is c_ast.ID:
			variableMap[statement.left.name]=statement.left.name
			variableMap_Local[statement.left.name]=statement.left.name
		else:
			temp_variableMap=getCounterVariables(statement.left,variableMap)
			if temp_variableMap is not None:
				for item in temp_variableMap.keys():
                        		variableMap_Local[item]=item
		if type(statement.right) is c_ast.ID:
			variableMap[statement.right.name]=statement.right.name
			variableMap_Local[statement.right.name]=statement.right.name
		else:
			temp_variableMap=getCounterVariables(statement.right,variableMap)
			if temp_variableMap is not None:
				for item in temp_variableMap.keys():
                        		variableMap_Local[item]=item
        elif type(statement) is c_ast.ArrayRef:
                getAllSubScripts(statement,variableMap,variableMap_Local)
	return variableMap_Local


#
#Get Varible Constant from Condition
#

def getCounterVariablesConst(statement,variableMap):
	if type(statement) is c_ast.UnaryOp:
		if type(statement.expr) is c_ast.ID:
			variableMap[statement.expr.name]=statement.expr.name
	        else:
                        getCounterVariablesConst(statement.expr,variableMap)    
	elif type(statement) is c_ast.ID:
		variableMap[statement.name]=statement.name
        elif type(statement) is c_ast.Constant:
                variableMap[statement.value]=statement.value
	#elif type(statement) is c_ast.ArrayRef:
	#	getCounterVariables(statement.expr,variableMap)
	elif type(statement) is c_ast.BinaryOp:
		if type(statement.left) is c_ast.ID:
			variableMap[statement.left.name]=statement.left.name
		else:
			getCounterVariablesConst(statement.left,variableMap)
		if type(statement.right) is c_ast.ID:
			variableMap[statement.right.name]=statement.right.name
		else:
			getCounterVariablesConst(statement.right,variableMap)









def getAllSubScripts(statement,variableMap,variableMap_Local):
    if type(statement.subscript) is c_ast.ID:
        variableMap[statement.subscript.name]=statement.name
        variableMap_Local[statement.subscript.name]=statement.name
    if type(statement.name) is c_ast.ArrayRef:
        getAllSubScripts(statement.name,variableMap,variableMap_Local)
#
#Get Counter Variable
#

def getCounterVariablesConf(statement,variableMap):
	variableMap_Local={}
	if type(statement) is c_ast.UnaryOp:
		if type(statement.expr) is c_ast.ID:
			variableMap[statement.expr.name]=statement.expr.name
	        else:
                        getCounterVariablesConf(statement.expr,variableMap)    
	elif type(statement) is c_ast.ID:
		variableMap[statement.name]=statement.name
        #elif type(statement) is c_ast.Constant:
        #        variableMap[statement.value]=statement.value
	#elif type(statement) is c_ast.ArrayRef:
	#	getCounterVariables(statement.expr,variableMap)
	elif type(statement) is c_ast.BinaryOp:
		if type(statement.left) is c_ast.ID:
			variableMap[statement.left.name]=statement.left.name
		else:
			getCounterVariablesConf(statement.left,variableMap)
		if type(statement.right) is c_ast.ID:
			variableMap[statement.right.name]=statement.right.name
		else:
			getCounterVariablesConf(statement.right,variableMap)






#
#Confirmation of Counter Variable
#

def getConfirmationVariables(statements,variableMap,variableMap_Conf):
    for statement in statements:
    	if type(statement) is c_ast.Assignment:
        	if type(statement.lvalue) is c_ast.ID:
            		if statement.lvalue.name in variableMap.keys():
            			variableMapExp={}
                		getCounterVariablesConf(statement.rvalue,variableMapExp)
                		if statement.lvalue.name in variableMapExp.keys():
                   			 variableMap_Conf[statement.lvalue.name]=statement.lvalue.name

def getArraySizeVar(local_counter_varMap,counter_variableMap_Conf,array_size_variableMap):
    for var in local_counter_varMap.keys():
        if var in counter_variableMap_Conf.keys() and var in array_size_variableMap.keys():
            #array_size_variableMap[var]=var
            del array_size_variableMap[var]
                




#create_Assert_Array(['x','y'],{'x':'x','y':'y'})
def create_Assert_Array(array_name,items,variableMap):
	if len(items)>0:
		if len(items[1:])>0:
			return c_ast.ArrayRef(name=create_Assert_Array(array_name,items[:-1],variableMap), subscript=c_ast.ID(name=items[-1]))	
		else:
			return c_ast.ArrayRef(name=array_name, subscript=c_ast.ID(name=items[-1]))
	return None
	


#creatArrayDec('a',['x','y']).show()

def creatArrayDec(name,parameterlist,degree):
    str_parameterlist=None
    count=0
    generator = c_generator.CGenerator()
    #for para in parameterlist:
    #    if is_number(para)==True and '.' in para:
    #        para=str(int(para.split(".")[0]))
    arraysize=1000000
    if degree==2:
        arraysize=100000
    elif degree==3:
        arraysize=100000
        
    for x in range(0, degree):
        if str_parameterlist==None:
            
            str_parameterlist='['+str(arraysize)+']'
        else:
            str_parameterlist='['+str(arraysize)+']'+str_parameterlist
        #if count<degree:
        #    if str_parameterlist==None:
        #        str_parameterlist='['+para+']'
        #        #str_parameterlist='['+']'
        #    else:
        #        str_parameterlist='['+para+']'+str_parameterlist
        #count=count+1
    #print '-----------@@@@@@@@@@@@'
    #print parameterlist
    #print count
    #print degree
    #print '-----------@@@@@@@@@@@@'

            #str_parameterlist='['+']'+str_parameterlist
    if str_parameterlist is not None:
        function='int '+name+str_parameterlist
    else:
        function='int '+name
    main_function='void main(){'+function+';}'
    parser = c_parser.CParser()
    ast = parser.parse(main_function)
    return ast.ext[0].body.block_items[0]







#
#Reconstruct Program by Removing assert,assume,error
#

def getPreDefinedFunIf(statement,degree,dec_map):
	new_iftrue=None
	new_iffalse=None
	global fail_count
	global error_count
	global assume_count
	global assert_count
	global new_variable

	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Label:
			#if statement.iftrue.name=='ERROR':
			#	fail_count=fail_count+1
			#	new_block_items1=[]
			#	new_block_items1.append(c_ast.Label(name=statement.iftrue.name, stmt=[]))
			#	new_block_items1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
			#	new_iftrue=c_ast.Compound(block_items=new_block_items1)
			#	new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                        #        dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
			if type(statement.iftrue) is c_ast.FuncCall:
				parameters=[]
				if statement.iftrue.args is not None:
					for param in statement.iftrue.args.exprs:
						if type(param) is c_ast.ID:
							parameters.append(param)
						elif type(param) is c_ast.Constant:
							parameters.append(param)
						elif type(param) is c_ast.BinaryOp:
							parameters.append(param)
						elif type(param) is c_ast.FuncCall:
							parameters.append(param)
						else:
							parameters.append(param)
                                        if statement.iftrue.name.name=='__VERIFIER_assert':
                                            new_statement=None
                                            for parameter in parameters:
                                                    if new_statement is None:
                                                            assert_count=assert_count+1
                                                            status,parameter=modificationOfCondition(parameter)
                                                            if status==True:
                                                                    parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
                                                            new_statement= c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE'), rvalue=parameter)
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                    else:
                                                            assert_count=assert_count+1
                                                            status,parameter=modificationOfCondition(parameter)
                                                            if status==True:
                                                                    parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
                                                            new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE'), rvalue=parameter), right=new_statement)
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                            new_iftrue=new_statement
                                        elif statement.iftrue.name.name=='__VERIFIER_assume':
                                            new_statement=None
                                            for parameter in parameters:
                                                    if new_statement is None:
                                                            assume_count=assume_count+1
                                                            new_statement= c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME'), rvalue=parameter)
                                                            new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                            dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                    else:
                                                            assume_count=assume_count+1
                                                            new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME'), rvalue=parameter), right=new_statement)
                                                            new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                            dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                            new_iftrue=new_statement
                                        elif statement.name.name=='__VERIFIER_error':
                                            fail_count=fail_count+1
                                            new_block_items1=[]
                                            #new_block_items1.append(c_ast.Label(name=statement.iftrue.name, stmt=[]))
                                            new_block_items1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
                                            new_iftrue=c_ast.Compound(block_items=new_block_items1)
                                            new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                            dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                        else:
                                            new_iftrue=statement.iftrue
                                
		elif type(statement.iftrue) is c_ast.Compound:
                    
                        #degree=degree+1
                        
			new_block_items=getPreDefinedFun(statement.iftrue.block_items,degree,dec_map)
                        
                        #degree=degree-1
                        
			new_iftrue=c_ast.Compound(block_items=new_block_items)
		else:
			new_iftrue=statement.iftrue
			
        if type(statement.iffalse) is c_ast.Label:
                    #if statement.iffalse.name=='ERROR':
                    #        fail_count=fail_count+1
                    #        new_block_items1=[]
                    #        #new_block_items1.append(statement.iffalse)
                    #        new_block_items1.append(c_ast.Label(name=statement.iftrue.name, stmt=[]))
                    #        new_block_items1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
                    #        new_iffalse=c_ast.Compound(block_items=new_block_items1)
                    #        new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                    #        dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                    if type(statement.iffalse) is c_ast.FuncCall:
                            parameters=[]
                            if statement.iffalse.args is not None:
                                    for param in statement.iftrue.args.exprs:
                                            if type(param) is c_ast.ID:
                                                    parameters.append(param)
                                            elif type(param) is c_ast.Constant:
                                                    parameters.append(param)
                                            elif type(param) is c_ast.BinaryOp:
                                                    parameters.append(param)
                                    if statement.name.name=='__VERIFIER_assert':
                                            new_statement=None
                                            for parameter in parameters:
                                                    if new_statement is None:
                                                            assert_count=assert_count+1
                                                            new_statement= c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE'), rvalue=parameter)
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                    else:
                                                            assert_count=assert_count+1
                                                            new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE'), rvalue=parameter), right=new_statement)
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                            new_iffalse=new_statement
                                    elif statement.name.name=='__VERIFIER_assume':
                                            new_statement=None
                                            for parameter in parameters:
                                                    if new_statement is None:
                                                            assume_count=assume_count+1
                                                            new_statement= c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME'), rvalue=parameter)
                                                            new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                            dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                    else:
                                                            assume_count=assume_count+1
                                                            new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME'), rvalue=parameter), right=new_statement)
                                                            new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                            dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                            new_iffalse=new_statement
                                    elif statement.name.name=='__VERIFIER_error':
                                            fail_count=fail_count+1
                                            new_block_items1=[]
                                            #new_block_items1.append(c_ast.Label(name=statement.iftrue.name, stmt=[]))
                                            new_block_items1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
                                            new_iftrue=c_ast.Compound(block_items=new_block_items1)
                                            new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                            dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                    else:
                                        new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.Compound:
                    
                #degree=degree+1
                        
                new_block_items=getPreDefinedFun(statement.iffalse.block_items,degree,dec_map)
                        
                #degree=degree-1
                        
                new_iffalse=c_ast.Compound(block_items=new_block_items)
        else:
                if type(statement.iffalse) is c_ast.If:
                    new_iffalse=getPreDefinedFunIf(statement.iffalse,degree,dec_map)
                else:
                        new_iffalse=statement.iffalse
				
	if new_iftrue is not None and new_iffalse is None:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=None)
	elif new_iftrue is not None and new_iffalse is not None:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
	elif new_iffalse is not None and type(new_iffalse) is c_ast.Compound:
		return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
	elif new_iffalse is not None and type(new_iffalse) is c_ast.If:
		return new_iffalse
	else:
		return None


#
#Convert Initiation to assignments   
#

def construct_program(statements):
    update_statements=[]
    for statement in statements:
    	if type(statement) is c_ast.Decl:
    		if type(statement.type) is c_ast.ArrayDecl:
                        if statement.init is not None:
                        	program=''                        	
			        d_list=[]
			        a_list=[]
			        
			        if statement.type.dim is None:
			        	d_list_update,a_list_update=getDimesnion4Init(statement.init)
			        	for x1 in d_list_update:
			        		d_list.append('initial_value'+x1)
			        	for x1 in a_list_update:
			        		a_list.append(x1)
			        else:
			        	for x in range(0, int(statement.type.dim.value)):
			        		d_list.append('initial_value.exprs['+str(x)+']')
			                	a_list.append('['+str(x)+']') 
			        	d_list,a_list=getDimesnion(statement.type,d_list,a_list)
                        	initial_value=statement.init
                        	for x1 in range(0, len(d_list)):
                                        stmt_value=eval(d_list[x1])
                                        if type(stmt_value) is c_ast.Constant:
                                            program=program+statement.name+a_list[x1]+'='+str(eval(d_list[x1]+'.value'))+';'
                                        else:
                                            if type(stmt_value) is c_ast.UnaryOp: 
                                                program=program+statement.name+a_list[x1]+'= '+stmt_value.op+str(eval(d_list[x1]+'.expr.value'))+';'
                        	
                        	program='int main{'+program+'}'
                        	parser = c_parser.CParser()
                        	ast1 = parser.parse(program)
                        	function_body = ast1.ext[0].body                        	
                        	statement.init=None
                        	update_statements.append(statement)
                        	for new_statement in function_body.block_items:
                        		update_statements.append(new_statement)
                        else:
                        	update_statements.append(statement)
                        
                else:
                	update_statements.append(statement)
        else:
        	update_statements.append(statement)
    return update_statements


def getDimesnion(statement,d_list,a_list):
    if type(statement.type) is c_ast.ArrayDecl:
        d_list_update=[]
        a_list_update=[]
        for x1 in range(0, len(d_list)):
            for x2 in range(0, int(statement.type.dim.value)):
                d_list_update.append(d_list[x1]+'.exprs['+str(x2)+']')
                a_list_update.append(a_list[x1]+'['+str(x2)+']')
        return getDimesnion(statement.type,d_list_update,a_list_update)
    else:
        return d_list,a_list
        

def getDimesnion4Init(statement):
	d_list_update=[]
       	a_list_update=[]
	if type(statement) is c_ast.InitList:
		count=0
		for x in statement.exprs:
			if type(x) is c_ast.InitList:
				new_d_list_update,new_a_list_update=getDimesnion4Init(x)
				for x1 in new_d_list_update:
					d_list_update.append('.exprs['+str(count)+']'+x1)
				for x1 in new_a_list_update:
					a_list_update.append('['+str(count)+']'+x1)
			else:
				d_list_update.append('.exprs['+str(count)+']')
				a_list_update.append('['+str(count)+']')
			count=count+1
	return d_list_update,a_list_update

			


#
#Remove C and C++ comments
# 
#

text='a=a+1;// test test'

def comment_remover(text):
    text=text.replace('extern void __VERIFIER_error() __attribute__ ((__noreturn__));','')
    def replacer(match):
        s = match.group(0)
        if s.startswith('/'):
            return " " # note: a space and not an empty string
        else:
            return s
    pattern = regex.compile(
        r'//.*?$|/\*.*?\*/|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        regex.DOTALL | regex.MULTILINE
    )
    return regex.sub(pattern, replacer, text)
    

#
#text='#include "assert.h"'
#

def include_remover(text):
	status=False
	find=regex.compile(r'\#(\s+)include|\#include')
	group = find.search(text)
	if group is not None:
		status=True
	return status
    
#
#content='   /**   * Constructor, which takes the output of a toStringFull() and converts it back   * into an Id.  Should not normally be used.   *   * @param hex The hexadeciaml representation from the toStringFull()   *//*  public static Id build(char[] chars, int offset, int length) {    int[] array = new int[nlen];        for (int i=0; i<nlen; i++)       for (int j=0; j<8; j++)         array[nlen-1-i] =(array[nlen-1-i] << 4) | trans(chars[offset + 8*i + j]);        return build(array);  }  */int main() {  int offset, length, nlen = __VERIFIER_nondet_int();  i'
#
def comment_remover_file(content):
	new_content=content.replace('/*','\n/*').replace('*/','\n*/')        
	lines = new_content.splitlines()
	new_lines=[]
	for line in lines:
		if line is not None and include_remover( line )==False:
			new_lines.append(comment_remover(line))
	content = ''.join(new_lines)
	content=comment_remover_update(content)
	return content


def comment_remover_update(text):
	for x in regex.findall(r'("[^\n]*"(?!\\))|(//[^\n]*$|/(?!\\)\*[\s\S]*?\*(?!\\)/)',text,8):text=text.replace(x[1],'')
 	return text


#
#Pre-Processig of Pre-Processor
#content='#include "assert.h #define LIMIT 1000000 #define LIMIT1 1000000'
#

def preProcessorHandling(content):
    
	new_content=content.replace(';',';\n').replace('}','}\n').replace('#','\n#').replace('int','\nint').replace('void','\nvoid').replace('void','\nvoid').replace('extern','\nextern ').replace('unsigned','\nunsigned').replace('Char','\nChar')   
	lines = new_content.splitlines()
	new_lines=[]
	defineMap={}
	for line in lines:
		definematch = regex.match("#define\\s+(\\w+)\\s+(.*)",line)
		if definematch:
			#deal with define statements by saving it in a dict
			#definedict[match.group(1)] = definedict[match.group(2)]
			defineMap[definematch.group(1)]=str(simplify(definematch.group(2)))
			new_lines.append(line)
	for line in new_lines:
		content=content.replace(line,'')
	return content,defineMap







#text='_PROVE'

def isAssertion(text):
	status=False
	find=regex.compile(r'\_PROVE')
	#find=regex.compile(r'(.+?)PROVE1')
	group = find.search(text)
	if group is not None:
		status=True
	return status



#text='A1'

def isArrayFinal(text):
	status=False
	if text is not None and (text.endswith('1') or text.endswith('_')):
		status=True
	return status


#text="'\0'"

def isChar(text):
        simple_escape = r"""([a-zA-Z._~!=&\^\-\\?'"])"""
        decimal_escape = r"""(\d+)"""
        hex_escape = r"""(x[0-9a-fA-F]+)"""
        escape_sequence = r"""(\\("""+simple_escape+'|'+decimal_escape+'|'+hex_escape+'))'
        cconst_char = r"""([^'\\\n]|"""+escape_sequence+')'
        char_const = "'"+cconst_char+"'"
	status=False
	find=regex.compile(char_const)
        #find=regex.compile(r'([\'][0-9a-fA-F\\]*[\'])')
	#find=regex.compile(r'(.+?)PROVE1')
	group = find.search(text)
	if group is not None:
		status=True
	return status






def getAssertAssume(f,o,a,cm):
	new_o={}
	new_a=[]
	new_f={}
	assert_list=[]
	assume_list=[]
        key_value=None
        assert_key_map={}
	for x in f:
		if x.find('_PROVE')<0 and x.find('_ASSUME')<0:
			new_f[x]=f[x]
	for x in o:
		if x.find('_PROVE')>0:
                        key_value=x
                        if key_value is not None:
                            assert_key_map[key_value]=o[x]
        		assert_list.append(o[x])
                elif x.find('_ASSUME')>0:
                        if o[x][-1][0]=='ite':
                            if o[x][-1][-1]==['0']:
                                new_e=eval("['implies',"+str(o[x][-1][1])+","+str(o[x][-1][2])+"]")
                                o[x][-1]=new_e

        		assume_list.append(o[x])
                elif x.find('_FAILED')>0:
                    #assert_list.append(o[x])

                    key_value=x
                    new_assert=[]
                    arg_list=expr_args(o[x][1])
                    if len(arg_list)>0:
                        new_assert.append('R')
                        parameterlist=[]
                        for para in arg_list:
                            parameterlist.append(para[0])
                        new_assert.append(parameterlist)
                        new_assert.append(o[x][1])
                        new_assert.append('0')
                        assert_list.append(new_assert)
                        if key_value is not None:
                            assert_key_map[key_value]=new_assert
                    else:
                        new_assert.append('c1')
                        new_assert.append(['==',o[x][1],['0']])
                        assert_list.append(new_assert)
                        if key_value is not None:
                            assert_key_map[key_value]=new_assert
                    new_o[x]=o[x]
        	else:
        		new_o[x]=o[x]
        
        update_new_a=[]
        for x in a:
                if x[0]=='i1':
                    if x[3][0].find('array')>0:
                        map_var={}
                        getAll_PROVE_ASSUME(x[4],map_var)
                        if len(map_var.keys())>0:
                            for e_array in map_var.keys():
                                new_e1 = copy.deepcopy(x)
                                var_array=eval("['"+e_array+"']")
                                var_e1=eval("['_x1']")
                                new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                new_e1[4]=expr_replace(new_e1[4],var_e1,var_array)
                                new_e1[4]=simplify_ind_equation(new_e1[4],map_var.keys())
                                update_new_a.append(new_e1)
                            x[4]=x[4][3]
                            x[4]=getEndElse(x[4])
                            update_new_a.append(x)
                        else:
                            update_new_a.append(x)
                    else:
                        if x[3][1][0]=='_s1':
                            map_var={}
                            getAll_PROVE_ASSUME(x[4],map_var)
                            x[4]=simplify_ind_equation(x[4],map_var.keys())
                            update_new_a.append(x) 
                        else:
                            update_new_a.append(x) 
                else:
                   update_new_a.append(x) 
        
        
        
        
        
        
        
        #for x in a:
        
        for x in update_new_a:
        	if x[0]=='i1':
        		if x[3][0].find('array')>0:
        			if '_PROVE' in expr2string1(x[4]):
                                        key_value=x[3][1][0]
                                        
                                        #new_word,const_var=getPrimeAssert(a,cm,x[2],cm[x[2]])
                                        new_word,const_var=getPrimeAssert(update_new_a,cm,x[2],cm[x[2]])

                                        if new_word is not None and const_var is not None:
                                            new_word=copy.deepcopy(new_word)
                                            new_word[-1]=eval("['"+const_var+"']")
                                        #list_conditin=getConditions(o,a,new_word)

                                        list_conditin=getConditions(o,update_new_a,new_word)
                                        print 
                                        con_stmt=None
                                        if list_conditin is not None:
                                            con_stmt=constructAndOrlist(list_conditin,'and')
                                        new_x = copy.deepcopy(x)
                                        #print '----------------------'
                                        #print expr2string1(x[4])
                                        #print '----------------------'
                                        x[4]=assert_filter1(x[4])
                                        var_e1=eval("['_x1']")
                                        x[3][1]=var_e1
                                        x[4]=assert_filter(x[4],x[3],new_word,cm)
                                        #x[4][2]=assert_filter(x[4][2],x[3],new_word,cm)  
                                        if  con_stmt is not None:
                                            new_stmt=[]
                                            new_stmt.append('implies')
                                            new_stmt.append(con_stmt)
                                            #new_stmt.append(x[4][2])
                                            #print '----------------------'
                                            #print expr2string1(con_stmt)
                                            #print expr2string1(x[4])
                                            #print '----------------------'
                                            new_stmt.append(x[4])
                                            #x[4][2]=new_stmt
                                            x[4]=new_stmt
        				assert_list.append(x)
                                        if key_value is not None:
                                            assert_key_map[key_value]=x
        				new_w = copy.deepcopy(new_x)
        				new_w[4]=copy.deepcopy(new_x[4][3])
                                        #new_w[4]=copy.deepcopy(x[4])
        				#new_a.append(new_w)
        			elif '_ASSUME' in expr2string1(x[4]):
                                        #new_word,const_var=getPrimeAssert(a,cm,x[2],cm[x[2]])
                                        
                                        print '--------==============='
                                        print x[4]
                                        print '--------==============='
                                        
                                        new_word,const_var=getPrimeAssert(update_new_a,cm,x[2],cm[x[2]])
                                        if new_word is not None and const_var is not None:
                                            new_word=copy.deepcopy(new_word)
                                            new_word[-1]=eval("['"+const_var+"']")
                                        #list_conditin=getConditions(o,a,new_word)
                                        list_conditin=getConditions(o,update_new_a,new_word)
                                        con_stmt=None
                                        if list_conditin is not None:
                                            con_stmt=constructAndOrlist(list_conditin,'and')
                                        new_x = copy.deepcopy(x)
                                        x[4]=assert_filter1(x[4])
                                        var_e1=eval("['_x1']")
                                        x[3][1]=var_e1
                                        x[4]=assert_filter(x[4],x[3],new_word,cm)
                                        #x[4][2]=assert_filter(x[4][2],x[3],new_word,cm)  
                                        if  con_stmt is not None:
                                            new_stmt=[]
                                            new_stmt.append('implies')
                                            new_stmt.append(con_stmt)
                                            #new_stmt.append(x[4][2])
                                            new_stmt.append(x[4])
                                            #x[4][2]=new_stmt
                                            x[4]=new_stmt
        				assume_list.append(x)
        				new_w = copy.deepcopy(new_x)
        				new_w[4]=copy.deepcopy(new_x[4][3])
                                        #new_w[4]=copy.deepcopy(x[4])
        				#new_a.append(new_w)
        			else:
        				new_a.append(x)
        		
        		elif x[3][0].find('_PROVE')>0:
        			#for var in cm.keys():
        			#	x[4]=expr_sub(x[4],cm[var],var)
                                if x[4][0].find('_PROVE')<0:
                                    assert_list.append(x)
        		elif x[3][0].find('_ASSUME')>0:
                                print '--------===============2'
                                print x[4]
                                print '--------===============2'

                                assume_list.append(x)
        		else:
        			new_a.append(x)
        	elif x[0]=='i0':
        		if x[2][0].find('_PROVE')>0:
                                if x[3][0].find('_PROVE')<0:
                                    assert_list.append(x)
        		elif x[2][0].find('_ASSUME')>0:
                                print '--------===============3'
                                print x[4]
                                print '--------===============3'

                                assume_list.append(x)
        		else:
        			new_a.append(x)
        	else:
			new_a.append(x)
        return new_f,new_o,new_a,extractAssert(assert_list,cm),extractAssume(assume_list,cm),extractAssertMap(assert_key_map,cm)
        

def getPrimeAssert(a,cm,var,constant):
    pime_eq=None
    constant_var=None
    for x in a:
        if x[0]=='i1':
            if x[3][0].find('array')>0:
                if x[2]==var:
                    pime_eq=x[3]
                    constant_var=cm[x[2]]
                else :
                    if x[2] in constant:
                        pime_eq=x[3]
                        constant_var=cm[x[2]]
    return pime_eq,constant_var
            




        
def extractAssert(assert_list,cm):
	update_assert_stmts=[]
	for stmt in assert_list:
		if stmt[0]=='e':
			update_stmt=[]
			update_stmt.append('s0')
			update_stmt.append(stmt[2])
			key=wff2string1(update_stmt)
			for iteam in cm:
				key=key.replace(cm[iteam],iteam+'+1')
			flag=False
			for temp_stmt in assert_list:
				if temp_stmt[0]=='i1':
					lefthandstmt=expr2string1(temp_stmt[3])
					if 'and' not in str(key) and 'or' not in str(key):
						if simplify(key)==simplify(lefthandstmt):
							flag=True
			if flag==False:
				if update_stmt[0]=='s0':
					temp=expr2string1(update_stmt[1])
					if '_PROVE' not in temp:
						if '<' in temp or '>' in temp or '=' in temp:
							update_assert_stmts.append(update_stmt)
				else:
					update_assert_stmts.append(update_stmt)
		else:
			if stmt[0]=='s0':
				temp=expr2string1(stmt[1])
				if '<' in temp or '>' in temp or '=' in temp:
					update_assert_stmts.append(stmt)
			else:
				if stmt[0]=='i1':
					stmt_assert=[]
					stmt_assert.append('c1')
					#stmt_assert.append(stmt[4][2])
                                        if stmt[4][0]=='ite':
                                            stmt[4] = assert_filter1(stmt[4])
                                        stmt_assert.append(stmt[4])
					update_assert_stmts.append(stmt_assert)
				else:
					update_assert_stmts.append(stmt)
			
	return update_assert_stmts
    

def extractAssertMap(assert_list_map,cm):
	update_assert_stmts_map={}
	for key_val in assert_list_map.keys():
                stmt=assert_list_map[key_val]
		if stmt[0]=='e':
			update_stmt=[]
			update_stmt.append('s0')
			update_stmt.append(stmt[2])
			key=wff2string1(update_stmt)
			for iteam in cm:
				key=key.replace(cm[iteam],iteam+'+1')
			flag=False
			for temp_stmt in assert_list_map.keys():
				if temp_stmt[0]=='i1':
					lefthandstmt=expr2string1(temp_stmt[3])
					if 'and' not in str(key) and 'or' not in str(key):
						if simplify(key)==simplify(lefthandstmt):
							flag=True
			if flag==False:
				if update_stmt[0]=='s0':
					temp=expr2string1(update_stmt[1])
					if '_PROVE' not in temp:
						if '<' in temp or '>' in temp or '=' in temp:
							update_assert_stmts_map[key_val]=update_stmt
				else:
					update_assert_stmts_map[key_val]=update_stmt
		else:
			if stmt[0]=='s0':
				temp=expr2string1(stmt[1])
				if '<' in temp or '>' in temp or '=' in temp:
					update_assert_stmts_map[key_val]=stmt
			else:
				if stmt[0]=='i1':
					stmt_assert=[]
					stmt_assert.append('c1')
					#stmt_assert.append(stmt[4][2])
                                        if stmt[4][0]=='ite':
                                            stmt[4] = assert_filter1(stmt[4])
                                        stmt_assert.append(stmt[4])
					update_assert_stmts_map[key_val]=stmt_assert
				else:
					update_assert_stmts_map[key_val]=stmt	
	return update_assert_stmts_map



def extractAssume(assume_list,cm):
	update_assume_stmts=[]
	for stmt in assume_list:
		if stmt[0]=='e':
			update_stmt=[]
			update_stmt.append('s0')
			update_stmt.append(stmt[2])
			key=wff2string1(update_stmt)
			for iteam in cm:
				key=key.replace(cm[iteam],iteam+'+1')
			flag=False
			for temp_stmt in assume_list:
				if temp_stmt[0]=='i1':
					lefthandstmt=expr2string1(temp_stmt[3])
					if 'and' not in str(key) and 'or' not in str(key):
						if simplify(key)==simplify(lefthandstmt):
							flag=True
			if flag==False:
				if update_stmt[0]=='s0':
					temp=expr2string1(update_stmt[1])
					if '_PROVE' not in temp:
						if '<' in temp or '>' in temp or '=' in temp:
							update_assume_stmts.append(update_stmt)
				else:
					update_assume_stmts.append(update_stmt)
		else:
			if stmt[0]=='s0':
				temp=expr2string1(stmt[1])
				if '<' in temp or '>' in temp or '=' in temp:
					update_assume_stmts.append(stmt)
			else:

				if stmt[0]=='i1':
					stmt_assume=[]
					stmt_assume.append('c1')
					#stmt_assert.append(stmt[4][2])
                                        stmt_assume.append(stmt[4])
					update_assume_stmts.append(stmt_assume)
				else:
					update_assume_stmts.append(stmt)
			
	return update_assume_stmts






	


def assert_filter1(e):
    if e[:1]==['ite']:
        arg_list=expr_args(e)
        #print '---------@@@@@@@@@@@@@@@1'
        #print arg_list[0]
        #print '---------@@@@@@@@@@@@@@@1'
        new_cond=conditionFilter(arg_list[0])
        #print '---------@@@@@@@@@@@@@@@2'
        #print new_cond
        #print '---------@@@@@@@@@@@@@@@2'
        if new_cond==None:
            return arg_list[1]
        else:
            new_stmt1=assert_filter1(arg_list[1])
            new_cond1=conditionFilter(arg_list[1])
            new_stmt2=assert_filter1(arg_list[2])
            new_cond2=conditionFilter(arg_list[2])
            if new_cond==None:
                return e
            else:
                if isArrayFunction(new_cond1[0])==True and '_PROVE' in new_cond1[1][0]:
                    if isArrayFunction(new_cond2[0])==True and '_PROVE' in new_cond2[1][0]:
                        return new_cond 
                    else:
                        new_stmt=[]
                        new_stmt.append('implies')
                        new_stmt.append(expr_complement(new_cond))
                        new_stmt.append(new_cond2)
                        return new_stmt
                else:
                    if '_PROVE' in new_cond1[0]:
                        new_stmt=[]
                        new_stmt.append('implies')
                        new_stmt.append(expr_complement(new_cond))
                        new_stmt.append(new_cond2)
                        return new_stmt
                    else:
                        new_stmt=[]
                        new_stmt.append('implies')
                        new_stmt.append(new_cond)
                        new_stmt.append(new_cond1)
                        return new_stmt
                
                



def getEndElse(e):
    if e[:1]==['ite']:
        arg_list=expr_args(e)
        if arg_list[2][:1]==['ite']:
            return getEndElse(arg_list[2])
        else:
            return arg_list[2]
    else:
        return e


def getAll_PROVE_ASSUME(e,map_var):
    arg_list=expr_args(e)
    op=expr_op(e)
    if len(arg_list)==0:
        if op.find('_PROVE')>0 or op.find('_ASSUME')>0:
            map_var[op]=op
    elif op=='ite':
        for x in arg_list:
            getAll_PROVE_ASSUME(x,map_var)
    elif op=='and':
        for x in arg_list:
            getAll_PROVE_ASSUME(x,map_var)
    else:
        for x in arg_list:
            getAll_PROVE_ASSUME(x,map_var)




def conditionFilter(e):
    if e[0]=='and':
        arg_list=expr_args(e)
        temp=[]
        for i in range(1,len(arg_list)):
            if conditionFilter(arg_list[i]) is not None:
                temp.append(arg_list[i])
        if len(temp)==0:
            return None
        elif len(temp)==1:
            return  temp[0]
        else:
            return e2[0]+temp
    elif e[0]=='=':
        if '_x1' in e[1][0]:
            return None
    elif e[0]=='ite':
        arg_list=expr_args(e)
        new_cond=conditionFilter(arg_list[1])
        if new_cond==None:
            return None
        else:
            return new_cond
    else:
        return e







def assert_filter(e,e1,e2,cm): #e,e1,e2: expr
	if isArrayFunction(e[:1][0])==True:
		if e1[0][1]==e[:1][0][1]:
			temp=[]
			count=0
                        arg_list=expr_args(e)
        		for x in expr_args(e2):
                            if count<len(expr_args(e2))-1:
                                temp.append(arg_list[count])
                            else:
                                temp.append(x)
                            count=count+1
			return e2[:1]+temp
		else:
			return e
	else:
		return e[:1]+list(assert_filter(x,e1,e2,cm) for x in expr_args(e))


def getConditions(o,a,e):
    for x in o:
        list_condition=[]
        get_conditions(o[x],e,list_condition)
        if len(list_condition) >0:
            return list_condition
    for x in a:
        if x[0]=='i0':
            list_condition=[]
            get_conditions(x[3],e,list_condition)
            if len(list_condition) >0:
                return list_condition
    return None

        
def get_conditions(e,e_el,list_condition):
        if e[:1]==['ite']:
        	temp=[]
        	count=0
        	cond=None
        	for x in expr_args(e):
                        get_conditions(x,e_el,list_condition)
        		if count==0:
        			cond=x
        		elif count==1:
        			if x==e_el and cond is not None:
                                    list_condition.append(cond) 
        		elif count==2:
                                if x==e_el and cond is not None:
                                    con=[]
                                    con.append('not')
                                    con.append(cond)
                                    list_condition.append(cond) 
        		count=count+1
        else:
        	for x in expr_args(e):
                    get_conditions(x,e_el,list_condition)       


def constructAndOrlist(e_array,operator):
	if len(e_array)>2:
                cond=[]
                cond.append(operator)
                cond.append(e_array[0])
                cond.append(constructAndOrlist(e_array[1:],operator))
		return cond
	if len(e_array)==2:
                cond=[]
                cond.append(operator)
                cond.append(e_array[0])
                cond.append(constructAndOrlist(e_array[1:],operator))
		return cond
	else:
		return e_array[0]


#
#Module to handle pointer 
#


def handlingPointer(statements):
	update_statements=[]
	for statement in statements:
    		if type(statement) is c_ast.Decl:
    			dimesnsion=0
    			d_map={}
    			flag_pointer=False
    			type_name,dimesnsion,flag_pointer=getTypeNameDimension(statement,dimesnsion,flag_pointer)
    			if flag_pointer==True:
    				getDimension4mMalloc(statement,d_map)
       				temp_program=type_name+' '+statement.name
    				for x in range(0, len(d_map.keys())):
    					if 'parameter'+str(x) in d_map.keys():
    						temp_program+='['+d_map['parameter'+str(x)]+']'
    				temp_program+=';'
    				parser = c_parser.CParser()
    				print '@@@@@@@'
    				print temp_program
    				print '@@@@@@@'
    				ast = parser.parse(temp_program)
    				update_statements.append(ast.ext[0])
    			else:
    				update_statements.append(statement)
    		else:
    			update_statements.append(statement)
    	return update_statements



def getTypeNameDimension(statement,dimesnsion,flag_pointer):
	if type(statement.type) is c_ast.PtrDecl:
		dimesnsion=dimesnsion+1;
		flag_pointer=True
		return getTypeNameDimension(statement.type,dimesnsion,flag_pointer)
	elif type(statement.type) is c_ast.ArrayDecl:
		dimesnsion=dimesnsion+1;
		return getTypeNameDimension(statement.type,dimesnsion,flag_pointer)
	else:
		if type(statement.type) is c_ast.TypeDecl:
			if type(statement.type.type) is c_ast.IdentifierType:
				if len(statement.type.type.names)>1:
					return statement.type.type.names[1],dimesnsion,flag_pointer
				else:
					return statement.type.type.names[0],dimesnsion,flag_pointer
				

def getDimension4mMalloc(statement,d_map):
	for child in statement.children():
		if type(child[1]) is c_ast.FuncCall:
			for param in child[1].args.exprs:
				extractDimesion(param,d_map)
		else:
			getDimension4mMalloc(child[1],d_map)


def extractDimesion(param,d_map):
	if type(param) is c_ast.BinaryOp:
		if type(param.left) is c_ast.ID and  type(param.right) is c_ast.UnaryOp:
			d_map['parameter'+str(len(d_map.keys()))]=param.left.name
		elif type(param.right) is c_ast.ID and  type(param.left) is c_ast.UnaryOp:
			d_map['parameter'+str(len(d_map.keys()))]=param.right.name
		elif type(param.left) is c_ast.ID and  type(param.right) is c_ast.BinaryOp:
			d_map['parameter'+str(len(d_map.keys()))]=param.left.name
		elif type(param.right) is c_ast.ID and  type(param.left) is c_ast.BinaryOp:
			d_map['parameter'+str(len(d_map.keys()))]=param.right.name
		elif type(param.right) is c_ast.BinaryOp and  type(param.left) is c_ast.BinaryOp:
			extractDimesion(param.right,d_map)
			extractDimesion(param.left,d_map)


def pointerToArray(statement):
	if type(statement) is c_ast.Decl:
    		dimesnsion=0
    		d_map={}
    		flag_pointer=False
    		type_name,dimesnsion,flag_pointer=getTypeNameDimension(statement,dimesnsion,flag_pointer)
    		if flag_pointer==True:
    			getDimension4mMalloc(statement,d_map)
       			temp_program=type_name+' '+statement.name
    			for x in range(0, len(d_map.keys())):
    				if 'parameter'+str(x) in d_map.keys():
    					temp_program+='['+d_map['parameter'+str(x)]+']'
    			temp_program+=';'
    			parser = c_parser.CParser()
    			ast = parser.parse(temp_program)
    			return ast.ext[0]
    		else:
    			return statement
  			



def arrangeEmptyStatement(statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.If:
            stmt=arrangeEmptyStatementIf(statement)
            if stmt is not None:
            	update_statements.append(stmt)
        elif type(statement) is c_ast.While:
            if type(statement.stmt) is c_ast.EmptyStatement:
                update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=[])))
            elif statement.stmt.block_items is not None:
            	stmt=arrangeEmptyStatement(statement.stmt.block_items)
            	if stmt is not None:
                	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=stmt)))
                else:
                	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=[])))
            else:
                update_statements.append(statement)
        else:
            update_statements.append(statement)
    return update_statements
           

    


def arrangeEmptyStatementIf(statement):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.EmptyStatement:
            if type(statement.iffalse) is c_ast.Compound:
                return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=statement.iffalse, iffalse=None)
            else:
                return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=statement.iffalse, iffalse=None)
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=arrangeEmptyStatement(statement.iftrue.block_items)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
            
        if type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                new_block_items=arrangeEmptyStatement(statement.iffalse.block_items)
                new_iffalse=c_ast.Compound(block_items=new_block_items)
            else:
                new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.If:
            new_iffalse=arrangeEmptyStatementIf(statement.iffalse)
        else:
            new_iffalse=statement.iffalse
            
    if new_iftrue is not None and new_iffalse is None:
        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=None)
    elif new_iftrue is not None and new_iffalse is not None:
        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
    elif new_iffalse is not None and type(new_iffalse) is c_ast.Compound:
	return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
    elif new_iffalse is not None and type(new_iffalse) is c_ast.If:
	return new_iffalse
    else:
	return None







#filename='gototest.c'

def remove_empty_statement(filename):
    content=None
    with open(filename) as f:
        content = f.read()
    content=content.replace('\r','')
    text = r""" """+content
    parser = c_parser.CParser()
    ast = parser.parse(text)
    #print ast.show()
    function_decl = ast.ext[0].decl
    function_param = function_decl
    function_body = ast.ext[0].body
    statements=function_body.block_items
    
    statements=programTransformation(function_body)
    
    
    body_comp = c_ast.Compound(block_items=statements)
    generator = c_generator.CGenerator()   
    print(generator.visit(body_comp))

    


	
	
	
	
def removeMultipleLabel(statements,label,labelMap):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.Goto:
                        if statement.name==label:
                        	new_label=label+str(len(labelMap.keys())+1)
                        	labelMap[new_label]=new_label
                        	update_statements.append(c_ast.Goto(name=new_label)) 
                        else:
                        	update_statements.append(statement) 
                elif type(statement) is c_ast.If:
                	update_statements.append(removeMultipleLabelIf(statement,label,labelMap))
                elif type(statement) is c_ast.While:
                	if statement.stmt.block_items is not None:
                		update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=removeMultipleLabel(statement.stmt.block_items,label,labelMap))))
			elif type(statement.stmt) is c_ast.Goto:
				if statement.stmt.name==label:
			        	new_label=label+str(len(labelMap.keys())+1)
			        	labelMap[new_label]=new_label
			        	new_block=[]
			        	new_block.append(c_ast.Goto(name=new_label))
			        	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
			        else:
			        	new_block=[]
			        	new_block.append(statement.stmt)
			        	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
			else:
                        	update_statements.append(statement)	
		                	
		else:
                	update_statements.append(statement)
        return update_statements




def removeMultipleLabelIf(statement,label,labelMap):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Goto:
        	if statement.iftrue.name==label:
	        	new_label=label+str(len(labelMap.keys())+1)
	        	labelMap[new_label]=new_label
                        new_iftrue=c_ast.Goto(name=new_label)
                else:
                   	new_iftrue=statement.iftrue
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=removeMultipleLabel(statement.iftrue.block_items,label,labelMap)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Goto:
		if statement.iffalse.name==label:
			new_label=label+str(len(labelMap.keys())+1)
			labelMap[new_label]=new_label
	                new_iffalse=c_ast.Goto(name=new_label)
	        else:
	        	new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.Compound:
		if statement.iffalse.block_items is not None:
	        	new_block_items=removeMultipleLabel(statement.iffalse.block_items,label,labelMap)
	                new_iffalse=c_ast.Compound(block_items=new_block_items)
	        else:
	                new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.If:
		new_iffalse=removeMultipleLabelIf(statement.iffalse,label,labelMap)
	else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)


    



def addMultipleLabel(statements,label,labelMap):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.Label:
                        if statement.name==label:
                        	for item in labelMap.keys():
                        		update_statements.append(c_ast.Label(name=item, stmt=None))
                        	if statement.stmt is not None:
                        		update_statements.append(statement.stmt)
                        else:
                        	update_statements.append(statement) 
                elif type(statement) is c_ast.If:
                	update_statements.append(addMultipleLabelIf(statement,label,labelMap))
                elif type(statement) is c_ast.While:
                	if statement.stmt.block_items is not None:
                		update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=addMultipleLabel(statement.stmt.block_items,label,labelMap))))
			elif type(statement.stmt) is c_ast.Goto:
				if statement.stmt.name==label:
					new_block=[]
					for item in labelMap.keys():
						new_block.append(c_ast.Label(name=item, stmt=None))
					if statement.stmt is not None:
						new_block.append(statement.stmt)
			        	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
			        else:
			        	new_block=[]
			        	new_block.append(statement.stmt)
			        	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
			else:
                        	update_statements.append(statement)	
		                	
		else:
                	update_statements.append(statement)
        return update_statements




def addMultipleLabelIf(statement,label,labelMap):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Label:
        	if statement.iftrue.name==label:
			new_block=[]
			for item in labelMap.keys():
				new_block.append(c_ast.Label(name=item, stmt=None))
			if statement.iftrue.stmt is not None:
				new_block.append(statement.stmt)
			new_iftrue=c_ast.Compound(block_items=new_block)
                else:
                   	new_iftrue=statement.iftrue
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=addMultipleLabel(statement.iftrue.block_items,label,labelMap)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Label:
		if statement.iffalse.name==label:
			new_block=[]
			for item in labelMap.keys():
				new_block.append(c_ast.Label(name=item, stmt=None))
			if statement.iffalse.stmt is not None:
				new_block.append(statement.stmt)
			new_iffalse=c_ast.Compound(block_items=new_block)
	        else:
	        	new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.Compound:
		if statement.iffalse.block_items is not None:
	        	new_block_items=addMultipleLabel(statement.iffalse.block_items,label,labelMap)
	                new_iffalse=c_ast.Compound(block_items=new_block_items)
	        else:
	                new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.If:
		new_iffalse=addMultipleLabelIf(statement.iffalse,label,labelMap)
	else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)







def removeOrphanLabel(statements,label):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.Label:
                        if statement.name!=label:
				update_statements.append(statement) 
                elif type(statement) is c_ast.If:
                	update_statements.append(removeOrphanLabelIf(statement,label))
                elif type(statement) is c_ast.While:
                	if statement.stmt.block_items is not None:
                		update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=removeOrphanLabel(statement.stmt.block_items,label))))
			elif type(statement.stmt) is c_ast.Goto:
				if statement.stmt.name!=label:
					new_block=[]
			        	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
			        else:
			        	new_block=[]
			        	new_block.append(statement.stmt)
			        	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
			else:
                        	update_statements.append(statement)	
		                	
		else:
                	update_statements.append(statement)
        return update_statements




def removeOrphanLabelIf(statement,label):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Label:
        	if statement.iftrue.name==label:
			new_block=[]
			if statement.iftrue.stmt is not None:
				new_block.append(statement.stmt)
			new_iftrue=c_ast.Compound(block_items=new_block)
                else:
                   	new_iftrue=statement.iftrue
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=removeOrphanLabel(statement.iftrue.block_items,label)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Label:
		if statement.iffalse.name==label:
			new_block=[]
			if statement.iffalse.stmt is not None:
				new_block.append(statement.stmt)
			new_iffalse=c_ast.Compound(block_items=new_block)
	        else:
	        	new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.Compound:
		if statement.iffalse.block_items is not None:
	        	new_block_items=removeOrphanLabel(statement.iffalse.block_items,label)
	                new_iffalse=c_ast.Compound(block_items=new_block_items)
	        else:
	                new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.If:
		new_iffalse=removeOrphanLabelIf(statement.iffalse,label)
	else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
    
   
 
dummyCount=0
    
def functionToAssignment(statements,functionMap):
 	global dummyCount
 	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.FuncCall:
			if  '__VERIFIER' not in statement.name.name:
				dummyCount=dummyCount+1
				update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_'+str(dummyCount)+'DUMMY'), rvalue=statement))
			else:
				update_statements.append(statement)
		elif type(statement) is c_ast.If:
	                	update_statements.append(functionToAssignmentIf(statement,functionMap))
	        elif type(statement) is c_ast.While:
	        	if type(statement.stmt) is c_ast.Compound:
	                	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=functionToAssignment(statement.stmt.block_items,functionMap))))
			else:
				if statement.stmt is not None:
					if type(statement) is c_ast.EmptyStatement:
						new_block=[]
						update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))	
					else:
						new_block=[]
						new_block.append(statement.stmt)
						update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=functionToAssignment(new_block,functionMap))))
				else:
			        	update_statements.append(statement)
		else:
                	update_statements.append(statement)
        return update_statements
                	
                	
                	
def functionToAssignmentIf(statement,functionMap):
      new_iftrue=None
      new_iffalse=None
      global dummyCount
      if type(statement) is c_ast.If:
          if type(statement.iftrue) is c_ast.Compound:
	  	new_block_items=functionToAssignment(statement.iftrue.block_items,functionMap)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
          elif type(statement.iftrue) is c_ast.FuncCall:
          	if  '__VERIFIER' not in statement.iftrue.name.name:
	  		dummyCount=dummyCount+1
	  		new_iftrue=c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_'+str(dummyCount)+'DUMMY'), rvalue=statement.iftrue)
	  	else:
	  		new_iftrue=statement.iftrue
          else:
               new_iftrue=statement.iftrue
              
          if type(statement.iffalse) is c_ast.Compound:
              if statement.iffalse.block_items is not None:
                  new_block_items=functionToAssignment(statement.iffalse.block_items,functionMap)
                  new_iffalse=c_ast.Compound(block_items=new_block_items)
              else:
                  new_iffalse=statement.iffalse
          elif type(statement.iffalse) is c_ast.FuncCall:
          	if  '__VERIFIER' not in statement.iffalse.name.name:
	      		dummyCount=dummyCount+1
	      		new_iffalse=c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_'+str(dummyCount)+'DUMMY'), rvalue=statement.iffalse)
	      	else:
	      		new_iffalse=statement.iffalse
          elif type(statement.iffalse) is c_ast.If:
              new_iffalse=functionToAssignmentIf(statement.iffalse,functionMap)
          else:
              new_iffalse=statement.iffalse
      return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
      
      


def getDummyFunction(f,o,a,cm):
	new_o={}
	for eq in o.keys():
		if o[eq][0]=='e':
			lefthandstmt=expr2string1(o[eq][1])
			if 'DUMMY' in lefthandstmt:
				new_eq=[]
				new_eq.append('s0')
				new_eq.append(o[eq][2])
				new_o[eq]=new_eq
			else:
				new_o[eq]=o[eq]
		else:
			new_o[eq]=o[eq]
	#return f,new_o,a,cm
	return f,o,a,cm


#def update__VERIFIER_nondet(f,o,a,cm):
#    for eq in a:
#        if eq[0]=='i1':
#            var_cstr_map={}
#            lhs=expr2z3(eq[3],var_cstr_map)
#            eq[4]=update__VERIFIER_nondet_stmt(eq[4],var_cstr_map)
#    return f,o,a,cm




def update__VERIFIER_nondet_stmt(e,var_map):
    args=expr_args(e)
    if '__VERIFIER_nondet' in e[0] and len(args)==0:
        if e[0] in var_map.keys():
            VC=var_map[e[0]]
            VC=VC+1
            key=e[0]
            var_map[key]=VC
            e[0] = e[0]+str(VC)
            return e
        else:
            key=e[0]
            var_map[key]=2
            e[0] = e[0]+str(2)
            return e
    else:
        return e[:1]+list(update__VERIFIER_nondet_stmt(x,var_map) for x in expr_args(e))




#Get all typedefination

typedef_map={}

def getAllTypeDef(ast):
	global typedef_map
	typedef_map={}
	generator = c_generator.CGenerator()
	for element in ast.ext:
		if type(element) is c_ast.Typedef: 
			if type(element.type.type) is c_ast.Struct:
				program_temp="struct "+ast.ext[0].type.type.name+";"
				temp_ast = parser.parse(program_temp)
				typedef_map[element.name]=generator.visit(temp_ast.ext[0])
			else:
				typedef_map[element.name]=generator.visit(element.type)	
				
				
				
				
				
def updateTypeDef(statement):
	global typedef_map
	parser = c_parser.CParser()
	pointer=None
	array=None
	if type(statement) is c_ast.Decl:
		if type(statement.type) is c_ast.PtrDecl:
			degree=0
    			type_stmt,degree,structType=getArrayDetails(statement,degree)
    			#if degree==1:
    			#	if type_stmt in typedef_map.keys():
    			#		type_stmt=typedef_map[type_stmt]
    			#	program_temp=type_stmt+' '+ statement.name
    			#	pointer=statement.name
    			#else:
    			#    	if type_stmt in typedef_map.keys():
			#    		type_stmt=typedef_map[type_stmt]
			#    	program_temp=type_stmt+' '+ statement.name
			#    	for x in range(0,degree):
    			#		program_temp+='[]'
    			#	pointer=statement.name
    			# commented on 16/11/2016
    			if type_stmt in typedef_map.keys():
				type_stmt=typedef_map[type_stmt]
			program_temp=type_stmt+' '+ statement.name
			for x in range(0,degree):
			    	program_temp+='[]'
    			pointer=statement.name
    			
    			program_temp+=';'
    			temp_ast = parser.parse(program_temp)
    			return temp_ast.ext[0],pointer,array
    		elif type(statement.type) is c_ast.ArrayDecl:
			degree=0
                        dimensionmap={}
    			type_stmt,degree,structType=getArrayDetails(statement,degree,dimensionmap)
			if type_stmt in typedef_map.keys():
				type_stmt=typedef_map[type_stmt]
			program_temp=type_stmt+' '+statement.name
			for x in range(0,degree):
				program_temp+='[]'
			program_temp+=';'
			array=statement.name
			temp_ast = parser.parse(program_temp)
    			#return temp_ast.ext[0],pointer,array
                        return statement,pointer,array
    		else:
    			type_stmt= statement.type.type.names[0]
    			if type_stmt in typedef_map.keys():
				type_stmt=typedef_map[type_stmt]
			program_temp=type_stmt+' '+ statement.name
			generator = c_generator.CGenerator()
			if statement.init is not None:
				value=generator.visit(statement.init)
				if value is not None:
					program_temp+='='+value
			program_temp+=';'
			temp_ast = parser.parse(program_temp)
    			return temp_ast.ext[0],pointer,array
	return None,pointer,array


def pointerHandlingParameter(ast):

	if type(ast) is c_ast.FuncDef:
		pointer_list=[]
		array_list=[]
		new_stmts=[]
		new_parameters=''
		generator = c_generator.CGenerator()
		parser = c_parser.CParser()
		if ast.decl.type.args is not None:
			parameters=ast.decl.type.args.params
			if parameters is not None:
				for parameter in parameters:
					if new_parameters=='':
						type_decl,pointer,array=updateTypeDef(parameter)
						if pointer is not None:
							pointer_list.append(pointer)
						if array is not None:
							array_list.append(array)
						new_parameters=generator.visit(type_decl)
					else:
						type_decl,pointer,array=updateTypeDef(parameter)
						if pointer is not None:
							pointer_list.append(pointer)
						if array is not None:
							array_list.append(array)
						new_parameters+=','+generator.visit(type_decl)
		return_type=generator.visit(ast.decl.type.type)
		function_name=ast.decl.name
    		new_fun=return_type+' '+ function_name+'('+ new_parameters +'){}'
    		new_fun=parser.parse(new_fun)
    		return new_fun.ext[0].decl,pointer_list,array_list
	else:
		return None,[],[]


def pointerHandlingDecl(function_body,pointer_list,array_list):
	update_statements=[]
	statements=function_body.block_items
	for statement in statements:
		if type(statement) is c_ast.Decl:
			new_statement,pointer,array=updateTypeDef(statement)
			new_stmt=None
			if pointer is not None:
				if statement.init is not None:
					if type(statement.init) is c_ast.InitList:
						new_statement=None
						new_stmt=None
					else:
						new_stmt=c_ast.Assignment(op='=', lvalue=c_ast.ID(name=pointer), rvalue=ref2function(statement.init))
				pointer_list.append(pointer)
			if array is not None:
				array_list.append(array)
			if new_statement is not None:
				update_statements.append(new_statement)
				if new_stmt is not None:
					update_statements.append(new_stmt)
			else:
				update_statements.append(statement)
		else:
			update_statements.append(statement)
	fun_body=c_ast.Compound(block_items=update_statements)
	return fun_body
	




def pointerHandling(statements,pointer_list,array_list):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.Decl:
			new_statement,pointer,array=updateTypeDef(statement)
			if pointer is not None:
				pointer_list.append(pointer)
			if array is not None:
				array_list.append(array)
			if new_statement is not None:
				update_statements.append(new_statement)
			else:
				update_statements.append(statement)
		elif type(statement) is c_ast.If:
			update_statements.append(pointerHandlingIf(statement,pointer_list,array_list))
		elif type(statement) is c_ast.While:
			if statement.stmt.block_items is not None:
                		update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=pointerHandling(statement.stmt.block_items,pointer_list,array_list))))
		elif type(statement) is c_ast.Assignment:
			update_statements.append(c_ast.Assignment(op=statement.op,lvalue=defref2function(statement.lvalue,pointer_list,array_list),rvalue=defref2function(statement.rvalue,pointer_list,array_list)))
		else:
			update_statements.append(statement)
	return update_statements
	


	
def pointerHandlingIf(statement,pointer_list,array_list):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Assignment:
        	new_iftrue=c_ast.Assignment(op=statement.iftrue.op,lvalue=defref2function(statement.iftrue.lvalue,pointer_list,array_list),rvalue=defref2function(statement.iftrue.rvalue,pointer_list,array_list))
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=pointerHandling(statement.iftrue.block_items,pointer_list,array_list)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Assignment:
		new_iftrue=c_ast.Assignment(op=statement.iffalse.op,lvalue=defref2function(statement.iffalse.lvalue,pointer_list,array_list),rvalue=defref2function(statement.iffalse.rvalue,pointer_list,array_list))
	elif type(statement.iffalse) is c_ast.Compound:
		if statement.iffalse.block_items is not None:
	        	new_block_items=pointerHandling(statement.iffalse.block_items,pointer_list,array_list)
	                new_iffalse=c_ast.Compound(block_items=new_block_items)
	        else:
	                new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.If:
		new_iffalse=pointerHandlingIf(statement.iffalse,pointer_list,array_list)
	else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
    
    
#def defref2function(statement,pointer_list,array_list):
#	if type(statement) is c_ast.UnaryOp:
#		parameter=[]
#		if statement.op=='*' and statement.expr.name in pointer_list:
#			parameter.append(statement.expr)
#			return c_ast.FuncCall(name=c_ast.ID(name='_data'), args=c_ast.ExprList(exprs=parameter))
#		elif statement.op=='*' and statement.expr.name in array_list:
#
#			return c_ast.ArrayRef(name=statement.expr, subscript=c_ast.Constant(type='int', value='0'))
#			#return c_ast.FuncCall(name=c_ast.ID(name='_data'), args=c_ast.ExprList(exprs=parameter))
#		elif statement.op=='&' and statement.expr.name in pointer_list:
#			parameter.append(statement.expr)
#			return c_ast.FuncCall(name=c_ast.ID(name='_address'), args=c_ast.ExprList(exprs=parameter))
#		else:
#			return c_ast.UnaryOp(op=statement.op, expr=defref2function(statement.expr,pointer_list,array_list))
#	elif type(statement) is c_ast.BinaryOp:
#		return c_ast.BinaryOp(op=statement.op,left=defref2function(statement.left,pointer_list,array_list),right=defref2function(statement.right,pointer_list,array_list))
#	else:
#		return statement





def defref2function(statement,pointer_list,array_list):
	if type(statement) is c_ast.UnaryOp:
		parameter=[]
		if statement.op=='*':
			stmt=defref2array(statement,pointer_list,array_list)
			if stmt is not None:
				return stmt
			else:
				return statement
		elif statement.op=='&' and statement.expr.name in pointer_list:
			parameter.append(statement.expr)
			return c_ast.FuncCall(name=c_ast.ID(name='_address'), args=c_ast.ExprList(exprs=parameter))
		else:
			return c_ast.UnaryOp(op=statement.op, expr=defref2function(statement.expr,pointer_list,array_list))
	elif type(statement) is c_ast.BinaryOp:
		return c_ast.BinaryOp(op=statement.op,left=defref2function(statement.left,pointer_list,array_list),right=defref2function(statement.right,pointer_list,array_list))
	else:
		return statement





		
		
def ref2function(statement):
	if type(statement) is c_ast.UnaryOp:
		parameter=[]
		if statement.op=='&':
			parameter.append(statement.expr)
			return c_ast.FuncCall(name=c_ast.ID(name='_address'), args=c_ast.ExprList(exprs=parameter))
		else:
			return c_ast.UnaryOp(op=statement.op, expr=ref2function(statement.expr))
	elif type(statement) is c_ast.BinaryOp:
		return c_ast.BinaryOp(op=statement.op,left=ref2function(statement.left),right=ref2function(statement.right))
	else:
		return statement


def defref2array(statement,pointer_list,array_list):
	if statement.op=='*' and type(statement.expr) is c_ast.UnaryOp :
		stmt=defref2array(statement.expr,pointer_list,array_list)
		if stmt is not None:
			return c_ast.ArrayRef(name=stmt, subscript=c_ast.Constant(type='int', value='0'))
		else:
			return None
	elif statement.op=='*' and type(statement.expr) is c_ast.BinaryOp :
            if type(statement.expr.left) is c_ast.ID and type(statement.expr.right) is c_ast.UnaryOp:
                stmt=defref2array(statement.expr.right,pointer_list,array_list)
                if stmt is not None:
			return c_ast.ArrayRef(name=stmt, subscript=statement.expr.left)
		else:
			return None
            elif type(statement.expr.right) is c_ast.ID and type(statement.expr.left) is c_ast.UnaryOp:
                stmt=defref2array(statement.expr.left,pointer_list,array_list)
                if stmt is not None:
			return c_ast.ArrayRef(name=stmt, subscript=statement.expr.right)
		else:
			return None
            elif type(statement.expr.left) is c_ast.Constant and type(statement.expr.right) is c_ast.UnaryOp:
                stmt=defref2array(statement.expr.right,pointer_list,array_list)
                if stmt is not None:
			return c_ast.ArrayRef(name=stmt, subscript=statement.expr.left)
		else:
			return None
            elif type(statement.expr.right) is c_ast.Constant and type(statement.expr.left) is c_ast.UnaryOp:
                stmt=defref2array(statement.expr.left,pointer_list,array_list)
                if stmt is not None:
			return c_ast.ArrayRef(name=stmt, subscript=statement.expr.right)
		else:
			return None
            elif type(statement.expr.left) is c_ast.ID and type(statement.expr.right) is c_ast.ID and statement.expr.right.name in pointer_list:
                return c_ast.ArrayRef(name=statement.expr.right, subscript=statement.expr.left)
            elif type(statement.expr.right) is c_ast.ID and type(statement.expr.left) is c_ast.ID and statement.expr.left.name in pointer_list:
                return c_ast.ArrayRef(name=statement.expr.left, subscript=statement.expr.right)
            elif type(statement.expr.left) is c_ast.ID and type(statement.expr.right) is c_ast.ID and statement.expr.right.name in array_list:
                return c_ast.ArrayRef(name=statement.expr.right, subscript=statement.expr.left)
            elif type(statement.expr.right) is c_ast.ID and type(statement.expr.left) is c_ast.ID and statement.expr.left.name in array_list:
                return c_ast.ArrayRef(name=statement.expr.left, subscript=statement.expr.right)
            #if type(statement.expr.left) is c_ast.ID and statement.expr.left.name in pointer_list:
             #   return c_ast.ArrayRef(name=stmt, subscript=statement.expr.right)
            #elif type(statement.expr.left) is c_ast.ID and statement.expr.left.name in array_list:
             #   return c_ast.ArrayRef(name=stmt, subscript=statement.expr.right)
            #if type(statement.expr.right) is c_ast.ID and statement.expr.right.name in pointer_list:
             #   return c_ast.ArrayRef(name=stmt, subscript=statement.expr.left)
            #elif type(statement.expr.right) is c_ast.ID and statement.expr.right.name in array_list:
             #   return c_ast.ArrayRef(name=stmt, subscript=statement.expr.left)
	elif statement.op=='*' and statement.expr.name in pointer_list:
		return c_ast.ArrayRef(name=statement.expr, subscript=c_ast.Constant(type='int', value='0'))
	elif statement.op=='*' and statement.expr.name in array_list:
		return c_ast.ArrayRef(name=statement.expr, subscript=c_ast.Constant(type='int', value='0'))
	
	else:
		return None





def updateResize(statements):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.Decl and type(statement.type) is c_ast.ArrayDecl and '_PROVE' not in statement.name and '_ASSUME' not in statement.name:
                        degree=0
                        dimensionmap={}
                        data_type,degree,structType=getArrayDetails(statement,degree,dimensionmap)
                        if degree==1:
                            update_statements.append(statement)
                                                    
                        else:
                            update_statements.append(statement)
                else:
                    update_statements.append(statement)
	return update_statements


def updateAddInitArray(statements):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.Decl and type(statement.type) is c_ast.ArrayDecl and '_PROVE' not in statement.name and '_ASSUME' not in statement.name:
                        degree=0
                        dimensionmap={}
                        data_type,degree,structType=getArrayDetails(statement,degree,dimensionmap)
                        
                        print data_type
                        
                        if degree==1 and len(dimensionmap)==1:
                            para_list=[]
                            para_list.append(c_ast.ID(name=statement.name))
                            if is_number(dimensionmap.values()[0]):
                                para_list.append(c_ast.Constant(type='int', value=dimensionmap.values()[0]))
                            else:
                                var_str=dimensionmap.values()[0]
                                if is_number(var_str[-1]):
                                    var_str = var_str[0:-1]
                                para_list.append(c_ast.ID(name=var_str))
                            update_statements.append(statement)
                            if data_type=='int':
                                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name='init_array'), args=c_ast.ExprList(exprs=para_list)))
                            elif data_type=='char':
                                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name='init_array_char'), args=c_ast.ExprList(exprs=para_list)))
                                
                            
                        else:
                            update_statements.append(statement)
                else:
                    update_statements.append(statement)
	return update_statements






def updateDeclartionFromWhile(statements):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.While:
			if statement.stmt.block_items is not None:
                                temp_update_statements,temp_decl_statements=updateDeclartionFromBlock(statement.stmt.block_items)
                                update_statements=update_statements+temp_decl_statements
				update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=temp_update_statements)))
                                	
			else:
				update_statements.append(statement)	
                elif type(statement) is c_ast.If:
                    temp_update_statement,temp_decl_statements=updateDeclartionFromIf(statement)
                    update_statements=update_statements+temp_decl_statements
                    update_statements.append(temp_update_statement)
                else:
                    update_statements.append(statement)
	return update_statements




def updateDeclartionFromBlock(statements):
    update_statements=[]
    decl_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            if statement.init is not None:
                new_init=copy.deepcopy(statement.init)
                if type(statement.name) is str:
                    update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=statement.name),rvalue=new_init))
                else:
                    update_statements.append(c_ast.Assignment(op='=',lvalue=statement.name,rvalue=new_init))
                statement.init=None
                decl_statements.append(statement)
            else:
                decl_statements.append(statement)
        elif type(statement) is c_ast.While:
            if statement.stmt.block_items is not None:
                temp_update_statements,temp_decl_statements=updateDeclartionFromBlock(statement.stmt.block_items)
                update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=temp_update_statements)))
                decl_statements=decl_statements+temp_decl_statements
            else:
                update_statements.append(c_ast.While(cond=statement.cond,stmt=statement.stmt))
        elif type(statement) is c_ast.If:
            temp_update_statement,temp_decl_statements=updateDeclartionFromIf(statement)
            update_statements.append(temp_update_statement)
            decl_statements=decl_statements+temp_decl_statements
        else:
            update_statements.append(statement)
    return update_statements,decl_statements



def updateDeclartionFromIf(statement):
    update_statements=[]
    decl_statements=[]
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                temp_update_statements,temp_decl_statements=updateDeclartionFromBlock(statement.iftrue.block_items)
                new_iftrue=c_ast.Compound(block_items=temp_update_statements)
                decl_statements=decl_statements+temp_decl_statements
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
	if type(statement.iffalse) is c_ast.Compound:
		if statement.iffalse.block_items is not None:
	        	temp_update_statements,temp_decl_statements=updateDeclartionFromBlock(statement.iffalse.block_items)
	                new_iffalse=c_ast.Compound(block_items=temp_update_statements)
                        decl_statements=decl_statements+temp_decl_statements
	        else:
	                new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.If:
                temp_update_statements,temp_decl_statements=updateDeclartionFromIf(statement.iffalse)
		new_iffalse=temp_update_statements
                decl_statements=decl_statements+temp_decl_statements
	else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse),decl_statements

















def change_var_name(statements):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.Decl:
			if type(statement.type) is c_ast.ArrayDecl:
                                if checkingArrayName(statement.type)==True:
                                    statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=renameArrayName(statement.type), init=statement.init, bitsize=statement.bitsize)
                                statement.type.dim=change_var_name_stmt(statement.type.dim)
			else:
                            if type(statement.type) is not c_ast.PtrDecl:
				if is_number(statement.type.declname[-1])==True:
					statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type), init=statement.init, bitsize=statement.bitsize)
				elif statement.type.declname in ['S','Q','N','in','is','limit']:
					statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type), init=statement.init, bitsize=statement.bitsize)
			update_statements.append(statement)
		elif type(statement) is c_ast.If:
			update_statements.append(change_var_nameIf(statement))
		elif type(statement) is c_ast.While:
                        if type(statement.stmt) is c_ast.Assignment:
                                new_block=[]
                                new_block.append(statement.stmt)
                                update_statements.append(c_ast.While(cond=change_var_name_stmt(statement.cond),stmt=c_ast.Compound(block_items=change_var_name(new_block))))
                        elif type(statement.stmt) is c_ast.UnaryOp:
                                new_block=[]
                                new_block.append(statement.stmt)
                                update_statements.append(c_ast.While(cond=change_var_name_stmt(statement.cond),stmt=c_ast.Compound(block_items=change_var_name(new_block))))
			elif type(statement.stmt) is c_ast.EmptyStatement:
                                statement
                                #update_statements.append(statement)
			elif statement.stmt.block_items is not None:
				update_statements.append(c_ast.While(cond=change_var_name_stmt(statement.cond),stmt=c_ast.Compound(block_items=change_var_name(statement.stmt.block_items))))	
			else:
				update_statements.append(c_ast.While(cond=change_var_name_stmt(statement.cond),stmt=c_ast.Compound(block_items=statement.stmt.block_items)))	
		elif type(statement) is c_ast.Assignment:
			update_statements.append(c_ast.Assignment(op=statement.op,lvalue=change_var_name_stmt(statement.lvalue),rvalue=change_var_name_stmt(statement.rvalue)))
		elif type(statement) is c_ast.Return:
                    statement.expr=change_var_name_stmt(statement.expr)
                    update_statements.append(statement)
                elif type(statement) is c_ast.FuncCall:
                    if statement.args is not None:
                        new_expr=[]
                        for exp in statement.args.exprs:
                            new_expr.append(change_var_name_stmt(exp))
                        update_statements.append(c_ast.FuncCall(name=statement.name,args=c_ast.ExprList(exprs=new_expr)))
                    else:
                        update_statements.append(statement)
		else:
			update_statements.append(statement)
	return update_statements
	


	
def change_var_nameIf(statement):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Assignment:
        	new_iftrue=c_ast.Assignment(op=statement.iftrue.op,lvalue=change_var_name_stmt(statement.iftrue.lvalue),rvalue=change_var_name_stmt(statement.iftrue.rvalue))
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=change_var_name(statement.iftrue.block_items)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
    
        if type(statement.iffalse) is c_ast.Assignment:
		new_iffalse=c_ast.Assignment(op=statement.iffalse.op,lvalue=change_var_name_stmt(statement.iffalse.lvalue),rvalue=change_var_name_stmt(statement.iffalse.rvalue))
	elif type(statement.iffalse) is c_ast.Compound:
		if statement.iffalse.block_items is not None:
	        	new_block_items=change_var_name(statement.iffalse.block_items)
	                new_iffalse=c_ast.Compound(block_items=new_block_items)
	        else:
	                new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.If:
		new_iffalse=change_var_nameIf(statement.iffalse)
	else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond= change_var_name_stmt(statement.cond), iftrue=new_iftrue, iffalse=new_iffalse)


def change_var_name_stmt(statement):
	if type(statement) is c_ast.BinaryOp:
		if type(statement.left) is c_ast.ID:
			if is_number(statement.left.name[-1])==True:
				stmt_left=c_ast.ID(name=statement.left.name+'_var')
			elif statement.left.name in ['S','Q','N','in','is','limit']:
				stmt_left=c_ast.ID(name=statement.left.name+'_var')
			else:
				stmt_left=change_var_name_stmt(statement.left)
		else:
			stmt_left=change_var_name_stmt(statement.left)
		
		if type(statement.right) is c_ast.ID:
			if is_number(statement.right.name[-1])==True:
				stmt_right=c_ast.ID(name=statement.right.name+'_var')
			elif statement.right.name in ['S','Q','N','in','is','limit']:
				stmt_right=c_ast.ID(name=statement.right.name+'_var')
			else:
				stmt_right=change_var_name_stmt(statement.right)
		else:
			stmt_right=change_var_name_stmt(statement.right)
		return c_ast.BinaryOp(op=statement.op, left=stmt_left, right=stmt_right)
	elif type(statement) is c_ast.UnaryOp:
		if type(statement.expr) is c_ast.ID:
			if is_number(statement.expr.name[-1])==True:
				stmt=c_ast.ID(name=statement.expr.name+'_var')
			elif statement.expr.name in ['S','Q','N','in','is','limit']:
				stmt=c_ast.ID(name=statement.expr.name+'_var')
			else:
				stmt=change_var_name_stmt(statement.expr)
		else:
			stmt=change_var_name_stmt(statement.expr)
		return c_ast.UnaryOp(op=statement.op, expr=stmt)
	elif type(statement) is c_ast.ID:
		if is_number(statement.name[-1])==True:
			return c_ast.ID(name=statement.name+'_var')
		elif statement.name in ['S','Q','N','in','is','limit']:
			return c_ast.ID(name=statement.name+'_var')
		else:
                        return statement
        elif type(statement) is c_ast.FuncCall:
            if statement.args is not None:
                new_expr=[]
                for exp in statement.args.exprs:
                    new_expr.append(change_var_name_stmt(exp))
                return c_ast.FuncCall(name=statement.name,args=c_ast.ExprList(exprs=new_expr))
            else:
                return statement
	
	else:
		if type(statement) is c_ast.ArrayRef:
                    return renameArrayName(statement)
                    #if checkingArrayName(statement)==True:
                    #    return renameArrayName(statement)
                    #else:
                    #    return statement
                elif type(statement) is c_ast.StructRef:
                    return c_ast.StructRef(name=change_var_name_stmt(statement.name),type=change_var_name_stmt(statement.type),field=statement.field)
                else:
                    return statement


def change_var_name_stmt1(statement,count,var_map,in_var_map,fun_count,all_var_int):
	if type(statement) is c_ast.BinaryOp:
		if type(statement.left) is c_ast.ID:
			if statement.left.name in var_map.keys() or statement.left.name in in_var_map.keys():
                                if statement.left.name in all_var_int:
                                    stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
                                else:
                                    stmt_left=statement.left
			else:
				stmt_left=statement.left
		else:
			stmt_left=change_var_name_stmt1(statement.left)
            
		if type(tatement.right) is c_ast.ID:
			if statement.right.name in var_map.keys() or statement.right.name in in_var_map.keys():
                                if statement.right.name in all_var_int:
                                    stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.right.name)
                                else:
                                    stmt_right=statement.right
			else:
				stmt_right=statement.right
		else:
			stmt_right=change_var_name_stmt1(statement.right)
            
		return c_ast.BinaryOp(op=statement.op, left=stmt_left, right=stmt_right)
	elif type(statement) is c_ast.UnaryOp:
		if type(statement.expr) is c_ast.ID:
			if statement.expr.name in var_map.keys() or statement.expr.name in in_var_map.keys():
                                if statement.expr.name in all_var_int:
                                    stmt=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.expr.name)
                                else:
                                    stmt=statement.expr
                        else:
				stmt=statement.expr
		else:
			stmt=change_var_name_stmt1(statement.expr)
		return c_ast.UnaryOp(op=statement.op, expr=stmt)
	elif type(statement) is c_ast.ID:
		if statement.name in var_map.keys() or statement.name in in_var_map.keys():
			if statement.name in all_var_int:
                            return c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name)
                        else:
                            return statement
                            
		else:
                        return statement
        elif type(statement) is c_ast.FuncCall:
            if statement.args is not None:
                new_expr=[]
                for exp in statement.args.exprs:
                    new_expr.append(change_var_name_stmt1(exp))
                return c_ast.FuncCall(name=statement.name,args=c_ast.ExprList(exprs=new_expr))
            else:
                return statement
	
	else:
		if type(statement) is c_ast.ArrayRef:
                    return renameArrayName1(statement)
                    #if checkingArrayName(statement)==True:
                    #    return renameArrayName(statement)
                    #else:
                    #    return statement
                else:
                    return statement









def change_var_name_decl(statement):
    if type(statement) is c_ast.Decl:
        if type(statement.type) is c_ast.ArrayDecl:
            if is_number(statement.name[-1])==True:
                statement.name=statement.name+'_var'
                renameArrayName(statement.type)
            elif statement.name in ['S','Q','N','in','is','limit']:
                statement.name=statement.name+'_var'
                renameArrayName(statement.type)
            else:
                statement.type.dim=change_var_name_stmt(statement.type.dim)
        else:
            if is_number(statement.type.declname[-1])==True:
                statement.name=statement.name+'_var' 
                statement.type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type)
            elif statement.type.declname in ['S','Q','N','in','is','limit']:
                statement.name=statement.name+'_var'  
                statement.type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type)
        return statement
    return statement









count__VERIFIER_nondet=0


def organize__VERIFIER_nondet(statements):
        global count__VERIFIER_nondet
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.Decl:
			if type(statement.type) is c_ast.ArrayDecl:
                                update_statements.append(statement)
			else:
                                init_values=None
                                if statement.init is not None:
                                    init_values=copy.deepcopy(statement.init)
                                statement=c_ast.Decl(name=statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.TypeDecl(declname=statement.type.declname, quals=statement.type.quals, type=statement.type.type), init=None, bitsize=statement.bitsize)
                                update_statements.append(statement)
                                if init_values is not None:
                                        update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=statement.name),rvalue=organize__VERIFIER_nondet_stmt(init_values)))
		elif type(statement) is c_ast.If:
			update_statements.append(organize__VERIFIER_nondetIf(statement))
		elif type(statement) is c_ast.While:
			if statement.stmt.block_items is not None:
				update_statements.append(c_ast.While(cond=organize__VERIFIER_nondet_stmt(statement.cond),stmt=c_ast.Compound(block_items=organize__VERIFIER_nondet(statement.stmt.block_items))))	
			else:
				update_statements.append(c_ast.While(cond=organize__VERIFIER_nondet_stmt(statement.cond),stmt=c_ast.Compound(block_items=statement.stmt.block_items)))	
		elif type(statement) is c_ast.Assignment:
			update_statements.append(c_ast.Assignment(op=statement.op,lvalue=organize__VERIFIER_nondet_stmt(statement.lvalue),rvalue=organize__VERIFIER_nondet_stmt(statement.rvalue)))
		else:
			update_statements.append(statement)
	return update_statements
	


	
def organize__VERIFIER_nondetIf(statement):
    global count__VERIFIER_nondet
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Assignment:
        	new_iftrue=c_ast.Assignment(op=statement.iftrue.op,lvalue=organize__VERIFIER_nondet_stmt(statement.iftrue.lvalue),rvalue=organize__VERIFIER_nondet_stmt(statement.iftrue.rvalue))
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=change_var_name(statement.iftrue.block_items)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Assignment:
		new_iftrue=c_ast.Assignment(op=statement.iffalse.op,lvalue=organize__VERIFIER_nondet_stmt(statement.iffalse.lvalue),rvalue=organize__VERIFIER_nondet_stmt(statement.iffalse.rvalue))
	elif type(statement.iffalse) is c_ast.Compound:
		if statement.iffalse.block_items is not None:
	        	new_block_items=change_var_name(statement.iffalse.block_items)
	                new_iffalse=c_ast.Compound(block_items=new_block_items)
	        else:
	                new_iffalse=statement.iffalse
	elif type(statement.iffalse) is c_ast.If:
		new_iffalse=organize__VERIFIER_nondetIf(statement.iffalse)
	else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond= organize__VERIFIER_nondet_stmt(statement.cond), iftrue=new_iftrue, iffalse=new_iffalse)


def organize__VERIFIER_nondet_stmt(statement):
        global count__VERIFIER_nondet
	if type(statement) is c_ast.BinaryOp:
		if type(statement.left) is c_ast.ID:
			stmt_left=organize__VERIFIER_nondet_stmt(statement.left)
		else:
			stmt_left=organize__VERIFIER_nondet_stmt(statement.left)
		
		if type(statement.right) is c_ast.ID:
			stmt_right=organize__VERIFIER_nondet_stmt(statement.right)
		else:
			stmt_right=organize__VERIFIER_nondet_stmt(statement.right)
		return c_ast.BinaryOp(op=statement.op, left=stmt_left, right=stmt_right)
	elif type(statement) is c_ast.UnaryOp:
		if type(statement.expr) is c_ast.ID:
			stmt=organize__VERIFIER_nondet_stmt(statement.expr)
		else:
			stmt=organize__VERIFIER_nondet_stmt(statement.expr)
		return c_ast.UnaryOp(op=statement.op, expr=stmt)
	elif type(statement) is c_ast.ID:
		if '__VERIFIER_nondet' in statement.name:
                        count__VERIFIER_nondet=count__VERIFIER_nondet+1
			return c_ast.ID(name=statement.name+str(count__VERIFIER_nondet))
		else:
			return statement
	elif type(statement) is c_ast.FuncCall:
                if '__VERIFIER_nondet' in statement.name.name:
                    count__VERIFIER_nondet=count__VERIFIER_nondet+1
                    statement.name=c_ast.ID(name=statement.name.name+str(count__VERIFIER_nondet))
                return statement
	else:
                return statement








#filename='veris.c_NetBSD-libc__loop_true-unreach-call_true-termination.c'
filename='sv-benchmarks/loops/trex04_true-unreach-call_false-termination1.i'
def changeTest(filename):
    content=None
    global new_variable
    with open(filename) as f:
        content = f.read()
    content=content.replace('\r','')
    text = r""" """+content
    parser = c_parser.CParser()
    ast = parser.parse(text)
    stmts=ast.ext[0].body.block_items
    statements=change_var_name(stmts)
    body=c_ast.Compound(block_items=statements)
    #body.show()
    generator = c_generator.CGenerator()
    print generator.visit(body)
    
		

#Add External Variables


def addAllExtVariables(statements,externalvariables,localvarmap):
	update_statements=[]
	for var in externalvariables.keys():
		variable=externalvariables[var]
		temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=[variable.getVariableType()])), init=None, bitsize=None)
		update_statements.append(temp)
		localvarmap[var]=variable
		if variable.getInitialvalue() is not None:
			update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var), rvalue=c_ast.Constant(type=variable.getVariableType(), value=variable.getInitialvalue())))
	for element in statements:
		update_statements.append(element)
	return update_statements,localvarmap
	

def getWitness(filename,functionname,resultfunction):
	witnessXml=[]
	#witnessXml1='<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'+'<graphml xmlns="http:\/\/graphml.graphdrawing.org\/xmlns" xmlns:xsi="http:\/\/www.w3.org\/2001\/XMLSchema-instance">'+'\t<key attr.name="isEntryNode" attr.type="boolean" for="node" id="entry">\n'+'\t\t<default>false<\/default>\n'+'\t<\/key>\n'+'\t<key attr.name="witness-type" attr.type="string" for="graph" id="witness-type"\/>\n'+'\t<key attr.name="sourcecodelang" attr.type="string" for="graph" id="sourcecodelang"\/>'+'\t<key attr.name="producer" attr.type="string" for="graph" id="producer"\/>\n'+'\t<key attr.name="specification" attr.type="string" for="graph" id="specification"\/>\n'+'\t<key attr.name="programFile" attr.type="string" for="graph" id="programfile"\/>\n'+'\t<key attr.name="programHash" attr.type="string" for="graph" id="programhash"\/>\n'+'\t<key attr.name="memoryModel" attr.type="string" for="graph" id="memorymodel"\/>\n'+'\t<key attr.name="architecture" attr.type="string" for="graph" id="architecture"\/>\n'+'\t<key attr.name="startline" attr.type="int" for="edge" id="startline"\/>\n'+'\t<key attr.name="assumption" attr.type="string" for="edge" id="assumption"\/>\n'+'\t<key attr.name="assumption.scope" attr.type="string" for="edge" id="assumption.scope"\/>\n'+'\t<key attr.name="assumption.resultfunction" attr.type="string" for="edge" id="assumption.resultfunction"\/>\n'+'\t<graph edgedefault="directed">\n'+'\t\t<data key="witness-type">violation_witness<\/data>\n'+'\t\t<data key="sourcecodelang">C<\/data>\n'+'\t\t<data key="producer">CPAchecker 1.6.1-svn<\/data>\n'+'\t\t<data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_assume)) )<\/data>\n'+'\t\t<data key="programfile">'+filename+'<\/data>\n'+'\t\t<data key="programhash">1776ed2413d170f227b69d8c79ba700d31db6f75<\/data>\n'+'\t\t<data key="memorymodel">precise<\/data>\n'+'\t\t<data key="memorymodel">precise<\/data>\n'+'\t\t<node id="entry">\n'+'\t\t\t<data key="entry">true<\/data>\n'+'\t\t</node>\n'+'\t\t<node id="error">\n'+'\t\t\t<data key="violation">true<\/data>\n'+'\t\t<\/node>\n'+'\t\t<edge source="entry" target="error">\n'+'\t\t\t<data key="startline">5<\/data>\n'+'\t\t\t<data key="assumption">\\result == 0<\/data>\n'
	#witnessXml1='<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'+'<graphml xmlns="http:\/\/graphml.graphdrawing.org\/xmlns" xmlns:xsi="http:\/\/www.w3.org\/2001\/XMLSchema-instance">'+'\t<key attr.name="isEntryNode" attr.type="boolean" for="node" id="entry">\n'+'\t\t<default>false<\/default>\n'+'\t<\/key>\n'+'\t<key attr.name="witness-type" attr.type="string" for="graph" id="witness-type"\/>\n'+'\t<key attr.name="sourcecodelang" attr.type="string" for="graph" id="sourcecodelang"\/>'+'\t<key attr.name="producer" attr.type="string" for="graph" id="producer"\/>\n'+'\t<key attr.name="specification" attr.type="string" for="graph" id="specification"\/>\n'+'\t<key attr.name="programFile" attr.type="string" for="graph" id="programfile"\/>\n'+'\t<key attr.name="programHash" attr.type="string" for="graph" id="programhash"\/>\n'+'\t<key attr.name="memoryModel" attr.type="string" for="graph" id="memorymodel"\/>\n'+'\t<key attr.name="architecture" attr.type="string" for="graph" id="architecture"\/>\n'+'\t<key attr.name="startline" attr.type="int" for="edge" id="startline"\/>\n'+'\t<key attr.name="assumption" attr.type="string" for="edge" id="assumption"\/>\n'+'\t<key attr.name="assumption.scope" attr.type="string" for="edge" id="assumption.scope"\/>\n'+'\t<key attr.name="assumption.resultfunction" attr.type="string" for="edge" id="assumption.resultfunction"\/>\n'+'\t<graph edgedefault="directed">\n'+'\t\t<data key="witness-type">violation_witness<\/data>\n'+'\t\t<data key="sourcecodelang">C<\/data>\n'+'\t\t<data key="producer">CPAchecker 1.6.1-svn<\/data>\n'+'\t\t<data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_assume)) )<\/data>\n'+'\t\t<data key="programfile">'+filename+'<\/data>\n'+'\t\t<data key="programhash">1776ed2413d170f227b69d8c79ba700d31db6f75<\/data>\n'+'\t\t<data key="memorymodel">precise<\/data>\n'+'\t\t<data key="memorymodel">precise<\/data>\n'+'\t\t<node id="entry">\n'+'\t\t\t<data key="entry">true<\/data>\n'+'\t\t</node>\n'+'\t\t<node id="error">\n'+'\t\t\t<data key="violation">true<\/data>\n'+'\t\t<\/node>\n'+'\t\t<edge source="entry" target="error">\n'
	witnessXml1='<?xml version="1.0" encoding="UTF-8" standalone="no"?>'+'<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><key attr.name="isEntryNode" attr.type="boolean" for="node" id="entry"><default>false</default></key><key attr.name="isViolationNode" attr.type="boolean" for="node" id="violation"><default>false</default></key><key attr.name="witness-type" attr.type="string" for="graph" id="witness-type"/><key attr.name="sourcecodelang" attr.type="string" for="graph" id="sourcecodelang"/><key attr.name="producer" attr.type="string" for="graph" id="producer"/><key attr.name="specification" attr.type="string" for="graph" id="specification"/><key attr.name="programFile" attr.type="string" for="graph" id="programfile"/><key attr.name="programHash" attr.type="string" for="graph" id="programhash"/><key attr.name="memoryModel" attr.type="string" for="graph" id="memorymodel"/><key attr.name="architecture" attr.type="string" for="graph" id="architecture"/><key attr.name="startline" attr.type="int" for="edge" id="startline"/><key attr.name="assumption" attr.type="string" for="edge" id="assumption"/><key attr.name="assumption.scope" attr.type="string" for="edge" id="assumption.scope"/><key attr.name="assumption.resultfunction" attr.type="string" for="edge" id="assumption.resultfunction"/><graph edgedefault="directed"><data key="witness-type">violation_witness</data><data key="sourcecodelang">C</data><data key="producer">CPAchecker 1.6.1-svn</data><data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )</data><data key="programfile">'+filename+'</data><data key="programhash">1776ed2413d170f227b69d8c79ba700d31db6f75</data><data key="memorymodel">precise</data><data key="architecture">32bit</data><node id="entry"><data key="entry">true</data></node><node id="error"><data key="violation">true</data></node><edge source="entry" target="error">'
	witnessXml.append(witnessXml1)
	#witnessXml2='\t\t\t<data key="assumption.scope">'+functionname+'<\/data>\n'+'\t\t\t<data key="assumption.resultfunction">'+resultfunction+'<\/data>\n'+'\t\t</edge>\n'+'\t</graph>\n'+'</graphml>\n'
	witnessXml2='<data key="assumption.scope">'+functionname+'</data><data key="assumption.resultfunction">'+resultfunction+'</data></edge></graph></graphml>'
	witnessXml.append(witnessXml2)
	witnessXml.append(functionname)
	witnessXml.append(filename)
	return witnessXml
	
def checkingArrayName(statement):
    if type(statement) is c_ast.ArrayDecl:
        if type(statement.type) is c_ast.TypeDecl:
            if is_number(statement.type.declname[-1])==True:
                #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                return True
            elif statement.type.declname in ['S','Q','N','in','is']:
                #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                return True
            else:
                #if type(statement.dim) is c_ast.ID:
                #    if is_number(statement.dim.name[-1])==True:
                #        #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                #        return True
                #    elif statement.dim.name in ['S','Q','N','in','is']:
                #        #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                #        return True
                #    else:
                return False
        elif type(statement.type) is c_ast.ArrayDecl:
            return checkingArrayName(statement.type)
        else:
            return False
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ID:
            if is_number(statement.name.name[-1])==True:
                return True
            elif statement.name.name in ['S','Q','N','in','is']:
                return True
            else:
                return False
        elif type(statement.name) is c_ast.ArrayRef:
            return checkingArrayName(statement.name)
        else:
            return False





def checkingArrayIndexName(statement):
    if type(statement) is c_ast.ArrayDecl:
        if type(statement.type) is c_ast.TypeDecl:
            if is_number(statement.type.declname[-1])==True:
                #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                return True
            elif statement.type.declname in ['S','Q','N','in','is']:
                #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                return True
            else:
                if type(statement.dim) is c_ast.ID:
                    if is_number(statement.dim.name[-1])==True:
                        #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                        return True
                    elif statement.dim.name in ['S','Q','N','in','is']:
                        #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                        return True
                    else:
                        return False
        elif type(statement.type) is c_ast.ArrayDecl:
            return checkingArrayIndexName(statement.type)
        else:
            return False
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ID:
            if type(statement.subscript) is c_ast.ID:
                if is_number(statement.subscript.name[-1])==True:
                    return True
                elif statement.subscript in ['S','Q','N','in','is']:
                    return True
                elif type(statement.subscript) is c_ast.BinaryOp:
                    if checkingArrayNameStmt(statement.subscript)==True:
                        return True
                elif type(statement.subscript) is c_ast.UnaryOp:
                    if checkingArrayNameStmt(statement.subscript.expr)==True:
                        return True
        elif type(statement.name) is c_ast.ArrayRef:
            return checkingArrayIndexName(statement.name)
        else:
            return False





def checkingArrayNameStmt(statement):
    if type(statement) is c_ast.BinaryOp:
        if checkingArrayNameStmt(statement.left)==True:
            return True
        if checkingArrayNameStmt(statement.right)==True:
            return True
    elif type(statement) is c_ast.UnaryOp:
        if checkingArrayNameStmt(statement.expr)==True:
            return True
    elif type(statement) is c_ast.ID:
        if is_number(statement.name[-1])==True:
            return True
        elif statement.name in ['S','Q','N','in','is']:
            return True
    else:
        return True


            
def renameArrayName(statement):
    if type(statement) is c_ast.ArrayDecl:
        if type(statement.type) is c_ast.TypeDecl:
            if is_number(statement.type.declname[-1])==True:
                statement=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type),dim=change_var_name_stmt(statement.dim), dim_quals=statement.dim_quals)
                return statement
            elif statement.type.declname in ['S','Q','N','in','is']:
                statement=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type),dim=change_var_name_stmt(statement.dim), dim_quals=statement.dim_quals)
                return statement
            else:
                return statement
        elif type(statement.type) is c_ast.ArrayDecl:
            statement=c_ast.ArrayDecl(type=renameArrayName(statement.type),dim=change_var_name_stmt(statement.type.dim), dim_quals=statement.type.dim_quals)
            return statement
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ID:
            if is_number(statement.name.name[-1])==True:
                return c_ast.ArrayRef(name=c_ast.ID(name=statement.name.name+'_var'),subscript=change_var_name_stmt(statement.subscript))
            elif statement.name.name in ['S','Q','N','in','is']:
                return c_ast.ArrayRef(name=c_ast.ID(name=statement.name.name+'_var'),subscript=change_var_name_stmt(statement.subscript))
            else:
                return c_ast.ArrayRef(name=c_ast.ID(name=statement.name.name),subscript=change_var_name_stmt(statement.subscript))
        elif type(statement.name) is c_ast.ArrayRef:
            return c_ast.ArrayRef(name=renameArrayName(statement.name),subscript=change_var_name_stmt(statement.subscript))
        


def renameArrayName1(statement,count,var_map,in_var_map,fun_count,all_var_int):
    if type(statement) is c_ast.ArrayDecl:
        if type(statement.type) is c_ast.TypeDecl:
            if statement.name in var_map.keys() or statement.name in in_var_map.keys():
                return c_ast.Decl(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=renameArrayName1(statement.type,count,var_map,in_var_map,fun_count,all_var_int), init=statement.init, bitsize=statement.bitsize)
            else:
                return c_ast.Decl(name=statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=renameArrayName1(statement.type,count,var_map,in_var_map,fun_count,all_var_int), init=statement.init, bitsize=statement.bitsize)
        elif type(statement.type) is c_ast.ArrayDecl:
            statement=c_ast.ArrayDecl(type=renameArrayName1(statement.type,count,var_map,in_var_map,fun_count,all_var_int),dim=change_var_name_stmt1(statement.type.dim,count,var_map,in_var_map,fun_count,all_var_int), dim_quals=statement.type.dim_quals)
            return statement
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ID:
            if statement.name in var_map.keys() or statement.name in in_var_map.keys():
                return c_ast.ArrayRef(name=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name.name),subscript=change_var_name_stmt1(statement.subscript,count,var_map,in_var_map,fun_count,all_var_int))
            else:
                return c_ast.ArrayRef(name=statement.name,subscript=change_var_name_stmt1(statement.subscript,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.name) is c_ast.ArrayRef:
            return c_ast.ArrayRef(name=renameArrayName1(statement.name,count,var_map,in_var_map,fun_count,all_var_int),subscript=change_var_name_stmt1(statement.subscript,count,var_map,in_var_map,fun_count,all_var_int))

 
 
 #statement='ForAll(x,ForAll(y,x==y))'
 
def createWFF(statement):
	updated_statement='int main(){'+statement+';}'
	parser = c_parser.CParser()
        ast1 = parser.parse(updated_statement)
	function_body = ast1.ext[0].body 
 	expression=organizeStatementToObject_C(function_body.block_items)
 	primeStatement(expression)
 	allvariable={}
 	str_program=programToinductiveDefination_C(expression , allvariable)
 	program=eval(str_program+']')
 	return expr2string1(program[2])

 
 
#filename='sv-benchmarks/locks/test_locks_5_true-unreach-call_false-termination1.c'
 
def remove_goto_test(filename):
     #filename='goto17.c'
     #filename='goto9.c'
     content=None
     with open(filename) as f:
         content = f.read()
     content=content.replace('\r','')
     text = r""" """+content
     parser = c_parser.CParser()
     ast = parser.parse(text)     
     function_decl = ast.ext[0].decl
     function_param = function_decl
     function_body = ast.ext[0].body
     statements=function_body.block_items
     print '#################RamRam1'
     body_comp = c_ast.Compound(block_items=statements)
     generator = c_generator.CGenerator()   
     print(generator.visit(body_comp))
     print '#################RamRam1'
 

 

   
def syntaxTranslate_Java(statements):
	update_statements=[]
   	for statement in statements:
   		if type(statement) is plyj.model.Unary:
   			if statement.sign=='x++':
   				update_statements.append(plyj.model.Assignment(operator='=',lhs=syntaxTranslateStmt_Java(statement.expression),  rhs=plyj.model.Additive(operator='+',lhs=syntaxTranslateStmt_Java(statement.expression), rhs=plyj.model.Literal(value='1'))))
   			elif statement.sign=='++x':
   				update_statements.append(plyj.model.Assignment(operator='=',lhs=syntaxTranslateStmt_Java(statement.expression),  rhs=plyj.model.Additive(operator='+',lhs=syntaxTranslateStmt_Java(statement.expression), rhs=plyj.model.Literal(value='1'))))
   			elif statement.sign=='x--':
			   	update_statements.append(plyj.model.Assignment(operator='=',lhs=syntaxTranslateStmt_Java(statement.expression),  rhs=plyj.model.Additive(operator='-',lhs=syntaxTranslateStmt_Java(statement.expression), rhs=plyj.model.Literal(value='1'))))
			elif statement.sign=='--x':
   				update_statements.append(plyj.model.Assignment(operator='=',lhs=syntaxTranslateStmt_Java(statement.expression),  rhs=plyj.model.Additive(operator='-',lhs=syntaxTranslateStmt_Java(statement.expression), rhs=plyj.model.Literal(value='1'))))
   			else:
   				update_statements.append(statement)
   		elif type(statement) is plyj.model.Assignment:
   			if statement.operator=='+=':
   				update_statements.append(plyj.model.Assignment(operator='=',lhs=statement.lhs,  rhs=plyj.model.Additive(operator='+',lhs=syntaxTranslateStmt_Java(statement.lhs), rhs=syntaxTranslateStmt_Java(statement.rhs))))
   			elif statement.operator=='-=':
   				update_statements.append(plyj.model.Assignment(operator='=',lhs=statement.lhs,  rhs=plyj.model.Additive(operator='-',lhs=syntaxTranslateStmt_Java(statement.lhs), rhs=syntaxTranslateStmt_Java(statement.rhs))))
   			elif statement.operator=='*=':
			   	update_statements.append(plyj.model.Assignment(operator='=',lhs=statement.lhs,  rhs=plyj.model.Multiplicative(operator='*',lhs=syntaxTranslateStmt_Java(statement.lhs), rhs=syntaxTranslateStmt_Java(statement.rhs))))
			elif statement.operator=='/=':
   				update_statements.append(plyj.model.Assignment(operator='=',lhs=statement.lhs,  rhs=plyj.model.Multiplicative(operator='/',lhs=syntaxTranslateStmt_Java(statement.lhs), rhs=syntaxTranslateStmt_Java(statement.rhs))))
   			else:
   				update_statements.append(syntaxTranslateStmt_Java(statement))					
   		elif type(statement) is plyj.model.For:
   			stmts=[]
   			for stmt in statement.init:
   				update_statements.append(stmt)
   			for stmt in statement.update:
   				stmts.append(stmt)
			for stmt in statement.body.statements:
				stmts.append(stmt)
			stmts=syntaxTranslate_Java(stmts)
			update_statements.append(plyj.model.While(predicate=syntaxTranslateStmt_Java(statement.predicate),body=plyj.model.Block(statements=stmts)))
		elif type(statement) is plyj.model.DoWhile:
   			stmts=syntaxTranslate_Java(statement.body.statements)
   			for stmt in stmts:
   				update_statements.append(stmt)
   			update_statements.append(plyj.model.While(predicate=syntaxTranslateStmt_Java(statement.predicate),body=plyj.model.Block(statements=stmts)))		
   		elif type(statement) is plyj.model.While:
		   	stmts=syntaxTranslate_Java(statement.body.statements)
		   	for stmt in stmts:
		   		update_statements.append(stmt)
   			update_statements.append(plyj.model.While(predicate=syntaxTranslateStmt_Java(statement.predicate),body=plyj.model.Block(statements=stmts)))		
   		elif type(statement) is plyj.model.Switch:
                	update_statements.append(convertToIfElse_Java(statement.switch_cases,statement.expression))
   		elif type(statement) is plyj.model.IfThenElse:
   			update_statements.append(syntaxTranslate_Java_If(statement))
   		else:
   			update_statements.append(syntaxTranslateStmt_Java(statement))
	return  update_statements
  
  
  
def syntaxTranslate_Java_If(statement):
 	stmt_if=None
 	stmt_else=None
        if type(statement.if_true) is plyj.model.Block:
            stmt_if=syntaxTranslate_Java(statement.if_true.statements)
        else:
            new_if_list=[]
            new_if_list.append(statement.if_true)
            stmt_if=syntaxTranslate_Java(new_if_list)
 	
 	if type(statement.if_false) is plyj.model.IfThenElse:
                print statement.if_false
 		stmt_else=syntaxTranslate_Java_If(statement.if_false) 		
 	else:
 		if statement.if_false is not None:
                    if type(statement.if_false) is plyj.model.Block:
                        stmt_else=syntaxTranslate_Java(statement.if_false.statements)
                        stmt_else=plyj.model.Block(statements=stmt_else)
                    else:
                        new_else_list=[]
                        new_else_list.append(statement.if_false)
                        stmt_else=syntaxTranslate_Java(new_else_list)
                        stmt_else=plyj.model.Block(statements=stmt_else)
                        
 	return plyj.model.IfThenElse(predicate=syntaxTranslateStmt_Java(statement.predicate),if_true=plyj.model.Block(statements=stmt_if),if_false=stmt_else)
    
 
 
def syntaxTranslateStmt_Java(statement):
	if type(statement) is plyj.model.Unary:
		if statement.sign=='x++':
	   		return plyj.model.Assignment(operator='=',lhs=syntaxTranslateStmt_Java(statement.expression),  rhs=plyj.model.Additive(operator='+',lhs=syntaxTranslateStmt_Java(statement.expression), rhs=plyj.model.Literal(value='1')))
	   	elif statement.sign=='++x':
	   		return plyj.model.Assignment(operator='=',lhs=syntaxTranslateStmt_Java(statement.expression),  rhs=plyj.model.Additive(operator='+',lhs=syntaxTranslateStmt_Java(statement.expression), rhs=plyj.model.Literal(value='1')))
	   	elif statement.sign=='x--':
			return plyj.model.Assignment(operator='=',lhs=syntaxTranslateStmt_Java(statement.expression),  rhs=plyj.model.Additive(operator='-',lhs=syntaxTranslateStmt_Java(statement.expression), rhs=plyj.model.Literal(value='1')))
		elif statement.sign=='--x':
   			return plyj.model.Assignment(operator='=',lhs=syntaxTranslateStmt_Java(statement.expression),  rhs=plyj.model.Additive(operator='-',lhs=syntaxTranslateStmt_Java(statement.expression), rhs=plyj.model.Literal(value='1')))
   		else:
   			return statement
	else:
		if type(statement) is plyj.model.Additive:
			return plyj.model.Additive(operator=statement.operator,lhs=syntaxTranslateStmt_Java(statement.lhs),rhs=syntaxTranslateStmt_Java(statement.rhs))
		elif type(statement) is plyj.model.Multiplicative:
			return plyj.model.Multiplicative(operator=statement.operator,lhs=syntaxTranslateStmt_Java(statement.lhs),rhs=syntaxTranslateStmt_Java(statement.rhs))
		elif type(statement) is plyj.model.Relational:
			return plyj.model.Relational(operator=statement.operator,lhs=syntaxTranslateStmt_Java(statement.lhs),rhs=syntaxTranslateStmt_Java(statement.rhs))
		elif type(statement) is plyj.model.Equality:
			return plyj.model.Equality(operator=statement.operator,lhs=syntaxTranslateStmt_Java(statement.lhs),rhs=syntaxTranslateStmt_Java(statement.rhs))
		elif type(statement) is plyj.model.FieldAccess:
			args=[]
			if type(statement.target) is plyj.model.FieldAccess:
				args.appens(syntaxTranslateStmt_Java(statement.target))
				return plyj.model.MethodInvocation(name=statement.name,arguments=args)
			else:
				if statement.target=='this':
					args.append(plyj.model.Name(value='_c1'))
				else:
					args.append(plyj.model.Name(value=statement.target))
				return plyj.model.MethodInvocation(name=statement.name,arguments=args)
		elif type(statement) is plyj.model.Assignment:
			return plyj.model.Assignment(operator='=',lhs=syntaxTranslateStmt_Java(statement.lhs),  rhs=syntaxTranslateStmt_Java(statement.rhs))
		elif type(statement) is plyj.model.ArrayAccess:
			return plyj.model.ArrayAccess(index=syntaxTranslateStmt_Java(statement.index),target=syntaxTranslateStmt_Java(statement.target))
		elif type(statement) is plyj.model.Return:
			return plyj.model.Return(result=syntaxTranslateStmt_Java(statement.result))
		elif type(statement) is plyj.model.MethodInvocation:
			args=[]
                        if statement.target is not None:
                            args.append(statement.target)
			for para in statement.arguments:
				args.append(syntaxTranslateStmt_Java(para))
			function_name=syntaxTranslateStmt_Java(statement.name)
			if function_name=='println':
				return None
			return plyj.model.MethodInvocation(name=function_name,arguments=args,target=None)
		elif type(statement) is plyj.model.Name:
			if '.' in statement.value:
				functions = statement.value.split('.')
				return constructFieldAccess2Function(functions)
			else:
				return statement
		else:
			return statement    
   
  
  
def constructFieldAccess2Function(term_list):
 	if len(term_list[2:])>0:
 		args=[]
 		args.append(constructFieldAccess2Function(term_list[1:]))
 		return plyj.model.MethodInvocation(name=term_list[0],arguments=args)
 	else:
 		args=[]
		args.append(plyj.model.Name(value=term_list[1]))
 		return plyj.model.MethodInvocation(name=term_list[0],arguments=args)
  
  
  


"""

Covert Switch Case to If-Else-If loop

"""


def convertToIfElse_Java(statements,condition):
	if statements is not None and len(statements)>0:
		statement=statements[0]
		stmts=[]
		for stmt in statement.body:
			if type(stmt) is not plyj.model.Break:
				stmts.append(stmt)
		new_condition=None
		for case in statement.cases:
			if case!='default':
				if new_condition is None:
					new_condition=plyj.model.Equality(operator='==',lhs=condition,rhs=case)
				else:
					new_condition=plyj.model.Relational(operator='||',lhs=new_condition,rhs=plyj.model.Equality(operator='==',lhs=condition,rhs=case))
			else:
				new_condition=None
	if len(statements[1:])>0:
		return plyj.model.IfThenElse(predicate=new_condition,if_true=plyj.model.Block(statements=stmts),if_false=convertToIfElse_Java(statements[1:],condition))
	else:
		if new_condition is not None:
			return plyj.model.IfThenElse(predicate=new_condition,if_true=plyj.model.Block(statements=stmts),if_false=None)
		else:
			return plyj.model.Block(statements=stmts)
          
#file_name='test.java'         
#file_name='benchmark/IntStack.java'  
                        
def translate2JavaObject(file_name):
	if not(os.path.exists(file_name)): 
		print "File not exits"
		return
	start_time=current_milli_time()
	p = getParser()
	tree = p.parse_file(file_name)
	javaclass_list={}
	import_list={}
        for type_decl in tree.type_declarations:
            className=type_decl.name
            list_membervariables={}
            list_membermethods={}
            list_constructors={}
            for element in type_decl.body:
                if type(element) is plyj.model.FieldDeclaration:
                    if type(element.type) is plyj.model.Type:
                        if type(element.type.name) is plyj.model.Name:
                            variableType=element.type.name.value
                            dimensions=element.type.dimensions
                            variablename=element.variable_declarators[0].variable.name
                            initialvalue=element.variable_declarators[0].initializer
                            modifiers=element.modifiers
			    variable=variableclass(variablename, variableType, modifiers, dimensions, initialvalue,None)
			    list_membervariables[variablename]=variable
                        else:
                            variableType=element.type.name
                            dimensions=element.type.dimensions
                            variablename=element.variable_declarators[0].variable.name
                            initialvalue=element.variable_declarators[0].initializer
                            modifiers=element.modifiers
                            variable=variableclass(variablename, variableType, modifiers, dimensions, initialvalue,None)
                            list_membervariables[variablename]=variable
                    else:
                        variableType=element.type
                        dimensions=0
                        variablename=element.variable_declarators[0].variable.name
                        initialvalue=element.variable_declarators[0].initializer
                        modifiers=element.modifiers
                        variable=variableclass(variablename, variableType, modifiers, dimensions, initialvalue,None)
                        list_membervariables[variablename]=variable
                else:
                    if type(element) is plyj.model.MethodDeclaration:
                        inputvar={}
                        localvar={}
                        usedCounter=0
                    	serialNo=0
                        for para in element.parameters:
                        	variablename=para.variable.name
                        	dimensions=0
                        	initialvalue=None
                        	modifiers=para.modifiers
                        	if type(para.type) is plyj.model.Type:
                        		if type(para.type.name) is plyj.model.Name:
                        			variableType=para.type.name.value
                        		else:
                        			variableType=para.type.name
                        		dimensions=para.type.dimensions
                        	else:
                        		if type(para.type) is plyj.model.Name:
                        			variableType=para.type.value
                        		else:
                        			variableType=para.type
				variable=variableclass(variablename, variableType, modifiers, dimensions, initialvalue, None)
				inputvar[variablename]=variable
                        methodname=element.name
                        methodmodifiers=element.modifiers
                        returnType=element.return_type
			body=syntaxTranslate_Java(element.body)
                        getLocalVaribales(body,localvar)
                        body=translateSyntaxJ2CBlock(body)
     			memberclass=membermethodclass(methodname, returnType , inputvar, localvar, body, usedCounter, serialNo, None)
			list_membermethods[methodname+str(len(inputvar.keys()))]=memberclass
                    elif type(element) is plyj.model.ConstructorDeclaration:
                    	inputvar={}
                    	localvar={}
                    	usedCounter=0
                    	serialNo=0
                    	for para in element.parameters:
				variablename=para.variable.name
			        dimensions=0
			        initialvalue=None
			        modifiers=para.modifiers
			        if type(para.type) is plyj.model.Type:
			        	if type(para.type.name) is plyj.model.Name:
			                	variableType=para.type.name.value
			                else:
			                        variableType=para.type.name
			                dimensions=para.type.dimensions
			        else:
			                if type(para.type) is plyj.model.Name:
			                	variableType=para.type.value
			                else:
			                	variableType=para.type
				variable=variableclass(variablename, variableType, modifiers, dimensions, initialvalue,None)
				inputvar[variablename]=variable
                    	methodname=element.name
                    	returnType=None
                    	body=syntaxTranslate_Java(element.block)
                    	memberclass=membermethodclass(methodname, returnType , inputvar, localvar, body, usedCounter, serialNo,None)
 			list_constructors[methodname+str(len(inputvar.keys()))]=memberclass
 		javaclass=javaClass(className, list_membervariables , list_membermethods, list_constructors)
 		javaclass_list[className]=javaclass
 	program=javaProgramClass(file_name, import_list , javaclass_list)   
 	return program
#Get Local Variables 

def getLocalVaribales(statements,localvariables):
        update_statements=[]
	for element in statements:
		if type(element) is plyj.model.VariableDeclaration:
                    if type(element.type) is plyj.model.Type:
                        if type(element.type.name) is plyj.model.Name:
                            variableType=element.type.name.value
                            dimensions=element.type.dimensions
                            variablename=element.variable_declarators[0].variable.name
                            initialvalue=element.variable_declarators[0].initializer
                            modifiers=element.modifiers
			    variable=variableclass(variablename, variableType, modifiers, dimensions, initialvalue)
			    localvariables[variablename]=variable
                            if initialvalue is not None:
                                update_statements.append(element)
                                update_statements.append(plyj.model.Assignment(operator='=',lhs=element.variable_declarators[0].variable,  rhs=initialvalue))
                            else:
                                update_statements.append(element)
                        else:
                            variableType=element.type.name
                            dimensions=element.type.dimensions
                            variablename=element.variable_declarators[0].variable.name
                            initialvalue=element.variable_declarators[0].initializer
                            modifiers=element.modifiers
                            variable=variableclass(variablename, variableType, modifiers, dimensions, initialvalue)
                            localvariables[variablename]=variable
                            if initialvalue is not None:
                                update_statements.append(element)
                                update_statements.append(plyj.model.Assignment(operator='=',lhs=element.variable_declarators[0].variable,  rhs=initialvalue))
                            else:
                                update_statements.append(element)
                    else:
                        variableType=element.type
                        dimensions=0
                        variablename=element.variable_declarators[0].variable.name
                        initialvalue=element.variable_declarators[0].initializer
                        modifiers=element.modifiers
                        variable=variableclass(variablename, variableType, modifiers, dimensions, initialvalue, None)
                        localvariables[variablename]=variable
                        if initialvalue is not None:
                            update_statements.append(element)
                            update_statements.append(plyj.model.Assignment(operator='=',lhs=element.variable_declarators[0].variable,  rhs=initialvalue))
                        else:
                            update_statements.append(element)
                elif type(element) is plyj.model.While:
                        update_statements.append(plyj.model.While(predicate=element.predicate,body=plyj.model.Block(statements=getLocalVaribales(element.body.statements,localvariables))))
                elif type(element) is plyj.model.IfThenElse:
                        update_statements.append(getLocalVaribales_If(element,localvariables))
                else:
                        update_statements.append(element)
        return update_statements




def getLocalVaribales_If(statement,localvariables):
 	stmt_if=None
 	stmt_else=None
 	stmt_if=getLocalVaribales(statement.if_true.statements,localvariables)
 	if type(statement.if_false) is plyj.model.IfThenElse:
 		stmt_else=getLocalVaribales_If(statement.if_false,localvariables) 		
 	else:
 		if statement.if_false is not None:
                    stmt_else=getLocalVaribales(statement.if_false.statements,localvariables)
                    stmt_else=plyj.model.Block(statements=stmt_else)
 	return plyj.model.IfThenElse(predicate=statement.predicate,if_true=plyj.model.Block(statements=stmt_if),if_false=stmt_else)


def translateSyntaxJ2CBlock(statements):
	update_statements=[]
	for statement in statements:
            if type(statement) is plyj.model.While:
		update_statements.append(c_ast.While(cond=stmtTranslateJ2C(statement.predicate), stmt=c_ast.Compound(block_items=translateSyntaxJ2CBlock(statement.body.statements))))
            elif type(statement) is plyj.model.IfThenElse:
                update_statements.append(translateSyntaxJ2CBlock_If(statement))
            else:
                if type(statement) is not plyj.model.VariableDeclaration:
                	update_statements.append(stmtTranslateJ2C(statement))
                else:
			if statement.variable_declarators[0].initializer is not None:
                                if type(statement.variable_declarators[0].initializer) is plyj.model.InstanceCreation:
                                    if type(statement.variable_declarators[0].initializer.type) is plyj.model.Type:
                                        print '############'
                                        print statement.variable_declarators[0].initializer.type.name.value
                                        statement.variable_declarators[0].initializer= plyj.model.Name(value='NOTNULL')
                                        print statement.variable_declarators[0].initializer
                                        print '############'
				update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=statement.variable_declarators[0].variable.name), rvalue=stmtTranslateJ2C(syntaxTranslateStmt_Java(statement.variable_declarators[0].initializer))))
        return update_statements
    
    
def translateSyntaxJ2CBlock_If(statement):
 	stmt_if=None
 	stmt_else=None
 	stmt_if=translateSyntaxJ2CBlock(statement.if_true.statements)
 	if type(statement.if_false) is plyj.model.IfThenElse:
 		stmt_else=translateSyntaxJ2CBlock_If(statement.if_false) 		
 	else:
 		if statement.if_false is not None:
                    stmt_else=translateSyntaxJ2CBlock(statement.if_false.statements)
                    stmt_else=c_ast.Compound(block_items=stmt_else) 
        return c_ast.If(cond=stmtTranslateJ2C(statement.predicate), iftrue=c_ast.Compound(block_items=stmt_if) ,iffalse=stmt_else)

    
    
			
def stmtTranslateJ2C(statement):
	if type(statement) is plyj.model.Assignment:
		return c_ast.Assignment(op=statement.operator, lvalue=stmtTranslateJ2C(statement.lhs), rvalue=stmtTranslateJ2C(statement.rhs))
	elif type(statement) is plyj.model.Unary:
		return c_ast.UnaryOp(op=statement.operator, expr=stmtTranslateJ2C(statement.expression))
	elif type(statement) is plyj.model.Additive:
		return c_ast.BinaryOp(op=statement.operator, left=stmtTranslateJ2C(statement.lhs), right=stmtTranslateJ2C(statement.rhs))
	elif type(statement) is plyj.model.Multiplicative:
		return c_ast.BinaryOp(op=statement.operator, left=stmtTranslateJ2C(statement.lhs), right=stmtTranslateJ2C(statement.rhs))
	elif type(statement) is plyj.model.Relational:
		return c_ast.BinaryOp(op=statement.operator, left=stmtTranslateJ2C(statement.lhs), right=stmtTranslateJ2C(statement.rhs))
	elif type(statement) is plyj.model.Equality:
		return c_ast.BinaryOp(op=statement.operator, left=stmtTranslateJ2C(statement.lhs), right=stmtTranslateJ2C(statement.rhs))
	elif type(statement) is plyj.model.Literal:
		return c_ast.Constant(type='int', value=statement.value)
	elif type(statement) is plyj.model.Name:
		return c_ast.ID(name=statement.value)
	elif type(statement) is plyj.model.Break:
		return c_ast.Break()
	elif type(statement) is plyj.model.Continue:
		return c_ast.Continue()
	elif type(statement) is plyj.model.ArrayAccess:
                return constructArrayC2Java(statement)
        elif type(statement) is plyj.model.Return:
        	return c_ast.Return(expr=stmtTranslateJ2C(statement.result))
        elif type(statement) is plyj.model.MethodInvocation:
                return creatFunctionCall(statement.name,statement.arguments)
       
        	

            

def constructArrayC2Java(statement):
    if type(statement) is plyj.model.ArrayAccess:
        if type(statement.target) is plyj.model.ArrayAccess:
            return c_ast.ArrayRef(name=constructArrayC2Java(statement.target), subscript=stmtTranslateJ2C(statement.index))
        else:
            return c_ast.ArrayRef(name=stmtTranslateJ2C(statement.target), subscript=stmtTranslateJ2C(statement.index))
        
        
#name='fun'
#parameterlist=['X','Y']
	
def creatFunctionCall(name,parameterlist):
    str_parameterlist=None
    generator = c_generator.CGenerator()
    for para in parameterlist:
        if str_parameterlist==None:
            str_parameterlist=generator.visit(stmtTranslateJ2C(para))
        else:
            str_parameterlist+=','+generator.visit(stmtTranslateJ2C(para))
    if str_parameterlist is not None:
        function=name+'('+str_parameterlist+')'
    else:
        function=name+'()'
    main_function='void main(){'+function+';}'
    parser = c_parser.CParser()
    ast = parser.parse(main_function)
    return ast.ext[0].body.block_items[0]


#c_ast.Assignment(op=statement.operator, lvalue=, rvalue=]

#Java Program 
#Plain Python object to store Information about Java Program 

class javaProgramClass(object):
 	def __init__(self, filename, import_list , classes):
        	self.filename = filename
        	self.import_list = import_list
        	self.classes = classes
        def getFilename(self):
        	return self.filename
        def getImport_list(self):
        	return self.import_list
        def getClasses(self):
        	return self.classes
           
#Java Class 
#Plain Python object to store Information about Java Class 

class javaClass(object):
 	def __init__(self, name, membervariables , membermethods, constructors):
        	self.name = name
        	self.membervariables = membervariables
        	self.membermethods = membermethods
        	self.constructors = constructors
        def getName(self):
        	return self.name
        def getMembervariables(self):
        	return self.membervariables
        def getMembermethods(self):
        	return self.membermethods
        def getConstructors(self):
        	return self.constructors
        	


#Java Basic Data Type

java_basic_datatype=['byte','short','int','long','float','double','boolean','char']


#file_name='benchmark/test.java'
#file_name = 'cav_experiment/benchmarks/cbmc-java/'

def translate_Java(file_name):
	program=translate2JavaObject(file_name)
	if program is not None:
		javaclass_list=program.getClasses()
		for classname in javaclass_list:
			class_object=javaclass_list[classname]
			print 'Class Name'
			print class_object.getName()
			if class_object is not None:
				list_membervariables = class_object.getMembervariables() 
				list_membermethods = class_object.getMembermethods()
				list_constructors = class_object.getConstructors()
				print '		Member Variables'
				var_list="{"
				for x in list_membervariables.keys():
					if list_membervariables[x].getDimensions()>0:
						var_list+=' '+x+':array'
					else:
						var_list+=' '+x+':'+list_membervariables[x].getVariableType()
				var_list+='}'
				print '		'+var_list
				counter=0
				
				
				
				for membermethodname in list_membermethods.keys():
					counter=counter+1
					membermethod=list_membermethods[membermethodname]
					statements=programTransformation(c_ast.Compound(block_items=membermethod.getBody()),list_membermethods)
					localvarmap=getVariables(c_ast.Compound(block_items=statements))
					for x in membermethod.getLocalvar():
						if x not in localvarmap.keys():
							localvarmap[x]=membermethod.getLocalvar()[x]
					membermethod.setLocalvar(localvarmap)
					membermethod.setBody(statements)
					print '		Member Method'
					print '		'+membermethod.getMethodname()
					print '		return Type'
					#print membermethod.getreturnType()
					print '		Input Variables'
					var_list="{"
					for x in membermethod.getInputvar():
						if membermethod.getInputvar()[x].getDimensions()>0:
							var_list+=' '+x+':array'
						else:
							var_list+=' '+x+':'+membermethod.getInputvar()[x].getVariableType()
					var_list+='}'
					print '		'+var_list
					print '		Local Variables'
					var_list="{"
					for x in membermethod.getLocalvar():
						if membermethod.getLocalvar()[x].getDimensions()>0:
							var_list+=' '+x+':array'
						else:
							var_list+=' '+x+':'+membermethod.getLocalvar()[x].getVariableType()
					var_list+='}'
					print '		'+var_list
					#allvariable={}
					#for x in membermethod.getInputvar():
					#	allvariable[x]=membermethod.getInputvar()[x]
					#for x in membermethod.getLocalvar():
                                	#	allvariable[x]=membermethod.getLocalvar()[x]
                                	#for x in list_membervariables.keys():
                                	#	allvariable[x]=list_membervariables[x]
                                        #print membermethod.getBody()
                                        #for stmt in membermethod.getBody():
                                        #    print stmt
                                        generator = c_generator.CGenerator()
                                        function_body=c_ast.Compound(block_items=membermethod.getBody())
                                        print(generator.visit(function_body))
                                        print intersect2(list_membervariables.keys(),membermethod.getLocalvar().keys())
                                        
                                 
                                        membermethod=membermethodclass(membermethod.getMethodname(),membermethod.getreturnType(),membermethod.getInputvar(),membermethod.getLocalvar(),function_body,0,counter,None)
 					program,variablesarray,fname,iputmap,opvariablesarray=translate2IntForm_Java(membermethod.getMethodname(),membermethod.getreturnType(),membermethod.getBody(),membermethod.getInputvar(),membermethod.getLocalvar(),list_membervariables,class_object.getName())
                                        f,o,a,cm,asser,assume=translate1(program,variablesarray,1)
				
				
				return_map={}
				for membermethodname in list_membermethods.keys():
					membermethod=list_membermethods[membermethodname]
					if membermethod.getreturnType() in return_map.keys():
						method_list=return_map[membermethod.getMethodname()]
						method_list.append(membermethod.getMethodname())
						return_map[membermethod.getreturnType()]=method_list
					else:
						method_list=[]
						method_list.append(membermethod.getMethodname())
						return_map[membermethod.getreturnType()]=method_list
				
                                for membermethodname in list_membermethods.keys():
                                	membermethod=list_membermethods[membermethodname]
                                	print membermethod.getMethodname()
                                	for x in membermethod.getInputvar():
						variable_type = membermethod.getInputvar()[x].getVariableType()
						if variable_type in return_map.keys():
							print x+'<---------->'+str(return_map[variable_type])
                                	print '---------------------------'
 








#
#
#

def expr_subsitute_fun(e,e1,e2,functions): #e,e1,e2: expr
    args=expr_args(e)
    op=expr_op(e)
    if op!='and' and op!='or' and op!='not' and op!='implies' and op!='ite' and op not in _infix_op and op in functions.keys():
        print '@@@@@@@@@@@@@@@@@@@@@'
        for parameter in args:
        	print parameter
        print '@@@@@@@@@@@@@@@@@@@@@'
    if e==e1:
        return e2
    else:
        return e[:1]+list(expr_subsitute_fun(x,e1,e2,functions) for x in expr_args(e))
        
        
        
#filename='sv-benchmarks-master/sv-benchmarks-master/c/array-industry-pattern/array_of_struct_single_elem_init_true-unreach-call.i'
        
def main_struct(filename):
    content=None
    struct_map={}
    global new_variable
    with open(filename) as f:
        content = f.read()
    content=content.replace('\r','')
    text = r""" """+content
    parser = GnuCParser()
    ast = parser.parse(text)  
    generator = c_generator.CGenerator()
    var_list=getVariables(ast.ext[1].body)
    for var in var_list.keys():
    	variable=var_list[var]
    	if variable.getStructType() is not None:
    		struct_map[var]=variable.getStructType()
    statements=ast.ext[1].body.block_items
    print generator.visit(c_ast.Compound(block_items=struct_transfer_block(statements,struct_map)))


    		
    		
def struct_transfer_block(statements,struct_map):
 	update_statements=[]
  	for statement in statements:
  		if type(statement) is c_ast.Assignment:
  			update_statements.append(c_ast.Assignment(op=statement.op, lvalue=struct_transfer(statement.lvalue,struct_map), rvalue=struct_transfer(statement.rvalue,struct_map))) 
 		elif type(statement) is c_ast.While:
 			update_statements.append(c_ast.While(cond=c_ast.BinaryOp(op=struct_transfer(statement.cond.op,struct_map), left=struct_transfer(statement.cond.left,struct_map), right=struct_transfer(statement.cond.right,struct_map)),stmt=c_ast.Compound(block_items=struct_transfer_block(statement.stmt.block_items,struct_map))))
 		elif type(statement) is c_ast.If:
 			update_statements.append(struct_transferIf(statement,struct_map))
 		else:
 			update_statements.append(statement)
 	return update_statements
 
 
def struct_transfer(statement,struct_map):
 	if type(statement) is c_ast.StructRef:
 		parameter=[]
 		parameter.append(statement.name)
 		if type(statement.name) is c_ast.ArrayRef:
 			struct_name=struct_map[getArrayName(statement.name)]
 			field_name=statement.field.name
 			return c_ast.FuncCall(name=c_ast.ID(name=struct_name+'_'+field_name), args=c_ast.ExprList(exprs=parameter))
 		else:
 			struct_name=struct_map[statement.name.name]
 			field_name=statement.field.name
 			return c_ast.FuncCall(name=c_ast.ID(name=struct_name+'_'+field_name), args=c_ast.ExprList(exprs=parameter))
 	elif type(statement) is c_ast.BinaryOp:
 		return c_ast.BinaryOp(op=statement.op,left=struct_transfer(statement.left,struct_map),right=struct_transfer(statement.right,struct_map))
 	elif type(statement) is c_ast.UnaryOp:
 		return c_ast.UnaryOp(op=statement.op, expr=struct_transfer(statement.expr,struct_map))
 	elif type(statement) is c_ast.While:
 		return c_ast.While(cond=c_ast.BinaryOp(op=struct_transfer(statement.cond.op,struct_map), left=struct_transfer(statement.cond.left,struct_map), right=struct_transfer(statement.cond.right,struct_map)),stmt=c_ast.Compound(block_items=struct_transfer_block(statement.stmt.block_items,struct_map)))
 	elif type(statement) is c_ast.If:
 		return struct_transferIf(statement,struct_map)
 	elif type(statement) is c_ast.Cast:
 		typename=getStructType(statement.to_type.type)
 		if typename in struct_map:
 			return c_ast.ID(name='NOTNULL')
 		else:
 			return statement	
 	else:
		return statement
		
		
def struct_transferIf(statement,struct_map):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=struct_transfer_block(statement.iftrue.block_items,struct_map))
			else:
				new_iftrue=c_ast.Compound(block_items=[])
		else:
			if type(statement) is c_ast.UnaryOp:
				new_iftrue=struct_transfer(statement.iftrue,struct_map)
			elif type(statement) is c_ast.BinaryOp:
				new_iftrue=struct_transfer(statement.iftrue,struct_map)
			else:
				new_blocks=[]
				new_blocks.append(statement.iftrue)
				new_iftrue=c_ast.Compound(block_items=struct_transfer_block(new_blocks,struct_map))
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=struct_transfer_block(statement.iffalse.block_items,struct_map))
			else:
				new_iffalse=c_ast.Compound(block_items=[])
		else:
			if type(statement.iffalse) is c_ast.If:
				new_iffalse=struct_transfer_block(statement.iffalse,struct_map)
			else:
				if type(statement) is c_ast.UnaryOp:
					new_iffalse=struct_transfer(statement.iffalse,struct_map)
				elif type(statement) is c_ast.BinaryOp:
					new_iffalse=struct_transfer(statement.iffalse,struct_map)
				else:
					if statement.iffalse is not None:
						new_blocks=[]
						new_blocks.append(statement.iffalse)
						new_iffalse=c_ast.Compound(block_items=struct_transfer_block(new_blocks,struct_map))
	return c_ast.If(cond=struct_transfer(statement.cond,struct_map), iftrue=new_iftrue, iffalse=new_iffalse)
	
def getArrayName(statement):
	if type(statement) is c_ast.ArrayRef:
		return getArrayName(statement.name)
	else:
		return statement.name
            
            
def getArrayNameDecl(statement):
	if type(statement) is c_ast.ArrayDecl:
		return getArrayNameDecl(statement.type)
	else:
		return statement.declname
		

#filename='sv-benchmarks/loop-lit/gr2006_true-unreach-call_true-termination-i.c'

#filename='sv-benchmarks/loop-invgen/apache-escape-absolute_true-unreach-call_true-termination.i'

#filename='syntax_test.py'

#filename='sv-benchmarks/loops/ludcmp_false-unreach-call.i'

#file_name='sv-benchmarks/loops/nec20_false-unreach-call_true-termination.i'

def main_test(filename):
    content=None
    try:
    	fd = open(filename)
	text = "".join(fd.readlines())
	text=replaceAddOperator(text)
    	filtered_program = SyntaxFilter.SLexer(text)
    	filtered_program.build()
    	content=filtered_program.filterSyntax()
    except SyntaxFilter.SLexerError as e:
    	print(e)
	sys.exit(1)
    text = r""" """+content
    print text
    parser = GnuCParser()
    ast = parser.parse(text)
    ast.show()
   
   
#file_name='benchmark(c)/sqrt.c'
#file_name='benchmark(c)/potSumm3.c' 
def cacheConstruct():
    	try:
		#fd = open(file_name)
		text = "T(n+1)=(i + n + 1)*_N1(n) + T(n)"
		text=replaceAddOperator(text)
    		filtered_program = SyntaxFilter.SLexer(text)
		filtered_program.build()
		counter=0
		variable_const_map={}
		print filtered_program.createCommonEquation(variable_const_map,counter)
	except SyntaxFilter.SLexerError as e:
		print(e)
		sys.exit(1)

def wolframalphaConstruct():
    	try:
		#fd = open(file_name)
		#text = " 1/4 n**2 (n + 1)**2"
		#text = "4 (-(n)+1)"
		text = '1/4 n^2 (n + 1)^2'
		text=replaceAddOperator(text)
    		filtered_program = SyntaxFilter.SLexer(text)
		filtered_program.build()
		print filtered_program.wolframalphaConstruct()
	except SyntaxFilter.SLexerError as e:
		print(e)
		sys.exit(1)
		

def getWolframalphaCacheTest():
	cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/2'],'(i + n + 1)**3 + T(n)':['N_1','N_1 + (n (n + (1 + 2*i) )*(- (2 - 2*i)  + n*(n + (1 + 2*i) )))/4']}
	expression='(n + i + 1)**3 + T(n)'
	base_expression='N_1'
	for element in cache_map.keys():
		if simplify(element)==simplify(expression):
			if simplify(cache_map[element][0])==simplify(base_expression):
				print 'Result'
				print cache_map[element][1]

#statement="1.0e-7"

def getExponent(statement):
    if 'e' in statement:
        expo=Integer(statement[statement.index('e')+1:len(statement)])
    if 'E' in statement:
        expo=Integer(statement[statement.index('E')+1:len(statement)])
    if expo>0:
        print expo+1
    else:
        print -1*expo*5



def testing():
    #program = ['-1', 'prog', [['-1', 'fun', ['main'], ['-1', 'seq', ['-1', '=', ['RET'], ['0']], ['-1', 'seq', ['-1', '=', ['d1array', ['store',['IntStack']], ['0']], ['0']], ['-1', 'seq', ['-1', '=', ['d1array', ['store',['IntStack']], ['1']], ['0']], ['-1', 'seq', ['-1', '=', ['d1array', ['store',['IntStack']], ['2']], ['0']], ['-1', 'seq', ['-1', '=', ['d1array', ['store',['IntStack']], ['3']], ['0']], ['-1', 'seq', ['-1', '=', ['d1array', ['store',['IntStack']], ['4']], ['0']], ['-1', 'seq', ['-1', '=', ['size',['IntStack']], ['0']], ['-1', '=', ['RET'], ['1']]]]]]]]]]]]

    #program = ['-1', 'prog', [['-1', 'fun', ['main'], ['-1', 'seq', ['-1', '=', ['RET'], ['0']], ['-1', 'seq', ['-1', '=', ['d1array', ['store', ['IntStack']], ['size', ['IntStack']]], ['value']], ['-1', 'seq', ['-1', '=', ['size', ['IntStack']], ['+', ['size', ['IntStack']], ['1']]], ['-1', '=', ['RET'], ['1']]]]]]]]
    
    program = ['-1', 'prog', [['-1', 'fun', ['main'], ['-1', 'seq', ['-1', '=', ['RET'], ['0']], ['-1', 'seq', ['-1', '=', ['result'], ['d1array', ['store' , ['IntStack']], ['-', ['size' , ['IntStack']], ['1']]]], ['-1', 'seq', ['-1', '=', ['size', ['IntStack']], ['-', ['size' , ['IntStack']], ['1']]], ['-1', '=', ['RET'], ['result']]]]]]]]
    
    vprogram ={'main': {'d1array': ['_y3', 'array', 'int', 'int'], 'store': ['_y2', 'IntStack' ,'array'], 'RET': ['_y1', 'int'], 'IntStack': ['_y5', 'class'], 'size': ['_y4', 'IntStack','int'], 'result': ['_y6', 'int']}}
    translate1(program,vprogram,1)


#def constrauctTrace4Test(ite_no):
def constrauctTrace4Test(file_name):
    data = [line.strip() for line in open(file_name, 'r')]
    
    equations = eval(data[0])
    
    assumptions = eval(data[1])
    
    vfact = eval(data[2])
    

    #Example1
    #equations = [['i1', 0, '_n1', ['y8', ['+', ['_n1'], ['1']]], ['ite', ['<', ['x8', ['_n1']], ['50']], ['+', ['y8', ['_n1']], ['1']], ['-', ['y8', ['_n1']], ['1']]]], ['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['==', ['ite', ['<', ['ite', ['<', ['x8', ['_n1']], ['50']], ['+', ['y8', ['_n1']], ['1']], ['-', ['y8', ['_n1']], ['1']]], ['0']], ['1'], ['0']], ['0']], ['+', ['x8', ['_n1']], ['1']], ['x8', ['_n1']]]], ['i1', 0, '_n1', ['break_1_flag8', ['+', ['_n1'], ['1']]], ['ite', ['<', ['ite', ['<', ['x8', ['_n1']], ['50']], ['+', ['y8', ['_n1']], ['1']], ['-', ['y8', ['_n1']], ['1']]], ['0']], ['1'], ['0']]], ['i0', 0, ['y8', ['0']], ['0']], ['i0', 0, ['x8', ['0']], ['0']], ['i0', 0, ['break_1_flag8', ['0']], ['0']], ['s0', ['or', ['<=', ['1'], ['0']], ['!=', ['break_1_flag8', ['_N1']], ['0']]]], ['s1', ['implies', ['<', ['_n1'], ['_N1']], ['and', ['>', ['1'], ['0']], ['==', ['break_1_flag8', ['_n1']], ['0']]]]]]
    #equations = [['i1', 0, '_n1', ['n4', ['+', ['_n1'], ['1']]], ['ite', ['==', ['%', ['+', ['_n1'], ['0']], ['2']], ['0']], ['+', ['n4', ['_n1']], ['1']], ['n4', ['_n1']]]], ['i0', 0, ['n4', ['0']], ['0']]]
    #Example2
    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['==', ['%', ['_n1'],['2']],['0']], ['+', ['x8', ['_n1']], ['1']], ['**', ['x8', ['_n1']], ['2']]]], ['i0', 0, ['x8', ['0']], ['0']]]
    #for equation in equations:
    #    print wff2string1(equation)
    #constrauctTrace4Main(equations,ite_no)
    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['>=', ['C'],['0']], ['+', ['x8', ['_n1']], ['1']], ['+', ['x8', ['_n1']], ['2']]]], ['i0', 0, ['x8', ['0']], ['0']]]
    
    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['>=', ['C'],['0']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['>=', ['x8',['_n1']],['0']], ['+', ['x8', ['_n1']], ['2']], ['+', ['x8', ['_n1']], ['2']]]]], ['i0', 0, ['x8', ['0']], ['0']]]

    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['>=', ['C'],['0']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['>=', ['B'],['0']], ['+', ['x8', ['_n1']], ['2']], ['+', ['x8', ['_n1']], ['3']]]]], ['i0', 0, ['x8', ['0']], ['0']]]

    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['<=', ['x8',['_n1']],['C']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['<=', ['x8',['_n1']],['B']], ['+', ['x8', ['_n1']], ['2']], ['+', ['x8', ['_n1']], ['3']]]]], ['i0', 0, ['x8', ['0']], ['A']]]

    
    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['>=', ['+',['_n1'],['*',['2'],['_n1']]],['0']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['>=', ['_n1'],['0']], ['+', ['x8', ['_n1']], ['2']], ['+', ['x8', ['_n1']], ['3']]]]], ['i0', 0, ['x8', ['0']], ['0']]]

    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['<=', ['x8',['_n1']],['C']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['<=', ['x8',['_n1']],['B']], ['x8', ['_n1']], ['-',['+', ['x8', ['_n1']], ['3']],['3']]]]], ['i0', 0, ['x8', ['0']], ['A']]]


    #assumptions =['A>=0','B>=0','C>=0']
    #assumptions =[]
    
    #vfact = [['A', 0, ['int']],['C', 0, ['int']],['B', 0, ['int']],['_n1', 0, ['int']],['x8', 1, ['int', 'int']]]
    #vfact = []
    
    conditionalCloseFormSoln(equations,assumptions,vfact)

#Close form solution of conditional equation
def conditionalCloseFormSoln(equations,assumptions,vfact):
    equation_map={}
    equation_base_map={}
    print 'Recurrence:'
    for equation in equations:
        if equation[0]=='i0':
            left_expr=expr2string1(equation[2])
            equation_base_map[left_expr]=equation
            right_expr=expr2string1(equation[3])
            print left_expr+' = '+right_expr
            
        elif equation[0]=='i1':
            left_expr=expr2string1(equation[3])
            equation_map[left_expr]=equation
            right_expr=expr2string1(equation[4])
            print left_expr+' = '+right_expr
    constCondExpression(equation_map,equation_base_map,assumptions,vfact)
        



def constCondExpression(equation_map,equation_base_map,assumptions,vfact):
    for equation in equation_map:
        e1 = equation_map[equation]
        equation_base=str(simplify(equation).subs(simplify(str(e1[2])+"+1"),0))
        e2 = equation_base_map[equation_base]
        
        #print '--------------@@@@@@@@@@@@@@'
        #check_term=expr_replace(copy.deepcopy(e1[3]),eval("['+',['"+e1[2]+"'],['1']]"),eval("['"+e1[2]+"']"))
        #print isOneCaseChange(e1[4],check_term,0)
        #print '--------------@@@@@@@@@@@@@@'
        #return
    
        map_con_expression={}
        
        conditionChecking(e1,map_con_expression)
        
        Type_Rec=None
        
        Detect_Type=None
        
        const=str(e1[2]).replace('_n','_k')
        
        iter_const=str(e1[2]).replace('_n','_X')
        
        incr_query_base=eval("['>=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['0']")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['-',['1']]")))+"]")
        
        decr_query_base=eval("['<=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['0']")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['-',['1']]")))+"]")

        
        incr_query=eval("['Implies',['>=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['1']]")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['"+const+"']")))+"],"+"['>=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['2']]")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['1']]")))+"]"+"]")
        
        decr_query=eval("['Implies',['<=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['1']]")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['"+const+"']")))+"],"+"['<=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['2']]")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['1']]")))+"]"+"]")
        
        
        if Type_Rec is None:
        
            conclusion=[]
            conclusion.append('s0')
            conclusion.append(incr_query_base)

        
            temp_frame=[]
            temp_output=[]
            temp_other=[]
        
            temp_other.append(e1)
            temp_other.append(e2)
        
            temp_constraint=[]
            witnessXml=''
        
            temp_post_condition=[]
            temp_post_condition.append(wff2z3_update(conclusion))

        
            status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
            
        
            if 'Successfully Proved' in status:
                conclusion=[]
                conclusion.append('s0')
                conclusion.append(incr_query)
            
                temp_post_condition=[]
                temp_post_condition.append(wff2z3_update(conclusion))
            
                vfact.append(eval("['"+const+"', 0, ['int']]"))
            
                temp_constraint.append(const+">=0")
            
                status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
                
                if 'Successfully Proved' in status:
                    Type_Rec='INCREMENTING'
            

        if Type_Rec is None:
        
            conclusion=[]
            conclusion.append('s0')
            conclusion.append(decr_query_base)

        
            temp_frame=[]
            temp_output=[]
            temp_other=[]
        
            temp_other.append(e1)
            temp_other.append(e2)
        
            temp_constraint=[]
            witnessXml=''
        
            temp_post_condition=[]
            temp_post_condition.append(wff2z3_update(conclusion))

        
            status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
        
            if 'Successfully Proved' in status:
                conclusion=[]
                conclusion.append('s0')
                conclusion.append(decr_query)
            
                temp_post_condition=[]
                temp_post_condition.append(wff2z3_update(conclusion))
            
                #vfact.append(eval("['"+const+"', 0, ['int']]"))
            
                #temp_constraint.append(const+">=0")
            
                status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
            
                if 'Successfully Proved' in status:
                    Type_Rec='DECREMENTING'






        
        for e_cond in map_con_expression:
            result_e = map_con_expression[e_cond]
            if len(result_e[0])==0:
                new_e1=copy.deepcopy(e1)
                new_e1[4]=result_e[3]
                result_sol = solve_rec(new_e1,e2)
                if result_sol is not None:
                    result_e.append(result_sol)
                if result_e[4] is not None:
                    new_e2=copy.deepcopy(e1)
                    new_e2[4]=result_e[4]
                    result_sol = solve_rec(new_e2,e2)
                    if result_sol is not None:
                        result_e[4]=result_sol
        
        cond_solution=[]
        cond_solution.append('i2')
        cond_solution.append('0')
        cond_solution.append(e1[2])
        cond_solution.append(expr_replace(copy.deepcopy(e1[3]),eval("['+',['"+e1[2]+"'],['1']]"),eval("['"+e1[2]+"']")))
        
        additional_axioms=[]
        
        for e_cond in map_con_expression:
            result_e = map_con_expression[e_cond]
            if len(result_e[0])==0 and len(result_e[1])==0:
                Detect_Type='Constant'
                if len(cond_solution)==4:
                    e_4th=[]
                    if result_e[4] is not None:
                        e_4th.append('ite')
                        e_4th.append(result_e[2])
                        e_4th.append(result_e[5][4])
                        e_4th.append(result_e[4][4])
                    else:
                        e_4th.append(result_e[5][4])
                    cond_solution.append(e_4th)
                else:
                    e_4th=[]
                    e_3th=cond_solution[4]
                    e_4th.append('ite')
                    e_4th.append(result_e[2])
                    e_4th.append(result_e[5][4])
                    e_4th.append(e_3th)
                    cond_solution[4]=e_4th
            elif len(result_e[0])==0 and len(result_e[1])>=0:
                Detect_Type='Variable'
                if len(cond_solution)==4:
                    e_4th=[]
                    if result_e[4] is not None:
                        e_4th.append('ite')
                        e_4th.append(result_e[2])
                        e_4th.append(result_e[5][4])
                        e_4th.append(result_e[4][4])
                    else:
                        e_4th.append('ite')
                        e_4th.append(result_e[2])
                        e_4th.append(result_e[5][4])
                        e_4th.append(None)
                    cond_solution.append(e_4th)
                else:
                    e_4th=[]
                    e_3th=cond_solution[4]
                    if e_3th[0]=='ite' and e_3th[3] is None:
                        if result_e[4][4] is not None:
                            e_4th.append('ite')
                            e_4th.append(result_e[2])
                            e_4th.append(result_e[5][4])
                            e_4th.append(result_e[4][4])
                            e_3th[3]=e_4th
                        else:
                            e_4th.append('ite')
                            e_4th.append(result_e[2])
                            e_4th.append(result_e[5][4])
                            e_4th.append(None)
                            e_3th[3]=e_4th
                    else:
                        e_4th.append('ite')
                        e_4th.append(result_e[2])
                        e_4th.append(result_e[5][4])
                        e_4th.append(e_3th)
                        cond_solution[4]=e_4th
            elif len(result_e[0])>0:
                Detect_Type=Type_Rec
                #print 'No Close Form Solution'
                new_e1=copy.deepcopy(e1)
                new_e1[3] = expr_replace(new_e1[3],eval("['+',['"+new_e1[2]+"'],['1']]"),eval("['"+new_e1[2]+"']"))
                new_e1[4] = expr_replace(new_e1[4],new_e1[3],e2[3])
                list_con_expression=[]
                conditionCheckingVerify(new_e1[4],list_con_expression,[])
                Case_Analysis=False
                for expr_list in list_con_expression:
                    var_cstr_map={}
                    expr2z3(expr_list[1],var_cstr_map)
                    for x in var_cstr_map:
                        vfact.append(eval("['"+x+"', 0, ['int']]"))
                        assumptions.append(var_cstr_map[x])
                    conclusion=[]
                    conclusion.append('s0')
                    conclusion.append(expr_list[1])
                    status=query2z3_cond(assumptions,wff2z3_update(conclusion),vfact)
                    expr_list.append(status)
                    if 'Successfully Proved' in status:
                        Case_Analysis=True
                
                case_map={}
                
                if Case_Analysis==False:
                    count=0
                    for expr_list in list_con_expression:
                        if count<len(list_con_expression)-1:
                            for x in range(0,len(list_con_expression)-1):
                                if x in case_map:
                                    list_cond=case_map[x]
                                    if count==x:
                                        list_cond.append(expr_list[1])
                                    else:
                                        list_cond.append(expr_complement(copy.deepcopy(expr_list[1])))
                                    case_map[x] = list_cond

                                else:
                                    list_cond=[]
                                    if count==x:
                                        list_cond.append(expr_list[1])
                                    else:
                                        list_cond.append(expr_complement(copy.deepcopy(expr_list[1])))
                                    case_map[x] = list_cond
                        count=count+1
                
                list_con_expression=[]
                conditionCheckingVerify(e1[4],list_con_expression,[])
                
                list_of_close_form_solns=[]
                
                    
                iter_Count=0
                list_of_close_form_solns=None
                
                perm= permutations(list_con_expression,len(list_con_expression))
                
                for x in list(perm):
                    updated_base_value=e2
                    allow_flag=False
                    for i in range(0,len(x)):
                            if allow_flag==False:
                                new_e3 = copy.deepcopy(e1)
                                new_e3[4] = x[i][2]
                                result_sol = solve_rec(new_e3,updated_base_value)
                                iter_Count=iter_Count+1
                                iter_const='_X'+str(iter_Count)
                                new_cond=expr_replace(copy.deepcopy(x[i][1]),result_sol[3],copy.deepcopy(result_sol[4]))
                                new_cond_const=expr_complement(expr_replace(copy.deepcopy(new_cond),eval("['"+new_e3[2]+"']"),eval("['"+iter_const+"']")))
                                eq1=[]
                                eq1.append('s0')
                                eq1.append(new_cond_const)
                                eq2=[]
                                eq2.append('s1')
                                eq2_temp=[]
                                eq2_temp.append('implies')
                                eq2_temp.append(eval("['<',['"+new_e3[2]+"'],['"+iter_const+"']]"))
                                eq2_temp.append(new_cond)
                                eq2.append(eq2_temp)
                                
                                
                                new_sol_base=expr_complement(expr_replace(copy.deepcopy(result_sol[4]),eval("['"+new_e3[2]+"']"),eval("['-',['"+iter_const+"'],['1']]")))
                                updated_base_value=copy.deepcopy(e2)
                                updated_base_value[3]=new_sol_base
                                new_cond_update=expr_replace(copy.deepcopy(new_cond),eval("['"+new_e3[2]+"']"),eval("['-',['"+new_e3[2]+"'],['1']]"))

                                
                                
                                query_sol=constructSolnQuery(new_cond_const,eval("['"+iter_const+"']"))
                                
                                expression = expr2string1(query_sol)
                                if 'or' not in expression and 'and' not in expression and 'If' not in expression:
                                    expression=expression.replace('==','-')
                                
                                    query_sol_update=solve_for_constant(expression, iter_const)
                                
                                    if query_sol_update is not None:
                                        query_sol=eval("['==',['"+iter_const+"'],"+str(query_sol_update)+"]") 
                            
                                    conclusion=[]
                                    conclusion.append('s0')
                                    conclusion.append(query_sol)

        
                                    temp_frame=[]
                                    temp_output=[]
                                    temp_other=[]
        
                                    temp_other.append(eq1)
                                    temp_other.append(eq2)
        
                                    temp_constraint=[]
                                    witnessXml=''
        
                                    temp_post_condition=[]
                                    temp_post_condition.append(wff2z3_update(conclusion))
                            
                                    vfact.append(eval("['"+iter_const+"', 0, ['int']]"))
                                        
                                    temp_constraint.append(iter_const+">0")
        
                                    status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
                                
                                    if 'Successfully Proved' in status:
                                        update_query_sol=eval("['-',"+str(query_sol[2])+",['1']]")
                                        updated_base_value[3] = expr_replace(updated_base_value[3],query_sol[1],update_query_sol)
                                else:
                                    if expr_find(eq1[1],eval("['"+iter_const+"']"))==True:
                                        additional_axioms.append(eq1)
                                        additional_axioms.append(eq2)

                            #print expr2string1(result_sol[4])
                            #print expr2string1(new_cond_update)
                            
                                var_cstr_map={}
                                expr2z3(new_cond_update,var_cstr_map)
                                conclusion=[]
                                conclusion.append('s0')
                                conclusion.append(new_cond_update)
                                final_query=wff2z3_update(conclusion)
                                for para_cont in range(1,iter_Count+1):
                                    if "_X"+str(para_cont) in final_query:
                                        vfact.append(eval("['_X"+str(para_cont)+"', 0, ['int']]"))
                                        assumptions.append('_X'+str(para_cont)+'>=0')
                                for para in var_cstr_map:
                                    vfact.append(eval("['"+para+"', 0, ['int']]"))
                                    assumptions.append(var_cstr_map[para])
                                status=query2z3_cond(assumptions,final_query,vfact)

                                if 'Successfully Proved' in status or len(var_cstr_map)==0:
                                    allow_flag=True
                            
                            
                                list_of_close_form_solns = construct_soln_ite(list_of_close_form_solns,new_cond_update,result_sol[4])
                            
                            #print expr2string1(list_of_close_form_solns)

                            #print '------------1'
                if list_of_close_form_solns is not None:
                    list_of_close_form_solns = reconstruct_soln_ite(list_of_close_form_solns)
                    if len(cond_solution)==4:
                        cond_solution.append(cond_solution)
                    else:
                        cond_solution[4]=list_of_close_form_solns

                #print expr2string1(cond_solution[4])
                #print Type_Rec
                #print Case_Analysis
                #return
                        
        list_con_expression=[]
    
        conditionCheckingVerify(cond_solution[4],list_con_expression,[])
                
        count=0
        for expr_list in list_con_expression:
            count=count+1
            if Detect_Type=='Variable' and Detect_Type=='Constant':
                var_cstr_map={}
                expr2z3(expr_list[1],var_cstr_map)
                for x in var_cstr_map:
                    vfact.append(eval("['"+x+"', 0, ['int']]"))
                    assumptions.append(var_cstr_map[x])
                conclusion=[]
                conclusion.append('s0')
                conclusion.append(expr_list[1])
                status=query2z3_cond(assumptions,wff2z3_update(conclusion),vfact)
                expr_list.append(status)
            else:
                if count!=len(list_con_expression):
                    var_cstr_map={}
                    expr2z3(expr_list[1],var_cstr_map)
                    for x in var_cstr_map:
                        vfact.append(eval("['"+x+"', 0, ['int']]"))
                        assumptions.append(var_cstr_map[x])
                    conclusion=[]
                    conclusion.append('s0')
                    conclusion.append(expr_list[1])
                    status=query2z3_cond(assumptions,wff2z3_update(conclusion),vfact)
                    expr_list.append(status)
        count=0
        if Detect_Type=='Variable' and Detect_Type=='Constant':
            for expr_list in list_con_expression:
                if 'Successfully Proved' in expr_list[3]:
                    cond_solution[4]=expr_list[2]
                    break

        else:
            for expr_list in list_con_expression:
                count=count+1
                if count!=len(list_con_expression):
                    if 'Successfully Proved' in expr_list[3]:
                        cond_solution[4]=expr_list[2]
                        break
        #print 'Detected Type'
        #print Detect_Type
        print 'Close Form Solution'
        print expr2string1(cond_solution[4])
        map_add_equ={}
        if len(additional_axioms)>0:
            print "Additional Axioms"
            for x in additional_axioms:
                key=wff2string1(x)
                if key not in map_add_equ.keys():
                    map_add_equ[key]=key
                    print key

       


def isOneCaseChange(e1,e2,count):
    if e1[0]=='ite':
        arg_list=expr_args(e1)
        if arg_list[1][0]=='ite':
            count=isOneCaseChange(arg_list[1],e2,count)
        else:
            exp1=simplify(expr2string1(arg_list[1]))
            exp2=simplify(expr2string1(e2))
            if exp1!=exp2:
                count=count+1
        if arg_list[2][0]=='ite':
            count=isOneCaseChange(arg_list[2],e2,count)
        else:
            exp1=simplify(expr2string1(arg_list[2]))
            exp2=simplify(expr2string1(e2))
            if exp1!=exp2:
                count=count+1
    return count

    




def construct_soln_ite(stmt,cond,cond_stmt):
    if stmt is None:
        stmt=[]
        stmt.append('ite')
        stmt.append(cond)
        stmt.append(cond_stmt)
        return stmt
    else:
        if stmt[0]=='ite':
            arg_list=expr_args(stmt)
            if len(arg_list)==2:
                stmt1=[]
                stmt1.append('ite')
                stmt1.append(cond)
                stmt1.append(cond_stmt)
                stmt.append(stmt1)
            else:
                arg_list[2] = construct_soln_ite(arg_list[2],cond,cond_stmt)
            return stmt
        else:
            return None
        
def reconstruct_soln_ite(stmt):
        if stmt[0]=='ite':
            arg_list=expr_args(stmt)
            if len(arg_list)==2:
                return arg_list[1]
            else:
                arg_list[2] = reconstruct_soln_ite(arg_list[2])
                temp=[]
                temp.append('ite')
                temp.append(arg_list[0])
                temp.append(arg_list[1])
                temp.append(arg_list[2])
                return temp
        return stmt


 
    
    






def constructSolnQuery(e,variable):
    if e[0]=='or':
        temp=[]
        temp.append('or')
        temp.append(constructSolnQuery(e[1],variable))
        temp.append(constructSolnQuery(e[2],variable))
        return temp
    elif e[0]=='and':
        temp=[]
        temp.append('and')
        temp.append(constructSolnQuery(e[1],variable))
        temp.append(constructSolnQuery(e[2],variable))
    if e[0]=='Or':
        temp=[]
        temp.append('Or')
        temp.append(constructSolnQuery(e[1],variable))
        temp.append(constructSolnQuery(e[2],variable))
        return temp
    elif e[0]=='And':
        temp=[]
        temp.append('And')
        temp.append(constructSolnQuery(e[1],variable))
        temp.append(constructSolnQuery(e[2],variable))
    elif e[0]=='<':
        if expr_find(e,variable)==True:
            e=expr_replace(e,variable,eval("['-',"+str(variable)+",['1']]"))
            e[0]='=='
            return e
        else:
            return e
    elif e[0]=='>':
        if expr_find(e,variable)==True:
            e=expr_replace(e,variable,eval("['-',"+str(variable)+",['1']]"))
            e[0]='=='
            return e
        else:
            return e
    elif e[0]=='<=':
        if expr_find(e,variable)==True:
            e[0]='=='
            return e
        else:
            return e
    elif e[0]=='=':
        if expr_find(e,variable)==True:
            e[0]='=='
            return e
        else:
            return e
    else:
        return e
    





       
            
                

def conditionChecking(e1,map_con_expression):
    if (e1[0]=='i1' and e1[4][0]=='ite') :
        arg_list=expr_args(e1[4])
        map_fun={}
        map_var={}
        isFunInExpression(arg_list[0],map_fun,map_var)
        list_expr=[]
        list_expr.append(map_fun)
        list_expr.append(map_var)
        list_expr.append(arg_list[0])
        list_expr.append(arg_list[1])
        if arg_list[2][0]=='ite':
            conditionChecking(arg_list[2],map_con_expression)
            list_expr.append(None)
        else:
            list_expr.append(arg_list[2])
        map_con_expression[expr2string1(arg_list[0])]=list_expr
    elif e1[0]=='ite':
        arg_list=expr_args(e1)
        map_fun={}
        map_var={}
        isFunInExpression(arg_list[0],map_fun,map_var)
        list_expr=[]
        list_expr.append(map_fun)
        list_expr.append(map_var)
        list_expr.append(arg_list[0])
        list_expr.append(arg_list[1])
        if arg_list[2][0]=='ite':
            conditionChecking(arg_list[2],map_con_expression)
            list_expr.append(None)
        else:
            list_expr.append(arg_list[2])
        map_con_expression[expr2string1(arg_list[0])]=list_expr






def conditionCheckingVerify(e1,list_con_expression,cond_expr):
    if e1[0]=='ite':
        temp_list=[]
        arg_list=expr_args(e1)
        if cond_expr==[]:
            new_cond_expr=expr_complement(copy.deepcopy(arg_list[0]))
        else:
            new_cond_expr=[]
            new_cond_expr.append('or')
            new_cond_expr.append(expr_complement(copy.deepcopy(arg_list[0])))
            new_cond_expr.append(cond_expr)        
        temp_list.append(expr2string1(arg_list[0])) 
        temp_list.append(arg_list[0])  
        temp_list.append(arg_list[1])
        list_con_expression.append(temp_list)
        if arg_list[2][0]=='ite':
            conditionCheckingVerify(arg_list[2],list_con_expression,new_cond_expr)
        else:
            temp_list=[]
            temp_list.append(expr2string1(new_cond_expr)) 
            temp_list.append(new_cond_expr)  
            temp_list.append(arg_list[2])
            list_con_expression.append(temp_list)
            







def isFunInExpression(e,map_fun,map_var):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if op.startswith('_n')==True or op.startswith('_x')==True:
            map_var[op]=op
    elif len(args)>0 and op!='and' and op!='or' and op!='not' and op!='implies' and op not in _infix_op:
        map_fun[op]=op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return isFunInExpression(args[0],map_fun)
            else:
                for x in args:
                    isFunInExpression(x,map_fun,map_var)
        elif op=='not' and len(args)==1:
            isFunInExpression(args[0],map_fun,map_var)
        elif op=='implies' and len(args)==2:
            isFunInExpression(args[0],map_fun,map_var)
            isFunInExpression(args[1],map_fun,map_var)
        elif op in _infix_op and len(args)==2:
            isFunInExpression(args[0],map_fun,map_var)
            isFunInExpression(args[1],map_fun,map_var)
        else:
            for x in args:
                isFunInExpression(x,map_fun,map_var)



#Equation Construction Recunce solution

def constrauctTrace4Main(equations,ite_no):
    equations_const_map={'1':['+',['*',['_n'],['_z1']],['_z2']],'2':['+',['+',['*',['*',['_n'],['_n']],['_z1']],['*',['_z2'],['_n']]],['_z3']]}
    equa_trace_map_main={}
    equa_degree_map_main={}
    subs_map={}
    
    for equation in equations:
        if equation[0]=='i0':
            left_expr=expr2string1(equation[2])
            element_list=[]
            element_list.append(equation[2])
            element_list.append(equation[3])
            subs_map[left_expr]=element_list
        elif equation[0]=='i1':
            left_expr=expr2string1(equation[3])
            if 'break_' not in left_expr:
                domain = expr_replace(copy.deepcopy(equation[3]),eval("['+',['"+equation[2]+"'],['1']]"),eval("['"+equation[2]+"']"))
                d_degree = 0
                d_degree = constrauctTrace4Degree(equation[4],d_degree,domain)
                equa_degree_map_main[expr2string1(equation[3])]=d_degree
    
    temp_subs_map={}
    for i in range(int(ite_no)):
        value=i            
        if i==0:
            for equation in equations:
                if equation[0]=='i1':
                    left_expr=expr2string1(equation[3])
                    if 'break_' not in left_expr:
                        equa_trace_map=constrauctTrace4Rec(equation,value,subs_map)
                        #subs_map={}
                        for e in equa_trace_map:
                            temp_subs_map[expr2string1(equa_trace_map[e][0])]=equa_trace_map[e]
                            if e in equa_trace_map_main.keys():
                                list_e=equa_trace_map_main[e]
                                list_e.append(equa_trace_map[e])
                                equa_trace_map_main[e]=list_e
                            else:
                                list_e=[]
                                list_e.append(equa_trace_map[e])
                                equa_trace_map_main[e]=list_e
        else:
            
            subs_map={}
            for x_key in temp_subs_map:
                subs_map[x_key]=temp_subs_map[x_key]
            temp_subs_map={}
            
            for equation in equations:
                if equation[0]=='i1':
                    left_expr=expr2string1(equation[3])
                    if 'break_' not in left_expr:
                        equa_trace_map=constrauctTrace4Rec(equation,value,subs_map)
                        for e in equa_trace_map:
                            temp_subs_map[expr2string1(equa_trace_map[e][0])]=equa_trace_map[e]
                            if e in equa_trace_map_main.keys():
                                list_e=equa_trace_map_main[e]
                                list_e.append(equa_trace_map[e])
                                equa_trace_map_main[e]=list_e
                            else:
                                list_e=[]
                                list_e.append(equa_trace_map[e])
                                equa_trace_map_main[e]=list_e
    

    for e in equa_trace_map_main.keys():
        key = equa_degree_map_main[e]
        list_of_var=[]
        list_of_equations=[]
        for x in range(key+1):
            list_of_var.append(simplify('_z'+str(x+1)))
        for e1 in equa_trace_map_main[e]:
            sol_eq = equations_const_map[str(key)]
            sol_eq = expr_replace(sol_eq,eval("['_n']"),eval("['"+str(e1[2])+"']"))
            list_of_equations.append(simplify(expr2string1(sol_eq)+'-'+expr2string1(e1[1])+'+1'))
        print '--------------------'
        print 'Degree:--'+str(key)
        print 'List Of Equation Generated--'
        print list_of_equations
        print '--------------------'
        solution_set = linsolve(list_of_equations,list_of_var)
        if solution_set is not EmptySet():
            if key==1:
                soln_1,soln_2 = next(iter(solution_set))
                sol_eq = equations_const_map[str(key)]
                sol_eq = expr_replace(sol_eq,eval("['_z1']"),eval("['"+str(soln_1)+"']"))
                sol_eq = expr_replace(sol_eq,eval("['_z2']"),eval("['"+str(soln_2)+"']"))
                print e.replace('+1','')
                print 'Solution is'
                print expr2string1(sol_eq)
            elif key==2:
                soln_1,soln_2,soln_3 = next(iter(solution_set))
                sol_eq = equations_const_map[str(key)]
                sol_eq = expr_replace(sol_eq,eval("['_z1']"),eval("['"+str(soln_1)+"']"))
                sol_eq = expr_replace(sol_eq,eval("['_z2']"),eval("['"+str(soln_2)+"']"))
                sol_eq = expr_replace(sol_eq,eval("['_z3']"),eval("['"+str(soln_3)+"']"))
                print e.replace('+1','')
                print 'Solution is'
                print expr2string1(sol_eq)
        else:
            print e.replace('+1','')
            print 'No Solution'


                    





def constrauctTrace4Rec(equation,value,subs_map):
    update_equ={}
    equa_trace_map={}
    if equation[0]=='i1':
        left_expr=expr2string1(equation[3])
        if 'break_' not in left_expr:
            new_e = copy.deepcopy(equation)
            new_e[3] = expr_replace(new_e[3],eval("['+',['"+equation[2]+"'],['1']]"),eval("['"+str(value+1)+"']"))
            new_e[4] = expr_replace(new_e[4],eval("['"+equation[2]+"']"),eval("['"+str(value)+"']"))
            update_equ[left_expr]=new_e
    for key in update_equ:
        e=update_equ[key]
        for sub in subs_map:
            e[3] = expr_replace(e[3],subs_map[sub][0],subs_map[sub][1])
            e[4] = expr_replace(e[4],subs_map[sub][0],subs_map[sub][1])
        if e[4][0]=='ite':
            ret_value = constrauctTrace4Cond(e[4])
            if ret_value is not None:
                final_exp=expr2string1(ret_value)
                if 'ite' not in final_exp and 'and' not in final_exp and 'or' not in final_exp:
                    equa_trace_map_temp = []
                    equa_trace_map_temp.append(e[3])
                    #equa_trace_map_temp.append(value)
                    equa_trace_map_temp.append(eval("['"+str(simplify(final_exp))+"']"))
                    equa_trace_map_temp.append(value)
                    equa_trace_map[key]=equa_trace_map_temp
        else:
            final_exp=expr2string1(e[4])
            if 'ite' not in final_exp and 'and' not in final_exp and 'or' not in final_exp:
                    equa_trace_map_temp = []
                    equa_trace_map_temp.append(e[3])
                    #equa_trace_map_temp.append(e[4])
                    equa_trace_map_temp.append(eval("['"+str(simplify(final_exp))+"']"))
                    equa_trace_map_temp.append(value)
                    equa_trace_map[key]=equa_trace_map_temp
    return equa_trace_map
    
        
def constrauctTrace4Cond(e):
    if e[0]=='ite':
        if e[1][0]=='ite':
            value=constrauctTrace4Cond(e[1])
            if value is not None:
                conclusion=[]
                conclusion.append('s0')
                conclusion.append(value)
                status=query2z3_cond([],wff2z3_update(conclusion),[])
                #print status
                if 'Successfully Proved' in status:
                    if e[2][0]=='ite':
                        return constrauctTrace4Cond(e[2])
                    else:
                        return e[2]
                elif 'Counter Example' in status:
                    if e[3][0]=='ite':
                        return constrauctTrace4Cond(e[3])
                    else:
                        return e[3]
                else:
                    return None
        else:
            conclusion=[]
            conclusion.append('s0')
            conclusion.append(e[1])
            status=query2z3_cond([],wff2z3_update(conclusion),[])
            #print status
            if 'Successfully Proved' in status:
                if e[2][0]=='ite':
                    return constrauctTrace4Cond(e[2])
                else:
                    return e[2]
            elif 'Counter Example' in status:
                if e[3][0]=='ite':
                    return constrauctTrace4Cond(e[3])
                else:
                    return e[3]
            else:
                return None
    else:
        return e
    
    
    
    
def constrauctTrace4Degree(e,d,domain):
    if e[0]=='ite':
        d = constrauctTrace4Degree(e[2],d,domain)
        d = constrauctTrace4Degree(e[3],d,domain)
        return d
    else:
        d_degree=degree(simplify(expr2string1(e)),gen=simplify(expr2string1(domain)))
        if d_degree>d:
            d=d_degree
        return d
    
    
def find_bound_auto(file_name,property=None):
	if not(os.path.exists(file_name)): 
        	print "File not exits"
		return
        if os.path.exists(currentdirectory+'/errorWitness.graphml'):
            os.remove(currentdirectory+'/errorWitness.graphml')
        if os.path.exists(currentdirectory+'/correctnessWitness.graphml'):
            os.remove(currentdirectory+'/correctnessWitness.graphml')
            
            
	start_time=current_milli_time()
	content=None
        witness_path=None
	global new_variable
	global fail_count
	global error_count
	global assume_count
        global assert_count
        global defineMap
        global defineDetaillist
        global map___VERIFIER_nondet
        global new_variable_array
        global counter_variableMap
        global counter_variableMap_Conf
        global sub_vfact
        global external_var_map
        global fun_call_map
        global current_fun_call
        global fun_substitution_map
        global line_no_stmt_map
        global count_ast_line_no
        global main_count_ast_line_no
        global main_line_no_stmt_ast_map
        
        struct_map={}
        fail_count=0
        error_count=0
        assume_count=0
        assert_count=0
        count_ast_line_no=0
        main_count_ast_line_no=0
        map___VERIFIER_nondet={}
        new_variable_array={}
        counter_variableMap={}
        counter_variableMap_Conf={}
        fun_call_map={}
        fun_substitution_map={}
        line_no_stmt_map={}
        function_vfacts=[]
        program_analysis=''
        program_analysis2=''
        program_analysis3=''
        program_analysis_decl=''
        program_analysis_var_decl=''
        current_fun_call=None
        struct_list=None
        type_struct_list=None
        line_no_stmt_map=None
        original_program=None
        new_program=None
        main_line_no_stmt_ast_map={}
        
	try:
		fd = open(file_name)
		text = "".join(fd.readlines())
                original_program=text
                
                defineMap={}
                content,defineMap=preProcessorHandling(text)
		text=replaceAddOperator(text)
    		filtered_program = SyntaxFilter.SLexer(text)
		filtered_program.build()
                
		content,struct_list,type_struct_list=filtered_program.filterSyntax()
                #print '--------------'
                #print content
                #print '--------------'
                #print struct_list
                #print '--------------'
                #print type_struct_list
                #print '--------------'
	except SyntaxFilter.SLexerError as e:
                print 'Error(Find Error in Input File)'
		#print(e)
		return
	text = r""" """+content
	parser = GnuCParser()
	#ast = parse_file(file_name, use_cpp=True)
        try:
            
            #print '##############'
            #print struct_list
            #print text
            #print '##############'
            try:
                new_program = text
                line_no_stmt_map = constructLineStmtmap(original_program,text)
            except Exception as e:
                line_no_stmt_map=None
            
            ast = parser.parse(text)
            for struct_str in struct_list:
                
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    struct_name=ast_struct.ext[0].type.name
                
                    isPointer=False
                
                    isTypedef=False
                
                    defName=None
                
                    variable_map=getVariablesC(ast_struct.ext[0].type.decls)
                
                    structobject = structclass(struct_name, isTypedef,  variable_map , defName, isPointer)
                
                    struct_map[struct_name]=structobject
                
            for struct_str in type_struct_list:
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    isPointer=False
                
                    isTypedef=False
                
                    struct_name = ast_struct.ext[0].name
                
                    if type(ast_struct.ext[0]) is c_ast.Typedef:
                        isTypedef=True
                    
                    if type(ast_struct.ext[0].type) is c_ast.PtrDecl:
                        isPointer=True
                    if isPointer==True:
                        struct_name = ast_struct.ext[0].type.type.type.name
                        defName = ast_struct.ext[0].type.type.declname
                        if struct_name is None and defName is not None:
                            struct_name=defName
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                    else:
                        struct_name = ast_struct.ext[0].type.declname
                        defName = ast_struct.ext[0].type.type.name
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                
        except Exception as e:
            #print 'Error(Find Error in Input File)'
            print 'Unknown'
            writeLogFile( "j2llogs.logs" ,str(e))
            return
        #ast.show()
	generator = c_generator.CGenerator()
	writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Translate \n"+"\nParameters--\n File Name--"+file_name+"\n")
	if ast is None:
		print "Error present in code. Please verify you input file"
	       	return
	if len(ast.ext)==0:
		print "Error present in code. Please verify you input file"
	        return
    	externalvarmap={}
        externalarraymap={}
	functionvarmap={}
	memberfunctionmap={}
	axiomeMap={}
	addition_array_map={}
	function_vfact_map={}
	witnessXml_map={}
	
    	counter=0 
        

        try:
            for e in ast.ext:
                    if type(e) is c_ast.Decl:
                            if type(e.type) is c_ast.FuncDecl:
                                    parametermap={}
                                    structType=None
                                    new_e,pointer_list,array_list=pointerHandlingParameter(e)
                                    if new_e is None:
                                            function_decl=e
                                    else:
                                            function_decl=new_e
                                    if function_decl.type.args is not None:
                                            for param_decl in function_decl.type.args.params:
                                                    if param_decl.name is not None:
                                                            structType=None
                                                            if type(param_decl.type) is c_ast.ArrayDecl:
                                                                    degree=0
                                                                    dimensionmap={}
                                                                    data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                    variable=variableclass(param_decl.name, data_type,None,dimensionmap,None,structType)
                                                            else:
                                                                    try:
                                                                        #variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                        variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                    except Exception as e:
                                                                        #print 'Error(Translation to Intermate Intermediate)'
                                                                        print 'Unknown'
                                                                        writeLogFile( "j2llogs.logs" ,str(e))
                                                                        #print str(e)
                                                                        return
                                                            parametermap[param_decl.name]=variable

                                    membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,None,None,0,0,None,None,None)
                                    functionvarmap[membermethod.getMethodname()]=membermethod

                            elif type(e.type) is c_ast.TypeDecl:
                                    #e.type.show()
                                    var_type=None
                                    initial_value=None
                                    structType=None
                                    e=change_var_name_decl(e)
                                    for child in e.children():
                                            if type(child[1].type) is c_ast.IdentifierType:
                                                    var_type=child[1].type.names[0]
                                            else:
                    				
                                                    initial_value=child[1].value
                                    #variable=variableclass(e.name, var_type,None,None,initial_value,structType)
                                    variable=variableclass(e.name, var_type,None,None,initial_value,structType)
                                    program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
                                    externalvarmap[e.name]=variable
                                    external_var_map[e.name]=e.name
                            elif type(e.type) is c_ast.ArrayDecl:
                                program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
                                array_name=getArrayNameDecl(e.type)
                                externalarraymap[array_name]=change_var_name_decl(e)
                                external_var_map[array_name]=e.name
                    else:
                            if type(e) is c_ast.FuncDef:                          
                                    parametermap={}
                                    new_e,pointer_list,array_list=pointerHandlingParameter(e)
                                    if new_e is None:
                                            function_decl=e
                                    else:
                                            function_decl=new_e
    				
                                    function_decl=e.decl
                                
                                
                                    function_body = e.body
                                
                                    if function_body.block_items is not None:
                                        #function_body=pointerHandlingDecl(function_body,pointer_list,array_list)
                                        statements=function_body.block_items
                                        statements=change_var_name(statements)
                                        function_body= c_ast.Compound(block_items=statements)
                                        localvarmap=getVariables(function_body)
                                        counter=counter+1
                                        if function_decl.type.args is not None:
                                                for param_decl in function_decl.type.args.params:
                                                        new_param_decl=declarationModifying(param_decl)
                                                        if new_param_decl is not None:
                                                            param_decl=new_param_decl
                                                        param_decl=change_var_name_decl(param_decl)
                                                        if param_decl.name is not None:
                                                                structType=None
                                                                if type(param_decl.type) is c_ast.ArrayDecl:
                                                                        #print param_decl.show()
                                                                        degree=0
                                                                        dimensionmap={}
                                                                        data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                        variable=variableclass(param_decl.name, data_type,None,dimensionmap,None,structType)
                                                                elif type(param_decl.type) is c_ast.PtrDecl:
                                                                        stmt=pointerToArray(param_decl)
                                                                        #print stmt.show()
                                                                        if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
                                                                                degree=0
                                                                                dimensionmap={}
                                                                                data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                                variable=variableclass(stmt.name, data_type,None,dimensionmap,None,structType)
                                                                else:				
                                                                        try:
                                                                            variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                        except Exception as e:
                                                                            print 'Error(Translation to Intermate Intermediate)'
                                                                            writeLogFile( "j2llogs.logs" ,str(e))
                                                                            #print str(e)
                                                                            return
                                                                parametermap[param_decl.name]=variable
                                    if function_decl.name in functionvarmap.keys():
                                            if function_decl.name!='__VERIFIER_assert':
                                                membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,None,function_decl)
                                                functionvarmap[function_decl.name]=membermethod
                                    else:
                                            if function_decl.type.args is not None:
                                                    for param_decl in function_decl.type.args.params:
                                                            new_param_decl=declarationModifying(param_decl)
                                                            if new_param_decl is not None:
                                                                param_decl=new_param_decl
                                                                param_decl=change_var_name_decl(param_decl)
                                                            if param_decl.name is not None:
                                                                    structType=None
                                                                    if type(param_decl.type) is c_ast.ArrayDecl:
                                                                            degree=0
                                                                            dimensionmap={}
                                                                            data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                            variable=variableclass(param_decl.name, data_type,None,dimensionmap,None,structType)
                                                                    elif type(param_decl.type) is c_ast.PtrDecl:
                                                                            stmt=pointerToArray(param_decl)
                                                                            if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
                                                                                    degree=0
                                                                                    dimensionmap={}
                                                                                    data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap={})
                                                                                    variable=variableclass(stmt.name, data_type,None,dimensionmap,None,structType)
								
                                                                    else:	
                                                                            try:
                                                                                variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                            except Exception as e:
                                                                                print 'Error(Translation to Intermate Intermediate)'
                                                                                writeLogFile( "j2llogs.logs" ,str(e))
                                                                                #print str(e)
                                                                                return
                                                                    parametermap[param_decl.name]=variable
                                            if function_decl.name!='__VERIFIER_assert' and function_decl.name!='exit':
                                                membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,copy.deepcopy(function_body),function_decl)
                                                functionvarmap[membermethod.getMethodname()]=membermethod
        except Exception as e:
            print 'Unknown'
            writeLogFile( "j2llogs.logs" ,str(e))
            #print str(e)
            return

    	for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
    		body=membermethod.getBody()
    		if body is not None:
                    if body.block_items is not None: 
                        
                        try:

                            statements,pa_statements=programTransformation(body,functionvarmap,medthod)
                        
                            statements = updatePointerStruct(statements,struct_map)
                        
                            pa_statements = updatePointerStruct(pa_statements,struct_map)
                            
                            #pa_statements = organizeInnerDeclartionMain(pa_statements)
                            
                        
                        except Exception as e:
                            #print 'Error(Translation to Intermate Intermediate)'
                            print 'Unknown'
                            writeLogFile( "j2llogs.logs" ,str(e))
                            #print str(e)
                            return
                        
                        for temp_method in externalarraymap.keys():
                            if isVarPresnt(statements,temp_method)==True:
                                new_statements=[]
                                new_statements.append(externalarraymap[temp_method])
                                statements=construct_program(new_statements+statements)
                        body_comp = c_ast.Compound(block_items=statements)
                        localvarmap=getVariables(body_comp)
                        statements,localvarmap=addAllExtVariables(statements,externalvarmap,localvarmap)
                        statements = translateStruct(statements,localvarmap,struct_map)
                        line_count_ast_Block(pa_statements)
                        #statements=pointerHandling(statements,pointer_list,array_list)
                        body_comp = c_ast.Compound(block_items=statements)
                        membermethod.setBody(body_comp)
                        membermethod.setLocalvar(localvarmap)
                        membermethod.setAnalysis_module(c_ast.Compound(block_items=pa_statements))
                    else:
                        membermethod.setBody(None)
                        membermethod.setLocalvar(None)
    		else:
		    membermethod.setBody(None)
    		    membermethod.setLocalvar(None)
    
    	temp_functionvarmap={}
    	
    	for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
                in_var_map=membermethod.getInputvar()
                if len(in_var_map)>0:
                    for x in in_var_map:
                        variable=in_var_map[x]
                        if variable.getDimensions() is not None and len(variable.getDimensions())>0:
                            temp_functionvarmap[medthod]=functionvarmap[medthod]
                elif medthod=='main':
                        temp_functionvarmap[medthod]=functionvarmap[medthod]
                
    	
    	for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
    		body=membermethod.getBody()
    		if body is not None:
                    if medthod=='main':
                        statements=body.block_items
                        statements = substituteFunBlock(statements,temp_functionvarmap,medthod,externalvarmap)
                        body_comp = c_ast.Compound(block_items=statements)
                        membermethod.setBody(body_comp)
                        #body_comp = c_ast.Compound(block_items=statements)
                        #generator = c_generator.CGenerator()
                        #print(generator.visit(body_comp))
                        if len(temp_functionvarmap)>0:
                            ret_body_comp,temp_status1,temp_status2 = reduceArraySize1("int main()"+generator.visit(body_comp))
                        
                            if ret_body_comp is not None and temp_status1==True and temp_status2:
                                body_comp = ret_body_comp.body
                                membermethod.setBody(body_comp)
                        

    
    	
    	
    
    	#program in intermediate form
    	programeIF=[]

    	programeIF.append('-1')
    			
    	programeIF.append('prog')

    	programe_array=[]

    	variables_list_map={}
        
    	for medthod in functionvarmap.keys():
                f_vfact=[]
                f_vfact_para=[]
    		membermethod=functionvarmap[medthod]
                if membermethod.getreturnType() is not 'void':
                    f_vfact.append(medthod)
                    f_vfact_para.append(membermethod.getreturnType())
                    for iv in membermethod.getInputvar():
                        i_var=membermethod.getInputvar()[iv]
                        f_vfact_para.append(i_var.getVariableType())
                    f_vfact.append(len(f_vfact_para)-1)
                    f_vfact.append(f_vfact_para)
                    function_vfacts.append(f_vfact)

                
    		body=membermethod.getBody()
                
    		if body is not None:
    			new_variable={}
    			update_statements=[]
    			   		
	    		body_comp=body
	    		
	    		membermethod.setTempoary(body_comp)
	    		
	    		statements=body.block_items
	    		
	    		new_variable.clear()

	    		update_statements=[]
			
			for var in new_variable.keys():
				if isBoolVariable( var )==True:
			    	    	#temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
                                        temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
			    		update_statements.append(temp)
			    	else:
			    		if type(new_variable[var]) is tuple:
                                            type_stmt,t_degree=new_variable[var]
                                            program_temp=type_stmt+' '+var
                                            for x in range(0,t_degree):
                                                program_temp+='[]'
                                            program_temp+=';'
                                            temp_ast = parser.parse(program_temp)
                                            update_statements.append(temp_ast.ext[0])
                                        else:
                                            if var in new_variable_array.keys():
                                                type_stmt='int'
                                                t_degree=new_variable_array[var]
                                                program_temp=type_stmt+' '+var
                                                for x in range(0,t_degree):
                                                    program_temp+='[]'
                                                program_temp+=';'
                                                temp_ast = parser.parse(program_temp)
                                                update_statements.append(temp_ast.ext[0])
                                            else:
                                                temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                                                update_statements.append(temp)
			        	
			for statement in statements:
    				update_statements.append(statement)
                        
                        body_comp=c_ast.Compound(block_items=update_statements)
	    		
    			membermethod.setBody(body_comp)
   
    			
    			localvarmap=getVariables(body_comp)
    			
    			for var in externalvarmap.keys():
				variable=externalvarmap[var]
				localvarmap[var]=variable
    			
    			membermethod.setLocalvar(localvarmap)
    			membermethod=functionvarmap[medthod]
    			    			
    			function=[]
    			
    			function.append('-1')
    			
    			function.append('fun')    			
    			
    			functionName=[]
    			
    			allvariable={}
    			
    			for x in membermethod.getInputvar():
				allvariable[x]=membermethod.getInputvar()[x]
			for x in membermethod.getLocalvar():
        			allvariable[x]=membermethod.getLocalvar()[x]
    			if validationOfInput(allvariable)==True:
				print 'Unkown'
				#print "Please Rename variable Name {S,Q,N,in,is} to other Name"
          			return
    			

    			try:
                            
                            program,variablesarray,fname,iputmap,opvariablesarray,module_analysis,module_analysis2=translate2IntForm(membermethod.getMethodname(),membermethod.getreturnType(),membermethod.getBody(),membermethod.getInputvar(),membermethod.getTempoary(),membermethod.getAnalysis_module(),struct_map)

                        except Exception as e:
                            #print 'Error(error occurred during translation intermediate format)'
                            print 'Unknown'
                            writeLogFile( "j2llogs.logs" ,str(e))
                        #    print str(e)
                            return
		

			functionName.append(fname)

                        
                        if len(iputmap.keys())>0:
                            for x_i in range(0,len(iputmap.keys())):
                                    functionName.append(iputmap.keys()[len(iputmap.keys())-1-x_i])


			function.append(functionName)
                        
                        
			
			function.append(program)
                        

			programe_array.append(function)
		
			variables_list_map[fname]=variablesarray
			
			addition_array=[]
			
			addition_array.append(iputmap)
			
			addition_array.append(allvariable)
			
			addition_array.append(opvariablesarray)
			
			addition_array_map[fname]=addition_array
			
			memberfunctionmap[fname]=membermethod
                        
                        
			
			function_vfact_list=[]
			function_vfact=[]
			function_vfact.append(fname)
			function_vfact.append(len(iputmap))
			parameters_type=[]
			parameters_type.append(membermethod.getreturnType())
			for x in defineDetaillist:
				function_vfact_list.append(x)
					
			
			defineDetaillist=[]
			for element in iputmap.keys():
				variable=iputmap[element]
				if variable is not None:
					parameters_type.append(variable.getVariableType())
			function_vfact.append(parameters_type)
			function_vfact_list.append(function_vfact)
			function_vfact_map[fname]=function_vfact_list	
                        
                        resultfunction='__VERIFIER_nondet_int'
                        
                        filename=file_name
                        functionname=functionName
                        
                        witnessXml=getWitness(filename,fname,resultfunction)
                        witnessXml_map[fname]= witnessXml
                        if program_analysis is not None:
                            #print '###########################3'
                            #print membermethod.getFun_decl().show()
                            #print '###########################3'
                            program_decl=programPrint(membermethod.getFun_decl())
                            #print '^^^^^^^^^^^^^^^^^^^'
                            #print membermethod.getMethodname()
                            #print membermethod.getreturnType()
                            #print program_decl
                            #print '^^^^^^^^^^^^^^^^^^^'
                            if 'main' not in program_decl:
                                program_analysis_decl+=programPrint(membermethod.getFun_decl())+';\n'
                            module_analysis_t1,module_analysis_t2=module_analysis2
                            print '%%%%%%%%%%%%%%%%%'
                            print program_decl
                            print '%%%%%%%%%%%%%%%%%'
                            program_analysis2=program_decl+programPrint(module_analysis_t1)+program_analysis2
                            program_analysis3=program_decl+programPrint(module_analysis_t2)+program_analysis3
                            program_analysis=program_decl+programPrint(module_analysis)+program_analysis
                            
        
        
        program_analysis=program_analysis_var_decl+program_analysis
        programeIF.append(programe_array)
        
        #print '--------------------------------'
        #print programeIF
        #print '--------------------------------'
        #print variables_list_map
        #print '--------------------------------'
        #return
        
        try:
            f_map,o_map,a_map,cm_map,assert_map,assume_map,assert_key_map=translate1(programeIF,variables_list_map,1)
            #print a_map
        except Exception as e:
            print 'Error(Translation Failed)'
            writeLogFile( "j2llogs.logs" ,str(e))
            #print str(e)
            return

        #Comment me to use Z3
        #return
        f_list=f_map.keys()
        cycle_list=[]
        programgraph_map=construct_graph(f_map,o_map,a_map,f_list)
        programgraph = graphclass.Graph(programgraph_map)
        

        
        if programgraph.cyclic():
            cycle_list=list(itertools.chain.from_iterable(programgraph.getAllNodesInCycle()))
            

        f_list=removeCycles(f_list,cycle_list)
        

        
        for f_x in cycle_list:
            for x in o_map[f_x]:
                if o_map[f_x][x][0]=='e':
                    o_map[f_x][x][2] = reconstructRecurences(o_map[f_x][x][2],cycle_list)
                    
        for f_x in cycle_list:
            if f_x in fun_call_map.keys() and fun_call_map[f_x]==1:
                for x in o_map['main']:
                    if o_map['main'][x][0]=='e':
                        o_map['main'][x][2] = reconstructRecurences(o_map['main'][x][2],cycle_list)
        


        function_substitution_test('main',programgraph_map,f_map,o_map,a_map,assert_map,assume_map,cycle_list)
        
        
           
        #print '$$$$$$$$$$$$$$$$$$$$'
        
        #print cycle_list
        
        #print '$$$$$$$$$$$$$$$$$$$$'
        
        
        
        
        #for x in f_map.keys():
        #    f=f_map[x]
        #    o=o_map[x]
        #    a=a_map[x]
        #    f,o,a=updateAxoimsRecurrences(f,o,a,cycle_list)
        #    f_map[x]=f
        #    o_map[x]=o
        #    a_map[x]=a
        
        if type(f_map) is dict and type(o_map) is dict and type(a_map) is dict and type(cm_map) is dict and type(assert_key_map) is dict:
                for key in f_map.keys():
                        membermethod=functionvarmap[key]                        
                        #print membermethod.getreturnType()
        		f=f_map[key]
        		o=o_map[key]
        		a=a_map[key]
        		cm=cm_map[key]
                        
        		assert_list=assert_map[key]
        		assume_list=assume_map[key]
                        
                        assert_list=function_substitution_main_Assert(assert_list,f_map,o_map,a_map,cycle_list)
                        
                        
        		addition_array=addition_array_map[key]
        		
        		vfacts,constraints=getVariFunDetails(f,o,a,addition_array[1],addition_array[2])
        		
        		vfacts2=getVariFunDetails2(f,o,a,addition_array[1],constraints,assert_list,assume_list)
                    
                        for x in a:
                            equ=getConstraints_Eq(x,addition_array[1],constraints)
                            if equ is not None:
                                constraints.append(equ)
        		vfacts=[]
        		for vfact in vfacts2:
        			vfacts.append(vfacts2[vfact])
                        
                        for x in function_vfacts:
                             vfacts.append(x)
                    

        		#for element in function_vfact_map.keys():
        		#	function_vfact_list=function_vfact_map[element]
        		#	for x in function_vfact_list:
                        #                if x[0] not in vfacts2.keys():
                        #                    vfacts.append(x)
                        f,o,a,cm,assert_list = rec_solver_tactic8(f,o,a,assert_list)
        		f,o,a,vfacts=organizeAxioms(f,o,a,vfacts)
                        #output_axioms_fn(f,o,a)
        		axiom=axiomclass(f,o,a,membermethod.getInputvar(), vfacts, constraints,cm,assert_list,assume_list,addition_array[1])
        		axiomeMap[key]=axiom

                #print '#######'
                #print external_var_map
                #print program_analysis
                #print '#######'
                end_time=current_milli_time()
                #print "Translation Time--"
		#print end_time-start_time
                #AssetionAnalysis2(program_analysis2,program_analysis_decl)
                #
                #return
                
                
                if len(f_list)==1 and 'main' in f_list:
                    axiommain=axiomeMap['main']
                    vfactsmain=axiommain.getVfact()
                    
                    a=axiommain.getOther_axioms()
                    assert_list_main=axiommain.getAsserts()
                    re_equations=[]
                    for fun in cycle_list:
                        axiom=axiomeMap[fun]
                        if axiom is not None:
                            equations=[]
                            list_exps={}
                            f=axiom.getFrame_axioms()
                            o=axiom.getOutput_equations()
                            witnessXml= witnessXml_map[fun]
                            assert_list=axiom.getAsserts()
                            vfacts=axiom.getVfact()
                            inputvar=axiom.getInputvariable()
                            
                            for x in o:
                                equation=[]
                                equation.append('R')
                                equation.append(inputvar.keys())
                                equation.append(o[x][1])

                                
                                equation.append(o[x][2])
                                a.append(equation)
                                equations.append(copy.deepcopy(equation))
                                re_equations.append(copy.deepcopy(equation))
                            for x in axiommain.getOutput_equations():
                                e=axiommain.getOutput_equations()[x]
                                if '_FAILED' in x and e[0]=='e':
                                    getRecuresiveFunDef(e[2],cycle_list,list_exps)
                                    temp_condition_map={}
                                    getAllCondtion_tactic8(e,temp_condition_map)
                                    list_ConcreteValue = getConcreteValue(temp_condition_map)
                                    if len(list_ConcreteValue)==1:
                                        results=AssetionAnalysis5(program_analysis,program_analysis_decl,list_ConcreteValue[0])
                                        if type(results) is str and  'Termination Failed' in results:
                                            print 'Termination Failed'
                                            return
                                        if results is not None and len(results.keys())>0:
                                            print 'VIAP_STANDARD_OUTPUT_False'
                                            #result=AssetionAnalysis3(program_analysis3,program_analysis_decl,file_name,property)
                                            result= AssetionAnalysis3_5(program_analysis3,program_analysis_decl,file_name,property,list_ConcreteValue[0])
                                            if result is not None:
                                                #print "Error Witness Generated"
                                                writtingFile( "errorWitness.graphml" , result )
                                                writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(result)+"\n" )
                                                return
                                            else:
                                                line_no,stmt2 = getLineNumber_terminate('__VERIFIER_error()','main')
                                            
                                                if property is None:
                                                    property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
                                                else:
                                                    if '=' in property:
                                                        value_names=property.split('=')
                                                        fd = open(value_names[1])
                                                        property = "".join(fd.readlines())
                                                    else:
                                                        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
                                            
                                                violation_witness2=''
                                                violation_witness2+="<node id=\"N0\"><data key=\"entry\">true</data></node>\n"
                                                violation_witness2+="<node id=\"N"+str(1)+"\">"+"\n<data key=\"violation\">true</data>\n<data key=\"violatedProperty\">__VERIFIER_error(); called in line "+str(line_no)+"</data>\n"+"</node>\n"
                                                violation_witness2+="<edge source=\"N"+str(0)+"\" target=\"N"+str(1)+"\">\n"
                                                violation_witness2+="<data key=\"sourcecode\">__VERIFIER_error();</data>\n"
                                                violation_witness2+="<data key=\"startline\">"+str(line_no)+"</data>\n"
                                                violation_witness2+="<data key=\"endline\">"+str(line_no)+"</data>\n"
                                                violation_witness2+="</edge>\n"
                                            
                                                hashcode=sha1(file_name)
                                                violation_witness1="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"+"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"+"<key attr.name=\"originFileName\" attr.type=\"string\" for=\"edge\" id=\"originfile\">\n"+"<default>"+filename+"</default>\n"+"</key>\n"+"<key attr.name=\"invariant\" attr.type=\"string\" for=\"node\" id=\"invariant\"/>\n"+"<key attr.name=\"invariant.scope\" attr.type=\"string\" for=\"node\" id=\"invariant.scope\"/>\n"+"<key attr.name=\"namedValue\" attr.type=\"string\" for=\"node\" id=\"named\"/>\n"+"<key attr.name=\"nodeType\" attr.type=\"string\" for=\"node\" id=\"nodetype\">\n"+"<default>path</default>\n"+"</key>"+"<key attr.name=\"isFrontierNode\" attr.type=\"boolean\" for=\"node\" id=\"frontier\">"+"<default>false</default>"+"</key>\n"+"<key attr.name=\"isViolationNode\" attr.type=\"boolean\" for=\"node\" id=\"violation\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isEntryNode\" attr.type=\"boolean\" for=\"node\" id=\"entry\">\n"+"<default>false</default>\n"+"</key>\n"+"<key attr.name=\"isSinkNode\" attr.type=\"boolean\" for=\"node\" id=\"sink\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"isLoopHead\" attr.type=\"boolean\" for=\"node\" id=\"loopHead\">\n"+"<default>false</default>"+"</key>"+"<key attr.name=\"violatedProperty\" attr.type=\"string\" for=\"node\" id=\"violatedProperty\"/>\n"+"<key attr.name=\"threadId\" attr.type=\"string\" for=\"edge\" id=\"threadId\"/>\n"+"<key attr.name=\"sourcecodeLanguage\" attr.type=\"string\" for=\"graph\" id=\"sourcecodelang\"/>\n"+"<key attr.name=\"programFile\" attr.type=\"string\" for=\"graph\" id=\"programfile\"/>\n"+"<key attr.name=\"programHash\" attr.type=\"string\" for=\"graph\" id=\"programhash\"/>\n"+"<key attr.name=\"specification\" attr.type=\"string\" for=\"graph\" id=\"specification\"/>\n"+"<key attr.name=\"memoryModel\" attr.type=\"string\" for=\"graph\" id=\"memorymodel\"/>\n"+"<key attr.name=\"architecture\" attr.type=\"string\" for=\"graph\" id=\"architecture\"/>\n"+"<key attr.name=\"producer\" attr.type=\"string\" for=\"graph\" id=\"producer\"/>\n"+"<key attr.name=\"sourcecode\" attr.type=\"string\" for=\"edge\" id=\"sourcecode\"/>\n"+"<key attr.name=\"startline\" attr.type=\"int\" for=\"edge\" id=\"startline\"/>\n"+"<key attr.name=\"endline\" attr.type=\"int\" for=\"edge\" id=\"endline\"/>\n"+"<key attr.name=\"lineColSet\" attr.type=\"string\" for=\"edge\" id=\"lineCols\"/>\n"+"<key attr.name=\"control\" attr.type=\"string\" for=\"edge\" id=\"control\"/>\n"+"<key attr.name=\"assumption\" attr.type=\"string\" for=\"edge\" id=\"assumption\"/>\n"+"<key attr.name=\"assumption.scope\" attr.type=\"string\" for=\"edge\" id=\"assumption.scope\"/>\n"+"<key attr.name=\"enterFunction\" attr.type=\"string\" for=\"edge\" id=\"enterFunction\"/>\n"+"<key attr.name=\"returnFromFunction\" attr.type=\"string\" for=\"edge\" id=\"returnFrom\"/>"+"<key attr.name=\"predecessor\" attr.type=\"string\" for=\"edge\" id=\"predecessor\"/>\n"+"<key attr.name=\"successor\" attr.type=\"string\" for=\"edge\" id=\"successor\"/>\n"+"<key attr.name=\"witness-type\" attr.type=\"string\" for=\"graph\" id=\"witness-type\"/>\n"+"<graph edgedefault=\"directed\">\n"+"<data key=\"witness-type\">violation_witness</data>\n"+"<data key=\"sourcecodelang\">C</data>"+"<data key=\"producer\">VIAP</data>"+"<data key=\"specification\">"+property+"</data>"+"<data key=\"programfile\">"+filename+"</data>\n"+"<data key=\"programhash\">"+hashcode+"</data>\n"+"<data key=\"memorymodel\">precise</data>\n"+"<data key=\"architecture\">32bit</data>\n"+"\n<node id=\"sink\"><data key=\"sink\">true</data></node>\n"
                                                writtingFile( "errorWitness.graphml" , str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n"))
                                                writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(violation_witness1+violation_witness2+"\n</graph>\n</graphml>\n")+"\n" )                     
                                                return
                    
                                    
                            for vfact in vfacts:
                                #if vfact[0][-1]!='1' and vfact[0]!=fun:
                                if vfact[0][0:len(vfact[0])-1] not in inputvar and vfact[0]!=fun:
                                    vfactsmain.append(vfact)
                                if vfact[0][-1]=='1' and '_FAILED1' in vfact[0]:
                                    vfactsmain.append(vfact)
                            for list_exp in list_exps:
                                status=prove_assert_tactic6(equations,list_exps[list_exp],cycle_list,vfactsmain,witnessXml)
                                if status is not None:
                                    a.append(status)
                            for tassert in assert_list:
                                assert_list_main.append(tassert)
                    
                    #print '--------------------'
                    #print re_equations
                    vfactsmain=axiommain.getVfact()
                    a=axiommain.getOther_axioms()
                    for x in axiommain.getOutput_equations():
                        if '_FAILED' in x:
                            e=axiommain.getOutput_equations()[x][2]
                            #print e
                            addition_equs = prove_assert_tactic7(e,re_equations,cycle_list,vfactsmain,witnessXml)
                            for addition_equ in addition_equs:
                                a.append(addition_equ)
                    
                    axiommain.setOther_axioms(a)
                    axiomeMap['main']=axiommain
                    #print '--------------------'
                program=programclass(file_name, memberfunctionmap , externalvarmap, axiomeMap, witnessXml_map) 
                prove_auto_loop_bound_strategy1(program,property,program_analysis,program_analysis_decl)
                #return program
        else:
        	print 'Error in  Translation'



def normalizeSmallest(left_list_exp,right_list_exp,const):
        
    remove_list=[]
    
    for x in  left_list_exp:
        
        if expr_find(x,const)!=True:
            args=expr_args(x)
            op=expr_op(x)
            if op=='-' and len(args)==1:
                
                right_list_exp.append(args[0])
                
                remove_list.append(x)
                
            else:
                
                right_list_exp.append(eval("['-',"+str(x)+"]"))
                
                remove_list.append(x)
                
    for x in remove_list:
        
        left_list_exp.remove(x)
        
    remove_list=[]
    
    for x in  right_list_exp:
        
        if expr_find(x,const)==True:
            args=expr_args(x)
            op=expr_op(x)
            if op=='-' and len(args)==1:
                
                left_list_exp.append(args[0])
                
                remove_list.append(x)
                
            else:
                
                left_list_exp.append(eval("['-',"+str(x)+"]"))
                
                remove_list.append(x)
                
    for x in remove_list:
        
        right_list_exp.remove(x)
            
    str_left_exps = None

        
    for x in left_list_exp:
        
        if str_left_exps is None:
            
            str_left_exps=str(x)
            
        else:
        
            if x[0]=='-':
                
                str_left_exps="['-',"+str_left_exps+","+str(x[1])+"]"
            
            else:
                
                str_left_exps="['+',"+ str_left_exps+","+str(x)+"]"
                
                
    str_right_exps = None
        
    for x in right_list_exp:
        
        if str_right_exps is None:
            
            str_right_exps=str(x)
            
        else:
        
            if x[0]=='-':
                
                str_right_exps="['-',"+str_right_exps+","+str(x[1])+"]"
            
            else:
                
                str_right_exps="['+',"+str_right_exps+","+str(x)+"]"

    if str_left_exps is not None and str_right_exps is not None:
        left_list_exp = eval(str_left_exps)
        right_list_exp = eval(str_right_exps)
        return left_list_exp, right_list_exp
    else:
        return None, None
        




def collectAllTermsProduct(e,list):
    
    args=expr_args(e)
    op=expr_op(e)

    if len(args)==0:
        if op != '0':
            list.append(e)
        
    else:
        if op in '*' and len(args)==2:
            
            collectAllTermsProduct(args[0],list)
            
            collectAllTermsProduct(args[1],list)
            
        elif op in '/' and len(args)==2:
            
            collectAllTermsProduct(args[0],list)
            
            collectAllTermsProduct(args[1],list)
            
        else:
            
            if e[0]!='0':
    
                list.append(e)





def collectAllTerms(e,list):
    
    args=expr_args(e)
    op=expr_op(e)

    if len(args)==0:
        if op != '0':
            list.append(e)
        
    else:
        if op in '+' and len(args)==2:
            
            collectAllTerms(args[0],list)
            
            collectAllTerms(args[1],list)
            
        elif op in '-' and len(args)==2:
            
            collectAllTerms(args[0],list)
            
            collectAllTerms_Neg(args[1],list)
            
        else:
            
            if e[0]!='0':
    
                list.append(e)



def collectAllTerms_Neg(e,list):
    
    args=expr_args(e)
    op=expr_op(e)

    if len(args)==0:
        if op != '0':
            list.append(eval("['-',"+str(e)+"]"))
    else:
        if op in '+' and len(args)==2:
            
            collectAllTerms_Neg(args[0],list)
            
            collectAllTerms_Neg(args[1],list)
            
        elif op in '-' and len(args)==2:
            
            collectAllTerms_Neg(args[0],list)
            
            collectAllTerms(args[1],list)
            
        else:
            
            if e[0]!='0':
        
                list.append(eval("['-',"+str(e)+"]"))









def isBigNPresent(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if '_N' in op:
            return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
            else:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
                result = isBigNPresent(args[1])
                if result is not None:
                    return result
        elif op=='not' and len(args)==1:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
        elif op=='implies' and len(args)==2:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
                result = isBigNPresent(args[1])
                if result is not None:
                    return result
        elif op == '-' and len(args)==1:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result

        elif op in _infix_op and len(args)==2:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
                result = isBigNPresent(args[1])
                if result is not None:
                    return result

        else:
            if '_N' in op:
                
                return e
    return None        





def isFunctionPresent_Sm(e):
    args=expr_args(e)
    op=expr_op(e)
    
    if op=='and' or op=='or':
        if len(args)==1:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
        else:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
            result = isFunctionPresent_Sm(args[1])
            if result is not None:
                return result
    elif op=='not' and len(args)==1:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
    elif op=='implies' and len(args)==2:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
            result = isFunctionPresent_Sm(args[1])
            if result is not None:
                return result
    elif op == '-' and len(args)==1:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result

    elif op in _infix_op and len(args)==2:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
            result = isFunctionPresent_Sm(args[1])
            if result is not None:
                return result

    else:
        
        if '_N' not in op and len(args)==2:
            
            return e
        
    return None        


def prove_auto_loop_bound_strategy1(program, property, program_analysis, program_analysis_decl):
    start_time = current_milli_time()
    if program is None:
        print 'Something is Wrong'
        return
    if program is not None:
        for name in program.getAxiomeMap():
            axiom = program.getAxiomeMap()[name]
            witnessXml = program.getWitnessXmlMap()[name]
            main_axiom = getAll_Smallest_S0(axiom)
            base_case_values = []
            is_non_det_present=None
            condition_exp_map={}
            for x in axiom.getOther_axioms():
                if x[0] == 'i0':
                    if 'break' not in x[-2][0]:
                        base_case_values.append(x)
                elif x[0] == 'i1':
                    getAllConditionsFesible(x[-1], condition_exp_map)
        
            for ec in condition_exp_map.values():
               if  fun_utiles.isNonDeterminstic(ec) is not None:
                   is_non_det_present=True
        
            condition_exp_map={}
            final_bound_values = []
            list_var_derived_val = {}
            final_complexity = None
            for list in main_axiom:
                for x in list:
                    if x[0] == 's1':
                        isFunPrs = isFunctionPresent_Sm(x[-1][2])
                        if isFunPrs is None:
                            if x[-1][2][0] == '<=' or x[-1][2][0] == '>=':
                                x_new = copy.deepcopy(x[-1][2])
                                x_new = expr_replace(x_new, x[-1][1][1], eval("['-'," + str(x[-1][1][2]) + ",['1']]"))
                                list_right_exp = []
                                list_left_exp = []
                                collectAllTerms(x_new[1], list_right_exp)
                                collectAllTerms(x_new[2], list_left_exp)
                                x_new[1], x_new[2] = normalizeSmallest(list_right_exp, list_left_exp, x[-1][1][2])
                                temp_list = []
                                list_var_derived_val[x[-1][1][1][0]] = expr2string1(x_new[2])
                                temp_list.append(x[-1][1][2])
                                temp_list.append(x_new[1])
                                temp_list.append(x_new[2])
                                final_bound_values.append(temp_list)
                            elif x[-1][2][0] == '<' or x[-1][2][0] == '>':
                                x_new = copy.deepcopy(x[-1][2])
                                x_new = expr_replace(x_new, x[-1][1][1], x[-1][1][2])
                                list_right_exp = []
                                list_left_exp = []
                                collectAllTerms(x_new[1], list_right_exp)
                                collectAllTerms(x_new[2], list_left_exp)
                                x_new[1], x_new[2] = normalizeSmallest(list_right_exp, list_left_exp, x[-1][1][2])
                                temp_list = []
                                list_var_derived_val[x[-1][1][1][0]] = expr2string1(x_new[2])
                                temp_list.append(x[-1][1][2])
                                temp_list.append(x_new[1])
                                temp_list.append(x_new[2])
                                final_bound_values.append(temp_list)

            print
            print
            if len(main_axiom) == len(final_bound_values):
                for x in final_bound_values:
                    var_cstr_map = {}
                    expression = expr2z3(x[-1], var_cstr_map)
                    expression = expr2string1(x[-1])
                    list_var_str = qualifier_list(var_cstr_map.keys())
                    list_cstr_str = cstr_list(var_cstr_map.values())
                    str_list_values = None
                    if list_var_str is not None:
                        for key in list_var_derived_val:
                            if str_list_values is None:
                                str_list_values = list_var_str.replace(key, key + '<' + list_var_derived_val[key])
                            else:
                                str_list_values = str_list_values.replace(key, key + '<' + list_var_derived_val[key])

                    #print '========================'
                    #list_left_exp = []
                    #print x[1]
                    #collectAllTerms(x[1], list_left_exp
                    #for y in list_left_exp:
                    #    list_temps=[]
                    #    collectAllTermsProduct(y,list_temps)
                    #    print list_temps
                    isLog=None
                    left_equ = expr2string1(expr_replace(copy.deepcopy(x[1]), x[0], eval("['_x']")))
                    right_equ = expr2string1(x[2])
                    #print left_equ+"-"+right_equ
                    solution = solve(simplify(left_equ+"-"+right_equ), simplify("_x"))
                    if solution is not None and len(solution)>1 and 'log' in str(solution) and str(solution[0])=='zoo':
                        x, y= fraction(solution[1])
                        if 'log' in str(solution[1]):
                            isLog=str(y)
                            expression=str(solution[1])
                    elif solution is not None and len(solution)==1 and 'log' in str(solution):
                        x, y= fraction(solution[0])
                        if 'log' in str(solution[0]):
                            isLog=str(y)
                            expression=str(solution[0])
                    if isLog is None:
                        print 'Bound - O(' + str(simplify('_n**' + str(max(degree_list(expression))))) + ')'+" of the loop corresponds to loop constant"+expr2string1(x[0])
                    else:
                        print 'Bound - O(' + str(simplify('log(_n**' + str(max(degree_list(expression)))+")/"+isLog)) + ')'
                    
                    if final_complexity is None:
                        if isLog is None:
                            final_complexity = simplify('_n**' + str(max(degree_list(expression))))
                        else:
                            final_complexity = simplify('log(_n**' + str(max(degree_list(expression)))+")/"+isLog)
                    else:
                        if isLog is None:
                            final_complexity = final_complexity * simplify('_n**' + str(max(degree_list(expression))))
                        else:
                            final_complexity = final_complexity * simplify('log(_n**' + str(max(degree_list(expression)))+")/"+isLog)
                    if list_cstr_str is not None:
                        print 'ForAll(' + list_var_str + ',Implies(And(' + list_cstr_str + ',' + str_list_values + '),' + expression + '))'
                    else:
                        print expression
                        
                if final_complexity is None:
                    print "Final Complexity ---- O(1)"
                else:
                    print 'Final Complexity ---- O(' + str(final_complexity) + ')'
            elif is_non_det_present==True:
 
                loop_info_list= []
                
                for i in range(0, len(main_axiom)):
                    x=main_axiom[len(main_axiom)-1-i]
                    condition_map_to_prove = {}
                    equations_map = {}
                    basecase_map = {}
                    var = None
                    constant_list =None
                    rec_equ_list = []
                    smallest_list = []
                    for y in x:
                        if y[0] == 'i1':
                            var = y[-3]
                            rec_equ_list.append(y)
                            equations_map[expr2string1(y[-2])] = y
                        elif y[0] == 'i0':
                            rec_equ_list.append(y)
                            basecase_map[expr2string1(y[-2])] = y
                        elif y[0] == 's0':
                            smallest_list.append(y)
                        elif y[0] == 's1':
                            constant_list = y[1][1][2]
                            smallest_list.append(y)
                    if var is not None and len(rec_equ_list) > 0:
                        condition_exp_map = {}
                        for e in rec_equ_list:
                            getAllConditionsFesible(e[-1], condition_exp_map)
                        else_cond=None
                        for ec in condition_exp_map.values():
                            if else_cond is None:
                                else_cond="['not',"+str(ec)+"]"
                            else:
                                else_cond="['and',"+str(ec)+","+else_cond+"]"
                                
                        else_cond=eval(else_cond)
                        
                        condition_exp_map[expr2string1(else_cond)] = else_cond
                        
                        list_of_info=[]
                        
                        list_of_info.append(rec_equ_list) #0 - Non break equations
                        
                        list_of_info.append(smallest_list)#1 - Non Break Condition
                        
                        list_of_info.append(condition_exp_map) #2 - Conditional Map
                        
                        list_of_info.append(var) #3 - Variable
                        
                        list_of_info.append(constant_list) #4 - Constant
                        
                        loop_info_list.append(list_of_info)
                        
                for i in range(0, len(loop_info_list)):
                    
                    all_solution_information = caseAnalysisFindTheComplexity2(loop_info_list, len(loop_info_list)-1-i, axiom) 
                    
                    if all_solution_information is not None:
                        
                        final_values=[]
                        
                        for x in all_solution_information:
                                
                            for y in x[1]:
                                main_condition_list=[]
                                
                                if y[0]=='s0':
                                
                                    condition_list=[]
                                
                                    getAllConditionFromS0(y[-1], condition_list)
                                
                                    for  z in condition_list:
                                        #constraint_list=[]
                                        #constraint_list
                                    
                                        if expr_find(z,loop_info_list[len(loop_info_list)-1-i][4] )==True:
                                        
                                            main_condition_list.append(z)
                                if len(main_condition_list)>0:
                                    for ec in x[1]:
                                        if ec[0]!='s0' and ec[0]!='s1':
                                            print 'Case'
                                            print  wff2z3_update(eval("['a',"+str(ec)+"]"))
                                for x in main_condition_list:
                                    if x[0]=='>' or x[0]=='<' or x[0]=='!=':
                                        x = expr_replace(x, loop_info_list[len(loop_info_list)-1-i][4], eval("['-',"+str(loop_info_list[len(loop_info_list)-1-i][4])+",['1']]"))
                                        #print expr2string1(x)
                                        x_new = copy.deepcopy(x)
                                        list_right_exp = []
                                        list_left_exp = []
                                        collectAllTerms(x_new[1], list_right_exp)
                                        collectAllTerms(x_new[2], list_left_exp)
                                        x_new[1], x_new[2] = normalizeSmallest(list_right_exp, list_left_exp, loop_info_list[len(loop_info_list)-1-i][4])
                                        if x_new[1] is not None and x_new[2] is not None:
                                            left_equ = expr2string1(expr_replace(copy.deepcopy(x_new[1]), loop_info_list[len(loop_info_list)-1-i][4], eval("['_x']")))
                                            right_equ = expr2string1(expr_replace(copy.deepcopy(x_new[2]), loop_info_list[len(loop_info_list)-1-i][4], eval("['_x']")))
                                            solution = solve(simplify(left_equ+"-"+right_equ), simplify("_x"))
                                            if solution is not None and len(solution)>1 and 'log' in str(solution) and str(solution[0])=='zoo':
                                                xx, yy= fraction(solution[1])
                                                #print x
                                                #print y
                                                if 'log' in str(solution[1]):
                                                    isLog=str(yy)
                                                    expression=str(solution[1])
                                                    print 'Bound - O(' + str(simplify("log(_n)/"+isLog)) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                    print 
                                                    print expression
                                                    final_values.append(simplify("log(_n)/"+isLog))

                                            elif solution is not None and len(solution)==1 and 'log' in str(solution):
                                                xx, yy= fraction(solution[0])
                                                #print x
                                                #print y
                                                if 'log' in str(solution[0]):
                                                    isLog=str(yy)
                                                    expression=str(solution[0])
                                                    print 'Bound - O(' + str(simplify("log(_n)/"+isLog)) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                    print 
                                                    print expression
                                                    final_values.append(simplify("log(_n)/"+isLog))
                                        else:
                                            #isLog=None
                                            left_equ = expr2string1(expr_replace(copy.deepcopy(x[1]), loop_info_list[len(loop_info_list)-1-i][4], eval("['_x']")))
                                            right_equ = expr2string1(expr_replace(copy.deepcopy(x[2]), loop_info_list[len(loop_info_list)-1-i][4], eval("['_x']")))
                                            #print left_equ+"-"+right_equ
                                            solution = solve(simplify(left_equ+"-"+right_equ), simplify("_x"))
                                            #print solution
                                            if solution is not None and len(solution)>1 and 'log' in str(solution) and str(solution[0])=='zoo':
                                                xx, yy= fraction(solution[1])
                                                #print x
                                                #print y
                                                if 'log' in str(solution[1]):
                                                    isLog=str(yy)
                                                    expression=str(solution[1])
                                                    print 'Bound - O(' + str(simplify("log(_n)/"+isLog)) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                    print 
                                                    print expression
                                                    final_values.append(simplify("log(_n)/"+isLog))

                                            elif solution is not None and len(solution)==1 and 'log' in str(solution):
                                                xx, yy= fraction(solution[0])
                                                #print x
                                                #print y
                                                if 'log' in str(solution[0]):
                                                    isLog=str(y)
                                                    expression=str(solution[0])
                                                    print 'Bound - O(' + str(simplify("log(_n)/"+isLog)) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                    print 
                                                    print expression
                                                    final_values.append(simplify("log(_n)/"+isLog))

                                            elif solution is not None and len(solution)==1 and 'log'not  in str(solution):
                                                print 'Bound - O(' + str(simplify("_n**"+str(max(degree_list(solution[0]))))) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                print 
                                                print expression
                                                final_values.append(simplify("_n**"+str(max(degree_list(solution[0])))))


                                    elif x[0]=='>=' or x[0]=='<=' or x[0]=='==':
                                        
                                        x = expr_replace(x, loop_info_list[len(loop_info_list)-1-i][4], eval("['-',"+str(loop_info_list[len(loop_info_list)-1-i][4])+",['1']]"))
                                        #print expr2string1(x)
                                        x_new = copy.deepcopy(x)
                                        list_right_exp = []
                                        list_left_exp = []
                                        collectAllTerms(x_new[1], list_right_exp)
                                        collectAllTerms(x_new[2], list_left_exp)
                                        x_new[1], x_new[2] = normalizeSmallest(list_right_exp, list_left_exp, loop_info_list[len(loop_info_list)-1-i][4])
                                        if x_new[1] is not None and x_new[2] is not None:
                                            left_equ = expr2string1(expr_replace(copy.deepcopy(x_new[1]), loop_info_list[len(loop_info_list)-1-i][4], eval("['_x']")))
                                            right_equ = expr2string1(expr_replace(copy.deepcopy(x_new[2]), loop_info_list[len(loop_info_list)-1-i][4], eval("['_x']")))
                                            solution = solve(simplify(left_equ+"-"+right_equ), simplify("_x"))
                                            if solution is not None and len(solution)>1 and 'log' in str(solution) and str(solution[0])=='zoo':
                                                xx, yy= fraction(solution[1])
                                                #print x
                                                #print y
                                                if 'log' in str(solution[1]):
                                                    isLog=str(yy)
                                                    expression=str(solution[1])
                                                    print 'Bound - O(' + str(simplify("log(_n)/"+isLog)) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                    print 
                                                    print expression
                                                    final_values.append(simplify("log(_n)/"+isLog))

                                            elif solution is not None and len(solution)==1 and 'log' in str(solution):
                                                xx, yy= fraction(solution[0])
                                                #print x
                                                #print y
                                                if 'log' in str(solution[0]):
                                                    isLog=str(yy)
                                                    expression=str(solution[0])
                                                    print 'Bound - O(' + str(simplify("log(_n)/"+isLog)) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                    print 
                                                    print expression
                                                    final_values.append(simplify("log(_n)/"+isLog))

                                        else:
                                            #isLog=None
                                            left_equ = expr2string1(expr_replace(copy.deepcopy(x[1]), loop_info_list[len(loop_info_list)-1-i][4], eval("['_x']")))
                                            right_equ = expr2string1(expr_replace(copy.deepcopy(x[2]), loop_info_list[len(loop_info_list)-1-i][4], eval("['_x']")))
                                            #print left_equ+"-"+right_equ
                                            solution = solve(simplify(left_equ+"-"+right_equ), simplify("_x"))
                                            #print solution
                                            if solution is not None and len(solution)>1 and 'log' in str(solution) and str(solution[0])=='zoo':
                                                xx, yy= fraction(solution[1])
                                                #print x
                                                #print y
                                                if 'log' in str(solution[1]):
                                                    isLog=str(yy)
                                                    expression=str(solution[1])
                                                    print 'Bound - O(' + str(simplify("log(_n)/"+isLog)) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                    print 
                                                    print expression
                                                    final_values.append(simplify("log(_n)/"+isLog))

                                            elif solution is not None and len(solution)==1 and 'log' in str(solution):
                                                xx, yy= fraction(solution[0])
                                                #print x
                                                #print y
                                                if 'log' in str(solution[0]):
                                                    isLog=str(y)
                                                    expression=str(solution[0])
                                                    print 'Bound - O(' + str(simplify("log(_n)/"+isLog)) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                    print 
                                                    print expression
                                                    final_values.append(simplify("log(_n)/"+isLog))

                                            elif solution is not None and len(solution)==1 and 'log'not  in str(solution):
                                                print 'Bound - O(' + str(simplify("_n**"+str(max(degree_list(solution[0]))))) + ')'+" of the loop corresponds to loop constant"+expr2string1(loop_info_list[len(loop_info_list)-1-i][4])
                                                print 
                                                print expression
                                                final_values.append(simplify("_n**"+str(max(degree_list(solution[0])))))

                        max_value=simplify(1)
                        for x in final_values:
                            degree_max=None
                            degree_x=None
                            if 'log' not in str(max_value) :
                                degree_max= degree(max_value, simplify("_n"))
                            else:
                                degree_max=0 
                                
                            if 'log' not in str(x) :
                                degree_max= degree(x, simplify("_n"))
                            else:
                                degree_max=0 
                            if degree_max>=degree_x:
                                max_value = x
                        print 
                        print 'Final Complexity ---- O(' + str(max_value) + ')'

 

            
            else:
                main_equation_map = {}
                new_close_formed_list = None
                loop_info_list= []
                constant_list=None
                best_case_map={}
                #all_base_list=[]
                for i in range(0, len(main_axiom)):
                    x=main_axiom[len(main_axiom)-1-i]
                    condition_map_to_prove = {}
                    break_conditon_map = {}
                    non_break_conditon = []
                    equations_map = {}
                    basecase_map = {}
                    var = None
                    rec_equ_list = []
                    smallest_list = []
                    break_flag_list = {}
                    
                    for y in x:
                        if y[0] == 'i1':
                            if 'break_' in y[-2][0]:
                                condition_list = []
                                getBreakConditions(y[-1], condition_list)
                                break_conditon_map[y[-2][0]] = condition_list
                            else:
                                var = y[-3]
                                getNoneBreakConditions(y[-1], non_break_conditon)
                                rec_equ_list.append(y)
                                equations_map[expr2string1(y[-2])] = y
                        elif y[0] == 'i0':
                            if 'break_' not in y[-2][0]:
                                rec_equ_list.append(y)
                                basecase_map[expr2string1(y[-2])] = y
                                #all_base_list.append(copy.deepcopy(y))
                                #print wff2string1(y)
                        elif y[0] == 's0':
                            getAllConditionFromS0(y[-1], smallest_list)
                            for ee in smallest_list:
                                if 'break_' in ee[1][0]:
                                    break_flag_list[ee[1][0]]=ee
                                    smallest_list.remove(ee)
                        elif y[0] == 's1':
                            constant_list = y[1][1][2]
                    
                    if var is not None and len(rec_equ_list) > 0:
                        condition_exp_map = {}
                        for e in rec_equ_list:
                            getAllConditionsFesible(e[-1], condition_exp_map)
                        for ec in condition_exp_map.values():
                            status = False
                            for eb in break_conditon_map:
                                if ec in break_conditon_map[eb]:
                                    status = True

                            if status == False:
                                condition_map_to_prove[expr2string1(ec)] = ec
                                
                        list_break_return=[]
                                        
                        list_break_non_return=[]
                                        
                        for ee in break_conditon_map:
                                            
                            for eec in break_conditon_map[ee]:
                                                
                                status=False
                                                
                                for eec_t in non_break_conditon:
                                                    
                                    if eec ==eec_t:
                                                        
                                        status=True
                                                        
                                if status==True:
                                                    
                                    list_break_non_return.append(eec)
                                                    
                                else:
                                                    
                                    list_break_return.append(eec)


                        if i==(len(main_axiom)-1):
                            list_of_info=[]
                            list_of_info.append(rec_equ_list) #0 - Non break equations
                            list_of_info.append(smallest_list)#1 - Non Break Condition
                            list_of_info.append(break_flag_list) #2 - Break Condition
                            list_of_info.append(break_conditon_map) #3 - Break Recurnsive Equation
                            list_of_info.append(non_break_conditon) #4 - Non Break Condition
                            list_of_info.append(condition_map_to_prove) #5 - Conditional Map
                            list_of_info.append(var) #6 - Variable
                            list_of_info.append(constant_list) #7 - Constant
                            list_of_info.append(list_break_non_return)# 8
                            list_of_info.append(list_break_return)#9
                            loop_info_list.append(list_of_info)
                            #caseAnalysisFindTheComplexity(loop_info_list, i, axiom)
                        else:
                            list_of_info=[]
                            list_of_info.append(rec_equ_list) #0 - Non break equations
                            list_of_info.append(smallest_list)#1 - Non Break Condition
                            list_of_info.append(break_flag_list) #2 - Break Condition
                            list_of_info.append(break_conditon_map) #3 - Break Recurnsive Equation
                            list_of_info.append(non_break_conditon) #4 - Non Break Condition
                            list_of_info.append(condition_map_to_prove) #5 - Conditional Map
                            list_of_info.append(var) #6 - Variable
                            list_of_info.append(constant_list) #7 - Constant
                            list_of_info.append(list_break_non_return)#8
                            list_of_info.append(list_break_return)#9
                            loop_info_list.append(list_of_info)


                list_of_break = []
                for i in range(0, len(loop_info_list)):
                    
                    all_solution_information = caseAnalysisFindTheComplexity(loop_info_list, len(loop_info_list)-1-i, axiom) 
                    if len(loop_info_list[len(loop_info_list)-1-i][-1])>0 and len(loop_info_list[len(loop_info_list)-1-i][-1][-1])>0:
                        break_result = loop_info_list[len(loop_info_list)-1-i][-1][-1][-1]
                        if 'break_' in break_result:
                            list_of_break.append(break_result)
                    #list_of_break
                    if  all_solution_information is not  None:
                        list_of_info = loop_info_list[len(loop_info_list)-1-i]
                        
                        ec_rec_equ_list  = list_of_info[0]
                        constraint_list = []
                        for x_solution_information in all_solution_information:
                            x_solution_list = x_solution_information[0]
                            x_smallest_con_list = x_solution_information[1]
                            eq_smallest=[]
                            complexity_list=[]
                            for j in range(0, len(list_of_info[1])):
                                if 'break_' not in expr2string1(list_of_info[1][j]):
                                    eq_smallest .append(copy.deepcopy(list_of_info[1][j]))
                                    
                            for x in x_smallest_con_list:
                                if x[0]=='i2':
                                    if '_n'in x[-2][1][0]:
                                        if x[-3] in expr2string1(x[-1]) or '_CE' in expr2string1(x[-1]):
                                            if x[-3] not in complexity_list:
                                                complexity_list.append(x[-3])
                                else:
                                    if len(x)==3 and len(x[1])==3 and len(x[1][1])==3 and len(x[1][1][2])>0:
                                        if '_n' in x[1][1][2][0] and x[1][1][2][0]  not in complexity_list :
                                            complexity_list.append(x[1][1][2][0])
 
                                    

                            
                            for x in x_solution_list:
                                if x[0]=='i2':
                                    if '_N'in x[-2][1][0]:
                                        for j in range(0, len(eq_smallest)):
                                            eq_smallest[j] = expr_replace(eq_smallest[j] , x[-2], x[-1])
                                    else:
                                        if x[-3] in expr2string1(x[-1]) or '_CE' in expr2string1(x[-1]):
                                            if x[-3] not in complexity_list:
                                                complexity_list.append(x[-3])

                            for p_e in ec_rec_equ_list:
                                
                                constraint_list.append(wff2z3_update(p_e))
                            
                            main_status=None
                            
                            for j in range(0, len(eq_smallest)):
                                
                                status = query2z3_update(constraint_list, wff2z3_update(eval("['a',"+str(eq_smallest[j] )+"]")), axiom.getVfact(), '')
                            
                                if 'Successfully Proved' in status:
                                    status=True
                                else:
                                    status=False
                                    
                                if main_status is None:
                                    main_status=status
                                else:
                                    main_status=main_status&status

                            if main_status==False:
                                final_value=simplify("1")
                                for cv in complexity_list:
                                    print 'Bound - O(' + str(simplify('_n**' + str(max(degree_list(simplify(cv)))))) + ')'+" of the loop corresponds to loop constant"+axiom.getConst_var_map()[cv]
                                    final_value=simplify(str(final_value)+"*n")
                                    axiom.getConst_var_map()
                                print 
                                print
                                print 'Detected Scenario is as follows-'
                                for x in x_smallest_con_list:
                                    if x[0]=='i2':
                                        if '_N'in x[-2][1][0]:
                                            print expr2string1(x[-2])+"="+expr2string1(x[-1])
                                    else:
                                        print expr2string1(x)
                                for x in x_solution_list:
                                    if '_N'in x[-2][1][0]:
                                        print expr2string1(x[-2])+"="+expr2string1(x[-1])
                                for a in axiom.getOutput_equations():
                                    if 'break_' not in a:
                                        e=axiom.getOutput_equations()[a]
                                        for x in x_solution_list:
                                            if '_N'in x[-2][1][0]:
                                                e[-1] = expr_replace(e[-1], x[-2], x[-1])
                                        print wff2string1(e)
                                    else:
                                        for y in list_of_break:
                                            if a in y:
                                                e=axiom.getOutput_equations()[a]
                                                e[-1]=eval("['1']")
                                                print wff2string1(e)
                                print
                                print 'Final Complexity ---- O(' + str(final_value) + ')'

                            #else:
                             #   print complexity_list
                                

                                

                

def caseAnalysisFindTheComplexity(loop_info_list, index, axiom):
    
    list_of_info = loop_info_list[index]
    
    
    condition_map_to_prove = list_of_info[5]
    
    list_break_non_return = list_of_info[8]
    
    list_break_return  = list_of_info[9]
    
    x_break_conditon_map = list_of_info[3]
        
    temp_all_solution_information =None
    
    if len(list_of_info)==11:
        
        temp_all_solution_information = list_of_info[10]
        
    
    ec_rec_equ_list  = list_of_info[0]
    
    var = list_of_info[6]
    
    const_list = list_of_info[7]
    
    const_in = copy.deepcopy(const_list)
    
    const_in[0]=const_in[0].replace('_N','_CE')
    
    variables_list=[]
    
    constant_list=[]
    
    constraint_list=[]
    
    base_values={}
    
    all_solution_information=[]
    
    for e in loop_info_list:
        
        variables_list.append(e[6])
        
        constant_list.append(e[7])
        
        
        for p_e in e[0]:
                                        
            constraint_list.append(wff2z3_update(p_e))
            
    if len(condition_map_to_prove) > 0:
                
        for key in condition_map_to_prove:
            
            list_seq_cond = []
                                
            ec = condition_map_to_prove[key]
                                
            ec_base= copy.deepcopy(ec)
                                
            ec_base = expr_replace(ec_base, eval("['" + var + "']"), eval("['0']"))
                                
            for p_var in variables_list:
                                    
                ec_base = expr_replace(ec_base, eval("['" + p_var + "']"), eval("['0']"))
                                    
                                        
            status = query2z3_update(constraint_list, wff2z3_update(eval("['a',"+str(ec_base)+"]")), axiom.getVfact(), '')
 
            if 'Successfully Proved' in status:
                
                if temp_all_solution_information is  None:
                
                    ec_rec_equ_list1 =[]
                
                    for e in ec_rec_equ_list:

                        e_new = copy.deepcopy(e)
                
                        result = getTheExpressionCond(e_new[-1], ec)
                                        
                        if result is not None:
                                            
                            e_new[-1] = result
                            
                        else:
                            if e_new[0]=='i1':
                                            
                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                            
                                ec_rec_equ_list2.append(e_new)

                        
                        ec_rec_equ_list1.append(e_new)
                                            
                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                    

                    
                    if len(results)==0:
                    
                        solution_list=[]
                    
                        solution_list_init=[]
                    
                        e_c_s1=eval("['implies',"+"['and',"+"['<=',['0'],['"+var+"']],"+"['<',['"+var+"'],"+str(const_in)+"]"+"],"+str(ec)+"]")
                    
                        #print  expr2string1(e_c_s1)   
                    
                        e_c_s2=expr_complement(copy.deepcopy(ec))
                    
                        e_c_s2 =expr_replace(e_c_s2, eval("['" + var + "']"), const_in)
                    
                        #print  expr2string1(e_c_s2)

                    
                        for key in soln_map:
                        
                            e_sol = copy.deepcopy(soln_map[key])
                        
                            e_sol_cont = copy.deepcopy(soln_map[key])
                                                
                            e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                            e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                
                            solution_list.append(soln_map[key])
                        
                            solution_list.append(e_sol)
                        
                            e_sol_cont[-2] = expr_replace(e_sol_cont[-2], eval("['" + var + "']"),  eval("['0']"))
                        
                            e_sol_cont[-1] = expr_replace(e_sol_cont[-1], eval("['" + var + "']"), const_in)
                        
                            e_sol_cont= eval("['i0',0,"+str(e_sol_cont[-2] )+","+str(e_sol_cont[-1] )+"]")
                        
                            solution_list_init.append(e_sol_cont)
                        
                        #Check for None Return Condition
                        if len(solution_list_init)>0:
        
                            for e_c in list_break_non_return:
                            
                                solution_information=[]
                            
                                solution_list=[]
                            
                                smallest_con_list=[]
                            
                                ec_rec_equ_list2 =[]
                
                                for e in ec_rec_equ_list:
                    
                                    e_new = copy.deepcopy(e)
                
                                    result = getTheExpressionCond(e_new[-1], e_c)
                                        
                                    if result is not None:
                                            
                                        e_new[-1] = result
                                
                                        ec_rec_equ_list2.append(e_new)
                                        
                                    else:
                                        
                                        if e_new[0]=='i1':
                                            
                                            e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                            
                                            ec_rec_equ_list2.append(e_new)
                                    
                                    
                                for e in solution_list_init:
                                
                                    e_new = copy.deepcopy(e)
                                
                                    ec_rec_equ_list2.append(e_new)
                                    
                                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list2)

                                for key in soln_map:
                                    
                                    soln_map[key][-1] = expr_replace(soln_map[key][-1], eval("['" + var + "']"), eval("['1']"))
                                    
                                    e_sol = copy.deepcopy(soln_map[key])
                                                                        
                                    e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                    e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)

                                    solution_list.append(soln_map[key])
                                    solution_list.append(e_sol)
                            
                                e_c_s3=copy.deepcopy(e_c)
                    
                                e_c_s3 =expr_replace(e_c_s3, eval("['" + var + "']"), const_in)
                            
                                smallest_con_list.append(e_c_s1)
                            
                                smallest_con_list.append(e_c_s2)
                            
                                smallest_con_list.append(e_c_s3)
                                
                                smallest_con_list.append(eval("['==',"+str(const_list)+",['+',"+str(const_in)+",['1']]]"))
                            
                                solution_information.append(solution_list)
                            
                                solution_information.append(smallest_con_list)
                                
                                solution_information.append(getBreakFunctionName(x_break_conditon_map, e_c))
                            
                            
                                all_solution_information.append(solution_information)
                else:
                    for x_solution_information in temp_all_solution_information:
                        
                        x_solution_list = x_solution_information[0]
                        
                        x_smallest_con_list = x_solution_information[1]    
                
                        ec_rec_equ_list1 =[]
                
                        for e in ec_rec_equ_list:
                    
                            e_new = copy.deepcopy(e)
                
                            result = getTheExpressionCond(e_new[-1], ec)
                                        
                            if result is not None:
                                
                                for x in x_solution_list:
                                    
                                    result =expr_replace(result, x[-2], x[-1])
                                            
                                e_new[-1] = result
                            else:
                                    if e_new[0]=='i1':
                                            
                                        e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                            ec_rec_equ_list1.append(e_new)
                                            
                        results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                
                        if len(results)==0:
                    
                            solution_list=[]
                    
                            solution_list_init=[]
                    
                            e_c_s1=eval("['implies',"+"['and',"+"['<=',['0'],['"+var+"']],"+"['<',['"+var+"'],"+str(const_in)+"]"+"],"+str(ec)+"]")
                    
                            #print  expr2string1(e_c_s1)   
                    
                            e_c_s2=expr_complement(copy.deepcopy(ec))
                    
                            e_c_s2 =expr_replace(e_c_s2, eval("['" + var + "']"), const_in)
                    
                            #print  expr2string1(e_c_s2)

                    
                            for key in soln_map:
                        
                                e_sol = copy.deepcopy(soln_map[key])
                        
                                e_sol_cont = copy.deepcopy(soln_map[key])
                                                
                                e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                
                                solution_list.append(soln_map[key])
                        
                                solution_list.append(e_sol)
                        
                                e_sol_cont[-2] = expr_replace(e_sol_cont[-2], eval("['" + var + "']"),  eval("['0']"))
                        
                                e_sol_cont[-1] = expr_replace(e_sol_cont[-1], eval("['" + var + "']"), const_in)
                        
                                e_sol_cont= eval("['i0',0,"+str(e_sol_cont[-2] )+","+str(e_sol_cont[-1] )+"]")
                        
                                solution_list_init.append(e_sol_cont)
                        
                            #Check for None Return Condition
                            if len(solution_list_init)>0:
        
                                for e_c in list_break_non_return:
                            
                                    solution_information=[]
                            
                                    solution_list=[]
                            
                                    smallest_con_list=[]
                            
                                    ec_rec_equ_list2 =[]
                
                                    for e in ec_rec_equ_list:
                    
                                        e_new = copy.deepcopy(e)
                
                                        result = getTheExpressionCond(e_new[-1], e_c)
                                        
                                        if result is not None:
                                            
                                            for x in x_solution_list:
                                                
                                                result =expr_replace(result, x[-2], x[-1])

                                                
                                            e_new[-1] = result
                                
                                            ec_rec_equ_list2.append(e_new)
                                            
                                        else:
                                            if e_new[0]=='i1':
                                                
                                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                                
                                                ec_rec_equ_list2.append(e_new)
                                            
                                    
                                    for e in solution_list_init:
                                
                                        e_new = copy.deepcopy(e)
                                
                                        ec_rec_equ_list2.append(e_new)
                                
                                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list2)
                            
                                    for key in soln_map:
                                
                                        soln_map[key][-1] = expr_replace(soln_map[key][-1], eval("['" + var + "']"), eval("['1']"))
                                        
                                        e_sol = copy.deepcopy(soln_map[key])
                                                                        
                                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)

                                        solution_list.append(soln_map[key])
                                
                                        solution_list.append(e_sol)
                            
                                    e_c_s3=copy.deepcopy(e_c)
                    
                                    e_c_s3 =expr_replace(e_c_s3, eval("['" + var + "']"), const_in)
                            
                                    smallest_con_list.append(e_c_s1)
                            
                                    smallest_con_list.append(e_c_s2)
                            
                                    smallest_con_list.append(e_c_s3)
                                    
                                    smallest_con_list.append(eval("['==',"+str(const_list)+",['+',"+str(const_in)+",['1']]]"))
                                    
                            
                                    solution_information.append(solution_list)
                            
                                    solution_information.append(smallest_con_list+x_smallest_con_list+x_solution_list)
                                    
                                    solution_information.append(getBreakFunctionName(x_break_conditon_map, e_c))
                            
                                    all_solution_information.append(solution_information)

            else:
                if temp_all_solution_information is  None:
                    
                    init_count = 0
                    
                    ec_rec_equ_list1 =[]
                
                    for e in ec_rec_equ_list:
                    
                        e_new = copy.deepcopy(e)
                
                        result = getTheExpressionCond(e_new[-1], ec)
                                        
                        if result is not None:
                                            
                            e_new[-1] = result
                        
                        else:
                        
                            if e_new[0]=='i0':
                            
                                init_count = init_count+1
                            
                                base_values["_CV"+str(init_count)] = e_new[-1] 

                                e_new[-1] = eval("['_CV"+str(init_count)+"']")
                                
                            if e_new[0]=='i1':
                                
                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                            
                        
                        ec_rec_equ_list1.append(e_new)
                                            
                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                
                    if len(results)==0:
                    
                        solution_list=[]
                    
                        solution_list_init=[]
                    
                        e_c_s1=eval("['implies',"+"['and',"+"['<=',['0'],['"+var+"']],"+"['<',['"+var+"'],"+str(const_in)+"]"+"],"+str(ec)+"]")
                    
                        #print  expr2string1(e_c_s1)   
                    
                        e_c_s2=expr_complement(copy.deepcopy(ec))
                    
                        e_c_s2 =expr_replace(e_c_s2, eval("['" + var + "']"), const_in)
                    
                        #print  expr2string1(e_c_s2)

                    
                        for key in soln_map:
                        
                            e_sol = copy.deepcopy(soln_map[key])
                        
                            e_sol_cont = copy.deepcopy(soln_map[key])
                                                
                            e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                            e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                
                            solution_list.append(soln_map[key])
                        
                            solution_list.append(e_sol)
                        
                            e_sol_cont[-2] = expr_replace(e_sol_cont[-2], eval("['" + var + "']"),  eval("['0']"))
                        
                            e_sol_cont[-1] = expr_replace(e_sol_cont[-1], eval("['" + var + "']"), const_in)
                        
                            e_sol_cont= eval("['i0',0,"+str(e_sol_cont[-2] )+","+str(e_sol_cont[-1] )+"]")
                        
                            solution_list_init.append(e_sol_cont)
                
                            #print  expr2string1(soln_map[key][-1])
                            #print  expr2string1(e_sol[-1])
                            #print  expr2string1(e_sol_cont[-1])
                        
                        #Check for None Return Condition
                        if len(solution_list_init)>0:
                            
                            for e_c in list_break_non_return:
                            
                                solution_information=[]
                            
                                solution_list=[]
                            
                                smallest_con_list=[]
                            
                                ec_rec_equ_list2 =[]
                
                                for e in ec_rec_equ_list:
                    
                                    e_new = copy.deepcopy(e)
                
                                    result = getTheExpressionCond(e_new[-1], e_c)
                                        
                                    if result is not None:
                                            
                                        e_new[-1] = result
                                
                                        ec_rec_equ_list2.append(e_new)
                                    
                                for e in solution_list_init:
                                
                                    e_new = copy.deepcopy(e)
                                
                                    ec_rec_equ_list2.append(e_new)
                                
                                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list2)
                                
                                for key in soln_map:
                                
                    
                                
                                    soln_map[key][-1] = expr_replace(soln_map[key][-1], eval("['" + var + "']"), eval("['1']"))
                                    
                                    e_sol = copy.deepcopy(soln_map[key])
                                                                        
                                    e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                    e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)

                                    solution_list.append(soln_map[key])
                                
                                    solution_list.append(e_sol)
                            
                                e_c_s3=copy.deepcopy(e_c)
                    
                                e_c_s3 =expr_replace(e_c_s3, eval("['" + var + "']"), const_in)
                                
                            
                                smallest_con_list.append(e_c_s1)
                            
                                smallest_con_list.append(e_c_s2)
                            
                                smallest_con_list.append(e_c_s3)
                                
                                smallest_con_list.append(eval("['==',"+str(const_list)+",['+',"+str(const_in)+",['1']]]"))
                                
                                #smallest_con_list.append(ec_base)
                                

                            
                                solution_information.append(solution_list)
                                
                                solution_information.append(smallest_con_list)
                                
                                solution_information.append(getBreakFunctionName(x_break_conditon_map, e_c))
                                
                                
                            
                                all_solution_information.append(solution_information)
                else:
                    
                     for x_solution_information in temp_all_solution_information:
                        
                        init_count = 0
                        
                        x_solution_list = x_solution_information[0]
                        
                        x_smallest_con_list = x_solution_information[1]    
                       
                        ec_rec_equ_list1 =[]
                
                        for e in ec_rec_equ_list:
                    
                            e_new = copy.deepcopy(e)
                                                    
                            result = getTheExpressionCond(e_new[-1], ec)
                        
                                        
                            if result is not None:
                                
                                for x in x_solution_list:
                                
                                    result =expr_replace(result, x[-2], x[-1])
                                            
                                e_new[-1] = result
                        
                            else:
                                #Need to Plug more path
                                #if e_new[0]=='i0':
                            
                                #    init_count = init_count+1
                            
                                #    base_values["_CV"+str(init_count)] = e_new[-1] 

                                #    e_new[-1] = eval("['_CV"+str(init_count)+"']")
                                    
                                if e_new[0]=='i1':
                                    
                                    e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                            #print wff2string1(e_new)
                            ec_rec_equ_list1.append(e_new)
                        
                        results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
            
                        if len(results)==0:
                    
                            solution_list=[]
                    
                            solution_list_init=[]
                    
                            e_c_s1=eval("['implies',"+"['and',"+"['<=',['0'],['"+var+"']],"+"['<',['"+var+"'],"+str(const_in)+"]"+"],"+str(ec)+"]")
                    
                            #print  expr2string1(e_c_s1)   
                    
                            e_c_s2=expr_complement(copy.deepcopy(ec))
                    
                            e_c_s2 =expr_replace(e_c_s2, eval("['" + var + "']"), const_in)
                    
                            #print  expr2string1(e_c_s2)

                    
                            for key in soln_map:
                        
                                e_sol = copy.deepcopy(soln_map[key])
                        
                                e_sol_cont = copy.deepcopy(soln_map[key])
                                                
                                e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                
                                solution_list.append(soln_map[key])
                        
                                solution_list.append(e_sol)
                        
                                e_sol_cont[-2] = expr_replace(e_sol_cont[-2], eval("['" + var + "']"),  eval("['0']"))
                        
                                e_sol_cont[-1] = expr_replace(e_sol_cont[-1], eval("['" + var + "']"), const_in)
                        
                                e_sol_cont= eval("['i0',0,"+str(e_sol_cont[-2] )+","+str(e_sol_cont[-1] )+"]")
                        
                                solution_list_init.append(e_sol_cont)
                
                                #print  expr2string1(soln_map[key][-1])
                                #print  expr2string1(e_sol[-1])
                                #print  expr2string1(e_sol_cont[-1])
                        
                            #Check for None Return Condition
                            if len(solution_list_init)>0:
                            
                                for e_c in list_break_non_return:
                            
                                    solution_information=[]
                            
                                    solution_list=[]
                            
                                    smallest_con_list=[]
                            
                                    ec_rec_equ_list2 =[]
                
                                    for e in ec_rec_equ_list:

                                        e_new = copy.deepcopy(e)
                
                                        result = getTheExpressionCond(e_new[-1], e_c)
                                        
                                        if result is not None:
                                            
                                            for x in x_solution_list:
                                                
                                                result =expr_replace(result, x[-2], x[-1])
                                                
                                            e_new[-1] = result
                                            
                                            ec_rec_equ_list2.append(e_new)
                                            
                                        else:
                                            if e_new[0]=='i1':
                                            
                                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                                
                                                ec_rec_equ_list2.append(e_new)

                                    
                                    for e in solution_list_init:
                                
                                        e_new = copy.deepcopy(e)
                                
                                        ec_rec_equ_list2.append(e_new)
                                
                                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list2)
                                    
                                    for key in soln_map:
                                
                                        soln_map[key][-1] = expr_replace(soln_map[key][-1], eval("['" + var + "']"), eval("['1']"))
                                        
                                        e_sol = copy.deepcopy(soln_map[key])
                                                                        
                                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)

                                        solution_list.append(soln_map[key])
                                
                                        solution_list.append(e_sol)
                            
                                    e_c_s3=copy.deepcopy(e_c)
                    
                                    e_c_s3 =expr_replace(e_c_s3, eval("['" + var + "']"), const_in)
                            
                                    smallest_con_list.append(e_c_s1)
                            
                                    smallest_con_list.append(e_c_s2)
                            
                                    smallest_con_list.append(e_c_s3)
                                    
                                    smallest_con_list.append(eval("['==',"+str(const_list)+",['+',"+str(const_in)+",['1']]]"))
                                    
                                    #smallest_con_list.append(ec_base)
                                    

                                    solution_information.append(solution_list)
                                
                                    solution_information.append(smallest_con_list+x_smallest_con_list+x_solution_list)
                                    
                                    solution_information.append(getBreakFunctionName(x_break_conditon_map, e_c))
                            
                                    all_solution_information.append(solution_information)
    else:
        if temp_all_solution_information is  None:
            
            ec_rec_equ_list1 =[]
            
            for e in ec_rec_equ_list:
                
                e_new = copy.deepcopy(e)
                                                                                        
                ec_rec_equ_list1.append(e_new)
                
            results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
            
            if len(results)==0:
                    
                solution_list=[]
                
                smallest_con_list=[]
                
                solution_information=[]
                    

                
                    
                for key in soln_map:
                                
                    e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                    e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                    e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                                                
                    solution_list.append(e_sol)
                        
                    solution_list.append(soln_map[key])

                solution_information.append(solution_list)
                                
                solution_information.append(smallest_con_list)
                            
                all_solution_information.append(solution_information)

        else:
            
            for x_solution_information in temp_all_solution_information:
                
                x_solution_list = x_solution_information[0]
                
                x_smallest_con_list = x_solution_information[1]     
            
                ec_rec_equ_list1 =[]
                
                for e in ec_rec_equ_list:
                    
                    e_new = copy.deepcopy(e)
                                                                
                    for x in x_solution_list:
                        
                        e_new[-1] =expr_replace(e_new[-1], x[-2], x[-1])
                        
                    ec_rec_equ_list1.append(e_new)
                    
                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
            
                if len(results)==0:
                    
                    solution_information=[]
                    
                    solution_list=[]
                    
                    smallest_con_list=[]
                    
                    for key in soln_map:
                                
                        e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                                                
                        solution_list.append(e_sol)
                        
                        solution_list.append(soln_map[key])
                        
                solution_information.append(solution_list)
                                
                solution_information.append(smallest_con_list+x_smallest_con_list+x_solution_list)
                            
                all_solution_information.append(solution_information)

    index=index-1
    if index>=0 and index <len(loop_info_list):
        list_of_info = loop_info_list[index]
        #print '~~~~~~~~~~~~~~~~~~~~~~'
        #for x in all_solution_information:
        #    for y in x[0]:
        #        print expr2string1(y[-2])
         #       print expr2string1(y[-1])

        list_of_info.append(all_solution_information)
        loop_info_list[index]=list_of_info 
        #caseAnalysisFindTheComplexity(loop_info_list, index, axiom)
    else:
        return all_solution_information
    return None





def caseAnalysisFindTheComplexity2(loop_info_list, index, axiom):
    
    list_of_info = loop_info_list[index]
    
    condition_map_to_prove = list_of_info[2]
    
    smallest_main_list = list_of_info[1]
            
    temp_all_solution_information =None
    
    if len(list_of_info)>=6:
        
        temp_all_solution_information = list_of_info[10]

    ec_rec_equ_list  = list_of_info[0]
    
    var = list_of_info[3]
    
    const_list = list_of_info[4]
    
    const_in = copy.deepcopy(const_list)
    
    const_in[0]=const_in[0].replace('_N','_CE')

    all_solution_information=[]
    
    
    if len(condition_map_to_prove) > 0:
        
        if temp_all_solution_information is  None:
            
            for key in condition_map_to_prove:
            
                ec_rec_equ_list1 =[]
                
                ec = condition_map_to_prove[key]
            
                for e in ec_rec_equ_list:

                    e_new = copy.deepcopy(e)
                
                    result = getTheExpressionCond(e_new[-1], ec)
                                        
                    if result is not None:
                                            
                        e_new[-1] = result
                            
                    else:
                            if e_new[0]=='i1':
                                            
                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                    
                    ec_rec_equ_list1.append(e_new)
                    
                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                    
                if len(results)==0:
                        
                    solution_information=[]
                    
                    solution_list=[]
                    
                    smallest_con_list=[]
                    
                    for key in soln_map:
                                
                        e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                            
                        solution_list.append(e_sol)
                            
                        solution_list.append(soln_map[key])
                            
                    smallest_con_list.append(ec)
                            
                        
                        
                    for e_s in smallest_main_list:
                            
                        new_e_s = copy.deepcopy(e_s)
                            
                        for e_sol in solution_list:
                                
                            new_e_s[-1] = expr_replace(new_e_s[-1], e_sol[-2], e_sol[-1])
                                
                        smallest_con_list.append(new_e_s)

                                                
                    solution_information.append(solution_list)
                                
                    solution_information.append(smallest_con_list)
                                    
                            
                    all_solution_information.append(solution_information)
        else:
            
            for x_solution_information in temp_all_solution_information:
                
                x_solution_list = x_solution_information[0]
                
                x_smallest_con_list = x_solution_information[1]     

                for key in condition_map_to_prove:
            
                    ec_rec_equ_list1 =[]
                    
                    ec = condition_map_to_prove[key]
            
                    for e in ec_rec_equ_list:

                        e_new = copy.deepcopy(e)
                
                        result = getTheExpressionCond(e_new[-1], ec)
                                        
                        if result is not None:
                            
                            for x in x_solution_list:
                        
                                e_new[-1] =expr_replace(e_new[-1], x[-2], x[-1])

                                            
                            e_new[-1] = result
                            
                        else:
                            
                            if e_new[0]=='i1':
                                            
                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                            
                        ec_rec_equ_list1.append(e_new)
                    
                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                    
                    if len(results)==0:
                        
                        solution_information=[]
                    
                        solution_list=[]
                    
                        smallest_con_list=[]
                    
                        for key in soln_map:
                                
                            e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                            e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                            e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                            
                            solution_list.append(e_sol)
                            
                            solution_list.append(soln_map[key])
                            
                        smallest_con_list.append(ec)
                            
                        for e_s in smallest_main_list:
                            
                            new_e_s = copy.deepcopy(e_s)
                            
                            for e_sol in solution_list:
                                
                                new_e_s[-1] = expr_replace(new_e_s[-1], e_sol[-2], e_sol[-1])
                                
                            smallest_con_list.append(new_e_s)
                                                
                        solution_information.append(solution_list)
                                
                        solution_information.append(smallest_con_list)
                                                                
                        all_solution_information.append(solution_information)
    else:
    
        if temp_all_solution_information is  None:
                        
            ec_rec_equ_list1 =[]
            
            for e in ec_rec_equ_list:

                e_new = copy.deepcopy(e)
                                
                ec_rec_equ_list1.append(e_new)
                    
            results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
            
                
            if len(results)==0:
                        
                solution_information=[]
                    
                solution_list=[]
                    
                smallest_con_list=[]
                    
                for key in soln_map:
                                
                    e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                    e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                    e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                            
                    solution_list.append(e_sol)
                            
                    solution_list.append(soln_map[key])
                            
                            
                    
                for e_s in smallest_main_list:
                            
                    new_e_s = copy.deepcopy(e_s)
                            
                    for e_sol in solution_list:
                                
                        new_e_s[-1] = expr_replace(new_e_s[-1], e_sol[-2], e_sol[-1])
                                
                    smallest_con_list.append(new_e_s)

                                                
                solution_information.append(solution_list)
                                
                solution_information.append(smallest_con_list)
                                    
                    
                all_solution_information.append(solution_information)
                    
        else:
            
            for x_solution_information in temp_all_solution_information:
                
                x_solution_list = x_solution_information[0]
                
                x_smallest_con_list = x_solution_information[1]     
            
                ec_rec_equ_list1 =[]
            
                for e in ec_rec_equ_list:

                    e_new = copy.deepcopy(e)
                
                    for x in x_solution_list:
                        
                        e_new[-1] =expr_replace(e_new[-1], x[-2], x[-1])

                    ec_rec_equ_list1.append(e_new)
                    
                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)

                if len(results)==0:
                        
                    solution_information=[]
                    
                    solution_list=[]
                    
                    smallest_con_list=[]
                    
                    for key in soln_map:
                                
                        e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                            
                        solution_list.append(e_sol)
                            
                        solution_list.append(soln_map[key])
                            
                            
                        
                    for e_s in smallest_main_list:
                            
                        new_e_s = copy.deepcopy(e_s)
                            
                        for e_sol in solution_list:
                                
                            new_e_s[-1] = expr_replace(new_e_s[-1], e_sol[-2], e_sol[-1])
                                
                        smallest_con_list.append(new_e_s)

                                                
                    solution_information.append(solution_list)
                                
                    solution_information.append(smallest_con_list)
                                    
                            
                    all_solution_information.append(solution_information)

    index=index-1
    if index>=0 and index <len(loop_info_list):
        list_of_info = loop_info_list[index]
        #print '~~~~~~~~~~~~~~~~~~~~~~'
        #for x in all_solution_information:
        #    for y in x[0]:
        #        print expr2string1(y[-2])
        #        print expr2string1(y[-1])

        list_of_info.append(all_solution_information)
        loop_info_list[index]=list_of_info 
        #caseAnalysisFindTheComplexity(loop_info_list, index, axiom)
    else:
        return all_solution_information
    return None















def getBreakFunctionName(break_con_map, cond):             
        for f_n in break_con_map:
            cond_list = break_con_map[f_n]
            if cond in cond_list:
                return f_n
        return None
        
            
            
            
            
            
        







def getSeqCond(e, list_cond, list_seq_cond):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if args[0] not in list_cond and args[0] not in list_seq_cond:
            list_seq_cond.append(args[0])
        if args[1][0] == 'ite':
            return getSeqCond(args[1], list_cond, list_seq_cond)
        if args[2][0] == 'ite':
            return getSeqCond(args[2], list_cond, list_seq_cond)


def getTheExpressionCond(e, ec):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if ec == args[0]:
            return args[1]
        if args[1][0] == 'ite':
            return getTheExpressionCond(args[1], ec)
        if args[2][0] == 'ite':
            return getTheExpressionCond(args[2], ec)
        else:
            return args[2]


def getAllConditionsFesible(e, condition_exp_map):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        key = expr2string1(args[0])
        if key not in condition_exp_map.keys():
            condition_exp_map[key] = args[0]
        if args[2][0] == 'ite':
            getAllConditionsFesible(args[2], condition_exp_map)


def getInductiveExpression(e, var):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if args[1][0] == 'ite':
            return getInductiveExpression(args[1], var)
        if expr_find(args[1], var) == True:
            return args[1]
        if args[2][0] == 'ite':
            return getInductiveExpression(args[2], var)
        if expr_find(args[2], var) == True:
            return args[2]


def getAllConditionFromS0(e, condition_list):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'or':
        if args[0][0] == 'or':
            getAllConditionFromS0(args[0], condition_list)
        else:
            condition_list.append(args[0])
        if args[1][0] == 'or':
            getAllConditionFromS0(args[1], condition_list)
        else:
            condition_list.append(args[1])
    else:
        condition_list.append(e)


def getConditionsFesible(e, condition_exp_map, key_value):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        key = expr2string1(args[0])
        if key in condition_exp_map.keys():
            list1 = condition_exp_map[key]
            temp_list = []
            temp_list.append(key_value)
            temp_list.append(args[1])
            list1.append(temp_list)
            condition_exp_map[key] = list1
        else:
            list1 = []
            list1.append(args[0])
            temp_list = []
            temp_list.append(key_value)
            temp_list.append(args[1])
            list1.append(temp_list)
            condition_exp_map[key] = list1
        if args[2][0] == 'ite':
            getConditionsFesible(args[2], condition_exp_map, key_value)
        else:
            key = None
            if key in condition_exp_map.keys():
                list1 = condition_exp_map[key]
                temp_list = []
                temp_list.append(key_value)
                temp_list.append(args[2])
                list1.append(args[1])
                condition_exp_map[key] = list1
            else:
                list1 = []
                list1.append(None)
                temp_list = []
                temp_list.append(key_value)
                temp_list.append(args[1])
                list1.append(args[2])
                condition_exp_map[key] = list1


def getBreakConditions(e, condition_list):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if args[1][0] == 'ite':
            getBreakConditions(args[1], condition_list)
        elif args[1][0] == '1':
            condition_list.append(args[0])
        if args[2][0] == 'ite':
            getBreakConditions(args[2], condition_list)
        elif args[2][0] == '1':
            condition_list.append(args[0])

def getNoneBreakConditions(e, condition_list):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if args[1][0] == 'ite':
            getNoneBreakConditions(args[1], condition_list)
        elif args[0] not in condition_list:
            condition_list.append(args[0])
        if args[2][0] == 'ite':
            getNoneBreakConditions(args[2], condition_list)





def getAll_Smallest_S0(axiom):
    main_axiom = []
    prev_big_N = None
    temp_list = None
    for x in axiom.getOther_axioms():
        if prev_big_N is None:
            temp_list = []
            temp_list.append(x)
            prev_big_N = x
        elif x[0] == 's1':
            temp_list.append(x)
            main_axiom.append(temp_list)
            prev_big_N = None
        else:
            temp_list.append(x)

    return main_axiom





def update_bound_smallest(axiom,witnessXml):
        global fun_call_map
	pre_condition=[]
	post_condition=[]
        constraint_list=[]
        condition_map={}
        update_equation=[]
        
        small_macro_eq=[]
        
        
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
	
        
	frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())

	subs_list=eqset2subs_list(axiom.getOutput_equations())
        for x in axiom.getOutput_equations():
            if axiom.getOutput_equations()[x][1][0]!='main':
                getAllCondtion_tactic8(axiom.getOutput_equations()[x],condition_map)
	for x in out_axioms:
		constraint_list.append(x)
        if len(condition_map)==1:
            for x in condition_map:
                temp_temp=[]
                temp_temp.append('s0')
                temp_temp.append(condition_map[x])
                constraint_list.append(wff2z3_update(temp_temp))

	for x in axiom.getOther_axioms(): 
        	equations=wff2z3_update(x)
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        if simplify(equations)!=False:
                            constraint_list.append(equations)
                    else:
                        constraint_list.append(equations)
                else:
                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in axiom.getConstraints():
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
                
        prev_big_N = None
	
        for x in axiom.getOther_axioms():
            if x[0]=='s0':
                result = isBigNPresent(x[-1])
                if result is not None:
                    prev_big_N = x
            elif x[0]=='s1':
                if prev_big_N is not None:
                    if prev_big_N[-1][0]=='<=' or prev_big_N[-1][0]=='>=':
                        expression = normal_form_constant(expr2string1(prev_big_N[-1]), expr2string1(x[-1][1][2]))
                        if '**' not in str(expression):
                            parser = c_parser.CParser()
                            ast = parser.parse("void test(){"+str(expression)+";}")
                            statement_temp=ast.ext[0].body.block_items[0]
                            axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                            if x[-1][1][2] == axupdate[-1][1]:
                                x_new=copy.deepcopy(axupdate)
                                x_new[-1][0]='=='
                                status=query2z3_cond(constraint_list,wff2z3_update1(x_new,axiom.getConst_var_map()),axiom.getVfact())
                                print status
                                if 'Successfully' in status:
                                    result_list=[]
                                    result_list.append(x_new[-1][1])
                                    result_list.append(x_new[-1][2])
                                    small_macro_eq.append(result_list)
                    else:
                        x_new=copy.deepcopy(x)
                        x_new[-1] = expr_replace(x_new[-1][2],x_new[-1][1][1],eval("['-',"+str(x_new[-1][1][2])+",['1']]"))
                        x_new[0] ='s0'
                        expression = normal_form_constant(expr2string1(x_new[-1]), expr2string1(x[-1][1][2]))
                        if '**' not in str(expression):
                            parser = c_parser.CParser()
                            ast = parser.parse("void test(){"+str(expression)+";}")
                            statement_temp=ast.ext[0].body.block_items[0]
                            axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                            if x[-1][1][2] == axupdate[-1][1]:
                                if axupdate[-1][0]=='<=' or axupdate[-1][0]=='>=':
                                    x_new=copy.deepcopy(axupdate)
                                    x_new[-1][0]='=='
                                    status=query2z3_cond(constraint_list,wff2z3_update1(x_new,axiom.getConst_var_map()),axiom.getVfact())
                                    print status
                                    if 'Successfully' in status:
                                        result_list=[]
                                        result_list.append(x_new[-1][1])
                                        result_list.append(x_new[-1][2])
                                        small_macro_eq.append(result_list)
                        

                    prev_big_N=None
        return small_macro_eq
    
###############################################################################################################################################################

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(x8(_n1)<50,x8(_n1)+1,ite(x8(_n1)<70,(x8(_n1)+3-2),x8(_n1)+2-1))" "_n1"
#recSolver.py "X(0)=A;Y(0)=B;X(_n1+1)=X(_n1)+1;Y(_n1+1)=X(_n1)+Y(_n1)"  "_n1"
#recSolver.py  "X(0)=A;Y(0)=B;Z(0)=C;X(_n1+1)=l*X(_n1)+l*Y(_n1)+l*Z(_n1)+D;Y(_n1+1)=l*X(_n1)+l*Y(_n1)+l*Z(_n1)+H;Z(_n1+1)=l*X(_n1)+l*Y(_n1)+l*Z(_n1)+F"  "_n1"
#recSolver.py  "X(0)=A;Y(0)=B;Z(0)=C;M(0)=j;M(_n1+1)=X(_n1)+M(_n1);X(_n1+1)=l*X(_n1)+l*Y(_n1)+l*Z(_n1)+D;Y(_n1+1)=l*X(_n1)+l*Y(_n1)+l*Z(_n1)+H;Z(_n1+1)=l*X(_n1)+l*Y(_n1)+l*Z(_n1)+F"  "_n1"
#recSolver.py  "X(0)=1;X(_n1+1)=ite(_n1==1,1,(_n1+1)*X(_n1))"
#recSolver.py  "y8(0) = 0;x8(0) = 0;y8((_n1+1)) = ite((x8(_n1)<50),(y8(_n1)+1),(y8(_n1)-1));x8((_n1+1)) = ite((ite((ite((x8(_n1)<50),(y8(_n1)+1),(y8(_n1)-1))<0),1,0)==0),(x8(_n1)+1),x8(_n1))" "_n1"
#recSolver.py  "y8(0) = 0;x8(0) = 0;y8((_n1+1)) = ite((x8(_n1)<50),(y8(_n1)+1),(y8(_n1)-1));x8((_n1+1)) = ite(x8(_n1)>=0,(x8(_n1)+1),x8(_n1))" "_n1"
#recSolver.py  "y8(0) = 0;x8((_n1+1)) = ite(x8(_n1)<50,x8(_n1),(x8(_n1)+1))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(_n1>=0,x8(_n1)+1,ite(_n1<70,(x8(_n1)+2),x8(_n1)+3))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(x8(_n1)>=0,x8(_n1)+1,ite(x8(_n1)<70,(x8(_n1)+2),x8(_n1)+3))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(x8(_n1)<50,x8(_n1)+1,ite(x8(_n1)<70,(x8(_n1)+2),x8(_n1)+3))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(_n1<50,x8(_n1)+1,ite(_n1<70,(x8(_n1)+2),x8(_n1)-3))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(_n1<A,x8(_n1)+1,ite(_n1<B,(x8(_n1)+2),x8(_n1)-3))" "_n1"



#./recSolver.py  "x8(0) = 0;y8(0) = 0;x8((_n1+1)) = ite(_n1<50,x8(_n1)+y8(_n1),ite(_n1<70,(x8(_n1)+1),x8(_n1)-1));y8((_n1+1)) = ite(_n1<50,y8(_n1)+1,ite(_n1<70,(x8(_n1)+y8(_n1)),y8(_n1)-3))" "_n1"



#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(50>_n1,x8(_n1)+1,ite(_n1<70,(x8(_n1)+2),x8(_n1)-3))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(A>_n1,x8(_n1)+1,ite(_n1<B,(x8(_n1)+2),x8(_n1)-3))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(70>_n1,x8(_n1)+1,ite(_n1>=0,(x8(_n1)+2),x8(_n1)-3))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(70<=_n1,x8(_n1)+1,ite(_n1>=0,(x8(_n1)+2),x8(_n1)-3))" "_n1"




#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(70>_n1,x8(_n1)+1,ite(_n1<50,(x8(_n1)+2),x8(_n1)-3))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(and(_n1>=7,_n1<10),x8(_n1)+2,ite(_n1>=10,(x8(_n1)-2),ite(_n1<7,x8(_n1)+1,x8(_n1)+3)))" "_n1"




#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(_n1<50,x8(_n1)+1,ite(_n1<70,(x8(_n1)+y8(_n1)),x8(_n1)-3));y8(0) = 0;y8((_n1+1)) = ite(_n1<50,x8(_n1)+y8(_n1),ite(_n1<70,(y8(_n1)+2),y8(_n1)-1))" "_n1"

#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(A>0,x8(_n1)+1,ite(B>0,(x8(_n1)+y8(_n1)),x8(_n1)-3));y8(0) = 0;y8((_n1+1)) = ite(A>0,x8(_n1)+y8(_n1),ite(B>0,(y8(_n1)+2),y8(_n1)-1))" "_n1"



#./recSolver.py  "x8(0) = 0;x8((_n1+1)) = ite(_n1<50,x8(_n1)+1,x8(_n1)-1)" "_n1"
#./recSolver.py  "break_1_flag8(0)=0;x8(0) = 0;x8((_n1+1)) = ite(_n1<50,x8(_n1)+1,x8(_n1)-1);break_1_flag8((_n1+1)) = ite((ite((x8(_n1)<50),(y8(_n1)+1),(y8(_n1)-1))<0),1,0)" "_n1"
#./recSolver.py  "n4(0) =0;n4((_n1+1)) = ite((((_n1+0)%2)==0),(n4(_n1)+1),n4(_n1))" "_n1"
#./recSolver.py  "X(0)=A;X(_n1+1)=ite(B>0,X(_n1)+1,ite(C>0,X(_n1)+2,X(_n1)))" "_n1"
#y8((_n1+1)) = ite((x8(_n1)<50),(y8(_n1)+1),(y8(_n1)-1))
#./recSolver.py "s4(0)=0;s4((_n1+1)) = ite((s4(_n1)!=0),(s4(_n1)+1),s4(_n1))"






def solve_recurrence(rec_equ,var):
    
    global fun_call_map
    
    global current_fun_call
    
    rec_list = rec_equ.split(';')
    
    list_equations=[]
    
    list_solutions = []
    
    axoims=None
    
    
    for rec_eq in rec_list:
        
        expression =[]
        left_side = rec_eq[0 : rec_eq.find('=')]
        right_side = rec_eq[rec_eq.find('=')+1:len(rec_eq)]

        #utiles_translation.resetGlobal()
        fun_call_map={}
        current_fun_call=None
    
        statement_temp = createASTStmt(left_side)
        left_side_update = expressionCreator_C(statement_temp)
        if left_side_update is not None:
            left_side_update=eval(left_side_update)
        
        #utiles_translation.resetGlobal()
        fun_call_map={}
        current_fun_call=None

        statement_temp = createASTStmt(right_side)
        
        
        right_side_update = expressionCreator_C(statement_temp)
        if right_side_update is not None:
            right_side_update=eval(right_side_update)
        
        if expr_find(left_side_update,eval("['"+var+"']"))==True:
            
            expression.append('i1')
            expression.append('0')
            expression.append(var)
            expression.append(left_side_update)
            expression.append(right_side_update)

        else:
            
            expression.append('i0')
            expression.append('0')
            expression.append(left_side_update)
            expression.append(right_side_update)

        list_equations.append(expression)
    
    
    results,soln_map = rec_solver_group(list_equations)
    
    
    for x in soln_map:
        
        results.append(soln_map[x])
    
    
    list_equations=[]
    
    closed_formed=[]
    
    for result in results:
        if result[0]=='i0' or result[0]=='i1':
            list_equations.append(result)
        else:
            if result[0]=='i2':
                closed_formed.append(result)
    if len(list_equations)>1:
        results,equations_map,basecase_map = mutual_rec_solver(list_equations,var)
        
        
        for result in results:
            closed_formed.append(result)
            
    
    #var_map={}
    #for x in list_equations:
    #    print wff2z3_update(x)
    #print var_map
    
    if len(list_equations)>0:
    
        results, axoims = solve_conditional_rec(equations_map, basecase_map, list_equations, var)
        
        if results is not None:
    
            for result in results:
                
                closed_formed.append(result)


    print 'NOt ABLE TO SOLVE FOLLOWING'
    if len(list_equations)>0:
        for x in list_equations:
            if x[0]=='i1':
                print wff2string1(x)
    else:
        print 'No Equations Left'
    
    print ''
    print 'CLOSED FORM SOLUTION'
    if len(closed_formed)>0:    
        for result in closed_formed:
            
            print wff2string1(result)
    else:
        print 'No Solution'
    
    print ''
    print 'ADDITIONAL AXIOMS'
    if axoims is not None:
        if len(axoims)>0:    
            for axoim in axoims:
                print wff2string1(axoim)
        else:
            print 'No Additional Axoims'
    else:
        print 'No Additional Axoims'
            
    
    #for equation in list_equations:
    #    print equation
        
    #Conditional 
    #print solve_rec(list_equations[1],list_equations[0])

    
    





def solve_recurrenceCall(list_equations,var):
    
    
    list_solutions = []
    
    axoims=None
    
    close_form_soln=[]
    
    add_axoims=[]
    
    left_out_eq=[]
    
    
    results,soln_map = rec_solver_group(list_equations)
    
    
    for x in soln_map:
        
        results.append(soln_map[x])
    
    
    list_equations=[]
    
    
    closed_formed=[]
    
    
    
    for result in results:
        if result[0]=='i0' or result[0]=='i1':
            list_equations.append(result)
        else:
            if result[0]=='i2':
                closed_formed.append(result)
            else:
                left_out_eq.append(result)
                
                
                
    if len(list_equations)>1:
        
        
        results,equations_map,basecase_map = mutual_rec_solver(list_equations,var)
            
        
        for result in results:
            closed_formed.append(result)
            
    
    
    #var_map={}
    #for x in list_equations:
    #    print FOL_translation.wff2z3_update(x)
    #print var_map
    #print '-----------------'
    #print list_equations
    #print '-----------------'
    if len(list_equations)>0:
        
        
        results, axoims = solve_conditional_rec(equations_map, basecase_map, list_equations, var)
            
    
        if results is not None:
    
            for result in results:
                closed_formed.append(result)


    #print 'NOt ABLE TO SOLVE FOLLOWING'
    if len(list_equations)>0:
        for x in list_equations:
            if x[0]=='i1':
                left_out_eq.append(x)
                #print FOL_translation.wff2string1(x)
    #else:
    #    print 'No Equations Left'
    
    #print ''
    #print 'CLOSED FORM SOLUTION'
    if len(closed_formed)>0:    
        for result in closed_formed:
            close_form_soln.append(result)
            #print FOL_translation.wff2string1(result)
    #else:
    #    print 'No Solution'
    
    #print ''
    #print 'ADDITIONAL AXIOMS'
    if axoims is not None:
        if len(axoims)>0:    
            for axoim in axoims:
                add_axoims.append(axoim)
                #print FOL_translation.wff2string1(axoim)
        #else:
        #    print 'No Additional Axoims'
    #else:
    #    print 'No Additional Axoims'
    return close_form_soln,add_axoims,left_out_eq
    #for equation in list_equations:
    #    print equation
        
    #Conditional 
    #print solve_rec(list_equations[1],list_equations[0])









#Create AST from an Expression

def createASTStmt(expression):
    parser = c_parser.CParser()
        
    ast = parser.parse("void test(){"+expression+";}")

    statement_temp=ast.ext[0].body.block_items[0]
    return statement_temp

#Solving a Group of Recurrences

def rec_solver_group(a):
    constant_fun_map={}
    equation_map={}
    base_map={}
    final_solution_map={}
    for axiom in a:
        if axiom[0]=='i1':
             lefthandstmt=expr2string1(axiom[3])
	     lefthandstmt=lefthandstmt.strip()
             equation_map[str(simplify(lefthandstmt))]=axiom
	if axiom[0]=='i0':
	     lefthandstmt=expr2string1(axiom[2])
	     lefthandstmt=lefthandstmt.strip()
	     base_map[str(simplify(lefthandstmt))]=axiom
             
    while True:
        solution_map={} 
	for equation in equation_map:
            e1=equation_map[equation]
	    equation_base=str(simplify(equation).subs(simplify(str(e1[2])+"+1"),0))
	    if equation_base in base_map.keys():
                e2=base_map[equation_base]
                result=solve_rec(e1,e2)
                if result is not None:
                    a.remove(base_map[equation_base])
                    del base_map[equation_base]
                    solution_map[equation]=result
	for equation in solution_map:
            a.remove(equation_map[equation])
	    del equation_map[equation]
	    e=solution_map[equation]
	    e1=copy.deepcopy(e)
	    variable=e[2]
	    a=solnsubstitution(a,e[3],e[4])
        for xx in solution_map.keys():
            final_solution_map[xx]=solution_map[xx]

	if len(equation_map)==0 or len(solution_map)==0:
            break
        
    return a,final_solution_map




"""
Mutual Recurrences Solving Module
#Add by Pritom Rajkhowa

"""

def mutual_rec_solver(list_equations,var):
    equation_map={}
    base_map={}
    fun_map={}
    coeff_map={}
    main_solutions=[]
    
    for axiom in list_equations:
        if axiom[0]=='i1':
            
             lefthandstmt = expr2string1(axiom[3])
             
	     lefthandstmt = lefthandstmt.strip()
             
             equation_map[str(simplify(lefthandstmt))]=axiom
             
             new_expr=copy.deepcopy(axiom[3])
             
             new_expr = expr_replace(new_expr,eval("['+',"+"['"+axiom[2]+"'],['1']]"),eval("['"+axiom[2]+"']"))
             
             
             fun_map[str(simplify(lefthandstmt))]=new_expr
             
	if axiom[0]=='i0':
	     lefthandstmt=expr2string1(axiom[2])
	     lefthandstmt=lefthandstmt.strip()
	     base_map[str(simplify(lefthandstmt))]=axiom
    
    
    
    for x in equation_map.keys():
        #print x
        #print FOL_translation.expr2string1(equation_map[x][4])
        
        equ_map = {}
        
        if 'ite' not in expr2string1(equation_map[x][4]):
        
            coeff_expr = simplify(expr2string1(equation_map[x][4]))
        
            for y in fun_map.keys():
            
                term = simplify(expr2string1(fun_map[y]))
            
                equ_map[str(term)] = coeff_expr.coeff(term)
            
                coeff_expr = coeff_expr - term*equ_map[str(term)]
            
                #print coeff_expr
            
            equ_map[None] = coeff_expr
        
            coeff_map[x] = equ_map
            
    new_coeff_map = copy.deepcopy(coeff_map)
    
    group_map={}
    
    
    for x in new_coeff_map.keys():
        
        if x is not None:
        
            group_list=None
                
            for y in new_coeff_map.keys():
                if x!=y:
                    if y in coeff_map.keys() and x in coeff_map.keys():
                    
                        ret = isMutualRecurGroup(coeff_map[y],coeff_map[x])
                        
                        if ret is not None:
                            if group_list is None:
                                group_list=[]
                                group_list.append(x)
                                group_list.append(y)
                                del coeff_map[y]
                            else:
                                group_list.append(y)
                                del coeff_map[y]
            if group_list is not None and x in group_list and x in coeff_map.keys():
                del coeff_map[x]
                group_map[x]=group_list
        
    for x in group_map.keys():
        group_list = group_map[x]
        if group_list is not None and len(group_list)>0:
            
            new_coeff_map2 = update_cofficent(group_list, new_coeff_map, var)
            
            solutions = solve_mutual_rec(group_list, new_coeff_map2, equation_map, base_map, var)
            
            if solutions is not None:
                
                for solution in solutions:
                    
                    main_solutions.append(solution)
                    
                    stmt1 = expr2string1(solution[3])
                    
                    term1=str(simplify(stmt1).subs(simplify(str(var)),simplify(str(var)+"+1")))
                    
                    term2=str(simplify(stmt1).subs(simplify(str(var)),0))
                    
                    if term1 in equation_map.keys():
                    
                        if equation_map[term1] in list_equations:
                            
                            list_equations.remove(equation_map[term1])
                        
                        del equation_map[term1]
                        
                    if term2 in base_map.keys():
                        
                        if base_map[term2] in list_equations:
                            
                            list_equations.remove(base_map[term2])

                        del base_map[term2]
                    for x in equation_map:
                        e = equation_map[x]
                        for y in solutions:
                            e[4] = expr_replace(e[4],y[3],y[4])
                    for x in base_map:
                        e = base_map[x]
                        for y in solutions:
                            e[3] = expr_replace(e[3],y[3],y[4])
    
    
    
    return main_solutions,equation_map,base_map



"""
Core Alg to solve Mutual Recurrences
"""

def solve_mutual_rec(group_list, new_coeff_map, equation_map, base_map, var):
    
    global fun_call_map
    global current_fun_call


    list_of_values=[]
    
    solutions=[]
    
    for x in group_list:
        list_of_value=[]
                
        factor,non_coeff = iscofficentEqual(new_coeff_map[x], var)
                
        if non_coeff is None:
            return None
            
        #utiles_translation.resetGlobal()
        fun_call_map={}
        current_fun_call=None

        
        if factor is None:
            
            return None
        
        statement_temp = createASTStmt(factor)
        list_of_value.append(expressionCreator_C(statement_temp))
        
        #utiles_translation.resetGlobal()
        fun_call_map={}
        current_fun_call=None

        statement_temp = createASTStmt(non_coeff)
        list_of_value.append(expressionCreator_C(statement_temp))
        
        
        term1 = simplify(x).subs(simplify(str(var)+"+1"),0)
        term2 = str(base_map[str(term1)][3])
        list_of_value.append(term2)
        term3 = copy.deepcopy(equation_map[x][3])
        term3 = expr_replace(term3,eval("['+',"+"['"+var+"'],['1']]"),eval("['"+var+"']"))
        list_of_value.append(term3)
        list_of_values.append(list_of_value)
        
    count=0
    const_expr=''
    const_expr_end=''
    const_coeff=''
    const_coeff_end=''
    const_value=None
    
    
    for list_of_value in list_of_values:
        
        const_value=list_of_value[0]

        if count<len(list_of_values)-1:
            const_expr+="['+',"+list_of_value[2]+","
            const_expr_end+="]"
            const_coeff+="['+',"+str(list_of_value[1])+","
            const_coeff_end+="]"
        else:
            const_expr+=str(list_of_value[2])
            const_coeff+=str(list_of_value[1])
            
        count=count+1
        
    for list_of_value in list_of_values:
        
        #res_expr ="['ite',['==',['"+var+"'],['0']],"+str(list_of_value[1])+","+"['+',"+"['+',"+"['*',['*',['power',['"+str(len(list_of_values))+"'],['"+var+"']],"+"['power',"+const_value+",['"+var+"']]],"+const_expr+const_expr_end+"]"+","+"['*',"+const_coeff+const_coeff_end+",['/'"+",['*',"+const_value+",['-',['1'],['*',['power',['"+str(len(list_of_values))+"'],['"+var+"']],['power',"+const_value+",['"+var+"']]]]],"+"['-',['1'],['*',['"+str(len(list_of_values))+"'],"+const_value+"]]]]],"+str(list_of_value[1])+"]"+"]"
        
        res_expr ="['ite',['==',['"+var+"'],['0']],"+str(list_of_value[2])+","+"['+',"+"['+',"+"['*',['*',['**',['"+str(len(list_of_values))+"'],['"+var+"']],"+"['**',"+const_value+",['"+var+"']]],"+const_expr+const_expr_end+"]"+","+"['*',"+const_coeff+const_coeff_end+",['/'"+",['*',"+const_value+",['-',['1'],['*',['**',['"+str(len(list_of_values))+"'],['"+var+"']],['**',"+const_value+",['"+var+"']]]]],"+"['-',['1'],['*',['"+str(len(list_of_values))+"'],"+const_value+"]]]]],"+str(list_of_value[1])+"]"+"]"
        
        express_main="['i2', '0', '"+var+"',"+str(list_of_value[3])+","+res_expr+"]"
        
        solutions.append(eval(express_main))
        
    return solutions


"""

Is eligible for mutual recurrences

"""

def isMutualRecurGroup(e_m1,e_m2):
    for x in e_m1.keys():
        if x is not None:
            if x not in e_m2.keys() or e_m1[x]!=e_m2[x]:
                return None
    return e_m2




"""

Is Cofficent of Equation are Equal

"""



def iscofficentEqual(new_coeff,var):
    status=True
    list1=new_coeff.keys()
    temp_map={}
    non_coeff=None
    for x in new_coeff.keys():
        if x is not None:
            temp_map[str(new_coeff[x])]=str(new_coeff[x])
        else:
            if var not in str(new_coeff[x]):
                non_coeff=str(new_coeff[x])
    if len(temp_map)==1:
        return temp_map.keys()[0],non_coeff
        
    else:
        return None,non_coeff



"""

Update Cofficent of Equation

"""




def update_cofficent(group_list, new_coeff, variable):
    
    key_map={}
    
    new_coeff2 = copy.deepcopy(new_coeff)
    
    for x in group_list:
        
        term1=simplify(x).subs(simplify(str(variable)+"+1"),variable)
        
        key_map[str(term1)] = str(x)
        
    for x in new_coeff.keys():
        if x is not None and x not in key_map.values():
            del new_coeff2[str(x)]
        if x in new_coeff2.keys():
            for y in new_coeff[x]:
                if y is not None and y not in key_map.keys():
                    del new_coeff2[x][y]
                
    return new_coeff2


def  simplificationOfConditions_rec(equations_map, basecase_map, list_equations, var):

        tuple_lists=[]
        
        for x in equations_map.keys():
            
            tuple_list=[]
            
            tuple_list.append(x)
            
            map_con_expression={}
            
            #map_con_expression_new={}
            
            map_fun = {}
            
            map_var = {}
            
            condition_map_constrt(equations_map[x][4],map_con_expression)
            
            #condition_map_constrt_new(equations_map[x][4],map_con_expression_new,None)
            
            
                        
            map_con_expression = simplificationOfConditions(list_equations, map_con_expression,x,var)
            
                        
            tuple_list.append(equations_map[x])#1
            
            tuple_list.append(map_fun)#2
            
            tuple_list.append(map_var)#3
            
            getAllVarFun(equations_map[x][4],map_fun,map_var)
            
            map_fun = {}
            
            map_var = {}
            
            getAllVarFun(equations_map[x][3],map_fun,map_var)
            
            tuple_list.append(map_fun)#4
            
            tuple_list.append(map_var)#5
            
            tuple_list.append(map_con_expression)#6
            
            #tuple_list.append(map_con_expression_new)#6
            
            
            tuple_lists.append(tuple_list)

        list_of_a_eq=[]
        
        for x in tuple_lists:
            
            if len(x[6])==1:
                
                x[1][-1]=x[6].values()[0][1]
                
                base_key = simplify(expr2string1(x[1][-2]))
                
                base_key = base_key.subs(simplify(var+"+1"),simplify('0'))
                
                list_of_a_eq.append(basecase_map[str(base_key)])
                
                list_of_a_eq.append(x[1])
        
        if len(list_of_a_eq)>0:
        
            results,soln_map  = rec_solver_group(list_of_a_eq)
            
            for equation in soln_map:
                list_equations.remove(equations_map[equation])
                base_key = simplify(equation).subs(simplify(var+"+1"),simplify('0'))
                del equations_map[equation]
                del basecase_map[str(base_key)]
                e=soln_map[equation]
                #e1=copy.deepcopy(e)
                #variable=e[2]
                for x in equations_map:
                    e_update=equations_map[x]
                    e_update[-1] = expr_replace(e_update[-1],e[3],e[4])
                
                for x in tuple_lists:
                    
                    if x[0]==equation:
                        
                        tuple_lists.remove(x)
                        
                    else:
                        
                        list_equations=solnsubstitution(list_equations,e[3],e[4])
                
            
                
            temp_tuple_lists,temp_results,temp_soln_map  = simplificationOfConditions_rec(equations_map, basecase_map, list_equations, var)
            

            
            soln_map = merge_two_dicts(soln_map,temp_soln_map)
            
            results= results+temp_results
            
            tuple_lists=tuple_lists+temp_tuple_lists
            
            return tuple_lists,results,soln_map

        else:
            
            return tuple_lists,[],{}
        
        return tuple_lists,[],{}




#Conditional recurrences Solver

def solve_conditional_rec(equations_map, basecase_map, list_equations, var):
    
        tuple_lists=[]
        
        solution_list=None
        
        additional_axoims=None
        
        
        
        tuple_lists,results,soln_map = simplificationOfConditions_rec(equations_map, basecase_map, list_equations, var)
        
        
        
        temp_tuple_lists=copy.deepcopy(tuple_lists)
        
        group_lists=[]
        
        for x in tuple_lists:
            
                        
            if x in temp_tuple_lists:
                
                group_list=[]
                
                group_list.append(x)
                
                for y in temp_tuple_lists:
                    if x!=y and x[2]==y[2]:
                        
                        group_list.append(y)
                        
                        temp_tuple_lists.remove(y)
                        
                if len(group_list)>0:
                    
                    group_lists.append(group_list)
                    
        
    
        for group_list in group_lists:   
            
                    
            
            soln,axoims = constructInfoSystem(group_list, equations_map, basecase_map, list_equations, var)
            
            #soln=[]
            #axoims=[]
            
            #soln,axoims = rec_solve_conditional(group_list, equations_map, basecase_map, list_equations, var) 
            
            if axoims is not None:
                
                if additional_axoims is None:
                    
                    additional_axoims = axoims
                    
                else:
                    
                    additional_axoims += axoims

                
                
            
            if  soln is not None:
                
                if solution_list is None:
                    
                    solution_list = soln
                    
                else:
                    
                    solution_list+=soln
                
        return solution_list,additional_axoims




"""

Solve the conditional equation

"""


COUNTER_START_INDEX=0

COUNTER_END_INDEX=0


COUNTER_INIT_VAL_INDEX=0



def constructInfoSystem(group_list, equations_map, basecase_map, equations_list, variable):
    
    global COUNTER_START_INDEX

    global COUNTER_END_INDEX

    global COUNTER_INIT_VAL_INDEX
    
    global fun_call_map
    
    global current_fun_call

    
    #final_solution_map={}
    
    final_solution_list=[]
    
    solution_map={}
    
    solution_else_map={}
    
    condition_map_start={}
    
    condition_map_end={}

    map_condition_equation={}
    
    map_condition_else_equation={}
    
    map_prev_value={}
    
    map_prev_prev_value={}
    
    map_init_value={}
    
    additional_axioms=[]
    
    map_type_1={}
    
    map_type_2={}
    
    map_con_expression_new=[]

    
    
    for x in group_list:
        
        
        condition_map_constrt_new(x[1][4],map_con_expression_new,None)
        #print '--------------'
        #print map_con_expression_new
        #print '--------------'
        
        for y in x[6]:
            
            z = x[6][y]
                        
            #print '-------------------'
            
            #print z
            #print x[1]
            
            #print '-------------------'
            
            if z[0] is not None:
            
                new_eq = copy.deepcopy(x[1])
            
                new_eq[-1] = z[1]
            
                equation_base = str(simplify(expr2string1(x[1][-2])).subs(simplify(str(variable)+"+1"),0))
    
                e_base = copy.deepcopy(basecase_map[equation_base])
            
                COUNTER_INIT_VAL_INDEX=COUNTER_INIT_VAL_INDEX+1
                
                initial_value=eval("['_CV"+str(COUNTER_INIT_VAL_INDEX)+"']")
                
                if y in condition_map_start:
                    
                    start_counter=condition_map_start[y]
                    
                else:
                
                    COUNTER_START_INDEX = COUNTER_START_INDEX+1


                    start_counter=eval("['_CS"+str(COUNTER_START_INDEX)+"']")
                    
                    condition_map_start[y]=start_counter
                    
                    
                if y in condition_map_end:
                    
                    end_counter=condition_map_end[y]
                    
                else:
                    
                    COUNTER_END_INDEX = COUNTER_END_INDEX+1
                    
                    end_counter=eval("['_CE"+str(COUNTER_END_INDEX)+"']")
                    
                    condition_map_end[y]=end_counter
                
                e_base[-1]=initial_value
            
                            
                
            
                smallest1 = eval("['implies',['and',['<=',"+str(start_counter)+",['"+variable+"']],['<',['"+variable+"'],"+str(end_counter)+"]],"+str(z[0])+"]")

                cond_compl = expr_complement(copy.deepcopy(z[0]))
                                         
                cond_compl = expr_replace(cond_compl,eval("['"+variable+"']"),end_counter)

                smallest2 = cond_compl

                condition_exp=eval("['<=',['"+variable+"'],"+str(end_counter)+"]")
                
                z.append(e_base)#3
                
                z.append(new_eq)#4
                
                z.append(smallest1)#5
                
                z.append(smallest2)#6
                
                z.append(condition_exp)#7
                
                close_form_exp = expr_replace(copy.deepcopy(x[1][-2]),eval("['+',['"+variable+"'],['1']]"),eval("['"+variable+"']"))
                
                z.append(close_form_exp)#8
                
                z.append(basecase_map[equation_base][-1])#9
                
                z.append(initial_value)#10
                
                z.append(start_counter)#11
                
                z.append(end_counter)#12

                
                if isFunctionPresent(z[0])==True:
                    
                    z.append('Function')#13
                    
                    small_part = expr_replace(copy.deepcopy(z[1]),eval("['+',['"+variable+"'],['1']]"),eval("['"+variable+"']"))
                    
                    incre_query=eval("['implies',"+str(z[0])+",['>=',"+str(z[1])+","+str(small_part)+"]]")
                    
                    vfacts = getAllVFacts(equations_list)
                    
                    post_condition=wff_a(incre_query)
                        
                    temp_post_condition=[]
                    
                    post_condition[0]='c1'
                    
                    temp_post_condition.append(wff2z3_update(post_condition))
                    
                    status=tactic1_update([],[],equations_list,[],temp_post_condition,vfacts,[],[],'')
                    
                    if 'Successfully Proved' in status:
                        
                        z.append('Increasing')
                        
                    else:
                        
                        incre_query=eval("['implies',"+str(z[0])+",['<=',"+str(z[1])+","+str(small_part)+"]]")
                    
                        post_condition=wff_a(incre_query)
                        
                        temp_post_condition=[]
                                                
                        temp_post_condition.append(wff2z3_update(post_condition))
                                                
                        status=tactic1_update([],[],equations_list,[],temp_post_condition,vfacts,[],[],'')
                
                        
                        if 'Successfully Proved' in status:
                            
                            z.append('Decreasing')
                                
                        else:
                        
                            z.append('Undefined')


                
                    
                elif isVariablePresent(z[0])==True and isFunctionPresent(z[0])!=True:
            
                    z.append('Counter')#13
                    
                elif isVariablePresent(z[0])!=True and isFunctionPresent(z[0])!=True:
            
                    z.append('Constant')#13
                    
                else:
                    
                    z.append('Not Able to Find')#13
                    
                if y in map_condition_equation:
                    
                    list_info_system=map_condition_equation[y]
                    
                    list_info_system.append(z)
                    
                    map_condition_equation[y]=list_info_system
                    
                else:
                    
                    list_info_system=[]
                    
                    list_info_system.append(z)
                    
                    map_condition_equation[y]=list_info_system
            else:
                
                new_eq = copy.deepcopy(x[1])
            
                new_eq[-1] = z[1]
            
                equation_base = str(simplify(expr2string1(x[1][-2])).subs(simplify(str(variable)+"+1"),0))
    
                e_base = copy.deepcopy(basecase_map[equation_base])
                
                COUNTER_INIT_VAL_INDEX=COUNTER_INIT_VAL_INDEX+1
                
                initial_value=eval("['_CV"+str(COUNTER_INIT_VAL_INDEX)+"']")

                e_base[-1]=initial_value
            
                smallest1 = None
                
                cond_compl = None
                                         
                smallest2 = cond_compl

                condition_exp=None
                
                z.append(e_base)#3
                
                z.append(new_eq)#4
                
                z.append(smallest1)#5
                
                z.append(smallest2)#6
                
                z.append(condition_exp)#7
                
                close_form_exp = expr_replace(copy.deepcopy(x[1][-2]),eval("['+',['"+variable+"'],['1']]"),eval("['"+variable+"']"))
                
                z.append(close_form_exp)#8
                
                z.append(basecase_map[equation_base][-1])#9
                
                z.append(initial_value)#10
                
                z.append(None)#11
                
                z.append(None)#12

                
                z.append('Else Case')#13
                
                
                small_part = expr_replace(copy.deepcopy(z[1]),eval("['+',['"+variable+"'],['1']]"),eval("['"+variable+"']"))
                    
                incre_query=eval("['>=',"+str(z[1])+","+str(small_part)+"]")
                    
                vfacts = getAllVFacts(equations_list)
                    
                post_condition=wff_a(incre_query)
                        
                temp_post_condition=[]
                    
                                                
                temp_post_condition.append(wff2z3_update(post_condition))
                
                        
                status=tactic1_update([],[],equations_list,[],temp_post_condition,vfacts,[],[],'')
                    
                    
                if 'Successfully Proved' in status:
                        
                    z.append('Increasing')
                        
                else:
                        
                    incre_query=eval("['<=',"+str(z[1])+","+str(small_part)+"]")
                    
                    post_condition=wff_a(incre_query)
                        
                    temp_post_condition=[]
                                                
                    temp_post_condition.append(wff2z3_update(post_condition))
                                                
                    status=tactic1_update([],[],equations_list,[],temp_post_condition,vfacts,[],[],'')
                                                
                    if 'Successfully Proved' in status:
                            
                        z.append('Decreasing')
                        
                    else:
                        
                        z.append('Undefined')
                        

                    
                                        
                if y in map_condition_else_equation:
                    
                    list_info_system=map_condition_else_equation[y]
                    
                    list_info_system.append(z)
                    
                    map_condition_else_equation[y]=list_info_system
                    
                else:
                    
                    list_info_system=[]
                    
                    list_info_system.append(z)
                    
                    map_condition_else_equation[y]=list_info_system






    if isCondEquType(map_condition_equation, map_condition_else_equation)=='Constant':
            
            
            
        for x in map_condition_equation:
                
            list_of_equations=[]
                
            list_info_system=map_condition_equation[x]
                
            for y in list_info_system:
                    
                list_of_equations.append(y[2])
                    
                list_of_equations.append(y[3])
                
                    
            results,soln_map  = rec_solver_group(list_of_equations)
            
                
            for y in list_info_system:
                
                for z in soln_map:
                    
                    if str(simplify(expr2string1(y[3][-2])))==z:
                        
                        soln=soln_map[z]
                        
                        y[1]=soln[-1]

        if None in map_condition_else_equation:
                
            list_info_system=map_condition_else_equation[None]
            
            list_of_equations=[]
            
            for y in list_info_system:
                                
                list_of_equations.append(y[2])
                
                list_of_equations.append(y[3])
                
            results,soln_map  = rec_solver_group(list_of_equations)
                
            
            for y in list_info_system:
                
                for z in soln_map:
                    
                    if str(simplify(expr2string1(y[3][-2])))==z:
                    
                        soln=soln_map[z]
                    
                        y[1]=soln[-1]
                        
        
        for x in map_condition_equation:
            
            list_info_system=map_condition_equation[x]
            
            
                        
            list_of_equations=[]
            
            for y in list_info_system:
                
                key_value = expr2string1(y[3][-2])
                
                if key_value in solution_map:
                        
                    map_init_value[expr2string1(y[9])]=y[8]
                        
                    y[1] = expr_replace(y[1],y[9],y[8])
                        
                    solution_list = solution_map[key_value]
                            
                    soln_str_start=solution_list[0]
                                                    
                    soln_str_start=soln_str_start+",['ite',"+str(y[4][2])+","+str(y[1])
                            
                    soln_str_end=solution_list[1]
                        
                    soln_str_end=soln_str_end+"]"
                        
                    solution_list[0] = soln_str_start
                        
                    solution_list[1] = soln_str_end
                        
                    solution_map[key_value]=solution_list
                        
                else:
                    
                    map_init_value[expr2string1(y[9])]=y[8]
                        
                    y[1] = expr_replace(y[1],y[9],y[8])
                        
                    soln_str_start="['ite',"+str(y[4][2])+","+str(y[1])
                        
                    soln_str_end="]"
                        
                    solution_list=[]
                        
                    solution_list.append(soln_str_start)#Solution Index 0
                        
                    solution_list.append(soln_str_end)#Solution Index 1
                        
                    solution_map[key_value]=solution_list
                        
        if None in map_condition_else_equation:
                
            list_info_system=map_condition_else_equation[None]
            
            for y in list_info_system:
                
                key_value = expr2string1(y[3][3])
                
                map_init_value[expr2string1(y[9])]=y[8]

                y[1] = expr_replace(y[1],y[9],y[8])
                                                                
                solution_else_map[key_value]=","+str(y[1])
                    
    elif isCondEquType(map_condition_equation, map_condition_else_equation)=='Counter' :  
            
        if isPeriodicCounter(map_condition_equation, map_condition_else_equation,variable)==True:   
                
            list_info_system=map_condition_equation[map_condition_equation.keys()[0]]
                
            equation_base = str(simplify(expr2string1(list_info_system[0][3][3])).subs(simplify(str(variable)+"+1"),0))
    
            equation_left = str(simplify(expr2string1(list_info_system[0][3][3])).subs(simplify(str(variable)+"+1"),simplify(str(variable))))
                
            term_list=[]
                
                
            list1=[]
            
            list1.append(list_info_system[0][0][0])
            
            
            list1.append(list_info_system[0][0][1][2][0])
            

            coeff_expr = simplify(expr2string1(list_info_system[0][1]))
            
            term = simplify(equation_left)
            
            
            coeff_const = coeff_expr.coeff(term)
            
            if str(coeff_const)=='1':
                
                result = coeff_expr - coeff_const*simplify(equation_left)
                
                list1.append(result)
                
                term_list.append(list1)

                
            list_info_system=map_condition_else_equation[map_condition_else_equation.keys()[0]]
                
                
                
            list1=[]
            
            coeff_expr = simplify(expr2string1(list_info_system[0][1]))
    
            term = simplify(equation_left)
            
            coeff_const = coeff_expr.coeff(term)
            
            if str(coeff_const)=='1':
                
                result = coeff_expr - coeff_const*simplify(equation_left)
                
                list1.append(result)
                                
                term_list.append(list1)



            if len(term_list)==2:
        
                if term_list[0][0]=='==':
            
                    fun_call_map={}
                    current_fun_call=None

                    statement_temp = createASTStmt(str(term_list[0][1]))
                    initer_update = expressionCreator_C(statement_temp)
            
                    fun_call_map={}
                    current_fun_call=None

                    statement_temp = createASTStmt(str(term_list[0][2]))
                    stmt_update1 = expressionCreator_C(statement_temp)
            
            
                    fun_call_map={}
                    current_fun_call=None

                    statement_temp = createASTStmt(str(term_list[1][0]))
                    stmt_update2 = expressionCreator_C(statement_temp)
                    
                    

            
                    #stmt_update="['+   ',['+',"+str(e_base[3])+",['*',"+str(stmt_update1)+",['-',['"+var+"'],['/',['"+var+"'],"+str(initer_update)+"]]]],"+"['*',['/',['"+var+"'],"+str(initer_update)+"],"+str(stmt_update2)+"]]"
                    stmt_update="['+',['+',"+str(list_info_system[0][8])+",['*',"+str(stmt_update2)+",['-',['"+variable+"'],['/',['"+variable+"'],"+str(initer_update)+"]]]],"+"['*',['/',['"+variable+"'],"+str(initer_update)+"],"+str(stmt_update1)+"]]"
            
                    key_value = expr2string1(list_info_system[0][3][-2])
                    solution_list=[]
                    solution_list.append(stmt_update)
                    solution_list.append('')
                    solution_map[key_value]=solution_list
                    solution_else_map[None]=''

            
                else:
            
                    fun_call_map={}
                    current_fun_call=None

            

                    statement_temp = createASTStmt(str(term_list[1][1]))
                    initer_update = expressionCreator_C(statement_temp)
            
                    fun_call_map={}
                    current_fun_call=None

                    statement_temp = createASTStmt(str(term_list[1][2]))
                    stmt_update1 = expressionCreator_C(statement_temp)
            
            
                    fun_call_map={}
                    current_fun_call=None

                    statement_temp = createASTStmt(str(term_list[0][0]))
                    stmt_update2 = expressionCreator_C(statement_temp)
                    
                                            
                    stmt_update="['+',['+',"+str(list_info_system[0][8])+",['*',"+str(stmt_update1)+",['-',['"+variable+"'],['/',['"+variable+"'],"+str(initer_update)+"]]]],"+"['*',['/',['"+variable+"'],"+str(initer_update)+"],"+str(stmt_update2)+"]]"
                    #stmt_update="['+',['+',"+str(e_base[3])+",['*',"+str(stmt_update2)+",['-',['"+var+"'],['/',['"+var+"'],"+str(initer_update)+"]]]],"+"['*',['/',['"+var+"'],"+str(initer_update)+"],"+str(stmt_update1)+"]]"
                    key_value = expr2string1(list_info_system[0][3][-2])
                    solution_list=[]
                    solution_list.append(stmt_update)
                    solution_list.append('')
                    solution_map[key_value]=solution_list
                    solution_else_map[None]=''
                    
                    
                
        else:
                
            #for x in map_con_expression_new:
                #print '--------------'
                #print x
                #print '--------------'
            for x in map_condition_equation:
                
                #print '~~~~~~~~~~~~~~~~~~'
                #print x
                #print '~~~~~~~~~~~~~~~~~~'
            
                list_info_system=map_condition_equation[x]
            
                list_of_equations=[]
            
                for y in list_info_system:
                                
                    list_of_equations.append(y[2])
                
                    list_of_equations.append(y[3])
                    

                
                results,soln_map  = rec_solver_group(list_of_equations)
                

            
            
                for y in list_info_system:
                    
                    for z in soln_map:
                                                
                        if str(simplify(expr2string1(y[3][-2])))==z:
                                                
                            soln=soln_map[z]
                                    
                            y[1]=soln[-1]
                    
                        
            if None in map_condition_else_equation:
                
                list_info_system=map_condition_else_equation[None]
            
                list_of_equations=[]
            
                for y in list_info_system:
                                
                    list_of_equations.append(y[2])
                
                    list_of_equations.append(y[3])
                
                results,soln_map  = rec_solver_group(list_of_equations)
                
            
                for y in list_info_system:
                
                    for z in soln_map:
                        
                        if str(simplify(expr2string1(y[3][-2])))==z:
                                                
                            soln=soln_map[z]
                    
                            y[1]=soln[-1]
                        
    
            #print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
            #print map_con_expression_new
            #print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
            #print map_condition_equation
            #print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'


            
            solution_map, solution_else_map, map_init_value, map_prev_value, map_prev_prev_value = find_Condition_Order(map_con_expression_new, map_condition_equation, map_condition_else_equation, variable, map_init_value, map_prev_value, map_prev_prev_value, solution_map, solution_else_map)
            
                    
                    
    elif isCondEquType(map_condition_equation, map_condition_else_equation)=='Function' and checkMonotonocity(map_condition_equation, map_condition_else_equation)!=None:           

        
        for x in map_condition_equation:
            
            list_info_system=map_condition_equation[x]
            
            list_of_equations=[]
            
            for y in list_info_system:
                                
                list_of_equations.append(y[2])
                
                list_of_equations.append(y[3])
                
            results,soln_map  = rec_solver_group(list_of_equations)
            
            
            for y in list_info_system:
                
                for z in soln_map:
                    
                    if str(simplify(expr2string1(y[3][-2])))==z:
                    
                        soln=soln_map[z]
                    
                        solN=copy.deepcopy(soln)
                    
                        solN[-1]=expr_replace(solN[-1],eval("['"+variable+"']"),y[11])
                    
                        solN[-2]=expr_replace(solN[-2],eval("['"+variable+"']"),y[11])
                    
                        y[1]=soln[-1]
                    
                    
                        if y[4] is not None:
                        
                    
                            y[4]=expr_replace(y[4],soln[-2],soln[-1])
                    
                    
                            y[4][2]=expr_replace(y[4][2],eval("['"+variable+"']"),eval("['-',['"+variable+"'],"+str(y[10])+"]"))
                        
                    
                        if y[5] is not None:
                        
                        
                            y[5]=expr_replace(y[5],solN[-2],solN[-1])
                        
                    
                            y[5]=expr_replace(y[5],eval(str(y[11])),eval("['-',"+str(y[11])+","+str(y[10])+"]"))
                        
        if None in map_condition_else_equation:
                
            list_info_system=map_condition_else_equation[None]
            
            list_of_equations=[]
            
            for y in list_info_system:
                                
                list_of_equations.append(y[2])
                
                list_of_equations.append(y[3])
                
            results,soln_map  = rec_solver_group(list_of_equations)
                
            
            for y in list_info_system:
                
                for z in soln_map:
                    
                    if str(simplify(expr2string1(y[3][-2])))==z:
                    
                        soln=soln_map[z]
                    
                        y[1]=soln[-1]
                    
                    
        #print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        #print map_con_expression_new
        #print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
        #print map_condition_equation
        #print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'

        solution_map, solution_else_map, map_init_value, map_prev_value, map_prev_prev_value = find_Condition_Order_Fun(map_con_expression_new, map_condition_equation, map_condition_else_equation, variable, map_init_value, map_prev_value, map_prev_prev_value, solution_map, solution_else_map)



                
                

    for x in solution_map:
                        
        eqn_soln=None
            
        key_value=str(simplify(x))
        
        solution_list = solution_map[x]
        
        final_soln = solution_list[0]
            
        final_soln += solution_else_map[x]
            
        final_soln += solution_list[1]
                                
        if key_value in equations_map:
                            
            eqn_soln = equations_map[key_value]
                
            if eqn_soln is not None:
                
                final_eqn_soln=copy.deepcopy(eqn_soln)
                                        
                if eqn_soln in equations_list:
                        
                    equations_list.remove(eqn_soln)
                
                del equations_map[key_value]
                
                final_eqn_soln[0] ='i2'
                
                final_eqn_soln[-1] = eval(final_soln)
                    
                final_eqn_soln[-2] = expr_replace(final_eqn_soln[-2],eval("['+',['"+variable+"'],['1']]"),eval("['"+variable+"']"))
                                
                for init_value in map_init_value:
                                
                    final_eqn_soln[-1] = expr_replace(final_eqn_soln[-1],eval("['"+init_value+"']"),map_init_value[init_value])
                
                #print final_eqn_soln
                    
                final_solution_list.append(final_eqn_soln)
                    
                    
                #final_solution_map[key_value]=final_eqn_soln
                
                
            
        #for x in final_solution_map:
            
        #    print final_solution_map[x]
            
        #for x in additional_axioms:
            
        #    print wff2string1(x)
            
            
    return final_solution_list,additional_axioms
                        
                            
                        
                        
                        
"""

Find the type of equation

"""

def isCondEquType(map_condition_equation, map_condition_else_equation):
    
    type_eq=None
    
    if len(map_condition_equation)>0:
            
        for x in map_condition_equation:
            
            list_info_system=map_condition_equation[x]
                
            for y in list_info_system:
                    
                key_value = expr2string1(y[3][-2])
                
                if type_eq is None:
                    
                    type_eq=y[12]
                    
                elif y[12]!=type_eq:
                    
                    type_eq=None
                    
    if type_eq is None:
          
          return False   
      
    else:
          
          return type_eq
              
                
"""

Find the Monotonocity of equation

"""

def checkMonotonocity(map_condition_equation, map_condition_else_equation):
    
    type_eq=None
    
    if len(map_condition_equation)>0:
            
        for x in map_condition_equation:
            
            list_info_system=map_condition_equation[x]
                
            for y in list_info_system:
                    
                key_value = expr2string1(y[3][-2])
                
                if type_eq is None:
                    
                    type_eq=y[13]
                    
                elif y[13]!=type_eq:
                    
                    type_eq=None
                    
        if None in map_condition_else_equation:
                
            list_info_system=map_condition_else_equation[None]
            
            for y in list_info_system:
                
                if y[13]!=type_eq:
                    
                    type_eq=None

                    
    if type_eq is None:
          
          return False   
      
    else:
          if type_eq=='Increasing': 
              
            return type_eq
        
          elif type_eq=='Decreasing':
              
            return type_eq
        
          else:
            
            return None
              
        
                

"""

Is periodic 

"""


def isPeriodicCounter(map_condition_equation, map_condition_else_equation, variable):
    
    if len(map_condition_equation)==1:
            
        list_info_system=map_condition_equation[map_condition_equation.keys()[0]]
            
        if (list_info_system[0][0][0]=='==' or list_info_system[0][0][0]=='!=') and list_info_system[0][0][1][0]=='%' and expr_find(list_info_system[0][0][1][1],eval("['"+variable+"']"))==True and is_number(list_info_system[0][0][1][2][0])==True:
            
            return True

    return False

           



def solvePeriodicType(e, equations_map, basecase_map, list_equations, var):
    
    
    equation_base = str(simplify(e[0]).subs(simplify(str(e[1][2])+"+1"),0))
    
    equation_left = str(simplify(e[0]).subs(simplify(str(e[1][2])+"+1"),simplify(str(e[1][2]))))
    
    e_base = basecase_map[equation_base]
    
    new_expr=copy.deepcopy(e[1][3])
    
    new_expr = fun_utiles.expr_replace(new_expr,eval("['+',"+"['"+e[1][2]+"'],['1']]"),eval("['"+e[1][2]+"']"))
    
    term_list=[]
    
    for x in e[6]:
        
        if e[6][x][2]=='Periodic':
            
            list1=[]
            
            list1.append(e[6][x][4])
            
            list1.append(e[6][x][3])

            coeff_expr = simplify(FOL_translation.expr2string1(e[6][x][1]))
    
            term = simplify(equation_left)
            
            coeff_const = coeff_expr.coeff(term)
            
            if str(coeff_const)=='1':
                
                result = coeff_expr - coeff_const*simplify(equation_left)
                
                list1.append(result)
                
                term_list.append(list1)
                
                
        elif e[6][x][2]==None:
            
            list1=[]
            
            coeff_expr = simplify(FOL_translation.expr2string1(e[6][x][1]))
    
            term = simplify(equation_left)
            
            coeff_const = coeff_expr.coeff(term)
            
            if str(coeff_const)=='1':
                
                result = coeff_expr - coeff_const*simplify(equation_left)
                
                list1.append(result)
                
                term_list.append(list1)

    if len(term_list)==2:
        if term_list[0][0]=='==':
            
            utiles_translation.resetGlobal()
            

            statement_temp = utiles_translation.createASTStmt(str(term_list[0][1]))
            initer_update = utiles_translation.expressionCreator_C(statement_temp)
            
            utiles_translation.resetGlobal()
            statement_temp = utiles_translation.createASTStmt(str(term_list[0][2]))
            stmt_update1 = utiles_translation.expressionCreator_C(statement_temp)
            
            
            utiles_translation.resetGlobal()
            statement_temp = utiles_translation.createASTStmt(str(term_list[1][0]))
            stmt_update2 = utiles_translation.expressionCreator_C(statement_temp)
            
            #stmt_update="['+',['+',"+str(e_base[3])+",['*',"+str(stmt_update1)+",['-',['"+var+"'],['/',['"+var+"'],"+str(initer_update)+"]]]],"+"['*',['/',['"+var+"'],"+str(initer_update)+"],"+str(stmt_update2)+"]]"
            stmt_update="['+',['+',"+str(e_base[3])+",['*',"+str(stmt_update2)+",['-',['"+var+"'],['/',['"+var+"'],"+str(initer_update)+"]]]],"+"['*',['/',['"+var+"'],"+str(initer_update)+"],"+str(stmt_update1)+"]]"
            
            soln = eval("['i2','"+e[1][1]+"','"+e[1][2]+"',"+str(new_expr)+","+stmt_update+']')
        
            if equations_map[e[0]] in list_equations:
                list_equations.remove(equations_map[e[0]])
            
            if basecase_map[equation_base] in list_equations:
                list_equations.remove(basecase_map[equation_base])

                
            del basecase_map[equation_base]
        
            del equations_map[e[0]]
        
            for x in equations_map:
                e = equations_map[x]
                e[4] = fun_utiles.expr_replace(e[4],soln[3],soln[4])
            
            for x in basecase_map:
                e = basecase_map[x]
                e[3] = fun_utiles.expr_replace(e[3],soln[3],soln[4])

            return  soln
            
        else:
            
            utiles_translation.resetGlobal()
            

            statement_temp = utiles_translation.createASTStmt(str(term_list[1][1]))
            initer_update = utiles_translation.expressionCreator_C(statement_temp)
            
            utiles_translation.resetGlobal()
            statement_temp = utiles_translation.createASTStmt(str(term_list[1][2]))
            stmt_update1 = utiles_translation.expressionCreator_C(statement_temp)
            
            
            utiles_translation.resetGlobal()
            statement_temp = utiles_translation.createASTStmt(str(term_list[0][0]))
            stmt_update2 = utiles_translation.expressionCreator_C(statement_temp)
                        


            stmt_update="['+',['+',"+str(e_base[3])+",['*',"+str(stmt_update1)+",['-',['"+var+"'],['/',['"+var+"'],"+str(initer_update)+"]]]],"+"['*',['/',['"+var+"'],"+str(initer_update)+"],"+str(stmt_update2)+"]]"
            #stmt_update="['+',['+',"+str(e_base[3])+",['*',"+str(stmt_update2)+",['-',['"+var+"'],['/',['"+var+"'],"+str(initer_update)+"]]]],"+"['*',['/',['"+var+"'],"+str(initer_update)+"],"+str(stmt_update1)+"]]"
            
            
            soln = eval("['i2','"+e[1][1]+"','"+e[1][2]+"',"+str(new_expr)+","+stmt_update+']')
        
            if equations_map[e[0]] in list_equations:
                list_equations.remove(equations_map[e[0]])
            
            if basecase_map[equation_base] in list_equations:
                list_equations.remove(basecase_map[equation_base])

                
            del basecase_map[equation_base]
        
            del equations_map[e[0]]
        
            for x in equations_map:
                e = equations_map[x]
                e[4] = fun_utiles.expr_replace(e[4],soln[3],soln[4])
            
            for x in basecase_map:
                e = basecase_map[x]
                e[3] = fun_utiles.expr_replace(e[3],soln[3],soln[4])

            return  soln
    
    return None








"""

Solve the conditional equation

"""


def rec_solve_conditional(group_list, equations_map, basecase_map, list_equations, var):
    
    vfacts = getAllVFacts(list_equations)
    
    if len(group_list)==1:
        for x in group_list:
            
            print x
            
            for y in x[6]:
                
                z = x[6][y]
                                
                if z[0] is not None:
                    
                    if isFunctionPresent(z[0])==True:
                            
                        equation = copy.deepcopy(x[1])
                        
                        equation[-1] = z[0]
                        
                        equation_base = str(simplify(x[0]).subs(simplify(str(x[1][2])+"+1"),0))
    
                        e_base = basecase_map[equation_base]

                        
                        base_case=copy.deepcopy(z[0])
                        
                        base_case=expr_replace(base_case,eval("['"+var+"']"),eval("['0']"))
                        
                        post_condition=wff_a(base_case)
                        
                        temp_post_condition=[]
                        
                        
                        temp_post_condition.append(wff2z3_update(post_condition))
                        
                        status=tactic1_update([],[],list_equations,[],temp_post_condition,vfacts,[],[],'')
                        
                        if 'Successfully Proved' in status:
                            
                            print 'Successfully Proved'





"""
Construct condtional Map for 
"""

def condition_map_constrt(e1,map_con_expression):
    if e1[0]=='ite':
        arg_list = expr_args(e1)
        list_expr=[]
        list_expr.append(arg_list[0])
        list_expr.append(arg_list[1])
        map_con_expression[expr2string1(arg_list[0])]=list_expr
        if arg_list[2][0]=='ite':
            condition_map_constrt(arg_list[2],map_con_expression)
        else:
            list_expr=[]
            list_expr.append(None)
            list_expr.append(arg_list[2])
            map_con_expression[None]=list_expr
            
"""
Construct condtional Map for New Implementation
"""

def condition_map_constrt_new(e1,map_con_expression,pre_cond):
    if e1[0]=='ite':
        arg_list = expr_args(e1)
        list_expr=[]
        if pre_cond is None:
            
            list_expr.append(arg_list[0])
            
            #list_expr.append(arg_list[1])
            
            list_expr.append(arg_list[0])
            
            if list_expr not in map_con_expression:
            
                map_con_expression.append(list_expr)
            
            #map_con_expression[expr2string1(arg_list[0])]=list_expr
            
            pre_cond=eval("['not',"+str(arg_list[0])+"]")

            
        else:
            new_arg = eval("['and',"+str(arg_list[0])+","+str(pre_cond)+"]")
            
            pre_cond = eval("['and',['not',"+str(arg_list[0])+"],"+str(pre_cond)+"]")
            
            #list_expr.append(arg_list[0])
            
            list_expr.append(new_arg)
            
            #list_expr.append(arg_list[1])
            
            list_expr.append(arg_list[0])
            
            if list_expr not in map_con_expression:
                
                map_con_expression.append(list_expr)
            
            #map_con_expression[expr2string1(arg_list[0])]=list_expr

            
        if arg_list[2][0]=='ite':
            
            condition_map_constrt_new(arg_list[2],map_con_expression,pre_cond)
        else:
            list_expr=[]
            list_expr.append(None)
            #list_expr.append(arg_list[2])
            
            list_expr.append(None)
            #map_con_expression[None]=list_expr
            
            if list_expr not in map_con_expression:
                map_con_expression.append(list_expr)




def find_Condition_Order(map_con_expression_new,map_condition_equation, map_condition_else_equation,variable, map_init_value, map_prev_value, map_prev_prev_value, solution_map, solution_else_map):
    
    #print '~~~~~~~~~~~~~~~~~'
    #print 'Enter'
    #print len(map_con_expression_new)
    #print map_init_value
    #print map_prev_value
    #print solution_map
    #print '~~~~~~~~~~~~~~~~~'
    
    map_con_expression_new_back_up=copy.deepcopy(map_con_expression_new)
    
    for list_element in map_con_expression_new:

        #print '@@@@@@@@@@@@@@@@@@@@@'
        #print list_element[1]
        #print '@@@@@@@@@@@@@@@@@@@@@'

        if list_element[1] is not None:
            
            list_info_system = map_condition_equation[expr2string1(list_element[1])]
                    
            for y in list_info_system:
                        
                key_value = expr2string1(y[3][-2])
                
                if key_value in solution_map:
                    
                    solution_list_prev=solution_map[key_value]
                    
                    prev_value_list = map_prev_value[key_value]
                    
                    
                    init_value = prev_value_list[0]
            
                    final_value = '_C'
                    
                    init_query = copy.deepcopy(list_element[0])
            
                    init_query_cmpl = copy.deepcopy(list_element[0])
            
                    init_query_cmpl = expr_complement(init_query_cmpl)
            
                    init_query = "['implies',"+"['and',['<=',['"+init_value+"'],['"+variable+"']],['<',['"+variable+"'],['"+final_value+"']]]"+","+str(init_query)+"]"
            
                    init_query_cmpl = "['implies',['<=',['"+final_value+"'],['"+variable+"']],"+str(init_query_cmpl)+"]"
            
                    init_query = wff_c1(eval(init_query))
            
                    init_query_cmpl = wff_c1(eval(init_query_cmpl))
            
                    list_equations=[]
            
                    list_equations.append(init_query)
            
                    list_equations.append(init_query_cmpl)
            
                    vfacts = getAllVFacts(list_equations)
            
                    temp_post_condition=[]
                    
                                        
                    status=tactic1_update_rec_solve([],[],list_equations,[],temp_post_condition,vfacts,[],[],'')
                    
                    

                    
                    
                    if 'Counter Example' in status:
                        
                        status = status.replace('Counter Example','').strip()
                
                        status = status[1:-1]
                
                        val_extract_map = processCounterExample(status)
                        
                        init_query = copy.deepcopy(list_element[0])
                
                        init_query = expr_replace(init_query,eval("['"+variable+"']"),eval("['"+init_value+"']"))
                            
                        temp_post_condition=[]

                        post_condition=wff_a(init_query)
                        
                        temp_post_condition=[]
                                                
                        temp_post_condition.append(wff2z3_update(post_condition))
                
                        status=tactic1_update_rec_solve([],[],list_equations,[],temp_post_condition,vfacts,[],[],'')
                        
                        
                        
                        
                        
                        if 'Successfully Proved' in status and  len(val_extract_map)>0 and final_value in val_extract_map.keys() :
                            
                            cond = "['and',['<=',['"+init_value+"'],['"+variable+"']],['<',['"+variable+"'],['"+val_extract_map[final_value]+"']]]"
                            
                            map_init_value[expr2string1(y[9])]=prev_value_list[1]
                            
                            value_expr=copy.deepcopy(y[1])
                            
                            for init_value_var in map_init_value:
                                
                                value_expr = expr_replace(value_expr,eval("['"+init_value_var+"']"),map_init_value[init_value_var])
                            
                                
                            value_expr = expr_replace(value_expr,eval("['"+variable+"']"),eval("['-',['"+variable+"'],['"+init_value+"']]"))
                            
                            soln_str_start = solution_list_prev[0]
                            
                            soln_str_start+=",['ite',"+str(cond)+","+str(value_expr)
                            
                            soln_str_end = solution_list_prev[1]
                        
                            soln_str_end+="]"
                        
                            solution_list=[]
                        
                            solution_list.append(soln_str_start)#Solution Index 0
                        
                            solution_list.append(soln_str_end)#Solution Index 1
                            
                            #solution_list.append(None)
                            
                            #solution_list.append(None)
                            
                            solution_map[key_value]=solution_list
                            
                            prev_list=[]
                            
                            prev_prev_list=[]
                            
                            final_init_value = expr_replace(copy.deepcopy(value_expr),eval("['"+variable+"']"),eval("['"+val_extract_map[final_value]+"']"))
                        
                            prev_list.append(val_extract_map[final_value])
                            
                            prev_list.append(final_init_value)
                            
                            map_prev_value[key_value] = prev_list
                            
                            
                            prev_prev_list.append(y[9])
                            
                            prev_prev_list.append(final_init_value)
                            
                            map_prev_prev_value[key_value] = prev_prev_list

                            
                            #print solution_map
                            #print '~~~~~~~~~~~~~~~~~1'
                            #print map_prev_value
                            #print '~~~~~~~~~~~~~~~~~2'
                            
                            if list_element in map_con_expression_new:
                            
                                map_con_expression_new.remove(list_element)
                            
                        else:
                        
                            if list_element in map_con_expression_new:
                                
                                map_con_expression_new.remove(list_element)
                            
                            #return find_Condition_Order(map_con_expression_new,map_condition_equation, map_condition_else_equation,variable, map_init_value, map_prev_value, solution_map, solution_else_map)
                    
                            
                    elif 'Successfully Proved' in status:
                        
                        temp_post_condition=[]
                                                
                        temp_post_condition.append(wff2z3_update(init_query))
                
                        status=tactic1_update_rec_solve([],[],[],[],temp_post_condition,vfacts,[],[],'')
                        
                        if 'Successfully Proved' in status:
                            
                            list_info_system=map_condition_equation[expr2string1(list_element[1])]
            
                            for y in list_info_system:
                
                                key_value = expr2string1(y[3][-2])
                
                                if key_value in map_prev_value:
                
                                    prev_value_list = map_prev_value[key_value]
                                        
                                    map_init_value[expr2string1(y[9])]=prev_value_list[1]
                    
                                    for init_value in map_init_value:
                        
                                        y[1] = expr_replace(y[1],eval("['"+init_value+"']"),map_init_value[init_value])
                        
                                    y[1] = expr_replace(y[1],eval("['"+variable+"']"),eval("['-',['"+variable+"'],['"+str(prev_value_list[0])+"']]"))
                                                                    
                                    solution_else_map[key_value]=","+str(y[1])
                    
                            return solution_map,solution_else_map,map_init_value,map_prev_value


                        else:
                            map_con_expression_new_update=[]
                        
                            temp=None
                        
                            for x in map_con_expression_new:
                            
                                if x is not list_element and x[0] is not None:
                                
                                    map_con_expression_new_update.append(x)
                                
                                elif x[0] is None:
                                
                                    temp = x
                                
                            map_con_expression_new_update.append(list_element)
                        
                            #print map_con_expression_new_update
                        
                            if temp is not None:
                        
                                map_con_expression_new_update.append(temp)
                        
                            map_con_expression_new = map_con_expression_new_update
                        

                    
                else:
                        
                    
                    
                    init_value='0'
            
                    final_value='_C'
                    
                    init_query = copy.deepcopy(list_element[0])
            
                    init_query_cmpl = copy.deepcopy(list_element[0])
            
                    init_query_cmpl = expr_complement(init_query_cmpl)
            
                    init_query = "['implies',"+"['and',['<=',['"+init_value+"'],['"+variable+"']],['<',['"+variable+"'],['"+final_value+"']]]"+","+str(init_query)+"]"
            
                    init_query_cmpl = "['implies',['<=',['"+final_value+"'],['"+variable+"']],"+str(init_query_cmpl)+"]"
            
                    init_query = wff_c1(eval(init_query))
            
                    init_query_cmpl = wff_c1(eval(init_query_cmpl))
            
                    list_equations=[]
            
                    list_equations.append(init_query)
            
                    list_equations.append(init_query_cmpl)
            
                    vfacts = getAllVFacts(list_equations)
            
                    temp_post_condition=[]
                                        
                    status=tactic1_update_rec_solve([],[],list_equations,[],temp_post_condition,vfacts,[],[],'')
                    
                    if 'Counter Example' in status:
                        
                        status = status.replace('Counter Example','').strip()
                
                        status = status[1:-1]
                
                        val_extract_map = processCounterExample(status)
                
                        init_query = copy.deepcopy(list_element[0])
                
                        init_query = expr_replace(init_query,eval("['"+variable+"']"),eval("['"+init_value+"']"))
                            

                        post_condition=wff_a(init_query)
                        
                        temp_post_condition=[]
                                                
                        temp_post_condition.append(wff2z3_update(post_condition))
                
                        status=tactic1_update_rec_solve([],[],list_equations,[],temp_post_condition,vfacts,[],[],'')
                        
                        if 'Successfully Proved' in status and  len(val_extract_map)>0 and final_value in val_extract_map.keys():
                            
                            cond = "['and',['<=',['"+init_value+"'],['"+variable+"']],['<',['"+variable+"'],['"+val_extract_map[final_value]+"']]]"
                            
                            value_expr=copy.deepcopy(y[1])
                            
                            map_init_value[expr2string1(y[9])]=y[8]
                            
                        
                            for init_value in map_init_value:
                                
                                value_expr = expr_replace(value_expr,eval("['"+init_value+"']"),map_init_value[init_value])
                            
                                
                                
                            soln_str_start="['ite',"+str(cond)+","+str(value_expr)
                        
                            soln_str_end="]"
                        
                            solution_list=[]
                        
                            solution_list.append(soln_str_start)#Solution Index 0
                        
                            solution_list.append(soln_str_end)#Solution Index 1
                            
                            #solution_list.append(None)
                            
                            #solution_list.append(None)
                            
                            solution_map[key_value]=solution_list
                            
                            prev_list=[]
                            
                            prev_prev_list=[]
                            
                            final_init_value = expr_replace(copy.deepcopy(value_expr),eval("['"+variable+"']"),eval("['"+val_extract_map[final_value]+"']"))
                        
                            prev_list.append(val_extract_map[final_value])
                            
                            prev_list.append(final_init_value)
                            
                            map_prev_value[key_value] = prev_list
                            
                            prev_prev_list.append(y[9])
                            
                            prev_prev_list.append(final_init_value)

                            
                            map_prev_prev_value[key_value] = prev_prev_list
                            
                            
                            if list_element in map_con_expression_new:
                                                        
                                map_con_expression_new.remove(list_element)
                            
                    elif 'Successfully Proved' in status:
                        
                        
                        temp_post_condition=[]
                                                
                        temp_post_condition.append(wff2z3_update(init_query))
                
                        status=tactic1_update_rec_solve([],[],[],[],temp_post_condition,vfacts,[],[],'')

                        if 'Successfully Proved' in status:
                            
                            list_info_system=map_condition_equation[expr2string1(list_element[1])]
            
                            for y in list_info_system:
                
                                key_value = expr2string1(y[3][-2])
                
                                value_expr=copy.deepcopy(y[1])
                            
                                map_init_value[expr2string1(y[9])]=y[8]
                            
                                for init_value in map_init_value:
                                
                                    value_expr = expr_replace(value_expr,eval("['"+init_value+"']"),map_init_value[init_value])
                                
                                soln_str_start=str(value_expr)
                        
                                soln_str_end=""
                        
                                solution_list=[]
                        
                                solution_list.append(soln_str_start)#Solution Index 0
                        
                                solution_list.append(soln_str_end)#Solution Index 1
                            
                                #solution_list.append(None)
                            
                                #solution_list.append(None)
                            
                                solution_map[key_value]=solution_list
                    
                    
                            return solution_map,solution_else_map,map_init_value,map_prev_value

                            
                        else:
                        
                            map_con_expression_new_update=[]
                        
                            temp = None
                        
                            for x in map_con_expression_new:
                            
                                if x is not list_element and x[0] is not None:
                                
                                    map_con_expression_new_update.append(x)
                                
                                elif x[0] is None:
                                
                                    temp = x

                                
                            map_con_expression_new_update.append(list_element)
                        
                            #print map_con_expression_new_update
                        
                            if temp is not None:
                        
                                map_con_expression_new_update.append(temp)
                        
                            map_con_expression_new = map_con_expression_new_update
                        

            #return find_Condition_Order(map_con_expression_new,map_condition_equation, map_condition_else_equation,variable, map_init_value, map_prev_value, solution_map, solution_else_map)
                        

    if len(map_con_expression_new_back_up)>len(map_con_expression_new):
        
        return find_Condition_Order(map_con_expression_new,map_condition_equation, map_condition_else_equation,variable, map_init_value, map_prev_value, map_prev_prev_value, solution_map, solution_else_map)
    
    else:
        
        list_info_system=map_condition_else_equation[None]
            
        for y in list_info_system:
                
            key_value = expr2string1(y[3][3])
                
            if key_value in map_prev_value:
                
                prev_value_list = map_prev_value[key_value]
                    
                                        
                map_init_value[expr2string1(y[9])]=prev_value_list[1]
                    
                for init_value in map_init_value:
                        
                    y[1] = expr_replace(y[1],eval("['"+init_value+"']"),map_init_value[init_value])
                        
                y[1] = expr_replace(y[1],eval("['"+variable+"']"),eval("['-',['"+variable+"'],['"+str(prev_value_list[0])+"']]"))
                                                                    
                solution_else_map[key_value]=","+str(y[1])
                    
        map_con_expression_new.remove(list_element)

        return solution_map,solution_else_map,map_init_value,map_prev_value, map_prev_prev_value
        






def find_Condition_Order_Fun(map_con_expression_new,map_condition_equation, map_condition_else_equation,variable, map_init_value, map_prev_value, map_prev_prev_value, solution_map, solution_else_map):
    
    #print '~~~~~~~~~~~~~~~~~'
    #print 'Enter'
    #print len(map_con_expression_new)
    #print map_init_value
    #print map_prev_value
    #print solution_map
    #print '~~~~~~~~~~~~~~~~~'
    
    map_con_expression_new_back_up=copy.deepcopy(map_con_expression_new)
    
    for list_element in map_con_expression_new:

        #print '@@@@@@@@@@@@@@@@@@@@@'
        #print list_element[1]
        #print '@@@@@@@@@@@@@@@@@@@@@'

        if list_element[1] is not None:
            
            list_info_system = map_condition_equation[expr2string1(list_element[1])]
                    
            for y in list_info_system:
                        
                key_value = expr2string1(y[3][-2])
                
                if key_value in solution_map:
                    
                    solution_list_prev=solution_map[key_value]
                    
                    prev_value_list = map_prev_value[key_value]
                    
                    
                    init_value = prev_value_list[0]
            
                    final_value = '_C'
                    
                    init_query = copy.deepcopy(list_element[0])
            
                    init_query_cmpl = copy.deepcopy(list_element[0])
            
                    init_query_cmpl = expr_complement(init_query_cmpl)
                    
                    
                    for z in list_info_system:
                        
                        init_query = expr_replace(init_query,z[7],z[1])
                        
                        #init_query = expr_replace(init_query,z[9],z[8])
                                                
                        init_query_cmpl = expr_replace(init_query_cmpl,z[7],z[1])
                        
                        #init_query_cmpl = expr_replace(init_query_cmpl,z[9],z[8])
                        
                        key_value = expr2string1(y[3][-2])
                        
                        prev_value_list = map_prev_value[key_value]
                        
                        init_query = expr_replace(init_query,z[9],prev_value_list[1])
                        
                        init_query_cmpl = expr_replace(init_query_cmpl,z[9],prev_value_list[1])
                        
                    
                    #init_query[1] = expr_replace(init_query[1],eval("['"+variable+"']"),eval("['-',['"+variable+"'],['"+prev_value_list[0]+"']]"))
                        
                    #init_query_cmpl[1] = expr_replace(init_query[1],eval("['"+variable+"']"),eval("['-',['"+variable+"'],['"+prev_value_list[0]+"']]"))
                        
            
                    init_query = "['implies',"+"['and',['<=',['"+init_value+"'],['"+variable+"']],['<',['"+variable+"'],['"+final_value+"']]]"+","+str(init_query)+"]"
            
                    init_query_cmpl = "['implies',['<=',['"+final_value+"'],['"+variable+"']],"+str(init_query_cmpl)+"]"
            
                    init_query = wff_c1(eval(init_query))
            
                    init_query_cmpl = wff_c1(eval(init_query_cmpl))
            
                    list_equations=[]
            
                    list_equations.append(init_query)
            
                    list_equations.append(init_query_cmpl)
            
                    vfacts = getAllVFacts(list_equations)
            
                    temp_post_condition=[]
                    
                                        
                    status=tactic1_update_rec_solve([],[],list_equations,[],temp_post_condition,vfacts,[],[],'')
                    

                    
                                        
                    if 'Counter Example' in status:
                        
                        status = status.replace('Counter Example','').strip()
                
                        status = status[1:-1]
                
                        val_extract_map = processCounterExample(status)
                        
                        init_query = copy.deepcopy(list_element[0])
                        
                        for z in list_info_system:
                        
                            init_query = expr_replace(init_query,z[7],z[1])
                        
                            #init_query = expr_replace(init_query,z[9],z[8])
                                                                        
                            key_value = expr2string1(y[3][-2])
                        
                            prev_value_list = map_prev_value[key_value]
                        
                            init_query = expr_replace(init_query,z[9],prev_value_list[1])


                        
                        
                        init_query = expr_replace(init_query,eval("['"+variable+"']"),eval("['0']"))
                            
                        temp_post_condition=[]

                        post_condition=wff_a(init_query)
                        
                        temp_post_condition=[]
                                                
                        temp_post_condition.append(wff2z3_update(post_condition))
                
                        status=tactic1_update_rec_solve([],[],list_equations,[],temp_post_condition,vfacts,[],[],'')
                        
                        
                        
                        if 'Successfully Proved' in status and  len(val_extract_map)>0 and final_value in val_extract_map.keys() and is_number(val_extract_map[final_value])==True:
                            
                            
                            update_init_value=str(int(val_extract_map[final_value])+int(init_value))
                            
                            cond = "['and',['<=',['"+init_value+"'],['"+variable+"']],['<',['"+variable+"'],['"+update_init_value+"']]]"
                            
                            map_init_value[expr2string1(y[9])]=prev_value_list[1]
                            
                            value_expr=copy.deepcopy(y[1])
                            
                            for init_value_var in map_init_value:
                                
                                value_expr = expr_replace(value_expr,eval("['"+init_value_var+"']"),map_init_value[init_value_var])
                            
                                
                            value_expr = expr_replace(value_expr,eval("['"+variable+"']"),eval("['-',['"+variable+"'],['"+init_value+"']]"))
                            
                            soln_str_start = solution_list_prev[0]
                            
                            soln_str_start+=",['ite',"+str(cond)+","+str(value_expr)
                            
                            
                            soln_str_end = solution_list_prev[1]
                        
                            soln_str_end+="]"
                        
                            solution_list=[]
                        
                            solution_list.append(soln_str_start)#Solution Index 0
                        
                            solution_list.append(soln_str_end)#Solution Index 1
                            
                            #solution_list.append(None)
                            
                            #solution_list.append(None)
                            
                            solution_map[key_value]=solution_list
                            
                            prev_list=[]
                            
                            prev_prev_list=[]
                            
                            final_init_value = expr_replace(copy.deepcopy(value_expr),eval("['"+variable+"']"),eval("['"+update_init_value+"']"))
                            

                        
                            prev_list.append(update_init_value)
                            
                            prev_list.append(final_init_value)
                            
                            map_prev_value[key_value] = prev_list
                            
                            
                            prev_prev_list.append(y[9])
                            
                            prev_prev_list.append(final_init_value)
                            
                            map_prev_prev_value[key_value] = prev_prev_list

                            
                            #print solution_map
                            #print '~~~~~~~~~~~~~~~~~1'
                            #print map_prev_value
                            #print '~~~~~~~~~~~~~~~~~2'
                            #print map_prev_prev_value
                            #print '~~~~~~~~~~~~~~~~~3'

                            
                            if list_element in map_con_expression_new:
                            
                                map_con_expression_new.remove(list_element)
                            
                        #else:
                        
                            #if list_element in map_con_expression_new:
                                
                            #    print '--------------------'
                                
                            #    print list_element
                                
                            #    print '--------------------'
                                
                            #    map_con_expression_new.remove(list_element)
                            
                            #return find_Condition_Order(map_con_expression_new,map_condition_equation, map_condition_else_equation,variable, map_init_value, map_prev_value, solution_map, solution_else_map)
                    
                            
                    elif 'Successfully Proved' in status:
                        
                        temp_post_condition=[]
                                                
                        temp_post_condition.append(wff2z3_update(init_query))
                
                        status=tactic1_update_rec_solve([],[],[],[],temp_post_condition,vfacts,[],[],'')
                        
                        if 'Successfully Proved' in status:
                            
                            list_info_system=map_condition_equation[expr2string1(list_element[1])]
            
                            for y in list_info_system:
                
                                key_value = expr2string1(y[3][-2])
                
                                if key_value in map_prev_value:
                
                                    prev_value_list = map_prev_value[key_value]
                                        
                                    map_init_value[expr2string1(y[9])]=prev_value_list[1]
                    
                                    for init_value in map_init_value:
                        
                                        y[1] = expr_replace(y[1],eval("['"+init_value+"']"),map_init_value[init_value])
                        
                                    y[1] = expr_replace(y[1],eval("['"+variable+"']"),eval("['-',['"+variable+"'],['"+str(prev_value_list[0])+"']]"))
                                                                    
                                    solution_else_map[key_value]=","+str(y[1])
                    
                            return solution_map,solution_else_map,map_init_value,map_prev_value


                        else:
                            map_con_expression_new_update=[]
                        
                            temp=None
                        
                            for x in map_con_expression_new:
                            
                                if x is not list_element and x[0] is not None:
                                
                                    map_con_expression_new_update.append(x)
                                
                                elif x[0] is None:
                                
                                    temp = x
                                
                            map_con_expression_new_update.append(list_element)
                        
                            #print map_con_expression_new_update
                        
                            if temp is not None:
                        
                                map_con_expression_new_update.append(temp)
                        
                            map_con_expression_new = map_con_expression_new_update
                        

                    
                else:
                        
                    
                    
                    init_value='0'
            
                    final_value='_C'
                    
                    init_query = copy.deepcopy(list_element[0])
            
                    init_query_cmpl = copy.deepcopy(list_element[0])
            
                    init_query_cmpl = expr_complement(init_query_cmpl)
                    
                    
                    
                    for z in list_info_system:
                        
                        init_query = expr_replace(init_query,z[7],z[1])
                        
                        init_query = expr_replace(init_query,z[9],z[8])
                                                
                        init_query_cmpl = expr_replace(init_query_cmpl,z[7],z[1])
                        
                        init_query_cmpl = expr_replace(init_query_cmpl,z[9],z[8])

                    
                    
                    
            
                    init_query = "['implies',"+"['and',['<=',['"+init_value+"'],['"+variable+"']],['<',['"+variable+"'],['"+final_value+"']]]"+","+str(init_query)+"]"
            
                    init_query_cmpl = "['implies',['<=',['"+final_value+"'],['"+variable+"']],"+str(init_query_cmpl)+"]"
            
                    init_query = wff_c1(eval(init_query))
            
                    init_query_cmpl = wff_c1(eval(init_query_cmpl))
            
                    list_equations=[]
            
                    list_equations.append(init_query)
            
                    list_equations.append(init_query_cmpl)
            
                    vfacts = getAllVFacts(list_equations)
            
                    temp_post_condition=[]
                    
                                        
                    status=tactic1_update_rec_solve([],[],list_equations,[],temp_post_condition,vfacts,[],[],'')
                    
                    
                    
                    if 'Counter Example' in status:
                        
                        status = status.replace('Counter Example','').strip()
                
                        status = status[1:-1]
                
                        val_extract_map = processCounterExample(status)
                
                        init_query = copy.deepcopy(list_element[0])
                        
                        
                        for z in list_info_system:
                        
                            init_query = expr_replace(init_query,z[7],z[1])
                        
                            init_query = expr_replace(init_query,z[9],z[8])

                
                        init_query = expr_replace(init_query,eval("['"+variable+"']"),eval("['"+init_value+"']"))
                            

                        post_condition=wff_a(init_query)
                        
                        temp_post_condition=[]
                                                
                        temp_post_condition.append(wff2z3_update(post_condition))
                
                        status=tactic1_update_rec_solve([],[],list_equations,[],temp_post_condition,vfacts,[],[],'')
                        
                        if 'Successfully Proved' in status and  len(val_extract_map)>0 and final_value in val_extract_map.keys():
                            
                            cond = "['and',['<=',['"+init_value+"'],['"+variable+"']],['<',['"+variable+"'],['"+val_extract_map[final_value]+"']]]"
                            
                            value_expr=copy.deepcopy(y[1])
                            
                            map_init_value[expr2string1(y[9])]=y[8]
                            
                        
                            for init_value in map_init_value:
                                
                                value_expr = expr_replace(value_expr,eval("['"+init_value+"']"),map_init_value[init_value])
                            

                                
                            soln_str_start="['ite',"+str(cond)+","+str(value_expr)
                        
                            soln_str_end="]"
                        
                            solution_list=[]
                        
                            solution_list.append(soln_str_start)#Solution Index 0
                        
                            solution_list.append(soln_str_end)#Solution Index 1
                            
                            #solution_list.append(None)
                            
                            #solution_list.append(None)
                            
                            solution_map[key_value]=solution_list
                            
                            prev_list=[]
                            
                            prev_prev_list=[]
                            
                            final_init_value = expr_replace(copy.deepcopy(value_expr),eval("['"+variable+"']"),eval("['"+val_extract_map[final_value]+"']"))
                        
                            prev_list.append(val_extract_map[final_value])
                            
                            prev_list.append(final_init_value)
                            
                            map_prev_value[key_value] = prev_list
                            
                            prev_prev_list.append(y[9])
                            
                            prev_prev_list.append(final_init_value)
                            

                            
                            map_prev_prev_value[key_value] = prev_prev_list
                            
                            
                            if list_element in map_con_expression_new:
                                                        
                                map_con_expression_new.remove(list_element)
                            
                    elif 'Successfully Proved' in status:
                        
                        
                        temp_post_condition=[]
                                                
                        temp_post_condition.append(wff2z3_update(init_query))
                
                        status=tactic1_update_rec_solve([],[],[],[],temp_post_condition,vfacts,[],[],'')

                        if 'Successfully Proved' in status:
                            
                            list_info_system=map_condition_equation[expr2string1(list_element[1])]
            
                            for y in list_info_system:
                
                                key_value = expr2string1(y[3][-2])
                
                                value_expr=copy.deepcopy(y[1])
                            
                                map_init_value[expr2string1(y[9])]=y[8]
                            
                                for init_value in map_init_value:
                                
                                    value_expr = expr_replace(value_expr,eval("['"+init_value+"']"),map_init_value[init_value])
                                
                                soln_str_start=str(value_expr)
                        
                                soln_str_end=""
                        
                                solution_list=[]
                        
                                solution_list.append(soln_str_start)#Solution Index 0
                        
                                solution_list.append(soln_str_end)#Solution Index 1
                            
                                #solution_list.append(None)
                            
                                #solution_list.append(None)
                            
                                solution_map[key_value]=solution_list
                    
                            #print 'XXXX--XX'
                            return solution_map,solution_else_map,map_init_value,map_prev_value

                            
                        else:
                        
                            map_con_expression_new_update=[]
                        
                            temp = None
                        
                            for x in map_con_expression_new:
                            
                                if x is not list_element and x[0] is not None:
                                
                                    map_con_expression_new_update.append(x)
                                
                                elif x[0] is None:
                                
                                    temp = x

                                
                            map_con_expression_new_update.append(list_element)
                        
                            #print map_con_expression_new_update
                        
                            if temp is not None:
                        
                                map_con_expression_new_update.append(temp)
                        
                            map_con_expression_new = map_con_expression_new_update
                        

            #return find_Condition_Order(map_con_expression_new,map_condition_equation, map_condition_else_equation,variable, map_init_value, map_prev_value, solution_map, solution_else_map)
                        
    #print '###############################'
    #print map_con_expression_new_back_up
    #print '--------------------------'
    #print map_con_expression_new
    #print '--------------------------'
    #print len(map_con_expression_new_back_up)>len(map_con_expression_new)
    #print '###############################'
    if len(map_con_expression_new_back_up)>len(map_con_expression_new):
        
        return find_Condition_Order_Fun(map_con_expression_new,map_condition_equation, map_condition_else_equation,variable, map_init_value, map_prev_value, map_prev_prev_value, solution_map, solution_else_map)
    
    else:
        
        list_info_system=map_condition_else_equation[None]
            
        for y in list_info_system:
                
            key_value = expr2string1(y[3][3])
                
            if key_value in map_prev_value:
                
                prev_value_list = map_prev_value[key_value]
                    
                                        
                map_init_value[expr2string1(y[9])]=prev_value_list[1]
                    
                for init_value in map_init_value:
                        
                    y[1] = expr_replace(y[1],eval("['"+init_value+"']"),map_init_value[init_value])
                        
                y[1] = expr_replace(y[1],eval("['"+variable+"']"),eval("['-',['"+variable+"'],['"+str(prev_value_list[0])+"']]"))
                                                                    
                solution_else_map[key_value]=","+str(y[1])
                    
        map_con_expression_new.remove(list_element)

        return solution_map,solution_else_map,map_init_value,map_prev_value, map_prev_prev_value


            




def processCounterExample(counterExample):

    val_extract_map={}
    
    if ',' in counterExample:
        
        val_list = counterExample.split(',')
        
        for val  in val_list:
            
            if '[' not in val and ']' not in val and '=' in val:
                
                var = val.split('=')
                
                if len(var)==2:
                
                    val_extract_map[var[0].strip()] = var[1].strip()
        
    return val_extract_map
        






"""
#Is Function Present 

"""
def getAllVarFun(e,map_fun,map_var):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if op.startswith('_n')==True or op.startswith('_x')==True:
            map_var[op]=op
    else:
        if op=='and' or op=='or':
            
            if len(args)==1:
                getAllVarFun(args[0],map_fun,map_var)
            else:
                for x in args:
                    getAllVarFun(x,map_fun,map_var)
        elif op=='not' and len(args)==1:
            getAllVarFun(args[0],map_fun,map_var)
        elif op=='implies' and len(args)==2:
            getAllVarFun(args[0],map_fun,map_var)
            getAllVarFun(args[1],map_fun,map_var)
        elif op in _infix_op and len(args)==2:
            getAllVarFun(args[0],map_fun,map_var)
            getAllVarFun(args[1],map_fun,map_var)
        else:
            if op !='ite' and '__VERIFIER_' not in op:
                map_fun[op]=op
            for x in args:
                getAllVarFun(x,map_fun,map_var)




def getAllVarFun_failed(e,map_fun,map_var,map_const):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if op.startswith('_n')==True or op.startswith('_x')==True:
            map_var[op]=op
        elif op.startswith('_N')==True:
            map_const[op]=op
    else:
        if op=='and' or op=='or':
            
            if len(args)==1:
                getAllVarFun_failed(args[0],map_fun,map_var,map_const)
            else:
                for x in args:
                    getAllVarFun_failed(x,map_fun,map_var,map_const)
        elif op=='not' and len(args)==1:
            getAllVarFun_failed(args[0],map_fun,map_var,map_const)
        elif op=='implies' and len(args)==2:
            getAllVarFun_failed(args[0],map_fun,map_var,map_const)
            getAllVarFun_failed(args[1],map_fun,map_var,map_const)
        elif op in _infix_op and len(args)==2:
            getAllVarFun_failed(args[0],map_fun,map_var,map_const)
            getAllVarFun_failed(args[1],map_fun,map_var,map_const)
        elif op in _infix_op and len(args)==1:
            getAllVarFun_failed(args[0],map_fun,map_var,map_const)
        else:
            if op !='ite' and '__VERIFIER_' not in op:
                map_fun[op]=op
            for x in args:
                getAllVarFun_failed(x,map_fun,map_var,map_const)



                
                
                
                
def getAllVFacts(equation_list):
    
    var_map={}
    getEqVariFunDetails(equation_list,var_map)
    vfacts=[]
    vfacts.append(eval("['_k1',0,['int']]"))
    for vfact in var_map:
        vfacts.append(var_map[vfact])
    return vfacts


#Collect all Function and Variable defination for Translation 2

def getEqVariFunDetails(list,var_map):
	for x in list:
            wff2stringvfacteq(x,var_map)
            




#print in normal infix notation
def wff2stringvfacteq(w,var_map):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 'R':
            expr2stringvfacteq(w[-2],var_map)
            expr2stringvfacteq(w[-1],var_map)
        elif w[0] == 'd0':
            expr2stringvfacteq(w[1],var_map)
            expr2stringvfacteq(w[2],var_map)
        elif w[0] == 'd1':
            expr2stringvfacteq(w[2],var_map)
            expr2stringvfacteq(w[3],var_map)
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1' or w[0]=='c1' :
            expr2stringvfacteq(w[1],var_map)




#Get all fact from equations
def expr2stringvfacteq(e,var_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
    	if op not in var_map.keys() and is_number(op)==False and is_hex(op)==None and op not in _base:
    		element=[]
    		element.append(op)
        	element.append(0)
        	element_para=[]
        	element.append(element_para)
                element_para.append('int')
                #print '----------'
                #print op
                #print element
                #print '----------'
        	var_map[op]=element
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                expr2stringvfacteq(args[0],var_map)
            else:
                for x in args:
                    expr2stringvfacteq(x,var_map)
        elif op=='not' and len(args)==1:
            expr2stringvfacteq(args[0],var_map)
        elif op=='implies' and len(args)==2:
            expr2stringvfacteq(args[0],var_map)
            expr2stringvfacteq(args[1],var_map)
        elif op in _infix_op and len(args)==2:
            expr2stringvfacteq(args[0],var_map)
            expr2stringvfacteq(args[1],var_map)
        else:
            if isArrayFunction(op)==True:
            	count=0
            	element=[]
            	element.append(op)
            	element.append(len(args))
            	element_para=[]
            	array_type=None
            	for parameter in args:
            		if count==0:
            			element_para.append('array')
            			element_in=[]
                                expr2stringvfacteq(parameter,var_map)
            			para_value=expr2string1(parameter,var_map)
            			element_in.append(para_value)
            			element_in.append(0)
            			element_para_in=[]
            			element_para_in.append('array')
            			element_in.append(element_para_in)
            			var_map[para_value]=element_in
            			array_type='int'
            		else:
            			expr2stringvfacteq(parameter,var_map,allvariablelist,constraints)
            			typename='int'
                                element_para.append(typename)            					
 			count=count+1
                        
                element_para.append(array_type)
                
            	element.append(element_para)
                
            	var_map[op]=element
                
            else:
            	if op not in var_map.keys() and op is not 'ite' and op not in _base:
            		element=[]
            		element.append(op)
            		element.append(len(args))
            		element_para=[]
            		if len(args)>0:
            			for x in args:
                                        expr2stringvfacteq(x,var_map)
                                        element_para.append('int')
            		       	element_para.append('int')
            		else:
            			element_para.append('int')
                                
            		element.append(element_para)
            		var_map[op]=element
                        
            for x in args:
                expr2stringvfacteq(x,var_map)





def prove_conditions(condition,setofaxoims,variable):
    vfacts = getAllVFacts(setofaxoims)
    post_condition=wff_a(condition)
    temp_post_condition=[]
    temp_post_condition.append(wff2z3_update(post_condition))
    status=tactic1_update_rec_solve([],[],setofaxoims,[],temp_post_condition,vfacts,[],[],'')
    if 'Successfully Proved' in status:
        return 'Successfully Proved'
    else:
        #return "Failed to Prove"
        base_case=copy.deepcopy(post_condition)
        base_case[-1]=expr_replace(base_case[-1],eval("['"+variable+"']"),eval("['0']"))
        temp_post_condition=[]
        temp_post_condition.append(wff2z3_update(base_case))
        status=tactic1_update_rec_solve([],[],setofaxoims,[],temp_post_condition,vfacts,[],[],'')
        if 'Successfully Proved' in status:
            assumption=copy.deepcopy(post_condition)
            assumption[-1]=expr_replace(assumption[-1],eval("['"+variable+"']"),eval("['_k1']"))
            conclusion=copy.deepcopy(post_condition)
            conclusion[-1]=expr_replace(conclusion[-1],eval("['"+variable+"']"),eval("['+',['_k1'],['1']]"))
            main_equation=eval("['implies',['and',['>=',['_k1'],['0']],"+str(assumption[-1])+"],"+str(conclusion[-1])+"]")
            main_equation=wff_a(main_equation)
            temp_post_condition=[]
            temp_post_condition.append(wff2z3_update(main_equation))
            #print temp_post_condition
            status=tactic1_update_rec_solve([],[],setofaxoims,[],temp_post_condition,vfacts,[],[],'')
            if 'Successfully Proved' in status:
                return 'Successfully Proved'
            else:
                return "Failed to Prove"
        else:
            return "Failed to Prove"
    return "Failed to Prove"




"""

#Simplification of conditions

"""


def simplificationOfConditions(list_equations, map_con_expression, equation,variable):
    
    new_map_con_expression = {}
    
    for cond_str in map_con_expression:
        
        cond_expr = map_con_expression[cond_str]
        
        condition= cond_expr[0]
        
        if condition is not None:
            
                    
            status = prove_conditions(condition,list_equations,variable,)
                                
            if 'Successfully Proved' in status:
                
                if len(new_map_con_expression)==1 and None in new_map_con_expression.keys():
                    
                    new_map_con_expression={}
                    
                new_map_con_expression[cond_str] = cond_expr        
        
                return new_map_con_expression
        
            else:
                                    
                new_map_con_expression[cond_str] = cond_expr
        else:
            
            new_map_con_expression[cond_str] = cond_expr
            
    return new_map_con_expression
        
        
def isElseInductiveCase():
    
    isInductive=False
            
    try:
                
        equation = simplify(equation)
                
        equation = equation.subs(simplify(var+"+1"),simplify(var))
                
        isInductive=(simplify(equation)==simplify(expr2string1(cond_expr[1])))
                
    except Exception as e:
                
        isInductive=False

"""
#Is Function Present 

"""
def isVariablePresent(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if op.startswith('_n')==True or op.startswith('_x')==True:
            return true
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                if isVariablePresent(args[0])==True:
                    return True
            else:
                status=False
                for x in args:
                    if isVariablePresent(x)==True:
                        return True
        elif op=='not' and len(args)==1:
            return isFunctionPresent(args[0])
        elif op=='implies' and len(args)==2:
             if isVariablePresent(args[0])==True or isVariablePresent(args[1])==True:
                 return True
        elif op in _infix_op and len(args)==2:
            if isVariablePresent(args[0])==True or isVariablePresent(args[1])==True:
                return True
        else:
            for x in args:
                if isVariablePresent(x)==True:
                    return True
    return None

    
    
"""
#Is Function Present 

"""
def isFunctionPresent(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if op.startswith('_n')==True or op.startswith('_x')==True:
            return None
    else:
        if op=='and' or op=='or':
            
            if len(args)==1:
                if isFunctionPresent(args[0])==True:
                    return True
            else:
                status=False
                for x in args:
                    if isFunctionPresent(x)==True:
                        return True
        elif op=='not' and len(args)==1:
            return isFunctionPresent(args[0])
        elif op=='implies' and len(args)==2:
             if isFunctionPresent(args[0])==True or isFunctionPresent(args[1])==True:
                 return True
        elif op in _infix_op and len(args)==2:
            if isFunctionPresent(args[0])==True or isFunctionPresent(args[1])==True:
                return True
        else:
            if op !='ite' :
                return True

    return None



def tactic1_update_rec_solve(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,witnessXml):
	global defineDetaillist
	defineDetaillist=[]
	constraint_list=[]
	frame_axioms=eqset2constraintlist_update(f)
	for x in frame_axioms:
		constraint_list.append(x)
	out_axioms=eqset2constraintlist_update(o)
    
	subs_list=eqset2subs_list(o)
	
	for x in out_axioms:
		constraint_list.append(x)
	for x in a: 
        	equations=wff2z3_update(x)                
        	equations_sp=None
                if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        status_value = query2z3_cond([],equations,vfact)
                        if 'Successfully Proved' not in status_value:
                            constraint_list.append(equations)
                    else:

                        constraint_list.append(equations)
                else:

                    constraint_list.append(equations)
                if x[0]=='s1':
        		equations_sp=wff2z3SC_update(x)
        		if equations_sp is not None:
        			constraint_list.append(equations_sp)        		
	for x in constaints:
		constraint_list.append(x)
	for x in pre_condition:
        	constraint_list.append(x)
        filter_map={}
        for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
	defineDetaillist=[]
        if len(conclusions)>0:
            for conclusion in conclusions:
                    writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
                    if conclusion is None:
                            return "Failed to Prove"
                    if "factorial" in conclusion:
                            cfact=eval("['factorial',1,['int','int']]")
                            vfact.append(cfact)
                    status=query2z3_rec_solve(constraint_list,conclusion,vfact,inputmap,witnessXml)
                    writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
                    if "Successfully Proved" in status:
                            return "Successfully Proved"			
                    elif "Counter Example" in status:
                            return 	status		
                    else:
                            return "Failed to Prove"
        else:
            
                #writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
                #if "factorial" in conclusion:
                #        cfact=eval("['factorial',1,['int','int']]")
                #        vfact.append(cfact)
                status=query2z3_rec_solve(constraint_list,None,vfact,inputmap,witnessXml)
                writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
                if "Successfully Proved" in status:
                        return "Successfully Proved"			
                elif "Counter Example" in status:
                        return 	status		
                else:
                        return "Failed to Prove"

"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def query2z3_rec_solve(constraint_list,conclusion,vfact,inputmap,witnessXml):
	TIMEOUT_REC_SOLVE=1000
	pythonProgram="import sys\n"
        pythonProgram+="import os\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
	pythonProgram+="from z3 import *\n"
        pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
	pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
	pythonProgram+="\t_p1=Int('_p1')\n"
	pythonProgram+="\t_p2=Int('_p2')\n"
	pythonProgram+="\t_n=Int('_n')\n"
        pythonProgram+="\t_bool=Int('_bool')\n"
	pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
	pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    

        duplicate_map={}
        
	status=""
	for [x,k,l] in vfact:
		if k==0:
			if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
				if l[0]=="int":
					if '_N' in x:
						pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
					else:				
						pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="double":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
				elif l[0]=="float":
					pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        	elif l[0]=="Bool":
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
				elif l[0]=="constant":
					pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
				elif l[0]=="array":
					if 'array(' not in x:
                                            pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
				else:
					pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                                duplicate_map[x]=x
                                        
		else:
			if x not in duplicate_map.keys():
                            if ('_PROVE' not in x or '_ASSUME' not in x):
                                    pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                    duplicate_map[x]=x
                                    for e in l:
                                            if e=="int":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="unsigned":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="long":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="array":
                                                    pythonProgram+=",arraySort"
                                            else:
                                                    pythonProgram+=",RealSort()"
                                    pythonProgram+=")\n"
	power_flag=False
	for equation in constraint_list:
		if '**' in equation or 'power' in equation:
			power_flag=True
	if conclusion is not None and ('**' in conclusion or 'power' in conclusion):
		power_flag=True
	if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
                pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
		pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        	pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

	pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
	pythonProgram+="\t_s.set(\"timeout\","+str(TIMEOUT_REC_SOLVE)+")\n"
	for equation in constraint_list:
                if 'main(argc, argv)' not in equation and 'argv1(argv)' not in equation and 'argc1(argc)' not in equation:
                    pythonProgram+="\t_s.add("+str(equation)+")\n"
	finalProgram=pythonProgram
	#finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
        if conclusion is not None:
            finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
	finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#print finalProgram
	writtingFile( "z3query.py" , finalProgram )
	writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
	try :
		proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
		output = proc.stdout.read()
		status=output
	except OSError  as err:
		print 'dharilo1'
	return status
